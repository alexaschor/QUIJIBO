!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef Matrix<A_Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols> A;$/;"	t	struct:Eigen::internal::make_coherent_impl
A	vcglib/vcg/complex/algorithms/inertia.h	/^ int A;   \/* alpha *\/$/;"	m	class:vcg::tri::Inertia
A	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    Eigen::SparseMatrix<double> A; \/\/ A$/;"	m	class:vcg::tri::PoissonSolver
A	vcglib/vcg/complex/algorithms/update/curvature.h	/^    float A;$/;"	m	class:vcg::tri::UpdateCurvature::AreaData
A	vcglib/wrap/io_trimesh/export_vmi.h	/^    template <int N> struct PlaceHolderType{ char A[N];};$/;"	m	struct:vcg::tri::io::PlaceHolderType
A	vcglib/wrap/math/sparse_matrix.h	/^virtual ScalarType &A(int row,int col)$/;"	f	class:SparseMatrix
A	vcglib/wrap/math/system_interface_ldl.h	/^double &A(int row,int col)$/;"	f	class:SystemLDL
A	vcglib/wrap/miq/core/sparsesystemdata.h	/^  SparseMatrixData& A() { return m_A; }$/;"	f	class:SparseSystemData
AABBBinaryTree	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTree(void) {$/;"	f	class:vcg::AABBBinaryTree
AABBBinaryTree	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^class AABBBinaryTree {$/;"	c	namespace:vcg
AABBBinaryTreeClosest	vcglib/vcg/space/index/aabb_binary_tree/closest.h	/^class AABBBinaryTreeClosest {$/;"	c	namespace:vcg
AABBBinaryTreeFrustumCull	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^class AABBBinaryTreeFrustumCull {$/;"	c	namespace:vcg
AABBBinaryTreeIndex	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^class AABBBinaryTreeIndex : public SpatialIndex<OBJTYPE, SCALARTYPE> {$/;"	c	namespace:vcg
AABBBinaryTreeKClosest	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^class AABBBinaryTreeKClosest {$/;"	c	namespace:vcg
AABBBinaryTreeNode	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		class AABBBinaryTreeNode {$/;"	c	class:vcg::AABBBinaryTree
AABBBinaryTreeNode	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::AABBBinaryTreeNode(void) {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
AABBBinaryTreeRay	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^class AABBBinaryTreeRay {$/;"	c	namespace:vcg
AACb	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^typedef bool AACb( const int pos,const char * str );$/;"	t
ABORT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ABORT /;"	d	file:
ABORT_ON_ASSERT_FAILURE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ABORT_ON_ASSERT_FAILURE /;"	d	file:
ABx_lx	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  ABx_lx              = 0x200,$/;"	e	enum:Eigen::DecompositionOptions
ACQUIRE_LOCK	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ACQUIRE_LOCK(/;"	d	file:
ACQUIRE_MALLOC_GLOBAL_LOCK	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ACQUIRE_MALLOC_GLOBAL_LOCK(/;"	d	file:
ACTIVECOORDINATEFRAME_H	vcglib/wrap/gui/activecoordinateframe.h	/^#define ACTIVECOORDINATEFRAME_H$/;"	d
ADD	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define ADD(/;"	d
ADD	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef ADD$/;"	d
ADOBE_RGB	vcglib/vcg/space/colorspace.h	/^		ADOBE_RGB = 0,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
ADOLC_numDir	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^int adtl::ADOLC_numDir;$/;"	m	class:adtl	file:
AEdgeType	vcglib/vcg/complex/all_types.h	/^		struct AEdgeType {};$/;"	s	struct:vcg::AllTypes
AF	vcglib/vcg/simplex/face/component_ocf.h	/^  std::vector<struct AdjTypePack> AF;$/;"	m	class:vcg::face::vector_ocf
AFace	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^class AFace       : public Face<   MyUsedTypes, face::VertexRef, face::Normal3f, face::EdgePlane, face::BitFlags> {};$/;"	c	file:
AFace	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^class AFace     : public FaceFN< AVertex,MyEdge,AFace > {};$/;"	c	file:
AFaceType	vcglib/vcg/complex/all_types.h	/^		struct AFaceType {};$/;"	s	struct:vcg::AllTypes
AHEdgeType	vcglib/vcg/complex/all_types.h	/^		struct AHEdgeType {};$/;"	s	struct:vcg::AllTypes
AIndex	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^typedef vcg::AABBBinaryTreeIndex<AFace, AScalarType, vcg::EmptyClass> AIndex;$/;"	t	file:
ALL_CHANNELS	vcglib/vcg/complex/algorithms/update/color.h	/^enum rgbChMask {ALL_CHANNELS = 7, RED_CHANNEL = 4, GREEN_CHANNEL = 2, BLUE_CHANNEL = 1, NO_CHANNELS = 0 };$/;"	e	enum:vcg::tri::UpdateColor::rgbChMask
AMesh	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^class AMesh     : public vcg::tri::TriMesh< std::vector<AVertex>, std::vector<AFace> > { };$/;"	c	file:
AMesh	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^class AMesh     : public tri::TriMesh< vector<AVertex>, vector<AFace> > {};$/;"	c	file:
ANTTWEAKBARMAPPER_H	vcglib/wrap/qt/anttweakbarMapper.h	/^#define ANTTWEAKBARMAPPER_H$/;"	d
APPLE_RGB	vcglib/vcg/space/colorspace.h	/^		APPLE_RGB = 1,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
ARC	vcglib/apps/plyrefine/main.cpp	/^#define ARC	/;"	d	file:
ARGUMENT	vcglib/wrap/system/qgetopt.h	/^    enum Type { SWITCH, OPTION, ARGUMENT, OPTIONAL };$/;"	e	enum:GetOpt::Option::Type
AROUND	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  enum{ PAIR, AROUND , NOTHING } mode;$/;"	e	enum:vcg::tri::BitQuad::Pos::__anon479
ARRAYSEMANTIC	vcglib/wrap/dae/colladaformat.h	/^		enum ARRAYSEMANTIC {VERTPOSITION,VERTNORMAL,VERTCOLOR, FACENORMAL,WEDGETEXCOORD};$/;"	g	class:Collada::Tags::FloatArrayTag
ASCompare	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            ASCompare(unsigned int vmask = 0) : mask(vmask)$/;"	f	struct:vcg::tri::AttributeSeam::ASCompare
ASCompare	vcglib/vcg/complex/algorithms/attribute_seam.h	/^        struct ASCompare$/;"	s	class:vcg::tri::AttributeSeam
ASExtract	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            ASExtract(unsigned int vmask = 0) : mask(vmask)$/;"	f	struct:vcg::tri::AttributeSeam::ASExtract
ASExtract	vcglib/vcg/complex/algorithms/attribute_seam.h	/^        struct ASExtract$/;"	s	class:vcg::tri::AttributeSeam
ASMask	vcglib/vcg/complex/algorithms/attribute_seam.h	/^        enum ASMask$/;"	g	class:vcg::tri::AttributeSeam
AScalarType	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^typedef float AScalarType;$/;"	t	file:
AT	vcglib/vcg/container/container_allocation_table.h	/^static std::list<ENTRY_TYPE >& AT(){							\/\/ tallocation table$/;"	f	class:vcg::CATEntry
AUXMATH_H	vcglib/wrap/miq/core/auxmath.h	/^#define AUXMATH_H$/;"	d
AV	vcglib/vcg/simplex/face/component_ocf.h	/^  std::vector<struct AdjTypePack> AV;$/;"	m	class:vcg::face::vector_ocf
AV	vcglib/vcg/simplex/vertex/component_ocf.h	/^  std::vector<struct VFAdjType> AV;$/;"	m	class:vcg::vertex::vector_ocf
AV0	vcglib/vcg/complex/algorithms/edge_collapse.h	/^     VFIVec & AV0() { return av0;}$/;"	f	struct:vcg::tri::EdgeCollapser::EdgeSet
AV01	vcglib/vcg/complex/algorithms/edge_collapse.h	/^     VFIVec & AV01(){ return av01;}$/;"	f	struct:vcg::tri::EdgeCollapser::EdgeSet
AV1	vcglib/vcg/complex/algorithms/edge_collapse.h	/^     VFIVec & AV1() { return av1;}$/;"	f	struct:vcg::tri::EdgeCollapser::EdgeSet
AVertex	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^class AVertex     : public Vertex< MyUsedTypes, vertex::Normal3f, vertex::Coord3f,vertex::BitFlags >{};$/;"	c	file:
AVertex	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^class AVertex   : public VertexVCVN< float ,MyEdge,AFace > {};$/;"	c	file:
AVertexType	vcglib/vcg/complex/all_types.h	/^		struct AVertexType {};$/;"	s	struct:vcg::AllTypes
Abs	vcglib/vcg/math/base.h	/^  inline double Abs(const double v)   { return fabs(v); }$/;"	f	namespace:vcg::math
Abs	vcglib/vcg/math/base.h	/^  inline float Abs(const float v)   { return fabsf(v); }$/;"	f	namespace:vcg::math
Abs	vcglib/vcg/math/eigen.h	/^Abs(const Eigen::MatrixBase<Derived>& p)$/;"	f	namespace:vcg
Abs	vcglib/vcg/space/deprecated_point2.h	/^inline Point2<SCALARTYPE> Abs(const Point2<SCALARTYPE> & p) {$/;"	f	namespace:vcg
Abs	vcglib/vcg/space/deprecated_point3.h	/^inline Point3<SCALARTYPE> Abs(const Point3<SCALARTYPE> & p) {$/;"	f	namespace:vcg
AbsDistFlag	vcglib/vcg/complex/algorithms/create/resampler.h	/^		bool AbsDistFlag; \/\/ if true the Distance Field computed is no more a signed one.$/;"	m	class:vcg::tri::Resampler::Walker
AccPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef ResPacket AccPacket;$/;"	t	class:Eigen::internal::gebp_traits
AccPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::AccPacket AccPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
AccPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type AccPacket;$/;"	t	class:Eigen::internal::gebp_traits
AccessorLevels	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum AccessorLevels {$/;"	g	namespace:Eigen
AccessorTag	vcglib/wrap/dae/colladaformat.h	/^		AccessorTag(const int count,const QString& source,const int stride)$/;"	f	class:Collada::Tags::AccessorTag
AccessorTag	vcglib/wrap/dae/colladaformat.h	/^	class AccessorTag : public XMLTag$/;"	c	namespace:Collada::Tags
AccumulateLaplacianInfo	vcglib/vcg/complex/algorithms/smooth.h	/^static void AccumulateLaplacianInfo(MeshType &m, SimpleTempData<typename MeshType::VertContainer,LaplacianInfo > &TD, bool cotangentFlag=false)$/;"	f	class:vcg::tri::Smooth
Acos	vcglib/vcg/math/base.h	/^  inline double Acos(const double v)   { return acos(v); }$/;"	f	namespace:vcg::math
Acos	vcglib/vcg/math/base.h	/^  inline float Acos(const float v)   { return acosf(v); }$/;"	f	namespace:vcg::math
Action	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	g	namespace:Eigen
ActiveCoordinateFrame	vcglib/wrap/gui/activecoordinateframe.cpp	/^ActiveCoordinateFrame::ActiveCoordinateFrame(float size)$/;"	f	class:ActiveCoordinateFrame
ActiveCoordinateFrame	vcglib/wrap/gui/activecoordinateframe.h	/^class ActiveCoordinateFrame: public MovableCoordinateFrame$/;"	c	namespace:vcg
ActiveInput	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef Matrix<ActiveScalar, InputsAtCompileTime, 1> ActiveInput;$/;"	t	class:Eigen::AutoDiffJacobian
ActiveScalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef AutoDiffScalar<DerivativeType> ActiveScalar;$/;"	t	class:Eigen::AutoDiffJacobian
ActiveScalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    typedef AutoDiffScalar<Matrix<BaseScalar,JacobianType::RowsAtCompileTime,1> > ActiveScalar;$/;"	t	class:Eigen::AutoDiffVector
ActiveValue	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef Matrix<ActiveScalar, ValuesAtCompileTime, 1> ActiveValue;$/;"	t	class:Eigen::AutoDiffJacobian
ActualCols	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualCols = Transpose ? MaxRows : MaxCols$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon205
ActualIndex	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^        ActualIndex = ReturnOpposite ? -Index : Index,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon47
ActualLhsType	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	class:Eigen::ProductBase
ActualLhsType	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector
ActualLhsType	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::ExtractType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector
ActualPacketAccessBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = 0x0;$/;"	m	namespace:Eigen
ActualPacketAccessBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = PacketAccessBit;$/;"	m	namespace:Eigen
ActualRhsType	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	class:Eigen::ProductBase
ActualRows	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualRows = Transpose ? MaxCols : MaxRows,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon205
Add	vcglib/vcg/math/histogram.h	/^	void Add(const ScalarType v)$/;"	f	class:vcg::Distribution
Add	vcglib/vcg/math/histogram.h	/^void Histogram<ScalarType>::Add(ScalarType v, ScalarType increment)$/;"	f	class:vcg::Histogram
Add	vcglib/vcg/space/box.h	/^	void Add( Box const & b )$/;"	f	class:vcg::Box
Add	vcglib/vcg/space/box.h	/^	void Add( const PointType & p )$/;"	f	class:vcg::Box
Add	vcglib/vcg/space/box2.h	/^	void Add( Box2 const & b )$/;"	f	class:vcg::Box2
Add	vcglib/vcg/space/box2.h	/^	void Add( const PointType & p )$/;"	f	class:vcg::Box2
Add	vcglib/vcg/space/box3.h	/^    void Add( Box3<BoxScalarType> const & b )$/;"	f	class:vcg::Box3
Add	vcglib/vcg/space/box3.h	/^    void Add( const Matrix44<BoxScalarType> &m, const Box3<BoxScalarType> & b )$/;"	f	class:vcg::Box3
Add	vcglib/vcg/space/box3.h	/^    void Add( const Point3<BoxScalarType> & p )$/;"	f	class:vcg::Box3
Add	vcglib/vcg/space/box3.h	/^void Add( const Point3<BoxScalarType> & p, const BoxScalarType radius )$/;"	f	class:vcg::Box3
Add	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void Add( ObjType* s,bool subdivideBox=false)$/;"	f	class:vcg::SpatialHashTable2D
Add	vcglib/vcg/space/index/spatial_hashing.h	/^		vcg::Box3i Add( ObjType* s)$/;"	f	class:vcg::SpatialHashTable
Add	vcglib/vcg/space/sphere3.h	/^template <class T> void Sphere3<T>::Add(const Point3<T> &p) {$/;"	f	class:vcg::Sphere3
Add	vcglib/vcg/space/sphere3.h	/^template <class T> void Sphere3<T>::Add(const Sphere3<T> &sphere) {$/;"	f	class:vcg::Sphere3
Add33Block	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void Add33Block(ScalarType val[3][3],int index[3][3][2])$/;"	f	class:vcg::tri::PoissonSolver
Add33Block	vcglib/wrap/miq/core/poisson_solver.h	/^	void Add33Block(ScalarType val[3][3],int index[3][3][2])$/;"	f	class:PoissonSolver
Add44Block	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void Add44Block(ScalarType val[4][4],int index[4][4][2])$/;"	f	class:vcg::tri::PoissonSolver
Add44Block	vcglib/wrap/miq/core/poisson_solver.h	/^	void Add44Block(ScalarType val[4][4],int index[4][4][2])$/;"	f	class:PoissonSolver
AddAreaTerm	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void AddAreaTerm(int index[3][3][2],ScalarType ScaleFactor)$/;"	f	class:vcg::tri::PoissonSolver
AddAreaTerm	vcglib/wrap/miq/core/poisson_solver.h	/^	void AddAreaTerm(int index[3][3][2],ScalarType ScaleFactor)$/;"	f	class:PoissonSolver
AddAttrib	vcglib/wrap/io_trimesh/import_vmi.h	/^        static void AddAttrib(MeshType &\/*m*\/, const char * \/*name*\/, unsigned int \/*s*\/, void * \/*data*\/){$/;"	f	struct:vcg::tri::io::K
AddAttrib	vcglib/wrap/io_trimesh/import_vmi.h	/^        static void AddAttrib(MeshType &m, const char * name, unsigned int s, void * data){$/;"	f	struct:vcg::tri::io::Der
AddAttrib	vcglib/wrap/io_trimesh/import_vmi.h	/^        static void AddAttrib(MeshType &m, const char * name, unsigned int s, void * data){$/;"	f	struct:vcg::tri::io::DerK
AddAttributesIfNeeded	vcglib/wrap/miq/core/seams_initializer.h	/^    void AddAttributesIfNeeded()$/;"	f	class:SeamsInitializer
AddAttributesIfNeeded	vcglib/wrap/miq/core/vertex_indexing.h	/^    void AddAttributesIfNeeded()$/;"	f	class:VertexIndexing
AddBox	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void AddBox(ObjType* s,$/;"	f	class:vcg::SpatialHashTable2D
AddBoxes	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void AddBoxes(ObjType* s,$/;"	f	class:vcg::SpatialHashTable2D
AddCell	vcglib/wrap/bmt/bmt.cpp	/^unsigned int BmtBuilder::AddCell(Bmt::Cell cell, unsigned int size, char *data) {  $/;"	f	class:BmtBuilder
AddClipSection	vcglib/wrap/gl/tetramesh.h	/^		void AddClipSection(Point3x p0,Point3x p1,Point3x p2)$/;"	f	class:vcg::tetra::GlTetramesh
AddComplexA	vcglib/wrap/miq/core/poisson_solver.h	/^	void AddComplexA(int VarXindex,$/;"	f	class:PoissonSolver
AddCost	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^    AddCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon185
AddCost	vcglib/vcg/math/eigen.h	/^		AddCost = 0,$/;"	e	enum:Eigen::NumTraits::__anon488
AddCost	vcglib/vcg/math/eigen.h	/^    AddCost = 1,$/;"	e	enum:Eigen::NumTraits::__anon486
AddCost	vcglib/vcg/math/eigen.h	/^    AddCost = 1,$/;"	e	enum:Eigen::NumTraits::__anon487
AddCost	vcglib/vcg/space/point3.h	/^    AddCost = 3,$/;"	e	enum:Eigen::NumTraits::__anon511
AddDataElem	vcglib/vcg/container/container_allocation_table.h	/^AddDataElem(typename STL_CONT::value_type * pt,int n)$/;"	f	class:vcg::CATEntry
AddDuplexVertexCoord	vcglib/wrap/io_trimesh/export_3ds.h	/^		inline static bool AddDuplexVertexCoord(std::map<Key,int> &m,Key key)$/;"	f	class:vcg::tri::io::Exporter3DS
AddEdge	vcglib/vcg/complex/allocate.h	/^            static EdgeIterator AddEdge(MeshType &m, VertexPointer v0, VertexPointer v1)$/;"	f	class:vcg::tri::Allocator
AddEdges	vcglib/vcg/complex/allocate.h	/^            static EdgeIterator AddEdges(MeshType &m, int n)$/;"	f	class:vcg::tri::Allocator
AddEdges	vcglib/vcg/complex/allocate.h	/^            static EdgeIterator AddEdges(MeshType &m, int n, std::vector<EdgePointer*> &local_vec)$/;"	f	class:vcg::tri::Allocator
AddEdges	vcglib/vcg/complex/allocate.h	/^            static EdgeIterator AddEdges(MeshType &m,int n, PointerUpdater<EdgePointer> &pu)$/;"	f	class:vcg::tri::Allocator
AddFace	vcg_mesh.hpp	/^    void AddFace(const MyMesh::FaceType& f, MyMesh::CoordType p)$/;"	f	class:vcg::MySampler
AddFace	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  bool AddFace() {$/;"	f	class:vcg::tri::AdvancingFront
AddFace	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  void AddFace(int v0, int v1, int v2) {$/;"	f	class:vcg::tri::AdvancingFront
AddFace	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        void AddFace(const FaceType &f, const CoordType &p){}$/;"	f	class:OverlapEstimation::VertexPointerSampler
AddFace	vcglib/vcg/complex/algorithms/point_sampling.h	/^  void AddFace(const FaceType &f, CoordType p)$/;"	f	class:vcg::tri::MeshSampler
AddFace	vcglib/vcg/complex/algorithms/point_sampling.h	/^  void AddFace(const FaceType &f, const CoordType &p)$/;"	f	class:vcg::tri::TrivialSampler
AddFace	vcglib/vcg/complex/allocate.h	/^            static FaceIterator AddFace(MeshType &m, CoordType p0, CoordType p1, CoordType p2)$/;"	f	class:vcg::tri::Allocator
AddFace	vcglib/vcg/complex/allocate.h	/^            static FaceIterator AddFace(MeshType &m, VertexPointer v0, VertexPointer v1, VertexPointer v2)$/;"	f	class:vcg::tri::Allocator
AddFaceVertex	vcglib/vcg/complex/algorithms/clustering.h	/^  inline void AddFaceVertex(MeshType &\/*m*\/, FaceType &\/*f*\/, int \/*i*\/)    {		assert(0);}$/;"	f	class:vcg::tri::NearestToCenter
AddFaceVertex	vcglib/vcg/complex/algorithms/clustering.h	/^  inline void AddFaceVertex(MeshType &\/*m*\/, FaceType &f, int i)$/;"	f	class:vcg::tri::AverageColorCell
AddFaces	vcglib/vcg/complex/allocate.h	/^            static FaceIterator AddFaces(MeshType &m, int n)$/;"	f	class:vcg::tri::Allocator
AddFaces	vcglib/vcg/complex/allocate.h	/^            static FaceIterator AddFaces(MeshType &m, int n, PointerUpdater<FacePointer> &pu)$/;"	f	class:vcg::tri::Allocator
AddFaces	vcglib/vcg/complex/allocate.h	/^            static FaceIterator AddFaces(MeshType &m, int n,std::vector<FacePointer *> &local_vec)$/;"	f	class:vcg::tri::Allocator
AddFixedVertex	vcglib/wrap/miq/core/poisson_solver.h	/^    void AddFixedVertex(VertexType *v)$/;"	f	class:PoissonSolver
AddGaussStiffening	vcglib/wrap/miq/core/stiffening.h	/^    static void AddGaussStiffening(MeshType & mesh,ScalarType C)$/;"	f	class:StiffeningInitializer
AddHEdge	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            static void AddHEdge(MeshType &m, HEdgeType * e0, HEdgeType * e1){$/;"	f	class:vcg::tri::UpdateHalfEdges
AddHEdges	vcglib/vcg/complex/allocate.h	/^            static HEdgeIterator AddHEdges(MeshType &m, int n)$/;"	f	class:vcg::tri::Allocator
AddHEdges	vcglib/vcg/complex/allocate.h	/^            static HEdgeIterator AddHEdges(MeshType &m, int n, std::vector<HEdgePointer*> &local_vec)$/;"	f	class:vcg::tri::Allocator
AddHEdges	vcglib/vcg/complex/allocate.h	/^            static HEdgeIterator AddHEdges(MeshType &m,int n, PointerUpdater<HEdgePointer> &pu)$/;"	f	class:vcg::tri::Allocator
AddIntrinsics	vcglib/wrap/io_trimesh/import_out.h	/^static bool  AddIntrinsics(vcg::Shotf &shot, const char * image_file)$/;"	f	class:vcg::tri::io::ImporterOUT
AddMesh	vcglib/vcg/complex/algorithms/clustering.h	/^  void AddMesh(MeshType &m)$/;"	f	class:vcg::tri::Clustering
AddNeighboursToHeap	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^  static void AddNeighboursToHeap( MeshType &m, VertexPointer vp, KdTree<float> &tree, std::vector<WArc> &heap)$/;"	f	class:vcg::tri::PointCloudNormal
AddNewIndex	vcglib/wrap/miq/core/vertex_indexing.h	/^    int AddNewIndex(VertexType* v0)$/;"	f	class:VertexIndexing
AddNewNormalVertex	vcglib/wrap/io_trimesh/export_obj.h	/^  inline static bool AddNewNormalVertex(typename std::map<CoordType,int> &m, CoordType &n ,int value)$/;"	f	class:vcg::tri::io::ExporterOBJ
AddNewTextureCoord	vcglib/wrap/io_trimesh/export_obj.h	/^  inline static bool AddNewTextureCoord(std::map<typename vcg::TexCoord2<ScalarType>,int> &m,$/;"	f	class:vcg::tri::io::ExporterOBJ
AddNode	vcglib/vcg/space/index/octree_template.h	/^	NodePointer AddNode(CenterType path)$/;"	f	class:vcg::OctreeTemplate
AddNodeToMesh	vcglib/wrap/io_trimesh/import_dae.h	/^		static void AddNodeToMesh(QDomElement node, $/;"	f	class:vcg::tri::io::ImporterDAE
AddPerEdgeAttribute	vcglib/vcg/complex/allocate.h	/^     AddPerEdgeAttribute( MeshType & m){$/;"	f	class:vcg::tri::Allocator
AddPerEdgeAttribute	vcglib/vcg/complex/allocate.h	/^     AddPerEdgeAttribute( MeshType & m, std::string name){$/;"	f	class:vcg::tri::Allocator
AddPerFaceAttribute	vcglib/vcg/complex/allocate.h	/^     AddPerFaceAttribute( MeshType & m){$/;"	f	class:vcg::tri::Allocator
AddPerFaceAttribute	vcglib/vcg/complex/allocate.h	/^     AddPerFaceAttribute( MeshType & m, std::string name){$/;"	f	class:vcg::tri::Allocator
AddPerMeshAttribute	vcglib/vcg/complex/allocate.h	/^     AddPerMeshAttribute( MeshType & m, std::string name){$/;"	f	class:vcg::tri::Allocator
AddPerVertexAttribute	vcglib/vcg/complex/allocate.h	/^     AddPerVertexAttribute( MeshType & m){$/;"	f	class:vcg::tri::Allocator
AddPerVertexAttribute	vcglib/vcg/complex/allocate.h	/^     AddPerVertexAttribute( MeshType & m, std::string name){$/;"	f	class:vcg::tri::Allocator
AddPixelCount	vcglib/apps/unsupported/shadevis/visshader.h	/^	void AddPixelCount(std::vector<float> &_VV, const std::vector<int> &PixSeen)$/;"	f	class:vcg::VisShader
AddPoint	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  void AddPoint(CoordType p)$/;"	f	struct:vcg::tri::VoronoiProcessing::QuadricSumDistance
AddPointSet	vcglib/vcg/complex/algorithms/clustering.h	/^	void AddPointSet(MeshType &m, bool UseOnlySelected=false)$/;"	f	class:vcg::tri::Clustering
AddPolygonToMesh	vcglib/wrap/io_trimesh/import_dae.h	/^    static DAEError AddPolygonToMesh(MyPolygon<typename ColladaMesh::VertexType>  &polyTemp, ColladaMesh& m)$/;"	f	class:vcg::tri::io::ImporterDAE
AddProp	vcglib/wrap/ply/plylib.cpp	/^void PlyElement::AddProp( const char * na, int ti, int isl, int t2 )$/;"	f	class:vcg::ply::PlyElement
AddQuadFace	vcglib/vcg/complex/allocate.h	/^            static FaceIterator AddQuadFace(MeshType &m, VertexPointer v0, VertexPointer v1, VertexPointer v2, VertexPointer v3)$/;"	f	class:vcg::tri::Allocator
AddRHS	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void AddRHS(ScalarType b[6],$/;"	f	class:vcg::tri::PoissonSolver
AddRHS	vcglib/wrap/miq/core/poisson_solver.h	/^	void AddRHS(ScalarType b[6],$/;"	f	class:PoissonSolver
AddRT	vcglib/wrap/gl/fbo.h	/^	bool AddRT(RenderTarget * rt)$/;"	f	class:FrameBuffer
AddRandomSample	vcglib/apps/metro/sampling.h	/^inline void Sampling<MetroMesh>::AddRandomSample(FaceIterator &T)$/;"	f	class:vcg::Sampling
AddRange	vcglib/vcg/space/index/octree.h	/^        void AddRange(const Voxel *voxel)$/;"	f	struct:vcg::Voxel
AddSample	vcglib/apps/metro/sampling.h	/^float Sampling<MetroMesh>::AddSample(const Point3x &p )$/;"	f	class:vcg::Sampling
AddSeamsByMM	vcglib/wrap/miq/core/seams_initializer.h	/^    void AddSeamsByMM()$/;"	f	class:SeamsInitializer
AddSingularityRound	vcglib/wrap/miq/core/poisson_solver.h	/^    void AddSingularityRound()$/;"	f	class:PoissonSolver
AddTextureSample	vcg_mesh.hpp	/^    void AddTextureSample(const MyMesh::FaceType&,$/;"	f	class:vcg::MySampler
AddTextureSample	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        void AddTextureSample(const FaceType &, const CoordType &, const Point2i &){}$/;"	f	class:OverlapEstimation::VertexPointerSampler
AddTextureSample	vcglib/vcg/complex/algorithms/point_sampling.h	/^  void AddTextureSample(const FaceType &, const CoordType &, const Point2i &, float )$/;"	f	class:vcg::tri::TrivialSampler
AddToRead	vcglib/wrap/ply/plylib.cpp	/^int PlyElement::AddToRead($/;"	f	class:vcg::ply::PlyElement
AddToRead	vcglib/wrap/ply/plylib.cpp	/^int PlyFile::AddToRead($/;"	f	class:vcg::ply::PlyFile
AddToRead	vcglib/wrap/ply/plylib.h	/^	inline int AddToRead( const PropDescriptor & p )$/;"	f	class:vcg::ply::PlyFile
AddTriangles	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            inline void AddTriangles(const char *vertices_list, char n, VertexPointer v12=NULL)$/;"	f	class:vcg::tri::MarchingCubes
AddUpdate	vcglib/wrap/bmt/bmt.cpp	/^void BmtBuilder::AddUpdate(std::vector<unsigned int> &created, std::vector<unsigned int> &erased) {$/;"	f	class:BmtBuilder
AddValA	vcglib/wrap/miq/core/poisson_solver.h	/^	void AddValA(int Xindex,$/;"	f	class:PoissonSolver
AddValB	vcglib/wrap/miq/core/poisson_solver.h	/^	void AddValB(int Xindex,$/;"	f	class:PoissonSolver
AddVert	vcg_mesh.hpp	/^    void AddVert(const MyMesh::VertexType& p)$/;"	f	class:vcg::MySampler
AddVert	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        void AddVert(VertexType &p){ sampleVec.push_back(&p); } \/\/this function is the only we really need$/;"	f	class:OverlapEstimation::VertexPointerSampler
AddVert	vcglib/vcg/complex/algorithms/point_sampling.h	/^  void AddVert(const VertexType &p)$/;"	f	class:vcg::tri::MeshSampler
AddVert	vcglib/vcg/complex/algorithms/point_sampling.h	/^  void AddVert(const VertexType &p)$/;"	f	class:vcg::tri::TrivialSampler
AddVert	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  void AddVert(const VertexType &p)$/;"	f	class:vcg::tri::ClusteringSampler
AddVertex	vcglib/vcg/complex/algorithms/clustering.h	/^  inline void AddVertex(MeshType &\/*m*\/, GridType &g, Point3i &pi, VertexType &v)$/;"	f	class:vcg::tri::NearestToCenter
AddVertex	vcglib/vcg/complex/algorithms/clustering.h	/^  inline void AddVertex(MeshType &m, GridType &\/*g*\/, Point3i &\/*pi*\/, VertexType &v)$/;"	f	class:vcg::tri::AverageColorCell
AddVertex	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  void AddVertex(VertexType &vertex) {$/;"	f	class:vcg::tri::AdvancingFront
AddVertex	vcglib/vcg/complex/allocate.h	/^            static VertexIterator AddVertex(MeshType &m, const CoordType &p)$/;"	f	class:vcg::tri::Allocator
AddVertex	vcglib/vcg/complex/allocate.h	/^            static VertexIterator AddVertex(MeshType &m, const CoordType &p, const Color4b &c)$/;"	f	class:vcg::tri::Allocator
AddVertexIndex	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void AddVertexIndex(VertexType* v,int index)$/;"	f	class:vcg::tri::PoissonSolver
AddVertices	vcglib/vcg/complex/allocate.h	/^            static VertexIterator AddVertices(MeshType &m, int n)$/;"	f	class:vcg::tri::Allocator
AddVertices	vcglib/vcg/complex/allocate.h	/^            static VertexIterator AddVertices(MeshType &m, int n, std::vector<VertexPointer *> &local_vec)$/;"	f	class:vcg::tri::Allocator
AddVertices	vcglib/vcg/complex/allocate.h	/^            static VertexIterator AddVertices(MeshType &m,int n, PointerUpdater<VertexPointer> &pu)$/;"	f	class:vcg::tri::Allocator
Add_Ons	vcglib/wrap/gl/addons.h	/^	class Add_Ons$/;"	c	namespace:vcg
AdditionalInfo	vcglib/wrap/io_trimesh/additionalinfo.h	/^	AdditionalInfo()$/;"	f	class:AdditionalInfo
AdditionalInfo	vcglib/wrap/io_trimesh/additionalinfo.h	/^class AdditionalInfo$/;"	c
AdditionalProductEvaluationMode	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^enum AdditionalProductEvaluationMode {SkylineTimeDenseProduct, SkylineTimeSkylineProduct, DenseTimeSkylineProduct};$/;"	g	namespace:Eigen
AddtoQ3	vcglib/vcg/math/quadric5.h	/^  void AddtoQ3(math::Quadric<double> &q3) const$/;"	f	class:vcg::Quadric5
AdjTypePack	vcglib/vcg/simplex/face/component_ocf.h	/^  AdjTypePack() {$/;"	f	struct:vcg::face::vector_ocf::AdjTypePack
AdjTypePack	vcglib/vcg/simplex/face/component_ocf.h	/^struct AdjTypePack {$/;"	s	class:vcg::face::vector_ocf
AdjVertex	vcglib/vcg/complex/algorithms/update/curvature.h	/^  struct AdjVertex {$/;"	s	class:vcg::tri::UpdateCurvature
AdjacencyRing	vcglib/vcg/complex/algorithms/hole.h	/^  static std::vector<FacePointer> &AdjacencyRing()$/;"	f	class:vcg::tri::SelfIntersectionEar
AdjointReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::MatrixBase
AdjointReturnType	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::SparseMatrixBase
AdjustBoundingBox	vcglib/vcg/space/index/octree.h	/^        inline int AdjustBoundingBox$/;"	f	class:vcg::Octree
AdvancingFront	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  AdvancingFront(MESH &_mesh): mesh(_mesh) {$/;"	f	class:vcg::tri::AdvancingFront
AdvancingFront	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^template <class MESH> class AdvancingFront {$/;"	c	namespace:vcg::tri
AdvancingTest	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  AdvancingTest(MESH &_mesh): AdvancingFront<MESH>(_mesh) {}$/;"	f	class:vcg::tri::AdvancingTest
AdvancingTest	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^template <class MESH> class AdvancingTest: public AdvancingFront<MESH> {$/;"	c	namespace:vcg::tri
Affine	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Affine        = 0x2,$/;"	e	enum:Eigen::TransformTraits
Affine2d	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Affine> Affine2d;$/;"	t	namespace:Eigen
Affine2f	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Affine> Affine2f;$/;"	t	namespace:Eigen
Affine3d	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Affine> Affine3d;$/;"	t	namespace:Eigen
Affine3f	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Affine> Affine3f;$/;"	t	namespace:Eigen
AffineCompact	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  AffineCompact = 0x10 | Affine,$/;"	e	enum:Eigen::TransformTraits
AffineCompact2d	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,AffineCompact> AffineCompact2d;$/;"	t	namespace:Eigen
AffineCompact2f	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,AffineCompact> AffineCompact2f;$/;"	t	namespace:Eigen
AffineCompact3d	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,AffineCompact> AffineCompact3d;$/;"	t	namespace:Eigen
AffineCompact3f	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,AffineCompact> AffineCompact3f;$/;"	t	namespace:Eigen
AffinePart	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^                              Block<MatrixType,Dim,HDim> >::type AffinePart;$/;"	t	class:Eigen::Transform
AffinePart	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::AffinePart AffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part
AffineTransformType	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Affine> AffineTransformType;$/;"	t	class:Eigen::Translation
Align	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^FourPCS<MeshType>::	 Align(  int L, vcg::Matrix44f & result, vcg::CallBackPos * cb ){ \/\/ main loop$/;"	f	class:vcg::tri::FourPCS
AlignWith	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::AlignWith(const Point3f primary,const Point3f secondary,const char c1,const char c2)$/;"	f	class:ActiveCoordinateFrame
AlignWith	vcglib/wrap/gui/coordinateframe.cpp	/^void MovableCoordinateFrame::AlignWith(const Point3f pri,const Point3f secondary,const char c1, const char c2)$/;"	f	class:MovableCoordinateFrame
AlignZeroTr	vcglib/vcg/complex/algorithms/symmetry.h	/^    CoordType AlignZeroTr;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
Aligned	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Aligned=1 $/;"	e	enum:Eigen::__anon259
AlignedBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int AlignedBit = 0x80;$/;"	m	namespace:Eigen
AlignedBox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox(const VectorType& _min, const VectorType& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox
AlignedBox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox()$/;"	f	class:Eigen::AlignedBox
AlignedBox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox
AlignedBox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const VectorType& p) : m_min(p), m_max(p) {}$/;"	f	class:Eigen::AlignedBox
AlignedBox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(int _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox
AlignedBox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
AlignedBox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define AlignedBox /;"	d
AlignedBox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef AlignedBox$/;"	d
AlignedBox	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox(const OtherVectorType1& _min, const OtherVectorType2& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox
AlignedBox	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox()$/;"	f	class:Eigen::AlignedBox
AlignedBox	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(Index _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox
AlignedBox	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox
AlignedBox	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const MatrixBase<Derived>& a_p)$/;"	f	class:Eigen::AlignedBox
AlignedBox	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
AlignedMapType	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Aligned> AlignedMapType;$/;"	t	class:Eigen::PlainObjectBase
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    AlignedOnScalar = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon169
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon10
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon16
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon27
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon28
AlignedOnScalar	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon29
AlignedScaling2d	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,2> AlignedScaling2d;$/;"	t	namespace:Eigen
AlignedScaling2f	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 2> AlignedScaling2f;$/;"	t	namespace:Eigen
AlignedScaling3d	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,3> AlignedScaling3d;$/;"	t	namespace:Eigen
AlignedScaling3f	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 3> AlignedScaling3f;$/;"	t	namespace:Eigen
AlignmentMask	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::LLT::__anon6
AlignmentMask	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::SVD::__anon349
AllEdge	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void AllEdge(MetroMesh & m, VertexSampler &ps)$/;"	f	class:vcg::tri::SurfaceSampling
AllFace	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void AllFace(MetroMesh & m, VertexSampler &ps)$/;"	f	class:vcg::tri::SurfaceSampling
AllTypes	vcglib/vcg/complex/all_types.h	/^struct AllTypes{$/;"	s	namespace:vcg
AllVertex	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void AllVertex(MetroMesh & m, VertexSampler &ps)$/;"	f	class:vcg::tri::SurfaceSampling
Alloc	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    static void Alloc(VertexType *v,vcg::TexCoord2f &coord)$/;"	f	class:vcg::tri::QuadricTexHelper
Alloc	vcglib/vcg/simplex/face/base.h	/^	inline void Alloc(const int & ){}$/;"	f	class:vcg::FaceTypeHolder
Alloc	vcglib/vcg/simplex/face/component.h	/^    inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::Quality
Alloc	vcglib/vcg/simplex/face/component.h	/^    inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::VFAdj
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns) {T::Alloc(ns);}$/;"	f	class:vcg::face::EmptyCore
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::BitFlags
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::Color
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::EFAdj
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::FEAdj
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::FFAdj
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::FHAdj
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::NormalAbs
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::Quality3
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::VertexRef
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::WedgeNormal
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::WedgeRealNormal
Alloc	vcglib/vcg/simplex/face/component.h	/^  inline void Alloc(const int & ns){T::Alloc(ns);}$/;"	f	class:vcg::face::WedgeTexCoord
Alloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Alloc(const int & \/*ns*\/){}$/;"	f	class:vcg::face::PolyInfo
Alloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Alloc(const int & ns) {$/;"	f	class:vcg::face::PFEAdj
Alloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Alloc(const int & ns) {$/;"	f	class:vcg::face::PFFAdj
Alloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Alloc(const int & ns) {$/;"	f	class:vcg::face::PFVAdj
Alloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Alloc(const int & ns) {$/;"	f	class:vcg::face::PVFAdj
Alloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Alloc(const int & ns) {T::Alloc(ns);}$/;"	f	class:vcg::face::PFHAdj
Allocate	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 void Allocate(const int size)$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
Allocate	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void Allocate(const BoundingBoxType &bounding_box, const int cell_per_side)$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
Allocate	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void Allocate(const int entry_per_side)$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
Allocate	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void Allocate(int size)$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
AllocateEdge	vcglib/vcg/complex/algorithms/update/topology.h	/^static void AllocateEdge(MeshType &m)$/;"	f	class:vcg::tri::UpdateTopology
AllocateSystem	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void AllocateSystem()$/;"	f	class:vcg::tri::PoissonSolver
AllocateSystem	vcglib/wrap/miq/core/poisson_solver.h	/^	void AllocateSystem()$/;"	f	class:PoissonSolver
Allocated	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^std::vector<MySegmentType> Allocated;$/;"	v
AllocatedCells	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        std::vector<Point2i> AllocatedCells;$/;"	m	class:vcg::SpatialHashTable2D
AllocatedCells	vcglib/vcg/space/index/spatial_hashing.h	/^	std::vector<Point3i> AllocatedCells;$/;"	m	class:vcg::SpatialHashTable
Allocator	vcglib/apps/unsupported/extractors/extractor/Definitions.h	/^typedef vcg::tri::Allocator< Mesh > Allocator;$/;"	t
Allocator	vcglib/vcg/complex/allocate.h	/^        class Allocator$/;"	c	namespace:vcg::tri
AllocatorType	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef typename vcg::tri::Allocator< TRIMESH_TYPE > AllocatorType;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
AllocatorType	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef typename vcg::tri::Allocator< TRIMESH_TYPE > AllocatorType;$/;"	t	class:vcg::tri::MarchingCubes
Alpha	vcglib/vcg/simplex/face/distance.h	/^        static ScalarType & Alpha(){static ScalarType alpha = 1.0; return alpha;}$/;"	f	class:vcg::face::PointNormalDistanceFunctor
Alpha	vcglib/vcg/simplex/vertex/distance.h	/^		static ScalarType & Alpha(){static ScalarType alpha = 1.0; return alpha;}$/;"	f	class:vcg::vertex::PointNormalDistanceFunctor
AltiVec	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^    AltiVec = 0x2,$/;"	e	enum:Eigen::Architecture::Type
AmbiVector	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    AmbiVector(Index size)$/;"	f	class:Eigen::internal::AmbiVector
AmbiVector	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector$/;"	c	namespace:Eigen::internal
AmbientDimAtCompileTime	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon329
AmbientDimAtCompileTime	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::Hyperplane::__anon331
AmbientDimAtCompileTime	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::ParametrizedLine::__anon332
AmbientDimAtCompileTime	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon357
AmbientDimAtCompileTime	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::Hyperplane::__anon361
AmbientDimAtCompileTime	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::ParametrizedLine::__anon362
AmbientTag	vcglib/wrap/dae/colladaformat.h	/^		AmbientTag()$/;"	f	class:Collada::Tags::AmbientTag
AmbientTag	vcglib/wrap/dae/colladaformat.h	/^	class AmbientTag : public XMLTag$/;"	c	namespace:Collada::Tags
Ancestor	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_all<Lhs>::type Ancestor;$/;"	t	struct:Eigen::internal::traits
Angle	vcglib/vcg/math/eigen.h	/^Angle(const Eigen::MatrixBase<Derived1>& p1, const Eigen::MatrixBase<Derived2> & p2)$/;"	f	namespace:vcg
Angle	vcglib/vcg/space/deprecated_point.h	/^	inline ScalarType &Angle(){$/;"	f	class:vcg::ndim::Point2
Angle	vcglib/vcg/space/deprecated_point.h	/^inline S Angle( Point3<S>  const & p1, Point3<S>  const & p2 )$/;"	f	namespace:vcg::ndim
Angle	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType Angle() const {$/;"	f	class:vcg::Point2
Angle	vcglib/vcg/space/deprecated_point2.h	/^inline T Angle( Point2<T> const & p0, Point2<T> const & p1 )$/;"	f	namespace:vcg
Angle	vcglib/vcg/space/deprecated_point3.h	/^inline P3ScalarType Angle( Point3<P3ScalarType> const & p1, Point3<P3ScalarType> const & p2 )$/;"	f	namespace:vcg
Angle	vcglib/vcg/space/deprecated_point4.h	/^T Angle( const Point4<T>& p1, const Point4<T>  & p2 )$/;"	f	namespace:vcg
Angle	vcglib/vcg/space/point2.h	/^	inline Scalar Angle() const$/;"	f	class:vcg::Point2
AngleAxis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define AngleAxis /;"	d
AngleAxis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef AngleAxis$/;"	d
AngleAxis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(Scalar angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(const QuaternionType& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis
AngleAxis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen
AngleAxis	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  inline AngleAxis(Scalar angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis
AngleAxis	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  template<typename QuatDerived> inline explicit AngleAxis(const QuaternionBase<QuatDerived>& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen
AngleAxisType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::Quaternion
AngleAxisType	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::QuaternionBase
AngleAxisType	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename Base::AngleAxisType AngleAxisType;$/;"	t	class:Eigen::Quaternion
AngleAxisd	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define AngleAxisd /;"	d
AngleAxisd	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef AngleAxisd$/;"	d
AngleAxisd	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
AngleAxisd	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
AngleAxisf	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define AngleAxisf /;"	d
AngleAxisf	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef AngleAxisf$/;"	d
AngleAxisf	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
AngleAxisf	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
AngleCos3D	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static ScalarType AngleCos3D(const FaceType *f,int e)$/;"	f	class:vcg::tri::Distortion
AngleCosDistortion	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static ScalarType AngleCosDistortion(const FaceType *f,int e)$/;"	f	class:vcg::tri::Distortion
AngleCosUV	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static ScalarType AngleCosUV(const FaceType *f,int e)$/;"	f	class:vcg::tri::Distortion
AngleDist	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			enum DistType{AreaDist,EdgeDist,AngleDist};$/;"	e	enum:vcg::tri::Distortion::DistType
AngleDistortion	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static ScalarType AngleDistortion(const FaceType *f)$/;"	f	class:vcg::tri::Distortion
AngleN	vcglib/vcg/math/eigen.h	/^AngleN(const Eigen::MatrixBase<Derived1>& p1, const Eigen::MatrixBase<Derived2> & p2)$/;"	f	namespace:vcg
AngleN	vcglib/vcg/space/deprecated_point.h	/^inline S AngleN( Point3<S>  const & p1, Point3<S>  const & p2 )$/;"	f	namespace:vcg::ndim
AngleN	vcglib/vcg/space/deprecated_point3.h	/^inline P3ScalarType AngleN( Point3<P3ScalarType> const & p1, Point3<P3ScalarType> const & p2 )$/;"	f	namespace:vcg
AngleRad3D	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static ScalarType AngleRad3D(const FaceType *f,int e)$/;"	f	class:vcg::tri::Distortion
AngleRadDistortion	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static ScalarType AngleRadDistortion(const FaceType *f,int e)$/;"	f	class:vcg::tri::Distortion
AngleRadUV	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static ScalarType AngleRadUV(const FaceType *f,int e)$/;"	f	class:vcg::tri::Distortion
Animate	vcglib/wrap/gui/trackball.cpp	/^void Trackball::Animate(unsigned int msec){$/;"	f	class:Trackball
Animate	vcglib/wrap/gui/trackmode.cpp	/^void NavigatorWasdMode::Animate(unsigned int msec, Trackball * tb){$/;"	f	class:NavigatorWasdMode
Animate	vcglib/wrap/gui/trackmode.cpp	/^void TrackMode::Animate(unsigned int, Trackball *){$/;"	f	class:TrackMode
AnisotropicDistance	vcglib/vcg/complex/algorithms/geodesic.h	/^  template <class CrossFunctor > AnisotropicDistance(MeshType &m, CrossFunctor &cf)$/;"	f	class:vcg::tri::AnisotropicDistance
AnisotropicDistance	vcglib/vcg/complex/algorithms/geodesic.h	/^class AnisotropicDistance{$/;"	c	namespace:vcg::tri
Annulus	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Annulus(MeshType & m, float externalRadius, float internalRadius, int slices)$/;"	f	namespace:vcg::tri
Append	vcglib/vcg/complex/append.h	/^class Append$/;"	c	namespace:vcg::tri
Apply	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  static void Apply( const VertexType &a,  const VertexType &b, ScalarType t, VertexType &res){$/;"	f	class:vcg::tri::GeometricInterpolator
Apply	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  static void Apply(MeshType &m, CoordType &origin, CoordType &end, ScalarType radius)$/;"	f	class:vcg::tri::CylinderClipping
Apply	vcglib/vcg/complex/algorithms/refine.h	/^  static void Apply(FaceType *f,$/;"	f	class:vcg::tri::TriSplit
Apply	vcglib/vcg/math/quadric.h	/^	ResultScalarType Apply( const Point3<ResultScalarType> & p ) const	\/\/ Applica la quadrica al punto p$/;"	f	class:vcg::math::Quadric
Apply	vcglib/vcg/math/quadric5.h	/^    ScalarType Apply(const ScalarType v[5]) const$/;"	f	class:vcg::Quadric5
Apply	vcglib/wrap/gui/trackball.cpp	/^void Trackball::Apply () {$/;"	f	class:Trackball
Apply	vcglib/wrap/gui/trackmode.cpp	/^void AreaMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:AreaMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void AxisMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:AxisMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void AxisMode::Apply (Trackball * tb, float WheelNotch)$/;"	f	class:AxisMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void CylinderMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:CylinderMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void CylinderMode::Apply (Trackball * tb, float WheelNotch)$/;"	f	class:CylinderMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void NavigatorWasdMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:NavigatorWasdMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void NavigatorWasdMode::Apply (Trackball * tb, float WheelNotch)$/;"	f	class:NavigatorWasdMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void PanMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:PanMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void PathMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:PathMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void PathMode::Apply (Trackball * tb, float WheelNotch)$/;"	f	class:PathMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void PlaneMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:PlaneMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void PolarMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:PolarMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void ScaleMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:ScaleMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void ScaleMode::Apply (Trackball * tb, float WheelNotch)$/;"	f	class:ScaleMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void SphereMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:SphereMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void TrackMode::Apply (Trackball * , Point3f ){}$/;"	f	class:TrackMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void TrackMode::Apply (Trackball * , float ){}$/;"	f	class:TrackMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void ZMode::Apply (Trackball * tb, Point3f new_point)$/;"	f	class:ZMode
Apply	vcglib/wrap/gui/trackmode.cpp	/^void ZMode::Apply (Trackball * tb, float WheelNotch)$/;"	f	class:ZMode
ApplyInverse	vcglib/wrap/gui/trackball.cpp	/^void Trackball::ApplyInverse() {$/;"	f	class:Trackball
ApplyRigidTransformation	vcglib/vcg/math/shot.h	/^void Shot<S, RotationType>::ApplyRigidTransformation(const Matrix44<S> & M)$/;"	f	class:vcg::Shot
ApplySimilarity	vcglib/vcg/math/shot.h	/^void Shot<S, RotationType>::ApplySimilarity( Matrix44<S>   M)$/;"	f	class:vcg::Shot
ApplySimilarity	vcglib/vcg/math/shot.h	/^void Shot<S, RotationType>::ApplySimilarity(const Similarity<S> & Sm)$/;"	f	class:vcg::Shot
ApproximateGeodesicDistance	vcglib/vcg/space/deprecated_point3.h	/^P3ScalarType ApproximateGeodesicDistance(const Point3<P3ScalarType>& p0, const Point3<P3ScalarType>& n0,$/;"	f	namespace:vcg
ApproximateGeodesicDistanceFunctor	vcglib/vcg/simplex/vertex/distance.h	/^class ApproximateGeodesicDistanceFunctor {$/;"	c	namespace:vcg::vertex
Architecture	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^namespace Architecture$/;"	n	namespace:Eigen
Area	vcglib/vcg/space/box.h	/^	inline S Area() const {$/;"	f	class:vcg::Box
Area	vcglib/vcg/space/box2.h	/^	inline ScalarType Area() const$/;"	f	class:vcg::Box2
Area3D	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static ScalarType Area3D(const FaceType *f)$/;"	f	class:vcg::tri::Distortion
AreaData	vcglib/vcg/complex/algorithms/update/curvature.h	/^  class AreaData$/;"	c	class:vcg::tri::UpdateCurvature
AreaDist	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			enum DistType{AreaDist,EdgeDist,AngleDist};$/;"	e	enum:vcg::tri::Distortion::DistType
AreaDistortion	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^            static ScalarType AreaDistortion(const FaceType *f,$/;"	f	class:vcg::tri::Distortion
AreaMode	vcglib/wrap/gui/trackmode.h	/^  AreaMode (const std::vector < Point3f > &pts)$/;"	f	class:vcg::AreaMode
AreaMode	vcglib/wrap/gui/trackmode.h	/^class AreaMode:public TrackMode {$/;"	c	namespace:vcg
AreaPreservingTextureOptimizer	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  AreaPreservingTextureOptimizer(MeshType &_m):Super(_m),data(_m.face),sum(_m.vert){$/;"	f	class:vcg::tri::AreaPreservingTextureOptimizer
AreaPreservingTextureOptimizer	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^class AreaPreservingTextureOptimizer:public TextureOptimizer<MESH_TYPE>{$/;"	c	namespace:vcg::tri
AreaUV	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static ScalarType AreaUV(const FaceType *f)$/;"	f	class:vcg::tri::Distortion
Arity1	vcglib/vcg/container/derivation_chain.h	/^					class Arity1: public A<Base > {$/;"	c	namespace:vcg
Arity10	vcglib/vcg/container/derivation_chain.h	/^					class Arity10: public J<Arity9<Base, A, B, C, D, E, F, G, H, I > > {};$/;"	c	namespace:vcg
Arity11	vcglib/vcg/container/derivation_chain.h	/^					class Arity11: public K<Arity10<Base, A, B, C, D, E, F, G, H, I, J> > {};$/;"	c	namespace:vcg
Arity12	vcglib/vcg/container/derivation_chain.h	/^					class Arity12: public L<Arity11<Base, A, B, C, D, E, F, G, H, I, J, K> > {};$/;"	c	namespace:vcg
Arity2	vcglib/vcg/container/derivation_chain.h	/^					class Arity2: public B<Arity1<Base, A> > {};$/;"	c	namespace:vcg
Arity3	vcglib/vcg/container/derivation_chain.h	/^					class Arity3: public C<Arity2<Base, A, B> > {};$/;"	c	namespace:vcg
Arity4	vcglib/vcg/container/derivation_chain.h	/^					class Arity4: public D<Arity3<Base, A, B, C> > {};$/;"	c	namespace:vcg
Arity5	vcglib/vcg/container/derivation_chain.h	/^					class Arity5: public E<Arity4<Base, A, B, C, D> > {};$/;"	c	namespace:vcg
Arity6	vcglib/vcg/container/derivation_chain.h	/^					class Arity6: public F<Arity5<Base, A, B, C, D, E> > {};$/;"	c	namespace:vcg
Arity7	vcglib/vcg/container/derivation_chain.h	/^					class Arity7: public G<Arity6<Base, A, B, C, D, E, F> > {};$/;"	c	namespace:vcg
Arity8	vcglib/vcg/container/derivation_chain.h	/^					class Arity8: public H<Arity7<Base, A, B, C, D, E, F, G > > {};$/;"	c	namespace:vcg
Arity9	vcglib/vcg/container/derivation_chain.h	/^					class Arity9: public I<Arity8<Base, A, B, C, D, E, F, G, H > > {};$/;"	c	namespace:vcg
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    Array(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Array
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Array& other)$/;"	f	class:Eigen::Array
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Array
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Array
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Array
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const T0& x, const T1& y)$/;"	f	class:Eigen::Array
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array() : Base()$/;"	f	class:Eigen::Array
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array(Index dim)$/;"	f	class:Eigen::Array
Array	vcglib/eigenlib/Eigen/src/Core/Array.h	/^class Array$/;"	c	namespace:Eigen
Array	vcglib/eigenlib/Eigen/src/Core/Map.h	/^  ::Array(const Scalar *data)$/;"	f	class:Eigen::Array
ArrayBase	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    ArrayBase() : Base() {}$/;"	f	class:Eigen::ArrayBase
ArrayBase	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^template<typename Derived> class ArrayBase$/;"	c	namespace:Eigen
ArraySourceTag	vcglib/wrap/dae/colladaformat.h	/^		ArraySourceTag(const QString& id,const QString& name)$/;"	f	class:Collada::Tags::ArraySourceTag
ArraySourceTag	vcglib/wrap/dae/colladaformat.h	/^	class ArraySourceTag : public XMLTag$/;"	c	namespace:Collada::Tags
ArrayWrapper	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline ArrayWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ArrayWrapper
ArrayWrapper	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^class ArrayWrapper : public ArrayBase<ArrayWrapper<ExpressionType> >$/;"	c	namespace:Eigen
ArrayXpr	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^struct ArrayXpr {};$/;"	s	namespace:Eigen
AsEdgeType	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsEdgeType: public T{typedef A EdgeType;			typedef EdgeType *	EdgePointer			;};$/;"	s	struct:vcg::Use
AsFaceType	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsFaceType: public T{typedef A FaceType;			typedef FaceType * FacePointer			;};$/;"	s	struct:vcg::Use
AsHEdgeType	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsHEdgeType: public T{typedef A HEdgeType;		typedef HEdgeType * HEdgePointer		;};$/;"	s	struct:vcg::Use
AsTetraType	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsTetraType: public T{typedef A TetraType;		typedef TetraType * TetraPointer		;};$/;"	s	struct:vcg::Use
AsVertexType	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsVertexType: public T{typedef A VertexType;	typedef VertexType * VertexPointer	;};$/;"	s	struct:vcg::Use
Asin	vcglib/vcg/math/base.h	/^  inline double Asin(const double v)   { return asin(v); }$/;"	f	namespace:vcg::math
Asin	vcglib/vcg/math/base.h	/^  inline float Asin(const float v)   { return asinf(v); }$/;"	f	namespace:vcg::math
Assert	vcglib/vcg/simplex/face/pos.h	/^	void Assert()$/;"	f	class:vcg::face::Pos
Assert	vcglib/vcg/simplex/tetrahedron/pos.h	/^	void Assert()$/;"	f	class:vcg::tetra::Pos
AssertAdj	vcglib/vcg/simplex/face/topology.h	/^void AssertAdj(FaceType & f)$/;"	f	namespace:vcg::face
AssetTag	vcglib/wrap/dae/colladaformat.h	/^		AssetTag()$/;"	f	class:Collada::Tags::AssetTag
AssetTag	vcglib/wrap/dae/colladaformat.h	/^	class AssetTag : public XMLTag$/;"	c	namespace:Collada::Tags
AssociatedPolynomial	vcglib/vcg/math/legendre.h	/^	double AssociatedPolynomial(unsigned l, unsigned m, ScalarType cos_theta, ScalarType sin_theta)$/;"	f	class:vcg::math::DynamicLegendre
AssociatedPolynomial	vcglib/vcg/math/legendre.h	/^	double AssociatedPolynomial(unsigned l, unsigned m, ScalarType x)$/;"	f	class:vcg::math::DynamicLegendre
AssociatedPolynomial	vcglib/vcg/math/legendre.h	/^	static double AssociatedPolynomial(unsigned l, unsigned m, ScalarType cos_theta, ScalarType sin_theta)$/;"	f	class:vcg::math::Legendre
AssociatedPolynomial	vcglib/vcg/math/legendre.h	/^	static double AssociatedPolynomial(unsigned l, unsigned m, ScalarType x)$/;"	f	class:vcg::math::Legendre
At	vcglib/vcg/container/simple_temporary_data.h	/^    void * At(unsigned int ) {assert(0);return (void*)0;}$/;"	f	class:vcg::Attribute
At	vcglib/vcg/container/simple_temporary_data.h	/^    void * At(unsigned int i ) {return &(*this)[i];};$/;"	f	class:vcg::SimpleTempData
Atan2	vcglib/vcg/math/base.h	/^  inline double Atan2(const double v0,const double v1)   { return atan2(v0,v1); }$/;"	f	namespace:vcg::math
Atan2	vcglib/vcg/math/base.h	/^  inline float Atan2(const float v0,const float v1)   { return atan2f(v0,v1); }$/;"	f	namespace:vcg::math
Attach	vcglib/wrap/gl/fbo.h	/^bool RenderTarget::Attach(FrameBuffer * fb)$/;"	f	class:RenderTarget
Attach	vcglib/wrap/gl/shaders.h	/^	void Attach(Shader * shd)$/;"	f	class:Program
AttachedShader	vcglib/wrap/gl/shaders.h	/^	Shader * AttachedShader(int i)$/;"	f	class:Program
AttachedShaders	vcglib/wrap/gl/shaders.h	/^	GLsizei AttachedShaders(void) const$/;"	f	class:Program
Attachment	vcglib/wrap/gl/fbo.h	/^	GLenum Attachment(void) const$/;"	f	class:ColorRenderTarget
Attachment	vcglib/wrap/gl/fbo.h	/^	GLenum Attachment(void) const$/;"	f	class:DepthRenderTarget
Attachment	vcglib/wrap/gl/fbo.h	/^	GLenum Attachment(void) const$/;"	f	class:StencilRenderTarget
AttrAll	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class A0, class A1, class A2,class A3,class A4>				struct AttrAll	: public Der<  MeshType, A4,	C3<MeshType, A0, A1, A2, A3> > {};$/;"	s	namespace:vcg::tri::io
AttrConstIterator	vcglib/vcg/complex/allocate.h	/^            typedef typename std::set<PointerToAttribute>::const_iterator AttrConstIterator;$/;"	t	class:vcg::tri::Allocator
AttrIterator	vcglib/vcg/complex/allocate.h	/^            typedef typename std::set<PointerToAttribute>::iterator AttrIterator;$/;"	t	class:vcg::tri::Allocator
AttrType	vcglib/vcg/container/simple_temporary_data.h	/^    typedef ATTR_TYPE AttrType;$/;"	t	class:vcg::Attribute
AttrType	vcglib/vcg/container/simple_temporary_data.h	/^    typedef ATTR_TYPE AttrType;$/;"	t	class:vcg::SimpleTempData
Attribute	vcglib/vcg/container/simple_temporary_data.h	/^    Attribute(){attribute = new ATTR_TYPE();}$/;"	f	class:vcg::Attribute
Attribute	vcglib/vcg/container/simple_temporary_data.h	/^class Attribute: public SimpleTempDataBase   {$/;"	c	namespace:vcg
Attribute	vcglib/wrap/gl/shaders.h	/^	void Attribute(int index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)$/;"	f	class:Program
AttributeHandle	vcglib/vcg/complex/base.h	/^        AttributeHandle( void *ah,const int & n):_handle ( (SimpleTempData<CONT,ATTR_TYPE> *)ah ),n_attr(n){}$/;"	f	class:vcg::tri::TriMesh::AttributeHandle
AttributeHandle	vcglib/vcg/complex/base.h	/^        AttributeHandle(){_handle=(SimpleTempData<CONT,ATTR_TYPE> *)NULL;}$/;"	f	class:vcg::tri::TriMesh::AttributeHandle
AttributeHandle	vcglib/vcg/complex/base.h	/^    class AttributeHandle{$/;"	c	class:vcg::tri::TriMesh
AttributeSeam	vcglib/vcg/complex/algorithms/attribute_seam.h	/^class AttributeSeam$/;"	c	namespace:vcg::tri
AuthorTag	vcglib/wrap/dae/colladaformat.h	/^		AuthorTag()$/;"	f	class:Collada::Tags::AuthorTag
AuthorTag	vcglib/wrap/dae/colladaformat.h	/^	class AuthorTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
AuthoringToolTag	vcglib/wrap/dae/colladaformat.h	/^		AuthoringToolTag()$/;"	f	class:Collada::Tags::AuthoringToolTag
AuthoringToolTag	vcglib/wrap/dae/colladaformat.h	/^	class AuthoringToolTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
AutoAlign	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  AutoAlign = 0,$/;"	e	enum:Eigen::__anon263
AutoDiffJacobian	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian() : Functor() {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian(const Functor& f) : Functor(f) {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian(const T0& a0) : Functor(a0) {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian(const T0& a0, const T1& a1) : Functor(a0, a1) {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  AutoDiffJacobian(const T0& a0, const T1& a1, const T2& a2) : Functor(a0, a1, a2) {}$/;"	f	class:Eigen::AutoDiffJacobian
AutoDiffJacobian	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^template<typename Functor> class AutoDiffJacobian : public Functor$/;"	c	namespace:Eigen
AutoDiffScalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    AutoDiffScalar() {}$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    AutoDiffScalar(const AutoDiffScalar& other)$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    AutoDiffScalar(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    AutoDiffScalar(const Scalar& value, const DerType& der)$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    AutoDiffScalar(const Scalar& value, int nbDer, int derNumber)$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    \/*explicit*\/ AutoDiffScalar(const Real& value)$/;"	f	class:Eigen::AutoDiffScalar
AutoDiffScalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^class AutoDiffScalar$/;"	c	namespace:Eigen
AutoDiffVector	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector() {}$/;"	f	class:Eigen::AutoDiffVector
AutoDiffVector	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector(const AutoDiffVector& other)$/;"	f	class:Eigen::AutoDiffVector
AutoDiffVector	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector(const AutoDiffVector<OtherValueType, OtherJacobianType>& other)$/;"	f	class:Eigen::AutoDiffVector
AutoDiffVector	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector(const ValueType& values)$/;"	f	class:Eigen::AutoDiffVector
AutoDiffVector	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector(const ValueType& values, const JacobianType& jac)$/;"	f	class:Eigen::AutoDiffVector
AutoDiffVector	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^class AutoDiffVector$/;"	c	namespace:Eigen
Autodetect	vcglib/wrap/glw/program.h	/^			Autodetect,$/;"	e	enum:glw::RasterizerSettings::RasterizerExecution
AverageColorCell	vcglib/vcg/complex/algorithms/clustering.h	/^  AverageColorCell(): p(0,0,0), n(0,0,0), c(0,0,0),cnt(0){}$/;"	f	class:vcg::tri::AverageColorCell
AverageColorCell	vcglib/vcg/complex/algorithms/clustering.h	/^class  AverageColorCell$/;"	c	namespace:vcg::tri
AverageEdgeLenght	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    static double AverageEdgeLenght(MeshType& m)$/;"	f	class:vcg::tri::Fitmaps
Avg	vcglib/vcg/math/histogram.h	/^	ScalarType Avg(){ DirtyCheck(); return avg;}$/;"	f	class:vcg::Distribution
Avg	vcglib/vcg/math/histogram.h	/^	ScalarType Avg(){ return avg\/cnt;}$/;"	f	class:vcg::Histogram
Ax_lBx	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Ax_lBx              = 0x100,$/;"	e	enum:Eigen::DecompositionOptions
Axis	vcglib/vcg/math/shot.h	/^vcg::Point3<S>  Shot<S,RotationType>::Axis(const int & i) const$/;"	f	class:vcg::Shot
AxisAlignedBoxType	vcglib/vcg/space/index/kdtree/kdtree.h	/^	typedef vcg::Box3<Scalar> AxisAlignedBoxType;$/;"	t	class:KdTree
AxisMode	vcglib/wrap/gui/trackmode.h	/^  AxisMode (const Line3f & ln)$/;"	f	class:vcg::AxisMode
AxisMode	vcglib/wrap/gui/trackmode.h	/^  AxisMode (const Point3f & origin, const Point3f & direction)$/;"	f	class:vcg::AxisMode
AxisMode	vcglib/wrap/gui/trackmode.h	/^class AxisMode:public TrackMode {$/;"	c	namespace:vcg
B	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef Matrix<B_Scalar, B_Rows, B_Cols, B_Options, B_MaxRows, B_MaxCols> B;$/;"	t	struct:Eigen::internal::make_coherent_impl
B	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  FourPoints B;											\/\/ coplanar base$/;"	m	class:vcg::tri::FourPCS
B	vcglib/vcg/complex/algorithms/inertia.h	/^ int B;   \/* beta *\/$/;"	m	class:vcg::tri::Inertia
B	vcglib/wrap/math/system_interface_ldl.h	/^double &B(int i)$/;"	f	class:SystemLDL
B	vcglib/wrap/opensg/vertex_component.h	/^	ScalarType B()$/;"	f	class:vcg::vert::OSGColorCore
BACKFACE_SHADING_BIT	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		BACKFACE_SHADING_BIT	= 0x000008,$/;"	e	enum:SplatRenderer::__anon519
BALL_PIVOTING_H	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^#define BALL_PIVOTING_H$/;"	d
BAx_lx	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  BAx_lx              = 0x400,$/;"	e	enum:Eigen::DecompositionOptions
BBOX_FACTOR	vcglib/apps/metro/metro.cpp	/^#define BBOX_FACTOR /;"	d	file:
BBOX_FACTOR	vcglib/apps/trimeshinfo/defs.h	/^#define BBOX_FACTOR /;"	d
BBOX_FACTOR	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define BBOX_FACTOR /;"	d
BBox	vcglib/vcg/space/segment2.h	/^    inline Box2<ScalarType> BBox( ) const$/;"	f	class:vcg::Segment2
BBox	vcglib/vcg/space/segment3.h	/^	inline Box3<ScalarType> BBox( ) const$/;"	f	class:vcg::Segment3
BEST_RGB	vcglib/vcg/space/colorspace.h	/^		BEST_RGB = 2,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
BETA_RGB	vcglib/vcg/space/colorspace.h	/^		BETA_RGB = 3,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
BEdges	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int BEdges;$/;"	m	struct:MeshInfo	file:
BLASFUNC	vcglib/eigenlib/Eigen/src/misc/blas.h	/^#define BLASFUNC(/;"	d
BLASLONG	vcglib/eigenlib/Eigen/src/misc/blas.h	/^typedef long BLASLONG;$/;"	t
BLASLONG	vcglib/eigenlib/Eigen/src/misc/blas.h	/^typedef long long BLASLONG;$/;"	t
BLASULONG	vcglib/eigenlib/Eigen/src/misc/blas.h	/^typedef unsigned long BLASULONG;$/;"	t
BLASULONG	vcglib/eigenlib/Eigen/src/misc/blas.h	/^typedef unsigned long long BLASULONG;$/;"	t
BLAS_H	vcglib/eigenlib/Eigen/src/misc/blas.h	/^#define BLAS_H$/;"	d
BLUE_CHANNEL	vcglib/vcg/complex/algorithms/update/color.h	/^enum rgbChMask {ALL_CHANNELS = 7, RED_CHANNEL = 4, GREEN_CHANNEL = 2, BLUE_CHANNEL = 1, NO_CHANNELS = 0 };$/;"	e	enum:vcg::tri::UpdateColor::rgbChMask
BOR	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	static int BOR(){static int bor=0; return bor++;}$/;"	f	struct:FAIL
BORDER	vcglib/vcg/connectors/hedge.h	/^		BORDER     = 0x0100,    \/\/ Border Flag$/;"	e	enum:vcg::HEdgeArityMax::__anon484
BORDER	vcglib/vcg/simplex/edge/base.h	/^		BORDER     = 0x0100,    \/\/ Border Flag$/;"	e	enum:vcg::EdgeArityMax::__anon496
BORDER	vcglib/vcg/simplex/vertex/base.h	/^		BORDER     = 0x0100,    \/\/ Border Flag$/;"	e	enum:vcg::VertexArityMax::__anon499
BORDER0	vcglib/vcg/simplex/face/base.h	/^		BORDER0     = 0x00000040,$/;"	e	enum:vcg::FaceArityMax::__anon497
BORDER0	vcglib/vcg/simplex/tetrahedron/base.h	/^		BORDER0     = 0x00000040,$/;"	e	enum:vcg::TetraArityMax::__anon498
BORDER012	vcglib/vcg/simplex/face/base.h	/^		BORDER012     = BORDER0 | BORDER1 | BORDER2 ,$/;"	e	enum:vcg::FaceArityMax::__anon497
BORDER1	vcglib/vcg/simplex/face/base.h	/^		BORDER1     = 0x00000080,$/;"	e	enum:vcg::FaceArityMax::__anon497
BORDER1	vcglib/vcg/simplex/tetrahedron/base.h	/^		BORDER1     = 0x00000080,$/;"	e	enum:vcg::TetraArityMax::__anon498
BORDER2	vcglib/vcg/simplex/face/base.h	/^		BORDER2     = 0x00000100,$/;"	e	enum:vcg::FaceArityMax::__anon497
BORDER2	vcglib/vcg/simplex/tetrahedron/base.h	/^		BORDER2     = 0x00000100,$/;"	e	enum:vcg::TetraArityMax::__anon498
BORDER3	vcglib/vcg/simplex/tetrahedron/base.h	/^		BORDER3     = 0x00000200,$/;"	e	enum:vcg::TetraArityMax::__anon498
BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
BOTTOM_LEFT	vcglib/wrap/qt/gl_label.h	/^    enum LabelPosition { TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT} ;$/;"	e	enum:vcg::glLabel::LabelPosition
BOTTOM_RIGHT	vcglib/wrap/qt/gl_label.h	/^    enum LabelPosition { TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT} ;$/;"	e	enum:vcg::glLabel::LabelPosition
BQ	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^typedef BitQuad<MeshType> BQ; \/\/ static class to make basic quad operations$/;"	t	class:vcg::tri::BitQuadCreation
BRADFORD	vcglib/vcg/space/colorspace.h	/^	enum ConeResponse	{	BRADFORD = 0,	VON_KRIES = 1, XYZ_SCALING = 2};$/;"	e	enum:vcg::ColorSpace::ConeResponse
BRUCE_RGB	vcglib/vcg/space/colorspace.h	/^		BRUCE_RGB = 4,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
BT	vcglib/vcg/space/index/grid_static_ptr.h	/^    typedef BasicGrid<FLT> BT;$/;"	t	class:vcg::GridStaticPtr
BUFFER	vcglib/wrap/gl/fbo.h	/^		BUFFER,$/;"	e	enum:RenderTarget::__anon516
BUTTERFLY	vcglib/apps/plyrefine/main.cpp	/^#define BUTTERFLY /;"	d	file:
BUTTERFLY	vcglib/apps/sample/trimesh_refine/trimesh_refine.cpp	/^#define BUTTERFLY /;"	d	file:
BUTTON_LEFT	vcglib/wrap/gui/trackball.h	/^                BUTTON_LEFT   = 0x0001, \/\/\/< Left mouse button pressed.$/;"	e	enum:vcg::Trackball::Button
BUTTON_MIDDLE	vcglib/wrap/gui/trackball.h	/^                BUTTON_MIDDLE = 0x0002, \/\/\/< Middle mouse button pressed.$/;"	e	enum:vcg::Trackball::Button
BUTTON_NONE	vcglib/wrap/gui/trackball.h	/^  enum Button { BUTTON_NONE   = 0x0000, \/\/\/< No button or key pressed.$/;"	e	enum:vcg::Trackball::Button
BUTTON_RIGHT	vcglib/wrap/gui/trackball.h	/^                BUTTON_RIGHT  = 0x0004, \/\/\/< Right mouse button pressed.$/;"	e	enum:vcg::Trackball::Button
BVIntersect	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^void BVIntersect(const BVH &tree, Intersector &intersector)$/;"	f	namespace:Eigen
BVIntersect	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^void BVIntersect(const BVH1 &tree1, const BVH2 &tree2, Intersector &intersector) \/\/TODO: tandem descent when it makes sense$/;"	f	namespace:Eigen
BVMinimize	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^typename Minimizer::Scalar BVMinimize(const BVH &tree, Minimizer &minimizer)$/;"	f	namespace:Eigen
BVMinimize	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^typename Minimizer::Scalar BVMinimize(const BVH1 &tree1, const BVH2 &tree2, Minimizer &minimizer)$/;"	f	namespace:Eigen
BYTE	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  BYTE=1,$/;"	e	enum:vcg::RawVolumeImporter::DataType
Back	vcglib/wrap/gui/trackball.cpp	/^void Trackball::Back(){}$/;"	f	class:Trackball
BalanceMedian	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^int AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::BalanceMedian(const ObjPtrVectorIterator & oBegin, const ObjPtrVectorIterator & oEnd, const int size, const int splitAxis, OBJBARYCENTERFUNCT & getBarycenter, ObjPtrVectorIterator & medianIter) {$/;"	f	class:vcg::AABBBinaryTree
Ball	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  Ball() {}$/;"	f	struct:Ball
Ball	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  Ball(const VectorType &c, double r) : center(c), radius(r) {}$/;"	f	struct:Ball
Ball	vcglib/eigenlib/unsupported/test/BVH.cpp	/^struct Ball$/;"	s	file:
BallPivoting	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  BallPivoting(MESH &_mesh, float _radius = 0, $/;"	f	class:vcg::tri::BallPivoting
BallPivoting	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^template <class MESH> class BallPivoting: public AdvancingFront<MESH> {$/;"	c	namespace:vcg::tri
BallPointStuff	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  BallPointStuff() : calls(0), count(0) {}$/;"	f	struct:BallPointStuff
BallPointStuff	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  BallPointStuff(const VectorType &inP) : p(inP), calls(0), count(0) {}$/;"	f	struct:BallPointStuff
BallPointStuff	vcglib/eigenlib/unsupported/test/BVH.cpp	/^struct BallPointStuff \/\/this class provides functions to be both an intersector and a minimizer, both for a ball and a point and for two trees$/;"	s	file:
BallType	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  typedef Ball<Dim> BallType;$/;"	t	struct:BallPointStuff	file:
BallType	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  typedef Ball<Dim> BallType;$/;"	t	struct:TreeTest	file:
BallTypeList	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  typedef std::vector<BallType, aligned_allocator<BallType> > BallTypeList;$/;"	t	struct:TreeTest	file:
BandMatrix	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline BandMatrix(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)$/;"	f	class:Eigen::internal::BandMatrix
BandMatrix	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^class BandMatrix : public BandMatrixBase<BandMatrix<_Scalar,Rows,Cols,Supers,Subs,Options> >$/;"	c	namespace:Eigen::internal
BandMatrixBase	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^class BandMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen::internal
BandMatrixWrapper	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline BandMatrixWrapper(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)$/;"	f	class:Eigen::internal::BandMatrixWrapper
BandMatrixWrapper	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^class BandMatrixWrapper : public BandMatrixBase<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	c	namespace:Eigen::internal
Bangle	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  ScalarType Bangle;$/;"	m	class:vcg::tri::FourPCS
Barycenter	vcglib/vcg/space/tetra3.h	/^Point3<ScalarType> Barycenter(const Tetra3<ScalarType> &t) $/;"	f	namespace:vcg
Barycenter	vcglib/vcg/space/triangle3.h	/^Point3<typename TriangleType::ScalarType> Barycenter(const TriangleType &t) $/;"	f	namespace:vcg
Base	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodDecomposition> Base;$/;"	t	class:Eigen::CholmodDecomposition
Base	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLDLT
Base	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLLT
Base	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT> Base;$/;"	t	class:Eigen::CholmodSupernodalLLT
Base	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    typedef PlainObjectBase<Array> Base;$/;"	t	class:Eigen::Array
Base	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::ArrayBase
Base	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    typedef ArrayBase<ArrayWrapper> Base;$/;"	t	class:Eigen::ArrayWrapper
Base	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    typedef MatrixBase<MatrixWrapper<ExpressionType> > Base;$/;"	t	class:Eigen::MatrixWrapper
Base	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor> Base;$/;"	t	class:Eigen::internal::TridiagonalMatrix
Base	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::internal::BandMatrixBase
Base	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    typedef MapBase<Block> Base;$/;"	t	class:Eigen::Block
Base	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    typedef typename internal::dense_xpr_base<Block>::type Base;$/;"	t	class:Eigen::Block
Base	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^                                         typename internal::traits<Rhs>::StorageKind>::ret>::Base Base;$/;"	t	class:Eigen::CwiseBinaryOp
Base	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl
Base	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseNullaryOp>::type Base;$/;"	t	class:Eigen::CwiseNullaryOp
Base	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp, XprType,typename internal::traits<XprType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryOp
Base	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl
Base	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp, MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryView
Base	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Base	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef DenseCoeffsBase<Derived> Base;$/;"	t	class:Eigen::DenseBase
Base	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, WriteAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    typedef typename internal::dense_xpr_base<Diagonal>::type Base;$/;"	t	class:Eigen::Diagonal
Base	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    typedef MatrixBase<DiagonalProduct> Base;$/;"	t	class:Eigen::DiagonalProduct
Base	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    typedef MatrixBase<Flagged> Base;$/;"	t	class:Eigen::Flagged
Base	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    typedef typename internal::dense_xpr_base<ForceAlignedAccess>::type Base;$/;"	t	class:Eigen::ForceAlignedAccess
Base	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    typedef Matrix<typename internal::scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType,1,1> Base;$/;"	t	class:Eigen::GeneralProduct
Base	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    typedef MapBase<Map> Base;$/;"	t	class:Eigen::Map
Base	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::MapBase
Base	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::MapBase
Base	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    typedef PlainObjectBase<Matrix> Base;$/;"	t	class:Eigen::Matrix
Base	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::MatrixBase
Base	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    typedef typename internal::dense_xpr_base<NestByValue>::type Base;$/;"	t	class:Eigen::NestByValue
Base	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::PermutationBase
Base	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<Map> Base;$/;"	t	class:Eigen::Map
Base	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationMatrix> Base;$/;"	t	class:Eigen::PermutationMatrix
Base	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationWrapper> Base;$/;"	t	class:Eigen::PermutationWrapper
Base	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::PlainObjectBase
Base	vcglib/eigenlib/Eigen/src/Core/Product.h	/^                                                typename Rhs::StorageKind>::ret>::Base Base;$/;"	t	class:Product
Base	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    typedef typename internal::dense_xpr_base<Product<Lhs, Rhs> >::type Base;$/;"	t	class:ProductImpl
Base	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^                       typename NestedProduct::_RhsNested> Base;$/;"	t	class:Eigen::ScaledProduct
Base	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef MatrixBase<Derived> Base;$/;"	t	class:Eigen::ProductBase
Base	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    typedef typename internal::dense_xpr_base<Replicate>::type Base;$/;"	t	class:Eigen::Replicate
Base	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::dense_xpr_base<ReturnByValue>::type Base;$/;"	t	class:Eigen::ReturnByValue
Base	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    typedef typename internal::dense_xpr_base<Reverse>::type Base;$/;"	t	class:Eigen::Reverse
Base	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    typedef typename internal::dense_xpr_base<Select>::type Base;$/;"	t	class:Eigen::Select
Base	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    typedef TriangularBase<SelfAdjointView> Base;$/;"	t	class:Eigen::SelfAdjointView
Base	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<SelfCwiseBinaryOp>::type Base;$/;"	t	class:Eigen::SelfCwiseBinaryOp
Base	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef ReturnByValue<triangular_solve_retval> Base;$/;"	t	struct:Eigen::internal::triangular_solve_retval
Base	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    typedef Stride<0, Value> Base;$/;"	t	class:Eigen::InnerStride
Base	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    typedef Stride<Value, 0> Base;$/;"	t	class:Eigen::OuterStride
Base	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    typedef typename internal::dense_xpr_base<SwapWrapper>::type Base;$/;"	t	class:Eigen::SwapWrapper
Base	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::Transpose
Base	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    typedef typename internal::TransposeImpl_base<MatrixType>::type Base;$/;"	t	class:Eigen::TransposeImpl
Base	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Map> Base;$/;"	t	class:Eigen::Map
Base	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Transpositions> Base;$/;"	t	class:Eigen::Transpositions
Base	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<TranspositionsWrapper> Base;$/;"	t	class:Eigen::TranspositionsWrapper
Base	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularBase<TriangularView> Base;$/;"	t	class:Eigen::TriangularView
Base	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^                     internal::traits<VectorType>::Flags & RowMajorBit ? Size : 1> Base;$/;"	t	class:Eigen::VectorBlock
Base	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::dense_xpr_base<PartialReduxExpr>::type Base;$/;"	t	class:Eigen::PartialReduxExpr
Base	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef MatrixBase<CoeffBasedProduct> Base;$/;"	t	class:Eigen::CoeffBasedProduct
Base	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef blas_traits<NestedXpr> Base;$/;"	t	struct:Eigen::internal::blas_traits
Base	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis
Base	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef RotationBase<Quaternion<_Scalar>,3> Base;$/;"	t	class:Eigen::Quaternion
Base	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D
Base	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    typedef FullPivLU<MatrixType> Base;$/;"	t	class:Eigen::LU
Base	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    typedef MatrixBase<Minor> Base;$/;"	t	class:Eigen::Minor
Base	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^    typedef HouseholderQR<MatrixType> Base;$/;"	t	class:Eigen::QR
Base	vcglib/eigenlib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef SelfAdjointEigenSolver<_MatrixType> Base;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver
Base	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis
Base	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    typedef MatrixBase<Homogeneous> Base;$/;"	t	class:Eigen::Homogeneous
Base	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map
Base	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<const Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map
Base	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef QuaternionBase<Quaternion<_Scalar,_Options> > Base;$/;"	t	class:Eigen::Quaternion
Base	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef RotationBase<Derived, 3> Base;$/;"	t	class:Eigen::QuaternionBase
Base	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D
Base	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef IterativeSolverBase<BiCGSTAB> Base;$/;"	t	class:Eigen::BiCGSTAB
Base	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef IterativeSolverBase<ConjugateGradient> Base;$/;"	t	class:Eigen::ConjugateGradient
Base	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLDLT<MatrixType, _UpLo> > Base; $/;"	t	class:Eigen::PastixLDLT
Base	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLLT<MatrixType, _UpLo> > Base;$/;"	t	class:Eigen::PastixLLT
Base	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLU<MatrixType> > Base;$/;"	t	class:Eigen::PastixLU
Base	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLDLT<MatrixType,Options> > Base;$/;"	t	class:Eigen::PardisoLDLT
Base	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLLT<MatrixType,_UpLo> > Base;$/;"	t	class:Eigen::PardisoLLT
Base	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLU<MatrixType> > Base;$/;"	t	class:Eigen::PardisoLU
Base	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialCholesky> Base;$/;"	t	class:Eigen::SimplicialCholesky
Base	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLDLT> Base;$/;"	t	class:Eigen::SimplicialLDLT
Base	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLLT> Base;$/;"	t	class:Eigen::SimplicialLLT
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^      BinaryOp,Lhs,Rhs, InnerIterator> Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef SparseMatrixBase<SparseDenseOuterProduct> Base;$/;"	t	class:Eigen::SparseDenseOuterProduct
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename _LhsNested::InnerIterator Base;$/;"	t	class:Eigen::SparseDenseOuterProduct::InnerIterator
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      Transpose<const typename Rhs::DiagonalVectorType> >::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      typename Lhs::DiagonalVectorType>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Lhs::Scalar>,const Rhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Rhs::Scalar>,const Lhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::SparseMatrixBase
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    typedef SparseMatrixBase<SparseSparseProduct> Base;$/;"	t	class:Eigen::SparseSparseProduct
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::InnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::InnerIterator
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::ReverseInnerIterator
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::InnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::InnerIterator
Base	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::ReverseInnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::ReverseInnerIterator
Base	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperILU> Base;$/;"	t	class:Eigen::SuperILU
Base	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperLU> Base;$/;"	t	class:Eigen::SuperLU
Base	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  typedef ReturnByValue<image_retval_base> Base;$/;"	t	struct:Eigen::internal::image_retval_base
Base	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  typedef ReturnByValue<kernel_retval_base> Base;$/;"	t	struct:Eigen::internal::kernel_retval_base
Base	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  typedef ReturnByValue<solve_retval_base> Base;$/;"	t	struct:Eigen::internal::solve_retval_base
Base	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  typedef ReturnByValue<sparse_solve_retval_base> Base;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base
Base	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^                       typename NumTraits<typename internal::traits<typename internal::remove_all<_DerType>::type>::Scalar>::Real>::value> Base;$/;"	t	class:Eigen::AutoDiffScalar
Base	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef IterativeSolverBase<GMRES> Base;$/;"	t	class:Eigen::GMRES
Base	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^            MatrixBase<SkylineProduct<LhsNested, RhsNested, ProductMode> > >::type Base;$/;"	t	struct:Eigen::internal::traits
Base	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    typedef typename SparseVector<Scalar,_Options,_Index>::InnerIterator Base;$/;"	t	class:Eigen::DynamicSparseMatrix::InnerIterator
Base	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    typedef typename SparseVector<Scalar,_Options,_Index>::ReverseInnerIterator Base;$/;"	t	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
Base	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef EdgeFlipPriority<MeshType> Base;$/;"	t	class:vcg::tri::Homeometry
Base	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef EdgeFlipPriority<MeshType> Base;$/;"	t	class:vcg::tri::VertReg
Base	vcglib/vcg/simplex/face/component_ocf.h	/^  vector_ocf<typename T::FaceType> &Base() const { return *_ovp;}$/;"	f	class:vcg::face::InfoOcf
Base	vcglib/vcg/simplex/vertex/component_ocf.h	/^		vector_ocf<typename T::VertexType> &Base() const { return *_ovp;}$/;"	f	class:vcg::vertex::InfoOcf
Base	vcglib/vcg/space/color4.h	/^	typedef Point4<T> Base;$/;"	t	class:vcg::Color4
BaseColor	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^Color4b BaseColor=Color4b::White;$/;"	v
BaseEdge	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^class BaseEdge : public vcg::Edge< BaseUsedTypes> {};$/;"	c	file:
BaseFace	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^class BaseFace    : public vcg::Face< BaseUsedTypes,$/;"	c	file:
BaseInterpolator	vcglib/vcg/complex/algorithms/refine.h	/^struct BaseInterpolator$/;"	s	namespace:vcg::tri
BaseMesh	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^class BaseMesh    : public vcg::tri::TriMesh<std::vector<BaseVertex>, std::vector<BaseFace> > {};$/;"	c	file:
BaseMeshTypeHolder	vcglib/vcg/complex/base.h	/^        struct BaseMeshTypeHolder{$/;"	s	namespace:vcg::tri
BaseObjectType	vcglib/wrap/glw/bookkeeping.h	/^		typedef NoType                                            BaseObjectType;$/;"	t	class:glw::detail::ObjectSharedPointer
BaseObjectType	vcglib/wrap/glw/bookkeeping.h	/^		typedef NoType                                      BaseObjectType;$/;"	t	class:glw::detail::RefCountedObject
BaseObjectType	vcglib/wrap/glw/bookkeeping.h	/^		typedef TBaseObject                                                                     BaseObjectType;$/;"	t	class:glw::detail::ObjectSharedPointer
BaseObjectType	vcglib/wrap/glw/bookkeeping.h	/^		typedef TBaseObject                                                                 BaseObjectType;$/;"	t	class:glw::detail::RefCountedObject
BaseOf	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct BaseOf                    { typedef NoType Type;                                                    };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf      <BoundBuffer> { typedef BoundObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundFeedbackBuffer> { typedef BoundBuffer Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundIndexBuffer> { typedef BoundBuffer Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundPixelPackBuffer> { typedef BoundBuffer Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundPixelUnpackBuffer> { typedef BoundBuffer Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundUniformBuffer> { typedef BoundBuffer Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundVertexBuffer> { typedef BoundBuffer Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <SafeBuffer> { typedef SafeObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf <Buffer> { typedef Object Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct BaseOf      <BoundFragmentShader> { typedef BoundShader Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct BaseOf     <SafeFragmentShader> { typedef SafeShader Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct BaseOf <FragmentShader> { typedef Shader Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf      <BoundFramebuffer> { typedef BoundObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <BoundDrawFramebuffer> { typedef BoundFramebuffer Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <BoundReadDrawFramebuffer> { typedef BoundFramebuffer Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <BoundReadFramebuffer> { typedef BoundFramebuffer Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <SafeFramebuffer> { typedef SafeObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf <Framebuffer> { typedef Object Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct BaseOf      <BoundGeometryShader> { typedef BoundShader Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct BaseOf     <SafeGeometryShader> { typedef SafeShader Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct BaseOf <GeometryShader> { typedef Shader Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct BaseOf      <BoundObject> { typedef NoType                      Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct BaseOf     <SafeObject> { typedef NoType                     Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct BaseOf    <Object> { typedef NoType        Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct BaseOf      <BoundProgram> { typedef BoundObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct BaseOf     <SafeProgram> { typedef SafeObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct BaseOf <Program> { typedef Object Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct BaseOf      <BoundRenderable> { typedef BoundObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct BaseOf     <SafeRenderable> { typedef SafeObject     Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct BaseOf <Renderable> { typedef Object Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct BaseOf      <BoundRenderbuffer> { typedef BoundObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct BaseOf     <SafeRenderbuffer> { typedef SafeRenderable   Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct BaseOf <Renderbuffer> { typedef Renderable Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct BaseOf      <BoundShader> { typedef BoundObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct BaseOf     <SafeShader> { typedef SafeObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct BaseOf <Shader> { typedef Object Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct BaseOf      <BoundTexture> { typedef BoundObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct BaseOf     <SafeTexture> { typedef SafeRenderable   Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct BaseOf <Texture> { typedef Renderable Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct BaseOf      <BoundTexture2D> { typedef BoundObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct BaseOf     <SafeTexture2D> { typedef SafeTexture   Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct BaseOf <Texture2D> { typedef Texture Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct BaseOf      <BoundTextureCube> { typedef BoundObject Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct BaseOf     <SafeTextureCube> { typedef SafeTexture   Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct BaseOf <TextureCube> { typedef Texture Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct BaseOf      <BoundVertexShader> { typedef BoundShader Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct BaseOf     <SafeVertexShader> { typedef SafeShader Type; }; };$/;"	s	namespace:glw::detail
BaseOf	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct BaseOf <VertexShader> { typedef Shader Type; }; };$/;"	s	namespace:glw::detail
BaseParameterClass	vcglib/vcg/complex/algorithms/local_optimization.h	/^class BaseParameterClass { };$/;"	c	namespace:vcg
BasePosType	vcglib/vcg/simplex/tetrahedron/pos.h	/^	typedef Pos<TetraType> BasePosType;$/;"	t	class:vcg::tetra::Pos
BaseScalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    typedef typename internal::traits<ValueType>::Scalar BaseScalar;$/;"	t	class:Eigen::AutoDiffVector
BaseType	vcglib/vcg/simplex/face/component_ocf.h	/^  typedef std::vector<VALUE_TYPE> BaseType;$/;"	t	class:vcg::face::vector_ocf
BaseType	vcglib/vcg/simplex/vertex/component_ocf.h	/^	typedef std::vector<VALUE_TYPE> BaseType;$/;"	t	class:vcg::vertex::vector_ocf
BaseType	vcglib/wrap/glw/bookkeeping.h	/^		typedef ObjectSharedPointer<TBaseObject, TDeleter, typename BaseOf<TBaseObject>::Type>  BaseType;$/;"	t	class:glw::detail::ObjectSharedPointer
BaseType	vcglib/wrap/glw/bookkeeping.h	/^		typedef RefCountedObject<TBaseObject, TDeleter, typename BaseOf<TBaseObject>::Type> BaseType;$/;"	t	class:glw::detail::RefCountedObject
BaseType	vcglib/wrap/glw/bookkeeping.h	/^		typedef void                                              BaseType;$/;"	t	class:glw::detail::ObjectSharedPointer
BaseType	vcglib/wrap/glw/bookkeeping.h	/^		typedef void                                        BaseType;$/;"	t	class:glw::detail::RefCountedObject
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BoundBuffer          BaseType;$/;"	t	class:glw::BoundFeedbackBuffer
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BoundBuffer          BaseType;$/;"	t	class:glw::BoundPixelPackBuffer
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BoundBuffer          BaseType;$/;"	t	class:glw::BoundPixelUnpackBuffer
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BoundBuffer          BaseType;$/;"	t	class:glw::BoundUniformBuffer
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BoundBuffer       BaseType;$/;"	t	class:glw::BoundIndexBuffer
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BoundBuffer       BaseType;$/;"	t	class:glw::BoundVertexBuffer
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BoundObject BaseType;$/;"	t	class:glw::BoundBuffer
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BufferBindingParams       BaseType;$/;"	t	class:glw::VertexBufferBindingParams
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BufferBindingParams      BaseType;$/;"	t	class:glw::FeedbackBufferBindingParams
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BufferBindingParams      BaseType;$/;"	t	class:glw::IndexBufferBindingParams
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BufferBindingParams      BaseType;$/;"	t	class:glw::PixelPackBufferBindingParams
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BufferBindingParams      BaseType;$/;"	t	class:glw::PixelUnpackBufferBindingParams
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef BufferBindingParams      BaseType;$/;"	t	class:glw::UniformBufferBindingParams
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef Object BaseType;$/;"	t	class:glw::Buffer
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef ObjectArguments BaseType;$/;"	t	class:glw::BufferArguments
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef ObjectBindingParams BaseType;$/;"	t	class:glw::BufferBindingParams
BaseType	vcglib/wrap/glw/buffer.h	/^		typedef SafeObject BaseType;$/;"	t	class:glw::SafeBuffer
BaseType	vcglib/wrap/glw/context.h	/^		typedef detail::NonCopyable BaseType;$/;"	t	class:glw::Context
BaseType	vcglib/wrap/glw/fragmentshader.h	/^		typedef BoundShader       BaseType;$/;"	t	class:glw::BoundFragmentShader
BaseType	vcglib/wrap/glw/fragmentshader.h	/^		typedef SafeShader       BaseType;$/;"	t	class:glw::SafeFragmentShader
BaseType	vcglib/wrap/glw/fragmentshader.h	/^		typedef Shader       BaseType;$/;"	t	class:glw::FragmentShader
BaseType	vcglib/wrap/glw/fragmentshader.h	/^		typedef ShaderArguments       BaseType;$/;"	t	class:glw::FragmentShaderArguments
BaseType	vcglib/wrap/glw/fragmentshader.h	/^		typedef ShaderBindingParams       BaseType;$/;"	t	class:glw::FragmentShaderBindingParams
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef BoundFramebuffer     BaseType;$/;"	t	class:glw::BoundDrawFramebuffer
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef BoundFramebuffer     BaseType;$/;"	t	class:glw::BoundReadDrawFramebuffer
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef BoundFramebuffer     BaseType;$/;"	t	class:glw::BoundReadFramebuffer
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef BoundObject BaseType;$/;"	t	class:glw::BoundFramebuffer
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef FramebufferBindingParams     BaseType;$/;"	t	class:glw::DrawFramebufferBindingParams
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef FramebufferBindingParams     BaseType;$/;"	t	class:glw::ReadDrawFramebufferBindingParams
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef FramebufferBindingParams     BaseType;$/;"	t	class:glw::ReadFramebufferBindingParams
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef Object      BaseType;$/;"	t	class:glw::Framebuffer
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef ObjectArguments      BaseType;$/;"	t	class:glw::FramebufferArguments
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef ObjectBindingParams      BaseType;$/;"	t	class:glw::FramebufferBindingParams
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef SafeObject  BaseType;$/;"	t	class:glw::SafeFramebuffer
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef void                BaseType;$/;"	t	class:glw::RenderTargetBinding
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef void                BaseType;$/;"	t	class:glw::RenderTargetMapping
BaseType	vcglib/wrap/glw/framebuffer.h	/^		typedef void         BaseType;$/;"	t	class:glw::RenderTarget
BaseType	vcglib/wrap/glw/geometryshader.h	/^		typedef BoundShader       BaseType;$/;"	t	class:glw::BoundGeometryShader
BaseType	vcglib/wrap/glw/geometryshader.h	/^		typedef SafeShader       BaseType;$/;"	t	class:glw::SafeGeometryShader
BaseType	vcglib/wrap/glw/geometryshader.h	/^		typedef Shader       BaseType;$/;"	t	class:glw::GeometryShader
BaseType	vcglib/wrap/glw/geometryshader.h	/^		typedef ShaderArguments       BaseType;$/;"	t	class:glw::GeometryShaderArguments
BaseType	vcglib/wrap/glw/geometryshader.h	/^		typedef ShaderBindingParams       BaseType;$/;"	t	class:glw::GeometryShaderBindingParams
BaseType	vcglib/wrap/glw/noncopyable.h	/^		typedef void        BaseType;$/;"	t	class:glw::detail::NonCopyable
BaseType	vcglib/wrap/glw/object.h	/^		typedef detail::NonCopyable   BaseType;$/;"	t	class:glw::BoundObject
BaseType	vcglib/wrap/glw/object.h	/^		typedef detail::NonCopyable BaseType;$/;"	t	class:glw::Object
BaseType	vcglib/wrap/glw/object.h	/^		typedef detail::NonCopyable BaseType;$/;"	t	class:glw::SafeObject
BaseType	vcglib/wrap/glw/object.h	/^		typedef void                BaseType;$/;"	t	class:glw::ObjectBindingParams
BaseType	vcglib/wrap/glw/object.h	/^		typedef void            BaseType;$/;"	t	class:glw::ObjectArguments
BaseType	vcglib/wrap/glw/objectdeleter.h	/^		typedef void          BaseType;$/;"	t	class:glw::detail::ObjectDeleter
BaseType	vcglib/wrap/glw/program.h	/^				typedef void        BaseType;$/;"	t	class:glw::Program::UniformInfo
BaseType	vcglib/wrap/glw/program.h	/^		typedef BoundObject BaseType;$/;"	t	class:glw::BoundProgram
BaseType	vcglib/wrap/glw/program.h	/^		typedef Object  BaseType;$/;"	t	class:glw::Program
BaseType	vcglib/wrap/glw/program.h	/^		typedef ObjectArguments    BaseType;$/;"	t	class:glw::ProgramArguments
BaseType	vcglib/wrap/glw/program.h	/^		typedef ObjectBindingParams BaseType;$/;"	t	class:glw::ProgramBindingParams
BaseType	vcglib/wrap/glw/program.h	/^		typedef SafeObject  BaseType;$/;"	t	class:glw::SafeProgram
BaseType	vcglib/wrap/glw/program.h	/^		typedef void                    BaseType;$/;"	t	class:glw::TransformFeedbackStream
BaseType	vcglib/wrap/glw/program.h	/^		typedef void                   BaseType;$/;"	t	class:glw::VertexAttributeBinding
BaseType	vcglib/wrap/glw/program.h	/^		typedef void                  BaseType;$/;"	t	class:glw::FragmentOutputBinding
BaseType	vcglib/wrap/glw/program.h	/^		typedef void               BaseType;$/;"	t	class:glw::RasterizerSettings
BaseType	vcglib/wrap/glw/program.h	/^		typedef void          BaseType;$/;"	t	class:glw::GeometryStage
BaseType	vcglib/wrap/glw/renderable.h	/^		typedef BoundObject     BaseType;$/;"	t	class:glw::BoundRenderable
BaseType	vcglib/wrap/glw/renderable.h	/^		typedef Object     BaseType;$/;"	t	class:glw::Renderable
BaseType	vcglib/wrap/glw/renderable.h	/^		typedef ObjectArguments     BaseType;$/;"	t	class:glw::RenderableArguments
BaseType	vcglib/wrap/glw/renderable.h	/^		typedef ObjectBindingParams BaseType;$/;"	t	class:glw::RenderableBindingParams
BaseType	vcglib/wrap/glw/renderable.h	/^		typedef SafeObject     BaseType;$/;"	t	class:glw::SafeRenderable
BaseType	vcglib/wrap/glw/renderbuffer.h	/^		typedef BoundRenderable   BaseType;$/;"	t	class:glw::BoundRenderbuffer
BaseType	vcglib/wrap/glw/renderbuffer.h	/^		typedef Renderable   BaseType;$/;"	t	class:glw::Renderbuffer
BaseType	vcglib/wrap/glw/renderbuffer.h	/^		typedef RenderableArguments   BaseType;$/;"	t	class:glw::RenderbufferArguments
BaseType	vcglib/wrap/glw/renderbuffer.h	/^		typedef RenderableBindingParams   BaseType;$/;"	t	class:glw::RenderbufferBindingParams
BaseType	vcglib/wrap/glw/renderbuffer.h	/^		typedef SafeRenderable   BaseType;$/;"	t	class:glw::SafeRenderbuffer
BaseType	vcglib/wrap/glw/shader.h	/^		typedef BoundObject BaseType;$/;"	t	class:glw::BoundShader
BaseType	vcglib/wrap/glw/shader.h	/^		typedef Object BaseType;$/;"	t	class:glw::Shader
BaseType	vcglib/wrap/glw/shader.h	/^		typedef ObjectArguments BaseType;$/;"	t	class:glw::ShaderArguments
BaseType	vcglib/wrap/glw/shader.h	/^		typedef ObjectBindingParams BaseType;$/;"	t	class:glw::ShaderBindingParams
BaseType	vcglib/wrap/glw/shader.h	/^		typedef SafeObject BaseType;$/;"	t	class:glw::SafeShader
BaseType	vcglib/wrap/glw/texture.h	/^		typedef BoundRenderable   BaseType;$/;"	t	class:glw::BoundTexture
BaseType	vcglib/wrap/glw/texture.h	/^		typedef Renderable  BaseType;$/;"	t	class:glw::Texture
BaseType	vcglib/wrap/glw/texture.h	/^		typedef RenderableArguments BaseType;$/;"	t	class:glw::TextureArguments
BaseType	vcglib/wrap/glw/texture.h	/^		typedef RenderableBindingParams   BaseType;$/;"	t	class:glw::TextureBindingParams
BaseType	vcglib/wrap/glw/texture.h	/^		typedef SafeRenderable   BaseType;$/;"	t	class:glw::SafeTexture
BaseType	vcglib/wrap/glw/texture.h	/^		typedef void              BaseType;$/;"	t	class:glw::TextureSampleMode
BaseType	vcglib/wrap/glw/texture2d.h	/^		typedef BoundTexture   BaseType;$/;"	t	class:glw::BoundTexture2D
BaseType	vcglib/wrap/glw/texture2d.h	/^		typedef SafeTexture   BaseType;$/;"	t	class:glw::SafeTexture2D
BaseType	vcglib/wrap/glw/texture2d.h	/^		typedef Texture   BaseType;$/;"	t	class:glw::Texture2D
BaseType	vcglib/wrap/glw/texture2d.h	/^		typedef TextureArguments   BaseType;$/;"	t	class:glw::Texture2DArguments
BaseType	vcglib/wrap/glw/texture2d.h	/^		typedef TextureBindingParams   BaseType;$/;"	t	class:glw::Texture2DBindingParams
BaseType	vcglib/wrap/glw/texturecube.h	/^		typedef BoundTexture   BaseType;$/;"	t	class:glw::BoundTextureCube
BaseType	vcglib/wrap/glw/texturecube.h	/^		typedef SafeTexture   BaseType;$/;"	t	class:glw::SafeTextureCube
BaseType	vcglib/wrap/glw/texturecube.h	/^		typedef Texture   BaseType;$/;"	t	class:glw::TextureCube
BaseType	vcglib/wrap/glw/texturecube.h	/^		typedef TextureArguments   BaseType;$/;"	t	class:glw::TextureCubeArguments
BaseType	vcglib/wrap/glw/texturecube.h	/^		typedef TextureBindingParams   BaseType;$/;"	t	class:glw::TextureCubeBindingParams
BaseType	vcglib/wrap/glw/utility.h	/^		typedef void                BaseType;$/;"	t	class:glw::ShaderHeaderBuilder
BaseType	vcglib/wrap/glw/vertexshader.h	/^		typedef BoundShader       BaseType;$/;"	t	class:glw::BoundVertexShader
BaseType	vcglib/wrap/glw/vertexshader.h	/^		typedef SafeShader       BaseType;$/;"	t	class:glw::SafeVertexShader
BaseType	vcglib/wrap/glw/vertexshader.h	/^		typedef Shader       BaseType;$/;"	t	class:glw::VertexShader
BaseType	vcglib/wrap/glw/vertexshader.h	/^		typedef ShaderArguments       BaseType;$/;"	t	class:glw::VertexShaderArguments
BaseType	vcglib/wrap/glw/vertexshader.h	/^		typedef ShaderBindingParams       BaseType;$/;"	t	class:glw::VertexShaderBindingParams
BaseUsedTypes	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^struct BaseUsedTypes: public vcg::UsedTypes<vcg::Use<BaseVertex>::AsVertexType,vcg::Use<BaseEdge>::AsEdgeType,vcg::Use<BaseFace>::AsFaceType>{};$/;"	s	file:
BaseVertex	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^class BaseVertex  : public vcg::Vertex< BaseUsedTypes,$/;"	c	file:
BaseVertexType	vcglib/wrap/dae/poly_triangulator.h	/^		typedef VERTEX_TYPE BaseVertexType;$/;"	t	class:vcg::tri::io::MyPolygon
BasicCrossFunctor	vcglib/vcg/complex/algorithms/geodesic.h	/^  BasicCrossFunctor(MeshType &m) { tri::RequirePerVertexCurvatureDir(m); }$/;"	f	struct:vcg::tri::BasicCrossFunctor
BasicCrossFunctor	vcglib/vcg/complex/algorithms/geodesic.h	/^struct BasicCrossFunctor$/;"	s	namespace:vcg::tri
BasicGrid	vcglib/vcg/space/index/grid_util.h	/^class BasicGrid \/\/:public SpatialIndex<SCALARTYPE> $/;"	c	namespace:vcg
BasicGrid2D	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^	class BasicGrid2D$/;"	c	namespace:vcg
BasicVertexPair	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  inline BasicVertexPair( VERTEX_TYPE * v0, VERTEX_TYPE * v1){V(0) = v0; V(1) = v1; }$/;"	f	class:vcg::tri::BasicVertexPair
BasicVertexPair	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  inline BasicVertexPair() {}$/;"	f	class:vcg::tri::BasicVertexPair
BasicVertexPair	vcglib/vcg/complex/algorithms/edge_collapse.h	/^class BasicVertexPair {$/;"	c	namespace:vcg::tri
BasisDerivativeType	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,Dynamic,Dynamic,RowMajor,NumOfDerivativesAtCompileTime,OrderAtCompileTime> BasisDerivativeType;$/;"	t	struct:Eigen::SplineTraits
BasisDerivativeType	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<_Scalar,Dynamic,Dynamic,RowMajor,NumOfDerivativesAtCompileTime,OrderAtCompileTime> BasisDerivativeType;$/;"	t	struct:Eigen::SplineTraits
BasisFunctions	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    Spline<_Scalar, _Dim, _Degree>::BasisFunctions($/;"	f	class:Eigen::Spline
BasisReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;$/;"	t	class:Eigen::MatrixBase
BasisVectorType	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    typedef typename SplineTraits<Spline>::BasisVectorType BasisVectorType;$/;"	t	class:Eigen::Spline
BasisVectorType	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,1,OrderAtCompileTime> BasisVectorType;$/;"	t	struct:Eigen::SplineTraits
Begin	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	void Begin()$/;"	f	class:Walker
Begin	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    void Begin()$/;"	f	class:vcg::tri::TrivialWalker
Begin	vcglib/vcg/complex/algorithms/create/resampler.h	/^		void Begin()$/;"	f	class:vcg::tri::Resampler::Walker
Begin	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			EntryIterator Begin() { return EntryIterator(this, CellCoordinate( 0,  0,  0)); }$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
Bennett5_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    Bennett5_functor(void) : Functor<double>(3,154) {}$/;"	f	struct:Bennett5_functor
Bennett5_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct Bennett5_functor : Functor<double>$/;"	s	file:
BestDim	vcglib/vcg/space/index/grid_util.h	/^	void BestDim( const __int64 elems, const Point3<scalar_type> & size, Point3i & dim )$/;"	f	namespace:vcg
BestDim	vcglib/vcg/space/index/grid_util.h	/^void BestDim( const Box3<scalar_type> box, const scalar_type voxel_size, Point3i & dim )$/;"	f	namespace:vcg
BestDim2D	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^	void BestDim2D( const Box2<scalar_type> box, const scalar_type voxel_size, Point2i & dim )$/;"	f	namespace:vcg
BestDim2D	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^	void BestDim2D( const __int64 elems, const Point2<scalar_type> & size, Point2i & dim )$/;"	f	namespace:vcg
BestMatchingNormal	vcglib/vcg/math/gen_normal.h	/^static int BestMatchingNormal(const Point3x &n, std::vector<Point3x> &nv)$/;"	f	class:vcg::GenNormal
Beta	vcglib/vcg/simplex/face/distance.h	/^        static ScalarType & Beta (){static ScalarType beta  = 1.0; return beta;}$/;"	f	class:vcg::face::PointNormalDistanceFunctor
Beta	vcglib/vcg/simplex/vertex/distance.h	/^		static ScalarType & Beta(){static ScalarType beta= 1.0; return beta;}$/;"	f	class:vcg::vertex::PointNormalDistanceFunctor
BiCGSTAB	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB() : Base() {}$/;"	f	class:Eigen::BiCGSTAB
BiCGSTAB	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB(const MatrixType& A) : Base(A) {}$/;"	f	class:Eigen::BiCGSTAB
BiCGSTAB	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^class BiCGSTAB : public IterativeSolverBase<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen
Bicubic	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        Bicubic() {};$/;"	f	class:vcg::tri::Fitmaps::Bicubic
Bicubic	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        Bicubic(vector<double>& input)$/;"	f	class:vcg::tri::Fitmaps::Bicubic
Bicubic	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    class Bicubic$/;"	c	class:vcg::tri::Fitmaps
BidiagonalType	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef BandMatrix<RealScalar, ColsAtCompileTime, ColsAtCompileTime, 1, 0> BidiagonalType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
BinCount	vcglib/vcg/math/histogram.h	/^ScalarType Histogram<ScalarType>::BinCount(ScalarType v)$/;"	f	class:vcg::Histogram
BinCount	vcglib/vcg/math/histogram.h	/^ScalarType Histogram<ScalarType>::BinCount(ScalarType v, ScalarType width)$/;"	f	class:vcg::Histogram
BinCountInd	vcglib/vcg/math/histogram.h	/^    ScalarType BinCountInd(int index) {return H[index];}$/;"	f	class:vcg::Histogram
BinIndex	vcglib/vcg/math/histogram.h	/^int Histogram<ScalarType>::BinIndex(ScalarType val) $/;"	f	class:vcg::Histogram
BinLowerBound	vcglib/vcg/math/histogram.h	/^    ScalarType BinLowerBound(int index) {return R[index];}$/;"	f	class:vcg::Histogram
BinNum	vcglib/vcg/math/histogram.h	/^  int BinNum() const {return n;};$/;"	f	class:vcg::Histogram
BinUpperBound	vcglib/vcg/math/histogram.h	/^    ScalarType BinUpperBound(int index) {return R[index+1];};$/;"	f	class:vcg::Histogram
BinWidth	vcglib/vcg/math/histogram.h	/^ScalarType Histogram<ScalarType>::BinWidth(ScalarType v) $/;"	f	class:vcg::Histogram
BinaryFunc	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef scalar_product_op<T> BinaryFunc;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
BinaryImage	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 BinaryImage() $/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
BinaryImage	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		 class BinaryImage$/;"	c	class:vcg::PerfectSpatialHashing
Bind	vcglib/wrap/gl/gl_object.h	/^	void Bind(void)$/;"	f	class:Bindable
BindAttribute	vcglib/wrap/gl/shaders.h	/^	void BindAttribute(int index, const char * name)$/;"	f	class:Program
BindMaterialTag	vcglib/wrap/dae/colladaformat.h	/^		BindMaterialTag()$/;"	f	class:Collada::Tags::BindMaterialTag
BindMaterialTag	vcglib/wrap/dae/colladaformat.h	/^	class BindMaterialTag : public XMLTag$/;"	c	namespace:Collada::Tags
BindToFB	vcglib/wrap/gl/fbo.h	/^	bool BindToFB(void)$/;"	f	class:BufferRenderTarget
BindToFB	vcglib/wrap/gl/fbo.h	/^	bool BindToFB(void)$/;"	f	class:TextureRenderTarget
BindVertexInputTag	vcglib/wrap/dae/colladaformat.h	/^		BindVertexInputTag(const QString& semantic,const QString& input_semantic,const QString& input_set)$/;"	f	class:Collada::Tags::BindVertexInputTag
BindVertexInputTag	vcglib/wrap/dae/colladaformat.h	/^	class BindVertexInputTag : public XMLTag$/;"	c	namespace:Collada::Tags
Bindable	vcglib/wrap/gl/gl_object.h	/^	Bindable(void)$/;"	f	class:Bindable
Bindable	vcglib/wrap/gl/gl_object.h	/^class Bindable$/;"	c
BindingHandleFromBinding	vcglib/wrap/glw/context.h	/^		struct BindingHandleFromBinding$/;"	s	class:glw::Context
BindingHandleFromObject	vcglib/wrap/glw/context.h	/^		struct BindingHandleFromObject$/;"	s	class:glw::Context
BindingTarget	vcglib/wrap/glw/context.h	/^		typedef std::pair<GLenum, GLint>                               BindingTarget;$/;"	t	class:glw::Context
BitFlags	vcglib/vcg/connectors/hedge_component.h	/^	BitFlags(){_flags=0;}$/;"	f	class:vcg::hedge::BitFlags
BitFlags	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class BitFlags:  public T {$/;"	c	namespace:vcg::hedge
BitFlags	vcglib/vcg/simplex/edge/component.h	/^	BitFlags(){_flags=0;}$/;"	f	class:vcg::edge::BitFlags
BitFlags	vcglib/vcg/simplex/edge/component.h	/^template <class T> class BitFlags:  public T {$/;"	c	namespace:vcg::edge
BitFlags	vcglib/vcg/simplex/face/component.h	/^  BitFlags():_flags(0) {}$/;"	f	class:vcg::face::BitFlags
BitFlags	vcglib/vcg/simplex/face/component.h	/^template <class T> class BitFlags:  public T {$/;"	c	namespace:vcg::face
BitFlags	vcglib/vcg/simplex/tetrahedron/component.h	/^  BitFlags(){_flags=0;}$/;"	f	class:vcg::tetra::BitFlags
BitFlags	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class BitFlags:  public T {$/;"	c	namespace:vcg::tetra
BitFlags	vcglib/vcg/simplex/vertex/component.h	/^  BitFlags(){_flags=0;}$/;"	f	class:vcg::vertex::BitFlags
BitFlags	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class BitFlags:  public T {$/;"	c	namespace:vcg::vertex
BitQuad	vcglib/vcg/complex/algorithms/bitquad_support.h	/^class BitQuad{$/;"	c	namespace:vcg::tri
BitQuadCreation	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^class BitQuadCreation{$/;"	c	namespace:vcg::tri
BitQuadOptimization	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^class BitQuadOptimization{$/;"	c	namespace:vcg::tri
BitScanForward	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define BitScanForward /;"	d	file:
BitScanReverse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define BitScanReverse /;"	d	file:
BitVector	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef std::vector<bool> BitVector;$/;"	t	class:vcg::tri::UpdateHalfEdges
Black	vcglib/vcg/space/color4.h	/^	  Black   = 0xff000000,$/;"	e	enum:vcg::Color4::ColorConstant
BlinnTag	vcglib/wrap/dae/colladaformat.h	/^		BlinnTag()$/;"	f	class:Collada::Tags::BlinnTag
BlinnTag	vcglib/wrap/dae/colladaformat.h	/^	class BlinnTag : public XMLTag$/;"	c	namespace:Collada::Tags
Block	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index i)$/;"	f	class:Eigen::Block
Block	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index startRow, Index startCol)$/;"	f	class:Eigen::Block
Block	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)$/;"	f	class:Eigen::Block
Block	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr,$/;"	f	class:Eigen::Block
Block	vcglib/eigenlib/Eigen/src/Core/Block.h	/^class Block<XprType,BlockRows,BlockCols, InnerPanel,true>$/;"	c	namespace:Eigen
Block	vcglib/eigenlib/Eigen/src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class Block$/;"	c	namespace:Eigen
BlockSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^    BlockSize  = EIGEN_PLAIN_ENUM_MAX(mr,nr)$/;"	e	enum:Eigen::internal::tribb_kernel::__anon209
BlockType	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MatrixType,Dynamic,Dynamic> BlockType;$/;"	t	struct:Eigen::internal::partial_lu_impl
Blue	vcglib/vcg/space/color4.h	/^	  Blue    = 0xffff0000,$/;"	e	enum:vcg::Color4::ColorConstant
Bmt	vcglib/wrap/bmt/bmt.cpp	/^Bmt::Bmt(): fp(NULL) {}$/;"	f	class:Bmt
Bmt	vcglib/wrap/bmt/bmt.h	/^class Bmt {$/;"	c	namespace:vcg
BmtBuilder	vcglib/wrap/bmt/bmt.cpp	/^BmtBuilder::BmtBuilder(): ftmp(NULL), fout(NULL) {}$/;"	f	class:BmtBuilder
BmtBuilder	vcglib/wrap/bmt/bmt.h	/^class BmtBuilder {$/;"	c	namespace:vcg
Border	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	static int &Border()           {static int bor=0; return bor;}$/;"	f	class:vcg::tri::TriEdgeCollapse::FailStat
BorderCount	vcglib/vcg/simplex/face/topology.h	/^inline int BorderCount(FaceType const & f)$/;"	f	namespace:vcg::face
BothDirections	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  BothDirections $/;"	e	enum:Eigen::DirectionType
BottomLeft	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomLeft	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeftBlock	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix< Scalar, Deg_1, Deg_1 >         BottomLeftBlock;$/;"	t	class:Eigen::internal::companion
BottomLeftCeil	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeftDiagonal	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix<Scalar, Deg_1, 1>               BottomLeftDiagonal;$/;"	t	class:Eigen::internal::companion
BottomLeftFloor	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRight	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomRight	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightCeil	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightFloor	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BoundBuffer	vcglib/wrap/glw/buffer.h	/^		BoundBuffer(const BufferHandle & handle, const BufferBindingParams & params)$/;"	f	class:glw::BoundBuffer
BoundBuffer	vcglib/wrap/glw/buffer.h	/^		BoundBuffer(void)$/;"	f	class:glw::BoundBuffer
BoundBuffer	vcglib/wrap/glw/buffer.h	/^class BoundBuffer : public BoundObject$/;"	c	namespace:glw
BoundBufferHandle	vcglib/wrap/glw/buffer.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundBuffer> ::Type  BoundBufferHandle;$/;"	t	namespace:glw
BoundDrawFramebuffer	vcglib/wrap/glw/framebuffer.h	/^		BoundDrawFramebuffer(const FramebufferHandle & handle, const DrawFramebufferBindingParams & params)$/;"	f	class:glw::BoundDrawFramebuffer
BoundDrawFramebuffer	vcglib/wrap/glw/framebuffer.h	/^		BoundDrawFramebuffer(void)$/;"	f	class:glw::BoundDrawFramebuffer
BoundDrawFramebuffer	vcglib/wrap/glw/framebuffer.h	/^class BoundDrawFramebuffer : public BoundFramebuffer$/;"	c	namespace:glw
BoundDrawFramebufferHandle	vcglib/wrap/glw/framebuffer.h	/^typedef   detail::ObjectSharedPointerTraits      <BoundDrawFramebuffer> ::Type BoundDrawFramebufferHandle;$/;"	t	namespace:glw
BoundFeedbackBuffer	vcglib/wrap/glw/buffer.h	/^		BoundFeedbackBuffer(const BufferHandle & handle, const FeedbackBufferBindingParams & params)$/;"	f	class:glw::BoundFeedbackBuffer
BoundFeedbackBuffer	vcglib/wrap/glw/buffer.h	/^		BoundFeedbackBuffer(void)$/;"	f	class:glw::BoundFeedbackBuffer
BoundFeedbackBuffer	vcglib/wrap/glw/buffer.h	/^class BoundFeedbackBuffer : public BoundBuffer$/;"	c	namespace:glw
BoundFeedbackBufferHandle	vcglib/wrap/glw/buffer.h	/^typedef   detail::ObjectSharedPointerTraits      <BoundFeedbackBuffer> ::Type BoundFeedbackBufferHandle;$/;"	t	namespace:glw
BoundFragmentShader	vcglib/wrap/glw/fragmentshader.h	/^		BoundFragmentShader(const FragmentShaderHandle & handle, const ShaderBindingParams & params)$/;"	f	class:glw::BoundFragmentShader
BoundFragmentShader	vcglib/wrap/glw/fragmentshader.h	/^class BoundFragmentShader : public BoundShader$/;"	c	namespace:glw
BoundFragmentShaderHandle	vcglib/wrap/glw/fragmentshader.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundFragmentShader> ::Type  BoundFragmentShaderHandle;$/;"	t	namespace:glw
BoundFramebuffer	vcglib/wrap/glw/framebuffer.h	/^		BoundFramebuffer(const FramebufferHandle & handle, const FramebufferBindingParams & params)$/;"	f	class:glw::BoundFramebuffer
BoundFramebuffer	vcglib/wrap/glw/framebuffer.h	/^		BoundFramebuffer(void)$/;"	f	class:glw::BoundFramebuffer
BoundFramebuffer	vcglib/wrap/glw/framebuffer.h	/^class BoundFramebuffer : public BoundObject$/;"	c	namespace:glw
BoundFramebufferHandle	vcglib/wrap/glw/framebuffer.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundFramebuffer> ::Type  BoundFramebufferHandle;$/;"	t	namespace:glw
BoundGeometryShader	vcglib/wrap/glw/geometryshader.h	/^		BoundGeometryShader(const GeometryShaderHandle & handle, const ShaderBindingParams & params)$/;"	f	class:glw::BoundGeometryShader
BoundGeometryShader	vcglib/wrap/glw/geometryshader.h	/^class BoundGeometryShader : public BoundShader$/;"	c	namespace:glw
BoundGeometryShaderHandle	vcglib/wrap/glw/geometryshader.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundGeometryShader> ::Type  BoundGeometryShaderHandle;$/;"	t	namespace:glw
BoundIndexBuffer	vcglib/wrap/glw/buffer.h	/^		BoundIndexBuffer(const BufferHandle & handle, const IndexBufferBindingParams & params)$/;"	f	class:glw::BoundIndexBuffer
BoundIndexBuffer	vcglib/wrap/glw/buffer.h	/^		BoundIndexBuffer(void)$/;"	f	class:glw::BoundIndexBuffer
BoundIndexBuffer	vcglib/wrap/glw/buffer.h	/^class BoundIndexBuffer : public BoundBuffer$/;"	c	namespace:glw
BoundIndexBufferHandle	vcglib/wrap/glw/buffer.h	/^typedef   detail::ObjectSharedPointerTraits      <BoundIndexBuffer> ::Type BoundIndexBufferHandle;$/;"	t	namespace:glw
BoundObject	vcglib/wrap/glw/object.h	/^		BoundObject(const ObjectHandle & handle, const ObjectBindingParams & params)$/;"	f	class:glw::BoundObject
BoundObject	vcglib/wrap/glw/object.h	/^		BoundObject(void)$/;"	f	class:glw::BoundObject
BoundObject	vcglib/wrap/glw/object.h	/^class BoundObject : public detail::NonCopyable$/;"	c	namespace:glw
BoundObjectHandle	vcglib/wrap/glw/object.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundObject> ::Type  BoundObjectHandle;$/;"	t	namespace:glw
BoundObjects	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^typename AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::NodeType * AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::BoundObjects(const ObjPtrVectorIterator & oBegin, const ObjPtrVectorIterator & oEnd, const unsigned int size, const unsigned int maxElemsPerLeaf, const ScalarType & leafBoxMaxVolume, const bool useVariance, OBJBOXFUNCT & getBox, OBJBARYCENTERFUNCT & getBarycenter) {$/;"	f	class:vcg::AABBBinaryTree
BoundPixelPackBuffer	vcglib/wrap/glw/buffer.h	/^		BoundPixelPackBuffer(const BufferHandle & handle, const PixelPackBufferBindingParams & params)$/;"	f	class:glw::BoundPixelPackBuffer
BoundPixelPackBuffer	vcglib/wrap/glw/buffer.h	/^		BoundPixelPackBuffer(void)$/;"	f	class:glw::BoundPixelPackBuffer
BoundPixelPackBuffer	vcglib/wrap/glw/buffer.h	/^class BoundPixelPackBuffer : public BoundBuffer$/;"	c	namespace:glw
BoundPixelPackBufferHandle	vcglib/wrap/glw/buffer.h	/^typedef   detail::ObjectSharedPointerTraits      <BoundPixelPackBuffer> ::Type BoundPixelPackBufferHandle;$/;"	t	namespace:glw
BoundPixelUnpackBuffer	vcglib/wrap/glw/buffer.h	/^		BoundPixelUnpackBuffer(const BufferHandle & handle, const PixelUnpackBufferBindingParams & params)$/;"	f	class:glw::BoundPixelUnpackBuffer
BoundPixelUnpackBuffer	vcglib/wrap/glw/buffer.h	/^		BoundPixelUnpackBuffer(void)$/;"	f	class:glw::BoundPixelUnpackBuffer
BoundPixelUnpackBuffer	vcglib/wrap/glw/buffer.h	/^class BoundPixelUnpackBuffer : public BoundBuffer$/;"	c	namespace:glw
BoundPixelUnpackBufferHandle	vcglib/wrap/glw/buffer.h	/^typedef   detail::ObjectSharedPointerTraits      <BoundPixelUnpackBuffer> ::Type BoundPixelUnpackBufferHandle;$/;"	t	namespace:glw
BoundProgram	vcglib/wrap/glw/program.h	/^		BoundProgram(const ProgramHandle & handle, const ProgramBindingParams & params)$/;"	f	class:glw::BoundProgram
BoundProgram	vcglib/wrap/glw/program.h	/^		BoundProgram(void)$/;"	f	class:glw::BoundProgram
BoundProgram	vcglib/wrap/glw/program.h	/^class BoundProgram : public BoundObject$/;"	c	namespace:glw
BoundProgramHandle	vcglib/wrap/glw/program.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundProgram> ::Type  BoundProgramHandle;$/;"	t	namespace:glw
BoundReadDrawFramebuffer	vcglib/wrap/glw/framebuffer.h	/^		BoundReadDrawFramebuffer(const FramebufferHandle & handle, const ReadDrawFramebufferBindingParams & params)$/;"	f	class:glw::BoundReadDrawFramebuffer
BoundReadDrawFramebuffer	vcglib/wrap/glw/framebuffer.h	/^		BoundReadDrawFramebuffer(void)$/;"	f	class:glw::BoundReadDrawFramebuffer
BoundReadDrawFramebuffer	vcglib/wrap/glw/framebuffer.h	/^class BoundReadDrawFramebuffer : public BoundFramebuffer$/;"	c	namespace:glw
BoundReadDrawFramebufferHandle	vcglib/wrap/glw/framebuffer.h	/^typedef   detail::ObjectSharedPointerTraits      <BoundReadDrawFramebuffer> ::Type BoundReadDrawFramebufferHandle;$/;"	t	namespace:glw
BoundReadFramebuffer	vcglib/wrap/glw/framebuffer.h	/^		BoundReadFramebuffer(const FramebufferHandle & handle, const ReadFramebufferBindingParams & params)$/;"	f	class:glw::BoundReadFramebuffer
BoundReadFramebuffer	vcglib/wrap/glw/framebuffer.h	/^		BoundReadFramebuffer(void)$/;"	f	class:glw::BoundReadFramebuffer
BoundReadFramebuffer	vcglib/wrap/glw/framebuffer.h	/^class BoundReadFramebuffer : public BoundFramebuffer$/;"	c	namespace:glw
BoundReadFramebufferHandle	vcglib/wrap/glw/framebuffer.h	/^typedef   detail::ObjectSharedPointerTraits      <BoundReadFramebuffer> ::Type BoundReadFramebufferHandle;$/;"	t	namespace:glw
BoundRenderable	vcglib/wrap/glw/renderable.h	/^		BoundRenderable(const RenderableHandle & handle, const RenderableBindingParams & params)$/;"	f	class:glw::BoundRenderable
BoundRenderable	vcglib/wrap/glw/renderable.h	/^		BoundRenderable(void)$/;"	f	class:glw::BoundRenderable
BoundRenderable	vcglib/wrap/glw/renderable.h	/^class BoundRenderable : public BoundObject$/;"	c	namespace:glw
BoundRenderableHandle	vcglib/wrap/glw/renderable.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundRenderable> ::Type  BoundRenderableHandle;$/;"	t	namespace:glw
BoundRenderbuffer	vcglib/wrap/glw/renderbuffer.h	/^		BoundRenderbuffer(const RenderbufferHandle & handle, const RenderbufferBindingParams & params)$/;"	f	class:glw::BoundRenderbuffer
BoundRenderbuffer	vcglib/wrap/glw/renderbuffer.h	/^		BoundRenderbuffer(void)$/;"	f	class:glw::BoundRenderbuffer
BoundRenderbuffer	vcglib/wrap/glw/renderbuffer.h	/^class BoundRenderbuffer : public BoundRenderable$/;"	c	namespace:glw
BoundRenderbufferHandle	vcglib/wrap/glw/renderbuffer.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundRenderbuffer> ::Type  BoundRenderbufferHandle;$/;"	t	namespace:glw
BoundShader	vcglib/wrap/glw/shader.h	/^		BoundShader(const ShaderHandle & handle, const ShaderBindingParams & params)$/;"	f	class:glw::BoundShader
BoundShader	vcglib/wrap/glw/shader.h	/^		BoundShader(void)$/;"	f	class:glw::BoundShader
BoundShader	vcglib/wrap/glw/shader.h	/^class BoundShader : public BoundObject$/;"	c	namespace:glw
BoundShaderHandle	vcglib/wrap/glw/shader.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundShader> ::Type  BoundShaderHandle;$/;"	t	namespace:glw
BoundTexture	vcglib/wrap/glw/texture.h	/^		BoundTexture(const TextureHandle & handle, const TextureBindingParams & params)$/;"	f	class:glw::BoundTexture
BoundTexture	vcglib/wrap/glw/texture.h	/^		BoundTexture(void)$/;"	f	class:glw::BoundTexture
BoundTexture	vcglib/wrap/glw/texture.h	/^class BoundTexture : public BoundRenderable$/;"	c	namespace:glw
BoundTexture2D	vcglib/wrap/glw/texture2d.h	/^		BoundTexture2D(const Texture2DHandle & handle, const Texture2DBindingParams & params)$/;"	f	class:glw::BoundTexture2D
BoundTexture2D	vcglib/wrap/glw/texture2d.h	/^		BoundTexture2D(void)$/;"	f	class:glw::BoundTexture2D
BoundTexture2D	vcglib/wrap/glw/texture2d.h	/^class BoundTexture2D : public BoundTexture$/;"	c	namespace:glw
BoundTexture2DHandle	vcglib/wrap/glw/texture2d.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundTexture2D> ::Type  BoundTexture2DHandle;$/;"	t	namespace:glw
BoundTextureCube	vcglib/wrap/glw/texturecube.h	/^		BoundTextureCube(const TextureCubeHandle & handle, const TextureCubeBindingParams & params)$/;"	f	class:glw::BoundTextureCube
BoundTextureCube	vcglib/wrap/glw/texturecube.h	/^		BoundTextureCube(void)$/;"	f	class:glw::BoundTextureCube
BoundTextureCube	vcglib/wrap/glw/texturecube.h	/^class BoundTextureCube : public BoundTexture$/;"	c	namespace:glw
BoundTextureCubeHandle	vcglib/wrap/glw/texturecube.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundTextureCube> ::Type  BoundTextureCubeHandle;$/;"	t	namespace:glw
BoundTextureHandle	vcglib/wrap/glw/texture.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundTexture> ::Type  BoundTextureHandle;$/;"	t	namespace:glw
BoundUniformBuffer	vcglib/wrap/glw/buffer.h	/^		BoundUniformBuffer(const BufferHandle & handle, const UniformBufferBindingParams & params)$/;"	f	class:glw::BoundUniformBuffer
BoundUniformBuffer	vcglib/wrap/glw/buffer.h	/^		BoundUniformBuffer(void)$/;"	f	class:glw::BoundUniformBuffer
BoundUniformBuffer	vcglib/wrap/glw/buffer.h	/^class BoundUniformBuffer : public BoundBuffer$/;"	c	namespace:glw
BoundUniformBufferHandle	vcglib/wrap/glw/buffer.h	/^typedef   detail::ObjectSharedPointerTraits      <BoundUniformBuffer> ::Type BoundUniformBufferHandle;$/;"	t	namespace:glw
BoundVertexBuffer	vcglib/wrap/glw/buffer.h	/^		BoundVertexBuffer(const BufferHandle & handle, const VertexBufferBindingParams & params)$/;"	f	class:glw::BoundVertexBuffer
BoundVertexBuffer	vcglib/wrap/glw/buffer.h	/^		BoundVertexBuffer(void)$/;"	f	class:glw::BoundVertexBuffer
BoundVertexBuffer	vcglib/wrap/glw/buffer.h	/^class BoundVertexBuffer : public BoundBuffer$/;"	c	namespace:glw
BoundVertexBufferHandle	vcglib/wrap/glw/buffer.h	/^typedef   detail::ObjectSharedPointerTraits      <BoundVertexBuffer> ::Type BoundVertexBufferHandle;$/;"	t	namespace:glw
BoundVertexShader	vcglib/wrap/glw/vertexshader.h	/^		BoundVertexShader(const VertexShaderHandle & handle, const ShaderBindingParams & params)$/;"	f	class:glw::BoundVertexShader
BoundVertexShader	vcglib/wrap/glw/vertexshader.h	/^class BoundVertexShader : public BoundShader$/;"	c	namespace:glw
BoundVertexShaderHandle	vcglib/wrap/glw/vertexshader.h	/^typedef   detail::ObjectSharedPointerTraits       <BoundVertexShader> ::Type  BoundVertexShaderHandle;$/;"	t	namespace:glw
BoundaryWeight	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  double    BoundaryWeight;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
BoundaryWeight	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  double  BoundaryWeight;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
BoundingBox	vcglib/apps/unsupported/extractors/extractor/Definitions.h	/^typedef vcg::Box3< int >						BoundingBox;$/;"	t
BoundingBox	vcglib/vcg/space/index/octree_template.h	/^	inline BoundingBoxType		BoundingBox()								{ return boundingBox;				}$/;"	f	class:vcg::OctreeTemplate
BoundingBoxInWorldCoordinates	vcglib/vcg/space/index/octree_template.h	/^	BoundingBoxType BoundingBoxInWorldCoordinates(const NodePointer n)$/;"	f	class:vcg::OctreeTemplate
BoundingBoxInWorldCoordinates	vcglib/vcg/space/index/octree_template.h	/^	inline void BoundingBoxInWorldCoordinates(const NodePointer n, BoundingBoxType &wc_bb) const$/;"	f	class:vcg::OctreeTemplate
BoundingBoxType	vcglib/vcg/space/index/octree.h	/^        typedef typename TemplatedOctree::BoundingBoxType 		BoundingBoxType;$/;"	t	class:vcg::Octree
BoundingBoxType	vcglib/vcg/space/index/octree_template.h	/^	typedef	vcg::Box3<ScalarType>			BoundingBoxType;$/;"	t	class:vcg::OctreeTemplate
BoundingBoxType	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		typedef typename  vcg::Box3< ScalarType >							BoundingBoxType;$/;"	t	class:vcg::PerfectSpatialHashing
Box	vcglib/vcg/complex/algorithms/clip.h	/^	static inline void Box(const Box3<ScalarType> & b, VERTEXINTEPOLATOR & vInterp, TriMeshType & m)$/;"	f	class:vcg::tri::TriMeshClipper
Box	vcglib/vcg/complex/algorithms/clip.h	/^	static inline void Box(const Box3<ScalarType> & b, VERTEXINTEPOLATOR & vInterp, TriMeshType & m, FACEINDEXCONTAINER & facesToDelete)$/;"	f	class:vcg::tri::TriMeshClipper
Box	vcglib/vcg/complex/algorithms/clip.h	/^	static inline void Box(const Box3<ScalarType> & b, VERTEXINTEPOLATOR & vInterp, const TriMeshType & m, TriMeshType & r)$/;"	f	class:vcg::tri::TriMeshClipper
Box	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Box(MeshType &in, const typename MeshType::BoxType & bb )$/;"	f	namespace:vcg::tri
Box	vcglib/vcg/complex/algorithms/update/bounding.h	/^static void Box(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateBounding
Box	vcglib/vcg/space/box.h	/^	inline  Box( const PointType & mi, const PointType & ma ) { _min = mi; _max = ma; }$/;"	f	class:vcg::Box
Box	vcglib/vcg/space/box.h	/^	inline  Box() { $/;"	f	class:vcg::Box
Box	vcglib/vcg/space/box.h	/^class Box : public Space<N,S> , Linear<Box>$/;"	c	namespace:vcg
Box2	vcglib/vcg/space/box2.h	/^	inline  Box2( const Box2 & b ) { min=b.min; max=b.max; }$/;"	f	class:vcg::Box2
Box2	vcglib/vcg/space/box2.h	/^	inline  Box2( const Point2<BoxScalarType> & mi, const Point2<BoxScalarType> & ma ) { min = mi; max = ma; }$/;"	f	class:vcg::Box2
Box2	vcglib/vcg/space/box2.h	/^	inline  Box2() { min.X()= 1; max.X()= -1; min.Y()= 1; max.Y()= -1; }$/;"	f	class:vcg::Box2
Box2	vcglib/vcg/space/box2.h	/^class Box2$/;"	c	namespace:vcg
Box2d	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^typedef AlignedBox<double, 2> Box2d;$/;"	t	file:
Box2d	vcglib/vcg/space/box.h	/^typedef Box<2,double> Box2d;$/;"	t	namespace:vcg
Box2d	vcglib/vcg/space/box2.h	/^typedef Box2<double> Box2d;$/;"	t	namespace:vcg
Box2f	vcglib/vcg/space/box.h	/^typedef Box<2,float>  Box2f;$/;"	t	namespace:vcg
Box2f	vcglib/vcg/space/box2.h	/^typedef Box2<float>  Box2f;$/;"	t	namespace:vcg
Box2i	vcglib/vcg/space/box.h	/^typedef Box<2,int>	  Box2i;$/;"	t	namespace:vcg
Box2i	vcglib/vcg/space/box2.h	/^typedef Box2<int>	 Box2i;$/;"	t	namespace:vcg
Box2s	vcglib/vcg/space/box.h	/^typedef Box<2,short>  Box2s;$/;"	t	namespace:vcg
Box2s	vcglib/vcg/space/box2.h	/^typedef Box2<short>  Box2s;$/;"	t	namespace:vcg
Box2x	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		typedef Box2<ScalarType> Box2x;$/;"	t	class:vcg::BasicGrid2D
Box2x	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        typedef typename BasicGrid2D<FLT>::Box2x Box2x;$/;"	t	class:vcg::SpatialHashTable2D
Box2x	vcglib/vcg/space/outline2_packer.h	/^  typedef typename vcg::Box2<SCALAR_TYPE> Box2x;$/;"	t	class:vcg::PolyPacker
Box2x	vcglib/vcg/space/rasterized_outline2_packer.h	/^    typedef typename vcg::Box2<SCALAR_TYPE> Box2x;$/;"	t	class:vcg::RasterizedOutline2Packer
Box2x	vcglib/vcg/space/rect_packer.h	/^  typedef typename vcg::Box2<SCALAR_TYPE> Box2x;$/;"	t	class:vcg::RectPacker
Box3	vcglib/vcg/space/box3.h	/^    inline  Box3( const Box3 & b ) { min=b.min; max=b.max; }$/;"	f	class:vcg::Box3
Box3	vcglib/vcg/space/box3.h	/^    inline  Box3( const Point3<BoxScalarType> & mi, const Point3<BoxScalarType> & ma ) { min = mi; max = ma; }$/;"	f	class:vcg::Box3
Box3	vcglib/vcg/space/box3.h	/^    inline  Box3() { min.X()= 1;max.X()= -1;min.Y()= 1;max.Y()= -1;min.Z()= 1;max.Z()= -1;}$/;"	f	class:vcg::Box3
Box3	vcglib/vcg/space/box3.h	/^  inline Box3(const Point3<BoxScalarType> & center, const BoxScalarType & radius) {$/;"	f	class:vcg::Box3
Box3	vcglib/vcg/space/box3.h	/^class Box3$/;"	c	namespace:vcg
Box3Type	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename vcg::Box3<ScalarType>  Box3Type;$/;"	t	class:vcg::tri::Clean
Box3Type	vcglib/vcg/complex/algorithms/hole.h	/^      typedef typename vcg::Box3<ScalarType>  Box3Type;$/;"	t	class:vcg::tri::Hole
Box3Type	vcglib/vcg/complex/algorithms/smooth.h	/^      typedef typename vcg::Box3<ScalarType>  Box3Type;$/;"	t	class:vcg::tri::Smooth
Box3Type	vcglib/vcg/complex/algorithms/stat.h	/^  typedef typename vcg::Box3<ScalarType>  Box3Type;$/;"	t	class:vcg::tri::Stat
Box3Type	vcglib/vcg/complex/algorithms/update/selection.h	/^typedef typename vcg::Box3<ScalarType>  Box3Type;$/;"	t	class:vcg::tri::UpdateSelection
Box3d	vcglib/vcg/space/box.h	/^typedef Box<3,double> Box3d;$/;"	t	namespace:vcg
Box3d	vcglib/vcg/space/box3.h	/^typedef Box3<double> Box3d;$/;"	t	namespace:vcg
Box3f	vcglib/vcg/space/box.h	/^typedef Box<3,float>  Box3f;$/;"	t	namespace:vcg
Box3f	vcglib/vcg/space/box3.h	/^typedef Box3<float>  Box3f;$/;"	t	namespace:vcg
Box3i	vcglib/vcg/space/box.h	/^typedef Box<3,int>	  Box3i;$/;"	t	namespace:vcg
Box3i	vcglib/vcg/space/box3.h	/^typedef Box3<int>	 Box3i;$/;"	t	namespace:vcg
Box3s	vcglib/vcg/space/box.h	/^typedef Box<3,short>  Box3s;$/;"	t	namespace:vcg
Box3s	vcglib/vcg/space/box3.h	/^typedef Box3<short>  Box3s;$/;"	t	namespace:vcg
Box3x	vcglib/apps/unsupported/shadevis/visshader.h	/^	typedef Box3<ScalarType> Box3x;$/;"	t	class:vcg::VisShader
Box3x	vcglib/vcg/space/index/grid_static_ptr.h	/^		typedef Box3<ScalarType> Box3x;$/;"	t	class:vcg::GridStaticPtr
Box3x	vcglib/vcg/space/index/grid_util.h	/^	typedef Box3<ScalarType> Box3x;$/;"	t	class:vcg::BasicGrid
Box3x	vcglib/vcg/space/index/spatial_hashing.h	/^		typedef typename SpatialHashTable<ContainerType,FLT>::Box3x Box3x;$/;"	t	class:vcg::DynamicSpatialHashTable
Box3x	vcglib/vcg/space/index/spatial_hashing.h	/^	typedef typename BasicGrid<FLT>::Box3x Box3x;$/;"	t	class:vcg::SpatialHashTable
BoxBOD_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    BoxBOD_functor(void) : Functor<double>(2,6) {}$/;"	f	struct:BoxBOD_functor
BoxBOD_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct BoxBOD_functor : Functor<double>$/;"	s	file:
BoxClipCode	vcglib/vcg/complex/algorithms/clip.h	/^	static inline unsigned int BoxClipCode(const ScalarType * offsets, const CoordType & p)$/;"	f	class:vcg::tri::TriMeshClipper
BoxToIBox	vcglib/vcg/space/index/grid_util.h	/^  inline void BoxToIBox( const Box3x & b, Box3i & ib ) const$/;"	f	class:vcg::BasicGrid
BoxToIBox	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		inline void BoxToIBox( const Box2x & b, Box2i & ib ) const$/;"	f	class:vcg::BasicGrid2D
BoxType	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  typedef AlignedBox<double, Dim> BoxType;$/;"	t	struct:BallPointStuff	file:
BoxType	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  typedef AlignedBox<double, Dim> BoxType;$/;"	t	struct:TreeTest	file:
BoxType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename vcg::Box3<ScalarType>      BoxType;$/;"	t	class:vcg::tri::SurfaceSampling
BoxType	vcglib/vcg/complex/base.h	/^    typedef Box3<ScalarType> BoxType;$/;"	t	class:vcg::tri::TriMesh
BoxType	vcglib/vcg/space/index/base.h	/^	typedef vcg::Box3<ScalarType> BoxType;$/;"	t	class:vcg::SpatialIndex
BoxType	vcglib/vcg/space/index/index2D/base_2d.h	/^	typedef vcg::Box2<ScalarType> BoxType;$/;"	t	class:vcg::SpatialIndex2D
BoxType	vcglib/vcg/space/triangle3.h	/^	typedef Box3<ScalarType> BoxType;$/;"	t	class:vcg::Triangle3
Bucket	vcglib/vcg/complex/algorithms/symmetry.h	/^    int Bucket(const vcg::Plane3<ScalarType> &Pl)$/;"	f	class:vcg::tri::ExtrinsicPlaneSymmetry
BucketVertexNormal	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    vector<vector<int> >* BucketVertexNormal(typename MESH_TYPE::VertContainer& vert, int bucketDim = 30)$/;"	f	class:OverlapEstimation
Buffer	vcglib/wrap/glw/buffer.h	/^		Buffer(Context * ctx)$/;"	f	class:glw::Buffer
Buffer	vcglib/wrap/glw/buffer.h	/^class Buffer : public Object$/;"	c	namespace:glw
BufferArguments	vcglib/wrap/glw/buffer.h	/^		BufferArguments(GLsizeiptr aSize, GLenum aUsage = GL_STATIC_DRAW, const void * aData = 0)$/;"	f	class:glw::BufferArguments
BufferArguments	vcglib/wrap/glw/buffer.h	/^		BufferArguments(void)$/;"	f	class:glw::BufferArguments
BufferArguments	vcglib/wrap/glw/buffer.h	/^class BufferArguments : public ObjectArguments$/;"	c	namespace:glw
BufferBindingParams	vcglib/wrap/glw/buffer.h	/^		BufferBindingParams(GLenum aTarget, GLenum aUnit)$/;"	f	class:glw::BufferBindingParams
BufferBindingParams	vcglib/wrap/glw/buffer.h	/^		BufferBindingParams(void)$/;"	f	class:glw::BufferBindingParams
BufferBindingParams	vcglib/wrap/glw/buffer.h	/^class BufferBindingParams : public ObjectBindingParams$/;"	c	namespace:glw
BufferHandle	vcglib/wrap/glw/buffer.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeBuffer> ::Type BufferHandle;$/;"	t	namespace:glw
BufferPtr	vcglib/wrap/glw/buffer.h	/^typedef   detail::ObjectSharedPointerTraits  <Buffer> ::Type BufferPtr;$/;"	t	namespace:glw
BufferRenderTarget	vcglib/wrap/gl/fbo.h	/^	BufferRenderTarget(void) : RenderTarget()$/;"	f	class:BufferRenderTarget
BufferRenderTarget	vcglib/wrap/gl/fbo.h	/^class BufferRenderTarget : public virtual RenderTarget$/;"	c
BufferSize	vcglib/wrap/io_trimesh/export_vmi.h	/^        static int BufferSize(const SaveMeshType &m){$/;"	f	class:vcg::tri::io::ExporterVMI
BufferType	vcglib/wrap/glw/type.h	/^	BufferType,$/;"	e	enum:glw::Type
Build	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Build( MeshType & in, const V & v)$/;"	f	namespace:vcg::tri
Build	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Build( MeshType & in, const V & v, const F & f)$/;"	f	namespace:vcg::tri
Build	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^  static void Build( MeshType &startMesh, MeshType &paraMesh, VoronoiAtlasParam &pp)$/;"	f	class:vcg::tri::VoronoiAtlas
BuildBiasedSeedVec	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void BuildBiasedSeedVec(MeshType &m,$/;"	f	class:vcg::tri::VoronoiProcessing
BuildFreeEntryList	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void BuildFreeEntryList()$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
BuildH1PreImage	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void BuildH1PreImage(const typename UniformGrid::EntryIterator &begin, const typename UniformGrid::EntryIterator &end)$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
BuildLaplacianMatrix	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void BuildLaplacianMatrix(double vfscale=1)$/;"	f	class:vcg::tri::PoissonSolver
BuildLaplacianMatrix	vcglib/wrap/miq/core/poisson_solver.h	/^	void BuildLaplacianMatrix(double vfscale=1)$/;"	f	class:PoissonSolver
BuildMesh	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	void BuildMesh(Mesh &mesh, Volume &volume, EXTRACTOR_TYPE &extractor)$/;"	f	class:Walker
BuildMesh	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  void BuildMesh(CallBackPos call = NULL, int interval = 512)$/;"	f	class:vcg::tri::AdvancingFront
BuildMesh	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  void BuildMesh(MeshType &mesh, VolumeType &volume, EXTRACTOR_TYPE &extractor, const float threshold, vcg::CallBackPos * cb=0)$/;"	f	class:vcg::tri::TrivialWalker
BuildMesh	vcglib/vcg/complex/algorithms/create/resampler.h	/^		void BuildMesh(Old_Mesh &old_mesh,New_Mesh &new_mesh,EXTRACTOR_TYPE &extractor,vcg::CallBackPos *cb)$/;"	f	class:vcg::tri::Resampler::Walker
BuildOnePixelTexture	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void BuildOnePixelTexture(Color4b c, unsigned int &TexInd)$/;"	f
BuildRandomOutlineVec	vcglib/vcg/complex/algorithms/outline_support.h	/^  static void BuildRandomOutlineVec(int outlineNum, std::vector< std::vector< Point2f > > &outline2Vec, int seed=0)$/;"	f	class:vcg::tri::OutlineUtil
BuildRoute	vcglib/vcg/space/index/octree_template.h	/^	ZOrderType BuildRoute(const CoordinateType &p, NodePointer *&route)$/;"	f	class:vcg::OctreeTemplate
BuildSeamConstraintsExplicitTranslation	vcglib/wrap/miq/core/poisson_solver.h	/^	void BuildSeamConstraintsExplicitTranslation() $/;"	f	class:PoissonSolver
BuildSeedMap	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void BuildSeedMap(MeshType &m, std::vector<VertexType *> &seedVec,  std::map<VertexPointer, int> &seedMap)$/;"	f	class:vcg::tri::VoronoiProcessing
BuildType	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      typedef Block<CoefficientsType,1, DiagonalSize> BuildType;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType
BuildVoronoiEdgeVec	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void BuildVoronoiEdgeVec(MeshType &m, std::vector<VoronoiEdge> &edgeVec)$/;"	f	class:vcg::tri::VoronoiProcessing
BuiltIn	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  BuiltIn$/;"	e	enum:Eigen::__anon262
Button	vcglib/wrap/gui/trackball.h	/^  enum Button { BUTTON_NONE   = 0x0000, \/\/\/< No button or key pressed.$/;"	g	class:vcg::Trackball
ButtonDown	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::ButtonDown(int button)$/;"	f	class:ActiveCoordinateFrame
ButtonDown	vcglib/wrap/gui/trackball.cpp	/^void Trackball::ButtonDown(Trackball::Button button, unsigned int msec) {$/;"	f	class:Trackball
ButtonUp	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::ButtonUp(int button)$/;"	f	class:ActiveCoordinateFrame
ButtonUp	vcglib/wrap/gui/trackball.cpp	/^void Trackball::ButtonUp(Trackball::Button button) {$/;"	f	class:Trackball
ByLine	vcglib/vcg/math/quadric.h	/^  void ByLine( const LineType & r ) \/\/ Init dato un raggio$/;"	f	class:vcg::math::Quadric
ByPlane	vcglib/vcg/math/quadric.h	/^	void ByPlane( const PlaneType & p )					\/\/ Init dato un piano$/;"	f	class:vcg::math::Quadric
C	vcglib/vcg/complex/algorithms/inertia.h	/^ int C;   \/* gamma *\/$/;"	m	class:vcg::tri::Inertia
C	vcglib/vcg/complex/base.h	/^    inline       Color4b &C()       { return c;  }$/;"	f	class:vcg::tri::TriMesh
C	vcglib/vcg/complex/base.h	/^    inline const Color4b &C() const	{ return c; }$/;"	f	class:vcg::tri::TriMesh
C	vcglib/vcg/container/entries_allocation_table.h	/^	const STL_CONT * EntryCATBase<STL_CONT>::C(){$/;"	f	class:vcg::EntryCATBase
C	vcglib/vcg/simplex/edge/component.h	/^	ColorType &C() { static ColorType dumcolor(vcg::Color4b::White); assert(0); return dumcolor; }$/;"	f	class:vcg::edge::EmptyCore
C	vcglib/vcg/simplex/edge/component.h	/^  ColorType &C() { return _color; }$/;"	f	class:vcg::edge::Color
C	vcglib/vcg/simplex/edge/component.h	/^  const ColorType &C() const { return _color; }$/;"	f	class:vcg::edge::Color
C	vcglib/vcg/simplex/face/component.h	/^  ColorType &C()       { return _color; }$/;"	f	class:vcg::face::Color
C	vcglib/vcg/simplex/face/component.h	/^  ColorType &C()       { static ColorType dumcolor(vcg::Color4b::White);  assert(0); return dumcolor; }$/;"	f	class:vcg::face::EmptyCore
C	vcglib/vcg/simplex/face/component_occ.h	/^		ColorType &C() { return CAT< vector_occ<FaceType>,ColorType>::Instance()->Get((FaceType*)this); }$/;"	f	class:vcg::face::ColorOcc
C	vcglib/vcg/simplex/face/component_ocf.h	/^  ColorType &C()        {$/;"	f	class:vcg::face::ColorOcf
C	vcglib/vcg/simplex/vertex/component.h	/^  ColorType &C()       { static ColorType dumcolor(vcg::Color4b::White); assert(0); return dumcolor; }$/;"	f	class:vcg::vertex::EmptyCore
C	vcglib/vcg/simplex/vertex/component.h	/^  inline       ColorType &C()       { return _color; }$/;"	f	class:vcg::vertex::Color
C	vcglib/vcg/simplex/vertex/component.h	/^  inline const ColorType &C() const { return _color; }$/;"	f	class:vcg::vertex::Color
C	vcglib/vcg/simplex/vertex/component_occ.h	/^  ColorType &C() { return CAT< vector_occ<VertType>,ColorType>::Instance()->Get((VertType*)this); }$/;"	f	class:vcg::vertex::ColorOcc
C	vcglib/vcg/simplex/vertex/component_ocf.h	/^        ColorType &C()       { assert((*this).Base().ColorEnabled); return (*this).Base().CV[(*this).Index()]; }$/;"	f	class:vcg::vertex::ColorOcf
C	vcglib/vcg/simplex/vertex/component_ocf.h	/^  const ColorType &C() const { assert((*this).Base().ColorEnabled); return (*this).Base().CV[(*this).Index()]; }$/;"	f	class:vcg::vertex::ColorOcf
C	vcglib/wrap/opensg/vertex_component.h	/^	ColorType & C() { assert(0); return ColorType(); }$/;"	f	class:vcg::vert::EmptyOSGColor
C	vcglib/wrap/opensg/vertex_component.h	/^	CoreType & C() $/;"	f	class:vcg::vert::OSGColor
C0	vcglib/wrap/io_trimesh/import_vmi.h	/^    >	struct C0		: public DerK<  MeshType, A0,    K12<MeshType, B0, B1, B2, B3, B4,B5,B6,B7,B8,B9,B10,B11,B12> > {};$/;"	s	namespace:vcg::tri::io
C1	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class A0, class A1>											struct C1		: public Der<  MeshType, A1,	C0<MeshType, A0> > {};$/;"	s	namespace:vcg::tri::io
C2	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class A0, class A1, class A2>	 								struct C2		: public Der<  MeshType, A2,	C1<MeshType, A0, A1> > {};$/;"	s	namespace:vcg::tri::io
C3	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class A0, class A1, class A2,class A3>	 					struct C3		: public Der<  MeshType, A3,	C2<MeshType, A0, A1, A2> > {};$/;"	s	namespace:vcg::tri::io
CA	vcglib/vcg/space/colorspace.h	/^	static double CA(int index)$/;"	f	class:vcg::ColorSpace
CACHE	vcglib/wrap/gcache/token.h	/^    enum Status { LOCKED = 1, READY = 0, CACHE = -1, REMOVE = -2, OUTSIDE = -3 };$/;"	e	enum:vcg::Token::Status
CACHE_DOOR_H	vcglib/wrap/gcache/door.h	/^#define CACHE_DOOR_H$/;"	d
CALLBACK	vcglib/wrap/gl/glu_tesselator.h	/^#define CALLBACK /;"	d
CALLBACK	vcglib/wrap/gl/glu_tesselator.h	/^#define CALLBACK$/;"	d
CALL_DIRECT_MMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^        #define CALL_DIRECT_MMAP(/;"	d	file:
CALL_DIRECT_MMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define CALL_DIRECT_MMAP(/;"	d	file:
CALL_MMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^        #define CALL_MMAP(/;"	d	file:
CALL_MMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define CALL_MMAP(/;"	d	file:
CALL_MORECORE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^        #define CALL_MORECORE(/;"	d	file:
CALL_MORECORE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define CALL_MORECORE(/;"	d	file:
CALL_MREMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^        #define CALL_MREMAP(/;"	d	file:
CALL_MREMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define CALL_MREMAP(/;"	d	file:
CALL_MUNMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^        #define CALL_MUNMAP(/;"	d	file:
CALL_MUNMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define CALL_MUNMAP(/;"	d	file:
CAT	vcglib/vcg/container/container_allocation_table.h	/^class CAT:public CATEntry<STL_CONT, EntryCAT<STL_CONT,ATTR_TYPE> >{$/;"	c	namespace:vcg
CATBase	vcglib/vcg/container/container_allocation_table.h	/^				class CATBase: public CATBaseBase{$/;"	c	namespace:vcg
CATBaseBase	vcglib/vcg/container/container_allocation_table.h	/^		struct CATBaseBase{$/;"	s	namespace:vcg
CATEntry	vcglib/vcg/container/container_allocation_table.h	/^CATEntry(){if(Id()==0){$/;"	f	class:vcg::CATEntry
CATEntry	vcglib/vcg/container/container_allocation_table.h	/^class CATEntry: public CATBase<STL_CONT>{$/;"	c	namespace:vcg
CATMULL	vcglib/apps/sample/trimesh_refine/trimesh_refine.cpp	/^#define CATMULL	/;"	d	file:
CAVALIERI	vcglib/vcg/math/camera.h	/^        CAVALIERI	=   3$/;"	e	enum:vcg::Camera::__anon485
CC	Makefile	/^CC         = g++$/;"	m
CCW_FLIP	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            enum FlipType { NO_FLIP, CW_FLIP, CCW_FLIP};$/;"	e	enum:vcg::tri::EdgeFlipPriority::FlipType
CDV	vcglib/vcg/simplex/face/component_ocf.h	/^  std::vector<typename VALUE_TYPE::CurvatureDirType> CDV;$/;"	m	class:vcg::face::vector_ocf
CEdge	vcglib/apps/pivoting/cmesh.h	/^class CEdge {$/;"	c
CEdge	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^class CEdge : public Edge<PolyUsedTypes>{};$/;"	c	file:
CEdge	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^class CEdge : public Edge<PolyUsedTypes>{};$/;"	c	file:
CFLAGS	Makefile	/^CFLAGS     = ${CFLAGS_COMMON} -O3 -I.\/vcglib$/;"	m
CFace	vcglib/apps/metro/metro.cpp	/^class CFace     : public vcg::Face< UsedTypes,vcg::face::VertexRef, vcg::face::Normal3d, vcg::face::EdgePlane,vcg::face::Color4b,vcg::face::Mark,vcg::face::BitFlags> {};$/;"	c	file:
CFace	vcglib/apps/pivoting/cmesh.h	/^class CFace: public FaceSimp2 <CVertex, CEdge, CFace, face::VertexRef, $/;"	c
CFace	vcglib/apps/quadrangulator/quadrangulator.cpp	/^class CFace   : public Face<  MyUsedTypes, face::VertexRef,$/;"	c	file:
CFace	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^class CFace   : public Face<   CUsedTypes,$/;"	c	file:
CFace	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^class CFace   : public Face<$/;"	c	file:
CFace	vcglib/apps/sample/trimesh_QT/glarea.h	/^class CFace   : public vcg::Face<  MyUsedTypes, vcg::face::VertexRef, vcg::face::Normal3f, vcg::face::BitFlags > {};$/;"	c
CFace	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^class CFace   : public vcg::Face<  MyUsedTypes, vcg::face::VertexRef, vcg::face::Normal3f, vcg::face::BitFlags > {};$/;"	c	file:
CFace	vcglib/apps/sample/trimesh_ant_qt/glwidget.h	/^class CFace   : public vcg::Face<  MyUsedTypes, vcg::face::VertexRef, vcg::face::Normal3f, vcg::face::BitFlags > {};$/;"	c
CFace	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^class CFace    : public Face< MyTypes, face::FFAdj, face::VFAdj, face::VertexRef, face::Normal3f, face::BitFlags, face::Mark > {};$/;"	c	file:
CFace	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^class CFace   : public FaceSimp2<   CVertex, CEdge, CFace, face::VertexRef, face::Normal3f > {};$/;"	c	file:
CFace	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^class CFace   : public Face<   MyUsedTypes, face::VertexRef, face::Normal3f > {};$/;"	c	file:
CG_RENDERAREA_H	vcglib/apps/pivoting/glarea.h	/^#define CG_RENDERAREA_H$/;"	d
CHAll	vcglib/wrap/gl/trimesh.h	/^        CHAll			= 0xff$/;"	e	enum:vcg::GLW::Change
CHColor	vcglib/wrap/gl/trimesh.h	/^        CHColor			= 0x04,$/;"	e	enum:vcg::GLW::Change
CHEdge	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^class CHEdge : public HEdge< PolyUsedTypes, hedge::BitFlags,$/;"	c	file:
CHEdge	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^class CHEdge : public HEdge<$/;"	c	file:
CHFace	vcglib/wrap/gl/trimesh.h	/^        CHFace			= 0x08,$/;"	e	enum:vcg::GLW::Change
CHFaceNormal	vcglib/wrap/gl/trimesh.h	/^        CHFaceNormal	= 0x10,$/;"	e	enum:vcg::GLW::Change
CHNormal	vcglib/wrap/gl/trimesh.h	/^        CHNormal		= 0x02,$/;"	e	enum:vcg::GLW::Change
CHRender	vcglib/wrap/gl/trimesh.h	/^        CHRender        = 0x20,$/;"	e	enum:vcg::GLW::Change
CHUNK_ALIGN_MASK	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define CHUNK_ALIGN_MASK /;"	d	file:
CHUNK_OVERHEAD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define CHUNK_OVERHEAD /;"	d	file:
CHVertex	vcglib/wrap/gl/trimesh.h	/^        CHVertex		= 0x01,$/;"	e	enum:vcg::GLW::Change
CIELabtoXYZ	vcglib/vcg/space/colorspace.h	/^	static Color4<T> CIELabtoXYZ(const Color4<T> & color, Illuminant ref)$/;"	f	class:vcg::ColorSpace
CIELabtoXYZ	vcglib/vcg/space/colorspace.h	/^	static void CIELabtoXYZ(double L, double a, double b, double &X, double &Y, double &Z,$/;"	f	class:vcg::ColorSpace
CIE_EPSILON	vcglib/vcg/space/colorspace.h	/^	static double CIE_EPSILON()$/;"	f	class:vcg::ColorSpace
CIE_KI	vcglib/vcg/space/colorspace.h	/^	static double CIE_KI()$/;"	f	class:vcg::ColorSpace
CIE_LAB	vcglib/img/img_attributes.h	/^    CIE_LAB,$/;"	e	enum:img::COLORSPACE
CIE_LUV	vcglib/img/img_attributes.h	/^    CIE_LUV,$/;"	e	enum:img::COLORSPACE
CIE_RGB	vcglib/vcg/space/colorspace.h	/^		CIE_RGB = 5,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
CIE_XYZ	vcglib/img/img_attributes.h	/^    CIE_XYZ,$/;"	e	enum:img::COLORSPACE
CINUSE_BIT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define CINUSE_BIT /;"	d	file:
CJMADD	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^#undef CJMADD$/;"	d
CLASSES_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		CLASSES_NODE=			6; $/;"	v
CLASS_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		CLASS_NODE=				7; $/;"	v
CLOTH_MESH_H	vcglib/apps/pivoting/cmesh.h	/^#define CLOTH_MESH_H$/;"	d
CMD_LINE_ARG_EDGE_SAMPLE	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_EDGE_SAMPLE /;"	d
CMD_LINE_ARG_EDGE_SAMPLE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_EDGE_SAMPLE /;"	d
CMD_LINE_ARG_FACE_SAMPLE	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_FACE_SAMPLE /;"	d
CMD_LINE_ARG_FACE_SAMPLE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_FACE_SAMPLE /;"	d
CMD_LINE_ARG_HIST	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_HIST /;"	d
CMD_LINE_ARG_HIST	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_HIST /;"	d
CMD_LINE_ARG_MONTECARLO_SAMPLING	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_MONTECARLO_SAMPLING /;"	d
CMD_LINE_ARG_MONTECARLO_SAMPLING	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_MONTECARLO_SAMPLING /;"	d
CMD_LINE_ARG_N_SAMPLES	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_N_SAMPLES /;"	d
CMD_LINE_ARG_N_SAMPLES	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_N_SAMPLES /;"	d
CMD_LINE_ARG_SAMPLES_PER_AREA_UNIT	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_SAMPLES_PER_AREA_UNIT /;"	d
CMD_LINE_ARG_SAMPLES_PER_AREA_UNIT	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_SAMPLES_PER_AREA_UNIT /;"	d
CMD_LINE_ARG_SAMPLE_TYPE	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_SAMPLE_TYPE /;"	d
CMD_LINE_ARG_SAMPLE_TYPE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_SAMPLE_TYPE /;"	d
CMD_LINE_ARG_SAVE_DISPLACEMENT	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_SAVE_DISPLACEMENT /;"	d
CMD_LINE_ARG_SAVE_DISPLACEMENT	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_SAVE_DISPLACEMENT /;"	d
CMD_LINE_ARG_SAVE_ERROR_AS_COLOUR	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_SAVE_ERROR_AS_COLOUR /;"	d
CMD_LINE_ARG_SAVE_ERROR_AS_COLOUR	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_SAVE_ERROR_AS_COLOUR /;"	d
CMD_LINE_ARG_SIMILAR_TRIANGLES_SAMPLING	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_SIMILAR_TRIANGLES_SAMPLING /;"	d
CMD_LINE_ARG_SIMILAR_TRIANGLES_SAMPLING	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_SIMILAR_TRIANGLES_SAMPLING /;"	d
CMD_LINE_ARG_SUBDIVISION_SAMPLING	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_SUBDIVISION_SAMPLING /;"	d
CMD_LINE_ARG_SUBDIVISION_SAMPLING	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_SUBDIVISION_SAMPLING /;"	d
CMD_LINE_ARG_VERTEX_SAMPLE	vcglib/apps/trimeshinfo/defs.h	/^#define CMD_LINE_ARG_VERTEX_SAMPLE /;"	d
CMD_LINE_ARG_VERTEX_SAMPLE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define CMD_LINE_ARG_VERTEX_SAMPLE /;"	d
CMFAIL	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define CMFAIL /;"	d	file:
CMLast	vcglib/wrap/gl/trimesh.h	/^    enum ColorMode	{CMNone, CMPerMesh, CMPerFace, CMPerVert, CMLast};$/;"	e	enum:vcg::GLW::ColorMode
CMNone	vcglib/wrap/gl/tetramesh.h	/^	enum ColorMode {CMNone, CMPerMesh,CMUser,CMPerTetraF,CMPerVertexF,CMPerVertex};$/;"	e	enum:vcg::tetra::GLW::ColorMode
CMNone	vcglib/wrap/gl/trimesh.h	/^    enum ColorMode	{CMNone, CMPerMesh, CMPerFace, CMPerVert, CMLast};$/;"	e	enum:vcg::GLW::ColorMode
CMPerFace	vcglib/wrap/gl/trimesh.h	/^    enum ColorMode	{CMNone, CMPerMesh, CMPerFace, CMPerVert, CMLast};$/;"	e	enum:vcg::GLW::ColorMode
CMPerMesh	vcglib/wrap/gl/tetramesh.h	/^	enum ColorMode {CMNone, CMPerMesh,CMUser,CMPerTetraF,CMPerVertexF,CMPerVertex};$/;"	e	enum:vcg::tetra::GLW::ColorMode
CMPerMesh	vcglib/wrap/gl/trimesh.h	/^    enum ColorMode	{CMNone, CMPerMesh, CMPerFace, CMPerVert, CMLast};$/;"	e	enum:vcg::GLW::ColorMode
CMPerTetraF	vcglib/wrap/gl/tetramesh.h	/^	enum ColorMode {CMNone, CMPerMesh,CMUser,CMPerTetraF,CMPerVertexF,CMPerVertex};$/;"	e	enum:vcg::tetra::GLW::ColorMode
CMPerVert	vcglib/wrap/gl/trimesh.h	/^    enum ColorMode	{CMNone, CMPerMesh, CMPerFace, CMPerVert, CMLast};$/;"	e	enum:vcg::GLW::ColorMode
CMPerVertex	vcglib/wrap/gl/tetramesh.h	/^	enum ColorMode {CMNone, CMPerMesh,CMUser,CMPerTetraF,CMPerVertexF,CMPerVertex};$/;"	e	enum:vcg::tetra::GLW::ColorMode
CMPerVertexF	vcglib/wrap/gl/tetramesh.h	/^	enum ColorMode {CMNone, CMPerMesh,CMUser,CMPerTetraF,CMPerVertexF,CMPerVertex};$/;"	e	enum:vcg::tetra::GLW::ColorMode
CMUser	vcglib/wrap/gl/tetramesh.h	/^	enum ColorMode {CMNone, CMPerMesh,CMUser,CMPerTetraF,CMPerVertexF,CMPerVertex};$/;"	e	enum:vcg::tetra::GLW::ColorMode
CMesh	vcglib/apps/metro/metro.cpp	/^class CMesh     : public vcg::tri::TriMesh< std::vector<CVertex>, std::vector<CFace> > {};$/;"	c	file:
CMesh	vcglib/apps/pivoting/cmesh.h	/^class CMesh: public tri::TriMesh< std::vector<CVertex>, std::vector<CFace> > {};$/;"	c
CMesh	vcglib/apps/quadrangulator/quadrangulator.cpp	/^class CMesh   : public tri::TriMesh< std::vector<CVertex>, std::vector<CFace> >{};$/;"	c	file:
CMesh	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^class CMesh   : public vcg::tri::TriMesh< vector<CVertex>, vector<CFace> > {};$/;"	c	file:
CMesh	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^class CMesh : public vcg::tri::TriMesh< vector<CVertex>, vector<CFace> > {};$/;"	c	file:
CMesh	vcglib/apps/sample/trimesh_QT/glarea.h	/^class CMesh   : public vcg::tri::TriMesh< std::vector<CVertex>, std::vector<CFace> > {};$/;"	c
CMesh	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^class CMesh   : public vcg::tri::TriMesh< std::vector<CVertex>, std::vector<CFace> > {};$/;"	c	file:
CMesh	vcglib/apps/sample/trimesh_ant_qt/glwidget.h	/^class CMesh   : public vcg::tri::TriMesh< std::vector<CVertex>, std::vector<CFace> > {};$/;"	c
CMesh	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^class CMesh    : public vcg::tri::TriMesh< vector<CVertex>, vector<CFace> > {};$/;"	c	file:
CMesh	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^class CMesh   : public vcg::tri::TriMesh< vector<CVertex>, vector<CFace> > {};$/;"	c	file:
CMesh	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^class CMesh   : public vcg::tri::TriMesh< vector<CVertex>, vector<CFace> > {};$/;"	c	file:
COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
COLOR	vcglib/wrap/bmt/strip_mesh.h	/^  enum Signature { NORMAL = 1, COLOR = 2, STRIP = 4 };$/;"	e	enum:vcg::StripMesh::Signature
COLOR	vcglib/wrap/gl/fbo.h	/^		COLOR,$/;"	e	enum:FrameBufferSemantic::__anon515
COLORSPACE	vcglib/img/img_attributes.h	/^  enum COLORSPACE {$/;"	g	namespace:img
COLOR_MATCH	vcglib/vcg/space/colorspace.h	/^		COLOR_MATCH = 6,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
COLOR_PER_FACE	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            COLOR_PER_FACE      = (1 << 6),$/;"	e	enum:vcg::tri::AttributeSeam::ASMask
COLOR_PER_VERTEX	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            COLOR_PER_VERTEX    = (1 << 4),$/;"	e	enum:vcg::tri::AttributeSeam::ASMask
COLOR_PER_WEDGE	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            COLOR_PER_WEDGE     = (1 << 5),$/;"	e	enum:vcg::tri::AttributeSeam::ASMask
COL_QT_CONVERT_H_	vcglib/wrap/qt/col_qt_convert.h	/^#define COL_QT_CONVERT_H_$/;"	d
COMPONENT_SPH_	vcglib/vcg/simplex/vertex/component_sph.h	/^#define COMPONENT_SPH_$/;"	d
COMPUTE_INTERVALS_ISECTLINE	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define COMPUTE_INTERVALS_ISECTLINE(/;"	d
COMPUTE_INTERVALS_ISECTLINE	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef COMPUTE_INTERVALS_ISECTLINE$/;"	d
CONTE	vcglib/vcg/complex/base.h	/^                typedef std::vector< typename TYPESPOOL::EdgeType  >		CONTE;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
CONTF	vcglib/vcg/complex/base.h	/^                typedef std::vector< typename TYPESPOOL::FaceType >		CONTF;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
CONTH	vcglib/vcg/complex/base.h	/^                typedef std::vector< typename TYPESPOOL::HEdgeType  >		CONTH;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
CONTV	vcglib/vcg/complex/base.h	/^                typedef std::vector< typename TYPESPOOL::VertexType  >	CONTV;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
COORDINATEFRAME_H	vcglib/wrap/gui/coordinateframe.h	/^#define COORDINATEFRAME_H$/;"	d
CORRUPTION_ERROR_ACTION	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define CORRUPTION_ERROR_ACTION(/;"	d	file:
CREASE0	vcglib/vcg/simplex/face/base.h	/^		CREASE0    = 0x00008000,$/;"	e	enum:vcg::FaceArityMax::__anon497
CREASE1	vcglib/vcg/simplex/face/base.h	/^		CREASE1    = 0x00010000,$/;"	e	enum:vcg::FaceArityMax::__anon497
CREASE2	vcglib/vcg/simplex/face/base.h	/^		CREASE2    = 0x00020000,$/;"	e	enum:vcg::FaceArityMax::__anon497
CROSS	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define CROSS(/;"	d
CROSS	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef CROSS$/;"	d
CSType	vcglib/wrap/io_trimesh/import_fbx.h	/^	typedef typename OpenMeshType::VertexType::ColorType::ScalarType CSType;$/;"	t	class:ImporterFBX
CTMError	vcglib/wrap/io_trimesh/import_ctm.h	/^enum CTMError {$/;"	g	class:vcg::tri::io::ImporterCTM
CUBE	vcglib/vcg/complex/algorithms/inertia.h	/^	inline ScalarType CUBE(ScalarType &x) const { return x*x*x;}$/;"	f	class:vcg::tri::Inertia
CURRENT_THREAD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define CURRENT_THREAD /;"	d	file:
CUsedTypes	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^struct CUsedTypes: public vcg::UsedTypes< vcg::Use<CVertex>::AsVertexType, vcg::Use<CFace>::AsFaceType >{};$/;"	s	file:
CUsedTypes	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^struct CUsedTypes: public vcg::UsedTypes< vcg::Use<CVertex>::AsVertexType, vcg::Use<CFace>::AsFaceType >{};$/;"	s	file:
CV	vcglib/vcg/simplex/face/component_ocf.h	/^  std::vector<typename VALUE_TYPE::ColorType> CV;$/;"	m	class:vcg::face::vector_ocf
CV	vcglib/vcg/simplex/vertex/component_ocf.h	/^  std::vector<typename VALUE_TYPE::ColorType> CV;$/;"	m	class:vcg::vertex::vector_ocf
CVertex	vcglib/apps/metro/metro.cpp	/^class CVertex   : public vcg::Vertex<UsedTypes,vcg::vertex::Coord3d,vcg::vertex::Qualityf,vcg::vertex::Normal3d,vcg::vertex::Color4b,vcg::vertex::BitFlags> {};$/;"	c	file:
CVertex	vcglib/apps/pivoting/cmesh.h	/^class CVertex: public$/;"	c
CVertex	vcglib/apps/quadrangulator/quadrangulator.cpp	/^class CVertex : public Vertex< MyUsedTypes,$/;"	c	file:
CVertex	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^class CVertex : public Vertex< CUsedTypes,$/;"	c	file:
CVertex	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^class CVertex : public Vertex<$/;"	c	file:
CVertex	vcglib/apps/sample/trimesh_QT/glarea.h	/^class CVertex : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::BitFlags>{};$/;"	c
CVertex	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^class CVertex : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::BitFlags>{};$/;"	c	file:
CVertex	vcglib/apps/sample/trimesh_ant_qt/glwidget.h	/^class CVertex : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::BitFlags>{};$/;"	c
CVertex	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^class CVertex  : public Vertex< MyTypes, vertex::VFAdj, vertex::Coord3f,vertex::BitFlags, vertex::Normal3f > {};$/;"	c	file:
CVertex	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^class CVertex : public VertexSimp2< CVertex, CEdge, CFace, vertex::Coord3f, vertex::Normal3f >{};$/;"	c	file:
CVertex	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^class CVertex : public Vertex< MyUsedTypes, vertex::Coord3f, vertex::Normal3f >{};$/;"	c	file:
CW_FLIP	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            enum FlipType { NO_FLIP, CW_FLIP, CCW_FLIP};$/;"	e	enum:vcg::tri::EdgeFlipPriority::FlipType
CYLINDER_CLIP_H	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^#define CYLINDER_CLIP_H$/;"	d
Cache	vcglib/wrap/gcache/cache.h	/^    Cache(uint64_t _capacity = INT_MAX):$/;"	f	class:vcg::Cache
Cache	vcglib/wrap/gcache/cache.h	/^class Cache: public Provider<Token> {$/;"	c	namespace:vcg
CallBack	vcglib/wrap/callback.h	/^typedef bool CallBack( const char * str );$/;"	t	namespace:vcg
CallBackPos	vcglib/wrap/callback.h	/^typedef bool CallBackPos(const int pos, const char * str );$/;"	t	namespace:vcg
CallBackSTLFaceAttribute	vcglib/wrap/io_trimesh/export_stl.h	/^typedef unsigned short CallBackSTLFaceAttribute(const SaveMeshType &m, const FaceType &f);$/;"	t	class:vcg::tri::io::ExporterSTL
Cam2Tsai	vcglib/wrap/tsai/tsaimethods.cpp	/^void TsaiMethods::Cam2Tsai(vcg::Shot<double> *s){$/;"	f	class:TsaiMethods
Camera	vcglib/vcg/math/camera.h	/^    Camera():$/;"	f	class:vcg::Camera
Camera	vcglib/vcg/math/camera.h	/^class Camera$/;"	c	namespace:vcg
CameraDesc	vcglib/wrap/io_trimesh/import_ply.h	/^static const  PropDescriptor &CameraDesc(int i)$/;"	f	class:vcg::tri::io::ImporterPLY
CameraDistance	vcglib/wrap/gl/trimesh.h	/^double CameraDistance(){$/;"	f	class:vcg::GlTrimesh
CameraParameters	vcglib/wrap/io_trimesh/export_u3d.h	/^			CameraParameters()$/;"	f	class:vcg::tri::io::u3dparametersclasses::Movie15Parameters::CameraParameters
CameraParameters	vcglib/wrap/io_trimesh/export_u3d.h	/^			CameraParameters(const float cam_fov_angle,const float cam_roll_angle,$/;"	f	class:vcg::tri::io::u3dparametersclasses::Movie15Parameters::CameraParameters
CameraParameters	vcglib/wrap/io_trimesh/export_u3d.h	/^			CameraParameters(const vcg::Point3f& mesh_center,const float mesh_bbox_diag)$/;"	f	class:vcg::tri::io::u3dparametersclasses::Movie15Parameters::CameraParameters
CameraParameters	vcglib/wrap/io_trimesh/export_u3d.h	/^		class CameraParameters$/;"	c	struct:vcg::tri::io::u3dparametersclasses::Movie15Parameters
CameraType	vcglib/vcg/math/shot.h	/^  typedef Camera<S> CameraType;$/;"	t	class:vcg::Shot
CameraViewing	vcglib/apps/unsupported/shadevis/visshader.h	/^	 bool CameraViewing;$/;"	m	class:vcg::VisShader
CanVectorizeInner	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner =    SameType$/;"	e	enum:Eigen::internal::traits::__anon194
CanVectorizeInner	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner = internal::traits<CoeffBasedProduct>::CanVectorizeInner$/;"	e	enum:Eigen::CoeffBasedProduct::__anon195
CanVectorizeLhs	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon194
CanVectorizeRhs	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeRhs = RhsRowMajor && (RhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon194
Candidate	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    Candidate(){}$/;"	f	struct:vcg::tri::FourPCS::Candidate
Candidate	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    Candidate(FourPoints _p,vcg::Matrix44<ScalarType>_T):p(_p),T(_T){}$/;"	f	struct:vcg::tri::FourPCS::Candidate
Candidate	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  struct Candidate$/;"	s	class:vcg::tri::FourPCS
CantOpen	vcglib/wrap/io_trimesh/import_gts.h	/^				enum GTSCodes {NoError=0, CantOpen, InvalidFile,$/;"	e	enum:vcg::tri::io::ImporterGTS::GTSCodes
CantOpen	vcglib/wrap/io_trimesh/import_off.h	/^  enum OFFCodes {NoError=0, CantOpen, InvalidFile,$/;"	e	enum:vcg::tri::io::ImporterOFF::OFFCodes
CapEdgeMesh	vcglib/wrap/gl/glu_tessellator_cap.h	/^void CapEdgeMesh(MeshType &em, MeshType &cm, bool revertFlag=false)$/;"	f	namespace:vcg::tri
CapHole	vcglib/apps/sample/trimesh_edge/trimesh_edge.cpp	/^void CapHole(MyMesh &m, MyMesh &capMesh, bool reverseFlag)$/;"	f
Cartesian2Polar	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 & Cartesian2Polar()$/;"	f	class:vcg::Point2
Cartesian2Polar	vcglib/vcg/space/point2.h	/^	inline Point2 & Cartesian2Polar()$/;"	f	class:vcg::Point2
Cases	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^            static char Cases(unsigned char cubetype, unsigned char u)$/;"	f	class:vcg::tri::MCLookUpTable
CasesClassic	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^            static char CasesClassic(unsigned char u, unsigned char w)$/;"	f	class:vcg::tri::MCLookUpTable
CauchyBounds	vcglib/eigenlib/unsupported/test/polynomialutils.cpp	/^void CauchyBounds(int deg)$/;"	f
CauchyBounds_scalar	vcglib/eigenlib/unsupported/test/polynomialutils.cpp	/^template<typename _Scalar> void CauchyBounds_scalar()$/;"	f
Cell	vcglib/vcg/space/index/grid_static_ptr.h	/^		typedef Link* Cell;$/;"	t	class:vcg::GridStaticPtr
Cell	vcglib/wrap/bmt/bmt.h	/^  class Cell {$/;"	c	class:vcg::Bmt
Cell	vcglib/wrap/mt/mt.h	/^  typedef C Cell;$/;"	t	class:vcg::DiracPolicy
Cell	vcglib/wrap/mt/mt.h	/^  typedef C Cell;$/;"	t	class:vcg::FrustumPolicy
Cell	vcglib/wrap/mt/mt.h	/^  typedef C Cell;$/;"	t	class:vcg::MT
CellCoordinate	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			typedef vcg::Point3i CellCoordinate;$/;"	t	class:vcg::PerfectSpatialHashing::UniformGrid
CellIterator	vcglib/vcg/space/index/grid_static_ptr.h	/^		typedef Cell CellIterator;$/;"	t	class:vcg::GridStaticPtr
CellIterator	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^            CellIterator(){}$/;"	f	struct:vcg::SpatialHashTable2D::CellIterator
CellIterator	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        struct CellIterator$/;"	s	class:vcg::SpatialHashTable2D
CellIterator	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename Spatial_Idexing::CellIterator CellIterator;$/;"	t	class:vcg::ClosestIterator
CellIterator	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename Spatial_Idexing::CellIterator CellIterator;$/;"	t	class:vcg::RayIterator
CellIterator	vcglib/vcg/space/index/spatial_hashing.h	/^		CellIterator(){}$/;"	f	struct:vcg::SpatialHashTable::CellIterator
CellIterator	vcglib/vcg/space/index/spatial_hashing.h	/^		typedef typename SpatialHashTable<ContainerType,FLT>::CellIterator CellIterator;$/;"	t	class:vcg::DynamicSpatialHashTable
CellIterator	vcglib/vcg/space/index/spatial_hashing.h	/^	struct CellIterator$/;"	s	class:vcg::SpatialHashTable
CellSize	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        size_t CellSize(const Point3i &cell)$/;"	f	class:vcg::SpatialHashTable2D
CellSize	vcglib/vcg/space/index/spatial_hashing.h	/^    size_t CellSize(const Point3i &cell)$/;"	f	class:vcg::SpatialHashTable
Cen	vcglib/vcg/simplex/vertex/distance.h	/^		static Point3<ScalarType> & Cen(){static Point3<ScalarType> cen(0,0,0); return cen;}$/;"	f	class:vcg::vertex::PointScaledDistanceFunctor
Center	vcglib/vcg/space/box.h	/^	PointType Center() const$/;"	f	class:vcg::Box
Center	vcglib/vcg/space/box2.h	/^	PointType Center() const$/;"	f	class:vcg::Box2
Center	vcglib/vcg/space/box3.h	/^    Point3<BoxScalarType> Center() const$/;"	f	class:vcg::Box3
Center	vcglib/vcg/space/index/octree_template.h	/^	CoordinateType Center(NodePointer n) const$/;"	f	class:vcg::OctreeTemplate
Center	vcglib/vcg/space/sphere3.h	/^  Point3<T> &Center() { return _center; }$/;"	f	class:vcg::Sphere3
Center	vcglib/vcg/space/sphere3.h	/^  const Point3<T> &Center() const { return _center; }$/;"	f	class:vcg::Sphere3
CenterInOctreeCoordinates	vcglib/vcg/space/index/octree_template.h	/^	inline CenterType CenterInOctreeCoordinates(const NodePointer n) const { return n->center;}$/;"	f	class:vcg::OctreeTemplate
CenterInWorldCoordinates	vcglib/vcg/space/index/octree_template.h	/^	inline void CenterInWorldCoordinates(const NodePointer n, CoordinateType &wc_Center) const$/;"	f	class:vcg::OctreeTemplate
CenterOfMass	vcglib/vcg/complex/algorithms/inertia.h	/^Point3<ScalarType>  CenterOfMass()$/;"	f	class:vcg::tri::Inertia
CenterPointBarycenter	vcglib/vcg/complex/algorithms/refine.h	/^struct CenterPointBarycenter : public std::unary_function<typename TRIMESH_TYPE::FacePointer, typename TRIMESH_TYPE::CoordType>$/;"	s	namespace:vcg::tri
CenterPx	vcglib/vcg/math/camera.h	/^    Point2<S>	CenterPx;			\/\/\/ Position of the projection of the focal center on the image plane. Expressed in pixels$/;"	m	class:vcg::Camera
CenterType	vcglib/vcg/space/index/octree.h	/^        typedef typename TemplatedOctree::CenterType 					CenterType;$/;"	t	class:vcg::Octree
CenterType	vcglib/vcg/space/index/octree_template.h	/^	typedef vcg::Point3i							CenterType;$/;"	t	class:vcg::OctreeTemplate
Central	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    Central$/;"	e	enum:Eigen::NumericalDiffMode
Centroid	vcglib/vcg/complex/algorithms/refine_loop.h	/^	Centroid() { reset(); }$/;"	f	struct:vcg::tri::Centroid
Centroid	vcglib/vcg/complex/algorithms/refine_loop.h	/^struct Centroid {$/;"	s	namespace:vcg::tri
Change	vcglib/wrap/gl/trimesh.h	/^    enum Change {$/;"	g	class:vcg::GLW
Check	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    int Check(Parameters& param)$/;"	f	class:OverlapEstimation
CheckBBoxCache	vcglib/wrap/ply/plystuff.h	/^        static bool CheckBBoxCache( const char * fname, Box3<ScalarType> & box, const char *fname2=0 )$/;"	f	namespace:vcg::ply
CheckCacheDirectory	vcglib/wrap/ply/plystuff.h	/^static bool CheckCacheDirectory( const char * dir )$/;"	f	namespace:vcg::ply
CheckCacheTime	vcglib/wrap/ply/plystuff.h	/^bool CheckCacheTime( const char * fname, const char * cname )$/;"	f	namespace:vcg::ply
CheckConsistency	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            static bool CheckConsistency(MeshType & m){$/;"	f	class:vcg::tri::UpdateHalfEdges
CheckConsistency_FHp	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            static bool CheckConsistency_FHp(MeshType &  m){$/;"	f	class:vcg::tri::UpdateHalfEdges
CheckEdge	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  bool CheckEdge(int v0, int v1) {$/;"	f	class:vcg::tri::AdvancingFront
CheckFlipDiag	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool CheckFlipDiag(FaceType &f){$/;"	f	class:vcg::tri::BitQuad
CheckFlipEdge	vcglib/vcg/simplex/face/topology.h	/^bool CheckFlipEdge(FaceType &f, int z)$/;"	f	namespace:vcg::face
CheckFlipEdgeNormal	vcglib/vcg/simplex/face/topology.h	/^bool CheckFlipEdgeNormal(FaceType &f, const int z, const float angleRad)$/;"	f	namespace:vcg::face
CheckIncidentFaces	vcglib/vcg/simplex/face/pos.h	/^		void CheckIncidentFaces(int & count, bool & on_border)$/;"	f	class:vcg::face::Pos
CheckLinkConditions	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    bool CheckLinkConditions (const PolyMeshType &mesh, const vcg::face::Pos<FaceType> &startPos) {$/;"	f	class:vcg::tri::PolychordCollapse::LinkConditions
CheckManifoldAfterEarClose	vcglib/vcg/complex/algorithms/hole.h	/^  bool CheckManifoldAfterEarClose()$/;"	f	class:vcg::tri::TrivialEar
CheckOrientation	vcglib/vcg/simplex/face/topology.h	/^bool CheckOrientation(FaceType &f, int z)$/;"	f	namespace:vcg::face
CheckPolychordFindStartPosition	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  static PC_ResultCode CheckPolychordFindStartPosition (const vcg::face::Pos<FaceType> &pos,$/;"	f	class:vcg::tri::PolychordCollapse
CheckValidity	vcglib/vcg/complex/algorithms/hole.h	/^      bool CheckValidity()$/;"	f	class:vcg::tri::Hole::Info
CheckVoronoiTopology	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static bool CheckVoronoiTopology(MeshType& m,std::vector<VertexType *> &seedVec)$/;"	f	class:vcg::tri::VoronoiProcessing
CholMatrixType	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef MatrixType CholMatrixType;$/;"	t	class:Eigen::CholmodBase
CholMatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholesky
CholMatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase
CholMatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLDLT
CholMatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLLT
CholMatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>                   CholMatrixType;$/;"	t	struct:Eigen::internal::traits
CholMatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>               CholMatrixType;$/;"	t	struct:Eigen::internal::traits
CholmodAuto	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodBase	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodBase()$/;"	f	class:Eigen::CholmodBase
CholmodBase	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodBase(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
CholmodBase	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodBase : internal::noncopyable$/;"	c	namespace:Eigen
CholmodDecomposition	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition() : Base() { init(); }$/;"	f	class:Eigen::CholmodDecomposition
CholmodDecomposition	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodDecomposition
CholmodDecomposition	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodDecomposition : public CholmodBase<_MatrixType, _UpLo, CholmodDecomposition<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodLDLt	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodMode	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^enum CholmodMode {$/;"	g	namespace:Eigen
CholmodSimplicialLDLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLDLT
CholmodSimplicialLDLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLDLT
CholmodSimplicialLDLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLDLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSimplicialLLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLLT
CholmodSimplicialLLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLLT
CholmodSimplicialLLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSimplicialLLt	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodSupernodalLLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSupernodalLLT
CholmodSupernodalLLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSupernodalLLT
CholmodSupernodalLLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSupernodalLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSupernodalLLt	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
ChordLengths	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFitting.h	/^  void ChordLengths(const PointArrayType& pts, KnotVectorType& chord_lengths)$/;"	f	namespace:Eigen
CircleLineIntersection	vcglib/vcg/space/intersection2.h	/^	inline bool CircleLineIntersection(const vcg::Line2<ScalarType> & line,$/;"	f	namespace:vcg
CircleStep	vcglib/wrap/gui/trackutils.h	/^  int CircleStep;$/;"	m	class:vcg::trackutils::DrawingHint
Circumcenter	vcglib/vcg/space/triangle3.h	/^Point3<typename TriangleType::ScalarType> Circumcenter(const TriangleType &t)$/;"	f	namespace:vcg
Clamp	vcglib/vcg/math/base.h	/^inline SCALAR  Clamp( const SCALAR & val, const SCALAR& minval, const SCALAR& maxval)$/;"	f	namespace:vcg::math
Clamp	vcglib/vcg/space/color4.h	/^inline Color4<float> Clamp(Color4<float> &c)$/;"	f	namespace:vcg
ClampMask	vcglib/wrap/io_trimesh/io_mask.h	/^static void ClampMask(MeshType &m, int &mask)$/;"	f	class:vcg::tri::io::Mask
ClassNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^	ClassNode(void){node_type = CLASS_NODE;};$/;"	f	class:ClassNode
ClassNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^class ClassNode: public Node$/;"	c
ClassType	vcglib/vcg/complex/algorithms/clip.h	/^	typedef TriMeshClipper<TRIMESHTYPE> ClassType;$/;"	t	class:vcg::tri::TriMeshClipper
ClassType	vcglib/vcg/complex/algorithms/clip.h	/^    typedef GenericVertexInterpolator<MESH_TYPE> ClassType;$/;"	t	class:vcg::tri::GenericVertexInterpolator
ClassType	vcglib/vcg/complex/algorithms/clip.h	/^    typedef TriangleInfo ClassType;$/;"	t	class:vcg::tri::TriMeshClipper::TriangleInfo
ClassType	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	typedef AABBBinaryTreeIndex<OBJTYPE, SCALARTYPE, NODEAUXDATA> ClassType;$/;"	t	class:vcg::AABBBinaryTreeIndex
ClassType	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		typedef AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE> ClassType;$/;"	t	class:vcg::AABBBinaryTree
ClassType	vcglib/vcg/space/index/aabb_binary_tree/closest.h	/^	typedef AABBBinaryTreeClosest<TREETYPE> ClassType;$/;"	t	class:vcg::AABBBinaryTreeClosest
ClassType	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	typedef AABBBinaryTreeFrustumCull<TREETYPE> ClassType;$/;"	t	class:vcg::AABBBinaryTreeFrustumCull
ClassType	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^	typedef AABBBinaryTreeKClosest<TREETYPE> ClassType;$/;"	t	class:vcg::AABBBinaryTreeKClosest
ClassType	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^	typedef AABBBinaryTreeRay<TREETYPE> ClassType;$/;"	t	class:vcg::AABBBinaryTreeRay
ClassType	vcglib/vcg/space/index/base.h	/^	typedef SpatialIndex<OBJTYPE, SCALARTYPE> ClassType;$/;"	t	class:vcg::SpatialIndex
ClassType	vcglib/vcg/space/index/index2D/base_2d.h	/^	typedef SpatialIndex2D<OBJTYPE, SCALARTYPE> ClassType;$/;"	t	class:vcg::SpatialIndex2D
ClassType	vcglib/wrap/utils.h	/^	typedef EmptyClass ClassType;$/;"	t	class:vcg::EmptyClass
ClassType	vcglib/wrap/utils.h	/^	typedef GetPointerFunctor ClassType;$/;"	t	class:vcg::GetPointerFunctor
ClassesNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^	ClassesNode(void){node_type = CLASSES_NODE;};$/;"	f	class:ClassesNode
ClassesNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^class ClassesNode: public Node$/;"	c
Clean	vcglib/vcg/complex/algorithms/clean.h	/^class Clean$/;"	c	namespace:vcg::tri
CleaningFlag	vcglib/apps/metro/metro.cpp	/^bool CleaningFlag=false;$/;"	v
Clear	vcglib/apps/unsupported/shadevis/visshader.h	/^	void Clear() {		$/;"	f	class:vcg::VisShader
Clear	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void Clear(MeshType &m)$/;"	f	class:vcg::tri::UpdateFlags
Clear	vcglib/vcg/complex/algorithms/update/selection.h	/^static void Clear(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
Clear	vcglib/vcg/complex/allocate.h	/^                void Clear(){newBase=oldBase=newEnd=oldEnd=0; remap.clear();}$/;"	f	class:vcg::tri::Allocator::PointerUpdater
Clear	vcglib/vcg/complex/base.h	/^void Clear()$/;"	f	class:vcg::tri::TriMesh
Clear	vcglib/vcg/math/histogram.h	/^	void Clear()$/;"	f	class:vcg::Distribution
Clear	vcglib/vcg/math/histogram.h	/^void Histogram<ScalarType>::Clear()$/;"	f	class:vcg::Histogram
Clear	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	void Clear(void)$/;"	f	class:vcg::AABBBinaryTreeIndex
Clear	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^void AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::Clear(void) {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
Clear	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^void AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::Clear(void) {$/;"	f	class:vcg::AABBBinaryTree
Clear	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void Clear()$/;"	f	class:vcg::SpatialHashTable2D
Clear	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 void Clear()$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
Clear	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void Clear()$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
Clear	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void Clear(bool delete_vectors=false)$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
Clear	vcglib/vcg/space/index/spatial_hashing.h	/^		void Clear()$/;"	f	class:vcg::SpatialHashTable
Clear	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>::Clear()$/;"	f	class:SplatRenderer
Clear	vcglib/wrap/mt/mt.h	/^  void Clear() {$/;"	f	class:vcg::MT
ClearAllF	vcglib/vcg/simplex/face/base.h	/^	void ClearAllF() { this->Flags() &= (~(FAUX0|FAUX1|FAUX2)); }$/;"	f	class:vcg::FaceArityMax
ClearB	vcglib/vcg/connectors/hedge.h	/^	void ClearB()	{this->Flags() &=~BORDER;}$/;"	f	class:vcg::HEdgeArityMax
ClearB	vcglib/vcg/simplex/edge/base.h	/^	void ClearB()	{this->Flags() &=~BORDER;}$/;"	f	class:vcg::EdgeArityMax
ClearB	vcglib/vcg/simplex/face/base.h	/^	void ClearB(int i)	{this->Flags() &= (~(BORDER0<<i));}$/;"	f	class:vcg::FaceArityMax
ClearB	vcglib/vcg/simplex/tetrahedron/base.h	/^	void ClearB(int i)	{this->Flags() &= (~(BORDER0<<i));}$/;"	f	class:vcg::TetraArityMax
ClearB	vcglib/vcg/simplex/vertex/base.h	/^	void ClearB()	{this->Flags() &=~BORDER;}$/;"	f	class:vcg::VertexArityMax
ClearClipSection	vcglib/wrap/gl/tetramesh.h	/^		void ClearClipSection()$/;"	f	class:vcg::tetra::GlTetramesh
ClearCrease	vcglib/vcg/simplex/face/base.h	/^	void ClearCrease(int i)	{this->Flags() &= (~(CREASE0<<i));}$/;"	f	class:vcg::FaceArityMax
ClearD	vcglib/vcg/connectors/hedge.h	/^	void ClearD() {this->Flags() &=(~DELETED);}\/\/\/  un-delete a edge$/;"	f	class:vcg::HEdgeArityMax
ClearD	vcglib/vcg/simplex/edge/base.h	/^	void ClearD() {this->Flags() &=(~DELETED);}\/\/\/  un-delete a edge$/;"	f	class:vcg::EdgeArityMax
ClearD	vcglib/vcg/simplex/face/base.h	/^	void ClearD() {this->Flags() &=(~DELETED);}$/;"	f	class:vcg::FaceArityMax
ClearD	vcglib/vcg/simplex/tetrahedron/base.h	/^	void ClearD() {this->Flags() &=(~DELETED);}$/;"	f	class:vcg::TetraArityMax
ClearD	vcglib/vcg/simplex/vertex/base.h	/^	void ClearD() {this->Flags() &=(~DELETED);}\/\/\/  un-delete a vertex$/;"	f	class:vcg::VertexArityMax
ClearF	vcglib/vcg/simplex/face/base.h	/^	void ClearF(int i)	{this->Flags() &= (~(FAUX0<<i));}$/;"	f	class:vcg::FaceArityMax
ClearFlag	vcglib/apps/metro/sampling.h	/^    void            ClearFlag(int flag)         {Flags &= (flag ^ -1);}$/;"	f	class:vcg::Sampling
ClearFlags	vcglib/vcg/connectors/hedge.h	/^	void ClearFlags() {this->Flags()=0;}$/;"	f	class:vcg::HEdgeArityMax
ClearFlags	vcglib/vcg/simplex/edge/base.h	/^	void ClearFlags() {this->Flags()=0;}$/;"	f	class:vcg::EdgeArityMax
ClearFlags	vcglib/vcg/simplex/face/base.h	/^	void ClearFlags() {this->Flags()=0;}$/;"	f	class:vcg::FaceArityMax
ClearFlags	vcglib/vcg/simplex/tetrahedron/base.h	/^	void ClearFlags() {this->Flags()=0;}$/;"	f	class:vcg::TetraArityMax
ClearFlags	vcglib/vcg/simplex/vertex/base.h	/^	void ClearFlags() {this->Flags()=0;}$/;"	f	class:vcg::VertexArityMax
ClearHeap	vcglib/vcg/complex/algorithms/local_optimization.h	/^void ClearHeap()$/;"	f	class:vcg::LocalOptimization
ClearHeapOld	vcglib/vcg/complex/algorithms/local_optimization.h	/^  void ClearHeapOld()$/;"	f	class:vcg::LocalOptimization
ClearHint	vcglib/wrap/gl/trimesh.h	/^    void ClearHint(Hint hn)$/;"	f	class:vcg::GlTrimesh
ClearModes	vcglib/wrap/gui/trackball.cpp	/^void Trackball::ClearModes()$/;"	f	class:Trackball
ClearPerVertexAttribute	vcglib/vcg/complex/allocate.h	/^  ClearPerVertexAttribute( MeshType & m,typename MeshType::template PerVertexAttributeHandle<ATTR_TYPE> & h){$/;"	f	class:vcg::tri::Allocator
ClearR	vcglib/vcg/connectors/hedge.h	/^	void ClearR() {this->Flags() |=NOTREAD;}\/\/\/  marks the edge as not readable$/;"	f	class:vcg::HEdgeArityMax
ClearR	vcglib/vcg/simplex/edge/base.h	/^	void ClearR() {this->Flags() |=NOTREAD;}\/\/\/  marks the edge as not readable$/;"	f	class:vcg::EdgeArityMax
ClearR	vcglib/vcg/simplex/face/base.h	/^	void ClearR() {this->Flags() |=NOTREAD;}$/;"	f	class:vcg::FaceArityMax
ClearR	vcglib/vcg/simplex/tetrahedron/base.h	/^	void ClearR() {this->Flags() |=NOTREAD;}$/;"	f	class:vcg::TetraArityMax
ClearR	vcglib/vcg/simplex/vertex/base.h	/^	void ClearR() {this->Flags() |=NOTREAD;}\/\/\/  marks the vertex as not readable$/;"	f	class:vcg::VertexArityMax
ClearS	vcglib/vcg/connectors/hedge.h	/^	void ClearS()	{this->Flags() &= ~SELECTED;}\/\/\/ Un-select a edge$/;"	f	class:vcg::HEdgeArityMax
ClearS	vcglib/vcg/simplex/edge/base.h	/^	void ClearS()	{this->Flags() &= ~SELECTED;}\/\/\/ Un-select a edge$/;"	f	class:vcg::EdgeArityMax
ClearS	vcglib/vcg/simplex/face/base.h	/^  void ClearS()	{this->Flags() &= ~SELECTED;}$/;"	f	class:vcg::FaceArityMax
ClearS	vcglib/vcg/simplex/tetrahedron/base.h	/^  void ClearS()	{this->Flags() &= ~SELECTED;}$/;"	f	class:vcg::TetraArityMax
ClearS	vcglib/vcg/simplex/vertex/base.h	/^	void ClearS()	{this->Flags() &= ~SELECTED;}\/\/\/ Un-select a vertex$/;"	f	class:vcg::VertexArityMax
ClearTermination	vcglib/vcg/complex/algorithms/local_optimization.h	/^  void ClearTermination()$/;"	f	class:vcg::LocalOptimization
ClearTerminationFlag	vcglib/vcg/complex/algorithms/local_optimization.h	/^	void ClearTerminationFlag	(int v){tf &= ~v;}$/;"	f	class:vcg::LocalOptimization
ClearUserBit	vcglib/vcg/connectors/hedge.h	/^	void ClearUserBit(int userBit){this->Flags() &= (~userBit);}$/;"	f	class:vcg::HEdgeArityMax
ClearUserBit	vcglib/vcg/simplex/edge/base.h	/^	void ClearUserBit(int userBit){this->Flags() &= (~userBit);}$/;"	f	class:vcg::EdgeArityMax
ClearUserBit	vcglib/vcg/simplex/face/base.h	/^	void ClearUserBit(int userBit){this->Flags() &= (~userBit);}$/;"	f	class:vcg::FaceArityMax
ClearUserBit	vcglib/vcg/simplex/tetrahedron/base.h	/^	void ClearUserBit(int userBit){this->Flags() &= (~userBit);}$/;"	f	class:vcg::TetraArityMax
ClearUserBit	vcglib/vcg/simplex/vertex/base.h	/^	void ClearUserBit(int userBit){this->Flags() &= (~userBit);}$/;"	f	class:vcg::VertexArityMax
ClearV	vcglib/vcg/connectors/hedge.h	/^	void ClearV()	{this->Flags() &=~VISITED;}$/;"	f	class:vcg::HEdgeArityMax
ClearV	vcglib/vcg/simplex/edge/base.h	/^	void ClearV()	{this->Flags() &=~VISITED;}$/;"	f	class:vcg::EdgeArityMax
ClearV	vcglib/vcg/simplex/face/base.h	/^  void ClearV()	{this->Flags() &= ~VISITED;}$/;"	f	class:vcg::FaceArityMax
ClearV	vcglib/vcg/simplex/tetrahedron/base.h	/^  void ClearV()	{this->Flags() &= ~VISITED;}$/;"	f	class:vcg::TetraArityMax
ClearV	vcglib/vcg/simplex/vertex/base.h	/^	void ClearV()	{this->Flags() &=~VISITED;}$/;"	f	class:vcg::VertexArityMax
ClearW	vcglib/vcg/connectors/hedge.h	/^	void ClearW() {this->Flags() |=NOTWRITE;}\/\/\/  marks the edge as writable$/;"	f	class:vcg::HEdgeArityMax
ClearW	vcglib/vcg/simplex/edge/base.h	/^	void ClearW() {this->Flags() |=NOTWRITE;}\/\/\/  marks the edge as writable$/;"	f	class:vcg::EdgeArityMax
ClearW	vcglib/vcg/simplex/face/base.h	/^	void ClearW() {this->Flags() |=NOTWRITE;}$/;"	f	class:vcg::FaceArityMax
ClearW	vcglib/vcg/simplex/tetrahedron/base.h	/^	void ClearW() {this->Flags() |=NOTWRITE;}$/;"	f	class:vcg::TetraArityMax
ClearW	vcglib/vcg/simplex/vertex/base.h	/^	void ClearW() {this->Flags() |=NOTWRITE;}\/\/\/  marks the vertex as writable$/;"	f	class:vcg::VertexArityMax
ClipPlane	vcglib/wrap/gl/tetramesh.h	/^			ClipPlane (){active=false;}$/;"	f	class:vcg::tetra::GlTetramesh::ClipPlane
ClipPlane	vcglib/wrap/gl/tetramesh.h	/^			ClipPlane(Point3x p0, Point3x p1,Point3x p2)$/;"	f	class:vcg::tetra::GlTetramesh::ClipPlane
ClipPlane	vcglib/wrap/gl/tetramesh.h	/^		class ClipPlane$/;"	c	class:vcg::tetra::GlTetramesh
ClipPolygonLine	vcglib/vcg/complex/algorithms/clip.h	/^	static inline void ClipPolygonLine(int mode, const ScalarType & value, CoordType * P_in, unsigned int n_in, CoordType * P_out, unsigned int & n_out)$/;"	f	class:vcg::tri::TriMeshClipper
Clock	vcglib/wrap/system/time/clock.h	/^  typedef QTime Clock;$/;"	t	namespace:mt
Close	vcglib/vcg/complex/algorithms/hole.h	/^  virtual bool Close(PosType &np0, PosType &np1, FacePointer f)$/;"	f	class:vcg::tri::SelfIntersectionEar
Close	vcglib/vcg/complex/algorithms/hole.h	/^  virtual bool Close(PosType &np0, PosType &np1, FaceType * f)$/;"	f	class:vcg::tri::TrivialEar
ClosedFlag	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^bool ClosedFlag=false;$/;"	v
Closest	vcglib/vcg/space/index/aabb_binary_tree/closest.h	/^	static inline ObjPtr Closest(TreeType & tree, OBJPOINTDISTANCEFUNCT & getPointDistance, const CoordType & p, const ScalarType & maxDist, ScalarType & minDist, CoordType & q) {$/;"	f	class:vcg::AABBBinaryTreeClosest
ClosestBaseType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef vcg::ClosestIterator<GRID, VDistFunct, VertTmark<MESH> > ClosestBaseType;$/;"	t	class:vcg::tri::ClosestVertexIterator
ClosestBaseType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef vcg::ClosestIterator<GRID,PDistFunct, FaceTmark<MESH> > ClosestBaseType;$/;"	t	class:vcg::tri::ClosestFaceEPIterator
ClosestFaceEPIterator	vcglib/vcg/complex/algorithms/closest.h	/^			ClosestFaceEPIterator(GridType &_Si):ClosestBaseType(_Si,PDistFunct()){}$/;"	f	class:vcg::tri::ClosestFaceEPIterator
ClosestFaceEPIterator	vcglib/vcg/complex/algorithms/closest.h	/^		class ClosestFaceEPIterator:public vcg::ClosestIterator<GRID,$/;"	c	namespace:vcg::tri
ClosestIterator	vcglib/vcg/space/index/space_iterators.h	/^		ClosestIterator(Spatial_Idexing &_Si,DISTFUNCTOR _dist_funct):Si(_Si),dist_funct(_dist_funct){}$/;"	f	class:vcg::ClosestIterator
ClosestIterator	vcglib/vcg/space/index/space_iterators.h	/^	class ClosestIterator$/;"	c	namespace:vcg
ClosestObjType	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^		class ClosestObjType {$/;"	c	class:vcg::AABBBinaryTreeKClosest
ClosestPoint	vcglib/vcg/space/line2.h	/^	PointType ClosestPoint(const PointType & p) const{$/;"	f	class:vcg::Line2
ClosestPoint	vcglib/vcg/space/line2.h	/^Point2<ScalarType> ClosestPoint( Line2<ScalarType,NORM> l, const Point2<ScalarType> & p) $/;"	f	namespace:vcg
ClosestPoint	vcglib/vcg/space/line3.h	/^	PointType ClosestPoint(const PointType & p) const{$/;"	f	class:vcg::Line3
ClosestPoint	vcglib/vcg/space/line3.h	/^Point3<ScalarType> ClosestPoint( Line3<ScalarType,NORM> l, const Point3<ScalarType> & p) $/;"	f	namespace:vcg
ClosestPoint	vcglib/vcg/space/ray2.h	/^	PointType ClosestPoint(const PointType & p) const{$/;"	f	class:vcg::Ray2
ClosestPoint	vcglib/vcg/space/ray2.h	/^Point2<ScalarType> ClosestPoint( Ray2<ScalarType,NORM> r, const Point3<ScalarType> & p) $/;"	f	namespace:vcg
ClosestPoint	vcglib/vcg/space/ray3.h	/^	PointType ClosestPoint(const PointType & p) const{$/;"	f	class:vcg::Ray3
ClosestPoint	vcglib/vcg/space/ray3.h	/^Point3<ScalarType> ClosestPoint( Ray3<ScalarType,NORM> r, const Point3<ScalarType> & p) $/;"	f	namespace:vcg
ClosestPoint	vcglib/vcg/space/segment2.h	/^Point2<ScalarType> ClosestPoint( Segment2<ScalarType> s, const Point2<ScalarType> & p)$/;"	f	namespace:vcg
ClosestPoint2Box2	vcglib/vcg/space/box2.h	/^Point2<ScalarType> ClosestPoint2Box2(const Point2<ScalarType> &test,$/;"	f	namespace:vcg
ClosestVertexIterator	vcglib/vcg/complex/algorithms/closest.h	/^			ClosestVertexIterator(GridType &_Si):ClosestBaseType(_Si,fn){}$/;"	f	class:vcg::tri::ClosestVertexIterator
ClosestVertexIterator	vcglib/vcg/complex/algorithms/closest.h	/^		class ClosestVertexIterator:public vcg::ClosestIterator<GRID, vcg::vertex::PointDistanceFunctor<typename MESH::ScalarType>, VertTmark<MESH> >$/;"	c	namespace:vcg::tri
Cluster	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef std::list<Scalar> Cluster;$/;"	t	class:Eigen::MatrixFunction
ClusterVertex	vcglib/vcg/complex/algorithms/clean.h	/^  static int ClusterVertex(MeshType &m, const ScalarType radius)$/;"	f	class:vcg::tri::Clean
Clustering	vcglib/vcg/complex/algorithms/clustering.h	/^class Clustering$/;"	c	namespace:vcg::tri
ClusteringSampler	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  ClusteringSampler(std::vector<VertexType *> &_vec): sampleVec(_vec)$/;"	f	class:vcg::tri::ClusteringSampler
ClusteringSampler	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^class ClusteringSampler$/;"	c	namespace:vcg::tri
Cmplx	vcglib/wrap/miq/core/auxmath.h	/^typedef std::complex<double> Cmplx;$/;"	t
CoeffBasedProduct	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const CoeffBasedProduct& other)$/;"	f	class:Eigen::CoeffBasedProduct
CoeffBasedProduct	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::CoeffBasedProduct
CoeffBasedProduct	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^class CoeffBasedProduct$/;"	c	namespace:Eigen
CoeffBasedProductMode	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon266
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon45
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon48
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = internal::traits<_CoefficientsType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon49
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    CoeffReadCost = LhsCoeffReadCost + RhsCoeffReadCost + functor_traits<BinaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon54
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    CoeffReadCost = functor_traits<NullaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon55
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    CoeffReadCost = _XprTypeNested::CoeffReadCost + functor_traits<UnaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon56
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    CoeffReadCost = traits<_MatrixTypeNested>::CoeffReadCost + functor_traits<ViewOp>::Cost,$/;"	e	enum:Eigen::internal::traits::__anon57
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::DenseBase::__anon58
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon64
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    CoeffReadCost = NumTraits<Scalar>::MulCost + MatrixType::CoeffReadCost + DiagonalType::DiagonalVectorType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon68
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon181
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::PermutationBase::__anon186
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::Transpose::__anon188
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    CoeffReadCost = _IndicesType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon187
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    CoeffReadCost = 0 \/\/ TODO CoeffReadCost should not be part of the expression traits$/;"	e	enum:internal::traits::__anon192
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    CoeffReadCost = 0 \/\/ FIXME why is it needed ?$/;"	e	enum:Eigen::internal::traits::__anon193
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon234
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon236
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    CoeffReadCost = traits<typename remove_all<ConditionMatrixNested>::type>::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon238
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon239
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    CoeffReadCost = MatrixTypeNestedPlain::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon248
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::TriangularBase::__anon251
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon252
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    CoeffReadCost = TraversalSize * traits<_MatrixTypeNested>::CoeffReadCost + int(CostOpType::value)$/;"	e	enum:Eigen::internal::traits::__anon322
CoeffReadCost	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      CoeffReadCost = InnerSize == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon194
CoeffReadCost	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost \/\/ minor is used typically on tiny matrices,$/;"	e	enum:Eigen::internal::traits::__anon348
CoeffReadCost	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon359
CoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    CoeffReadCost = MatrixType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon408
CoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    CoeffReadCost = LhsCoeffReadCost + RhsCoeffReadCost + NumTraits<Scalar>::MulCost$/;"	e	enum:Eigen::internal::traits::__anon413
CoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon414
CoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon417
CoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost*10$/;"	e	enum:Eigen::internal::traits::__anon418
CoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
CoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon424
CoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon430
CoeffReadCost	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon450
CoeffReadCost	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon451
CoeffReadCost	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon452
CoeffReadCost	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon456
CoeffReturnType	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::ArrayBase
CoeffReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::DenseBase
CoeffReturnType	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type CoeffReturnType;$/;"	t	class:Eigen::DenseCoeffsBase
CoeffReturnType	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MapBase
CoeffReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MatrixBase
CoeffReturnType	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::conditional<_HasDirectAccess, const Scalar&, Scalar>::type CoeffReturnType;$/;"	t	class:Eigen::SparseMatrixBase
CoeffScalar	vcglib/vcg/complex/algorithms/harmonic.h	/^	typedef double CoeffScalar;$/;"	t	class:vcg::tri::Harmonic
CoeffType	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    typedef AutoDiffScalar<typename JacobianType::ColXpr> CoeffType;$/;"	t	class:Eigen::AutoDiffVector
CoeffVectorType	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::HessenbergDecomposition
CoeffVectorType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::Tridiagonalization
CoeffVectorType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::CoeffVectorType CoeffVectorType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
Coefficients	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^                        : int(AmbientDimAtCompileTime)+1,1> Coefficients;$/;"	t	class:Eigen::Hyperplane
Coefficients	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar, 4, 1> Coefficients;$/;"	t	class:Eigen::Quaternion
Coefficients	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^                        : Index(AmbientDimAtCompileTime)+1,1,Options> Coefficients;$/;"	t	class:Eigen::Hyperplane
Coefficients	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    typedef Map<Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    typedef Map<const Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    typedef typename internal::traits<Map>::Coefficients Coefficients;$/;"	t	class:Eigen::Map
Coefficients	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<_Scalar,4,1,_Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Coefficients Coefficients;$/;"	t	class:Eigen::QuaternionBase
Coefficients	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Quaternion>::Coefficients Coefficients;$/;"	t	class:Eigen::Quaternion
CoefficientsType	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrix
CoefficientsType	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixWrapper
CoefficientsType	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixBase
CoefficientsType	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^  typedef Matrix<Scalar,DataRowsAtCompileTime,ColsAtCompileTime,Options&RowMajor?RowMajor:ColMajor> CoefficientsType;$/;"	t	struct:Eigen::internal::traits
CoefficientsType	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^  typedef _CoefficientsType CoefficientsType;$/;"	t	struct:Eigen::internal::traits
Cofactor	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED Scalar Cofactor(unsigned int i, unsigned int j) const$/;"	f
Cofactor	vcglib/vcg/math/old_deprecated_matrix.h	/^			TYPE Cofactor(unsigned int i, unsigned int j) const$/;"	f	class:vcg::ndim::Matrix
CoherentAccessPattern	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^const int CoherentAccessPattern     = 0x1;$/;"	m	namespace:Eigen
Col	vcglib/vcg/complex/algorithms/clustering.h	/^  Color4b Col() const {return Color4b::White;}$/;"	f	class:vcg::tri::NearestToCenter
Col	vcglib/vcg/complex/algorithms/clustering.h	/^  Color4b Col() const$/;"	f	class:vcg::tri::AverageColorCell
ColMajor	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  ColMajor = 0,$/;"	e	enum:Eigen::__anon263
ColPivHouseholderQR	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR()$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^template<typename _MatrixType> class ColPivHouseholderQR$/;"	c	namespace:Eigen
ColPivHouseholderQRPreconditioner	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  ColPivHouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
ColSpMatrix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor> ColSpMatrix;$/;"	t	class:Eigen::PastixBase
ColSpMatrix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLDLT
ColSpMatrix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLLT
ColSpMatrix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLU
ColType	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColType;$/;"	t	class:Eigen::JacobiSVD
ColVector	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1> ColVector;$/;"	t	class:Eigen::SVD
ColVectorType	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::LU
ColVectorType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
ColVectorType	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
ColXpr	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ColXpr ColXpr;$/;"	t	class:Eigen::MatrixBase
ColXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ColXpr;$/;"	t
Collada	vcglib/wrap/dae/colladaformat.h	/^namespace Collada$/;"	n
ColladaFace	vcglib/wrap/io_trimesh/import_dae.h	/^    class ColladaFace    : public vcg::Face<  ColladaTypes,$/;"	c	class:vcg::tri::io::ImporterDAE
ColladaMesh	vcglib/wrap/io_trimesh/import_dae.h	/^    class ColladaMesh    : public vcg::tri::TriMesh< std::vector<ColladaVertex>, std::vector<ColladaFace> > {};$/;"	c	class:vcg::tri::io::ImporterDAE
ColladaTag	vcglib/wrap/dae/colladaformat.h	/^		ColladaTag()$/;"	f	class:Collada::Tags::ColladaTag
ColladaTag	vcglib/wrap/dae/colladaformat.h	/^	class ColladaTag : public XMLTag$/;"	c	namespace:Collada::Tags
ColladaTypes	vcglib/wrap/io_trimesh/import_dae.h	/^    class ColladaTypes: public vcg::UsedTypes < vcg::Use<ColladaVertex>::template AsVertexType,$/;"	c	class:vcg::tri::io::ImporterDAE
ColladaVertex	vcglib/wrap/io_trimesh/import_dae.h	/^    class ColladaVertex  : public vcg::Vertex< ColladaTypes,$/;"	c	class:vcg::tri::io::ImporterDAE
CollapseAllPolychords	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  static void CollapseAllPolychords (PolyMeshType &mesh, const bool checkSing = true) {$/;"	f	class:vcg::tri::PolychordCollapse
CollapseCounterDiag	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool CollapseCounterDiag(FaceType &f, ScalarType interpol, MeshType& m, Pos* affected=NULL){$/;"	f	class:vcg::tri::BitQuad
CollapseDiag	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool CollapseDiag(FaceType &f, ScalarType interpol, MeshType& m, Pos* affected=NULL){$/;"	f	class:vcg::tri::BitQuad
CollapseEdge	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool CollapseEdge(FaceType &f, int w0, MeshType& m, Pos *affected=NULL){$/;"	f	class:vcg::tri::BitQuad
CollapseEdgeDirect	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool CollapseEdgeDirect(FaceType &f, int w0, MeshType& m){$/;"	f	class:vcg::tri::BitQuad
CollapsePolychord	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  static PC_ResultCode CollapsePolychord (PolyMeshType &mesh,$/;"	f	class:vcg::tri::PolychordCollapse
CollectUVBorder	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^  static void CollectUVBorder(VoroMesh *rm, std::vector<Point2f> &uvBorder)$/;"	f	class:vcg::tri::VoronoiAtlas
Collide	vcglib/vcg/space/box.h	/^	bool Collide(Box const &b)$/;"	f	class:vcg::Box
Collide	vcglib/vcg/space/box2.h	/^	bool Collide( Box2 const &b )$/;"	f	class:vcg::Box2
Collide	vcglib/vcg/space/box3.h	/^    bool Collide(Box3<BoxScalarType> const &b) const$/;"	f	class:vcg::Box3
Color	vcglib/vcg/simplex/edge/component.h	/^  Color():_color(vcg::Color4b::White) {}$/;"	f	class:vcg::edge::Color
Color	vcglib/vcg/simplex/edge/component.h	/^template <class A, class T> class Color: public T {$/;"	c	namespace:vcg::edge
Color	vcglib/vcg/simplex/face/component.h	/^  Color():_color(vcg::Color4b::White) {}$/;"	f	class:vcg::face::Color
Color	vcglib/vcg/simplex/face/component.h	/^template <class A, class T> class Color: public T {$/;"	c	namespace:vcg::face
Color	vcglib/vcg/simplex/vertex/component.h	/^  Color():_color(vcg::Color4b::White) {}$/;"	f	class:vcg::vertex::Color
Color	vcglib/vcg/simplex/vertex/component.h	/^template <class A, class T> class Color: public T {$/;"	c	namespace:vcg::vertex
Color4	vcglib/vcg/space/color4.h	/^  inline Color4 ( const Point4<T> &c) :Point4<T>(c) {}$/;"	f	class:vcg::Color4
Color4	vcglib/vcg/space/color4.h	/^  inline Color4 ( const T nx, const T ny, const T nz , const T nw ) :Point4<T>(nx,ny,nz,nw) {}$/;"	f	class:vcg::Color4
Color4	vcglib/vcg/space/color4.h	/^  inline Color4 (){}$/;"	f	class:vcg::Color4
Color4	vcglib/vcg/space/color4.h	/^class Color4 : public Point4<T>$/;"	c	namespace:vcg
Color4	vcglib/vcg/space/color4.h	/^inline Color4<float>::Color4(Color4<float>::ColorConstant cc)$/;"	f	class:vcg::Color4
Color4	vcglib/vcg/space/color4.h	/^inline Color4<unsigned char>::Color4(Color4<unsigned char>::ColorConstant cc)$/;"	f	class:vcg::Color4
Color4b	vcglib/vcg/simplex/edge/component.h	/^template <class TT> class Color4b: public edge::Color<vcg::Color4b, TT> {$/;"	c	namespace:vcg::edge
Color4b	vcglib/vcg/simplex/face/component.h	/^template <class T> class Color4b: public Color<vcg::Color4b, T> { public:$/;"	c	namespace:vcg::face
Color4b	vcglib/vcg/simplex/vertex/component.h	/^template <class TT> class Color4b: public Color<vcg::Color4b, TT> {$/;"	c	namespace:vcg::vertex
Color4b	vcglib/vcg/space/color4.h	/^typedef Color4<unsigned char>  Color4b;$/;"	t	namespace:vcg
Color4bOcc	vcglib/vcg/simplex/face/component_occ.h	/^template <class T> class Color4bOcc: public ColorOcc<vcg::Color4b, T> {};$/;"	c	namespace:vcg::face
Color4bOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class Color4bOcc: public ColorOcc<vcg::Color4b, T> {};$/;"	c	namespace:vcg::vertex
Color4bOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class Color4bOcf: public ColorOcf<vcg::Color4b, T> {};$/;"	c	namespace:vcg::face
Color4bOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class Color4bOcf: public ColorOcf<vcg::Color4b, T> {$/;"	c	namespace:vcg::vertex
Color4d	vcglib/vcg/space/color4.h	/^typedef Color4<double>         Color4d;$/;"	t	namespace:vcg
Color4f	vcglib/vcg/space/color4.h	/^typedef Color4<float>          Color4f;$/;"	t	namespace:vcg
ColorApplyDiff	vcglib/vcg/complex/algorithms/update/color.h	/^static Color4b ColorApplyDiff(Color4b old_color, Color4b new_color, float intensity)$/;"	f	class:vcg::tri::UpdateColor
ColorAvgInfo	vcglib/vcg/complex/algorithms/update/color.h	/^  class ColorAvgInfo$/;"	c	class:vcg::tri::UpdateColor
ColorBrightnessContrast	vcglib/vcg/complex/algorithms/update/color.h	/^static Color4b ColorBrightnessContrast(Color4b c, float brightness, float contrast)$/;"	f	class:vcg::tri::UpdateColor
ColorConstant	vcglib/vcg/space/color4.h	/^	enum ColorConstant  {$/;"	g	class:vcg::Color4
ColorConverter	vcglib/wrap/qt/col_qt_convert.h	/^	class ColorConverter$/;"	c	namespace:vcg
ColorDesaturate	vcglib/vcg/complex/algorithms/update/color.h	/^static Color4b ColorDesaturate(Color4b c, int method)$/;"	f	class:vcg::tri::UpdateColor
ColorEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  bool ColorEnabled;$/;"	m	class:vcg::vertex::vector_ocf
ColorEqualize	vcglib/vcg/complex/algorithms/update/color.h	/^static Color4b ColorEqualize(Color4b c, int cdf_l[256], int cdf_r[256], int cdf_g[256], int cdf_b[256], unsigned int rgbMask)$/;"	f	class:vcg::tri::UpdateColor
ColorFlag	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^bool ColorFlag=true;$/;"	v
ColorLevels	vcglib/vcg/complex/algorithms/update/color.h	/^static Color4b ColorLevels(Color4b c, float gamma, float in_min, float in_max, float out_min, float out_max, unsigned char rgbMask)$/;"	f	class:vcg::tri::UpdateColor
ColorMap	vcglib/wrap/io_trimesh/import_off.h	/^  static const vcg::Color4f ColorMap(int i)$/;"	f	class:vcg::tri::io::ImporterOFF
ColorMode	vcglib/wrap/gl/tetramesh.h	/^	enum ColorMode {CMNone, CMPerMesh,CMUser,CMPerTetraF,CMPerVertexF,CMPerVertex};$/;"	g	class:vcg::tetra::GLW
ColorMode	vcglib/wrap/gl/trimesh.h	/^    enum ColorMode	{CMNone, CMPerMesh, CMPerFace, CMPerVert, CMLast};$/;"	g	class:vcg::GLW
ColorMul	vcglib/vcg/complex/algorithms/update/color.h	/^static Color4b ColorMul(Color4b c, float factor)$/;"	f	class:vcg::tri::UpdateColor
ColorOcc	vcglib/vcg/simplex/face/component_occ.h	/^template <class A, class T> class ColorOcc: public T {$/;"	c	namespace:vcg::face
ColorOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class A, class T> class ColorOcc: public T {$/;"	c	namespace:vcg::vertex
ColorOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class A, class T> class ColorOcf: public T {$/;"	c	namespace:vcg::face
ColorOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class A, class T> class ColorOcf: public T {$/;"	c	namespace:vcg::vertex
ColorPow	vcglib/vcg/complex/algorithms/update/color.h	/^static Color4b ColorPow(Color4b c, float exponent)$/;"	f	class:vcg::tri::UpdateColor
ColorRamp	vcglib/vcg/space/color4.h	/^inline static Color4 ColorRamp(const float &minf,const float  &maxf ,float v )$/;"	f	class:vcg::Color4
ColorRenderBuffer	vcglib/wrap/gl/fbo.h	/^	ColorRenderBuffer(void) : ColorRenderTarget(), BufferRenderTarget()$/;"	f	class:ColorRenderBuffer
ColorRenderBuffer	vcglib/wrap/gl/fbo.h	/^class ColorRenderBuffer : public virtual ColorRenderTarget, public virtual BufferRenderTarget$/;"	c
ColorRenderTarget	vcglib/wrap/gl/fbo.h	/^	ColorRenderTarget(void) : RenderTarget()$/;"	f	class:ColorRenderTarget
ColorRenderTarget	vcglib/wrap/gl/fbo.h	/^class ColorRenderTarget : public virtual RenderTarget$/;"	c
ColorRenderTexture	vcglib/wrap/gl/fbo.h	/^	ColorRenderTexture(Texture2D * tex) : ColorRenderTarget(), TextureRenderTarget()$/;"	f	class:ColorRenderTexture
ColorRenderTexture	vcglib/wrap/gl/fbo.h	/^	ColorRenderTexture(void) : ColorRenderTarget(), TextureRenderTarget()$/;"	f	class:ColorRenderTexture
ColorRenderTexture	vcglib/wrap/gl/fbo.h	/^class ColorRenderTexture : public virtual ColorRenderTarget, public virtual TextureRenderTarget$/;"	c
ColorSmoothInfo	vcglib/vcg/complex/algorithms/smooth.h	/^class ColorSmoothInfo$/;"	c	class:vcg::tri::Smooth
ColorSpace	vcglib/apps/sample/colorspace/colorspace.cpp	/^typedef vcg::ColorSpace<double> ColorSpace;$/;"	t	file:
ColorSpace	vcglib/vcg/space/colorspace.h	/^class ColorSpace$/;"	c	namespace:vcg
ColorTag	vcglib/wrap/dae/colladaformat.h	/^		ColorTag(const float r,const float g,const float b,const float a)$/;"	f	class:Collada::Tags::ColorTag
ColorTag	vcglib/wrap/dae/colladaformat.h	/^	class ColorTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
ColorTexture	vcglib/wrap/gl/fbo.h	/^	ColorTexture(void) : Texture()$/;"	f	class:ColorTexture
ColorTexture	vcglib/wrap/gl/fbo.h	/^class ColorTexture : public virtual Texture$/;"	c
ColorTexture1D	vcglib/wrap/gl/fbo.h	/^	ColorTexture1D(void) : ColorTexture(), Texture1D()$/;"	f	class:ColorTexture1D
ColorTexture1D	vcglib/wrap/gl/fbo.h	/^class ColorTexture1D : public virtual ColorTexture, public virtual Texture1D$/;"	c
ColorTexture2D	vcglib/wrap/gl/fbo.h	/^	ColorTexture2D(void) : ColorTexture(), Texture2D()$/;"	f	class:ColorTexture2D
ColorTexture2D	vcglib/wrap/gl/fbo.h	/^class ColorTexture2D : public virtual ColorTexture, public virtual Texture2D$/;"	c
ColorTexture3D	vcglib/wrap/gl/fbo.h	/^	ColorTexture3D(void) : ColorTexture(), Texture3D()$/;"	f	class:ColorTexture3D
ColorTexture3D	vcglib/wrap/gl/fbo.h	/^class ColorTexture3D : public virtual ColorTexture, public virtual Texture3D$/;"	c
ColorType	vcglib/vcg/simplex/edge/component.h	/^	typedef vcg::Color4b ColorType;$/;"	t	class:vcg::edge::EmptyCore
ColorType	vcglib/vcg/simplex/edge/component.h	/^  typedef A ColorType;$/;"	t	class:vcg::edge::Color
ColorType	vcglib/vcg/simplex/face/component.h	/^  typedef A ColorType;$/;"	t	class:vcg::face::Color
ColorType	vcglib/vcg/simplex/face/component.h	/^  typedef A ColorType;$/;"	t	class:vcg::face::WedgeColor
ColorType	vcglib/vcg/simplex/face/component.h	/^  typedef vcg::Color4b ColorType;$/;"	t	class:vcg::face::EmptyCore
ColorType	vcglib/vcg/simplex/face/component_occ.h	/^		typedef A ColorType;$/;"	t	class:vcg::face::ColorOcc
ColorType	vcglib/vcg/simplex/face/component_ocf.h	/^  typedef A ColorType;$/;"	t	class:vcg::face::ColorOcf
ColorType	vcglib/vcg/simplex/face/component_ocf.h	/^  typedef A ColorType;$/;"	t	class:vcg::face::WedgeColorOcf
ColorType	vcglib/vcg/simplex/vertex/component.h	/^  typedef A ColorType;$/;"	t	class:vcg::vertex::Color
ColorType	vcglib/vcg/simplex/vertex/component.h	/^  typedef vcg::Color4b ColorType;$/;"	t	class:vcg::vertex::EmptyCore
ColorType	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef A ColorType;$/;"	t	class:vcg::vertex::ColorOcc
ColorType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef A ColorType;$/;"	t	class:vcg::vertex::ColorOcf
ColorType	vcglib/wrap/io_trimesh/import_fbx.h	/^	typedef typename OpenMeshType::VertexType::ColorType ColorType;$/;"	t	class:ImporterFBX
ColorType	vcglib/wrap/opensg/vertex_component.h	/^	typedef A ColorType;														\/\/\/ Must be a OSG::Color3 type as : OSG::Color3ub, OSG:Color3f etc...$/;"	t	class:vcg::vert::OSGColor
ColorType	vcglib/wrap/opensg/vertex_component.h	/^	typedef OSG::Color3f ColorType;$/;"	t	class:vcg::vert::EmptyOSGColor
ColorType	vcglib/wrap/opensg/vertex_component.h	/^	typedef T ColorType;$/;"	t	class:vcg::vert::OSGColorCore
ColorWhiteBalance	vcglib/vcg/complex/algorithms/update/color.h	/^static Color4b ColorWhiteBalance(Color4b c, Color4b unbalancedWhite)$/;"	f	class:vcg::tri::UpdateColor
Cols	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    Cols  = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon142
Cols	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    static const int Cols = Traits::ColsAtCompileTime;$/;"	m	class:Eigen::MatrixFunction
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon4
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon5
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon45
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon48
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon49
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    ColsAtCompileTime = MatrixCols == 0 ? 0 : BlockCols,$/;"	e	enum:Eigen::internal::traits::__anon50
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon53
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon58
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon64
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^      ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon65
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon67
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon175
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon181
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon186
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon188
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    ColsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon187
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    ColsAtCompileTime = RhsCleaned::ColsAtCompileTime,$/;"	e	enum:internal::traits::__anon192
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    ColsAtCompileTime = traits<Rhs>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon193
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    ColsAtCompileTime = ColFactor==Dynamic || int(MatrixType::ColsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon234
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon236
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    ColsAtCompileTime = ConditionMatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon238
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    ColsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon248
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon251
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    ColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon321
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      ColsAtCompileTime = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon194
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    ColsAtCompileTime = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon348
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon350
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon351
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon352
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon354
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon355
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    ColsAtCompileTime = Direction==Horizontal ? ColsPlusOne : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon359
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^      ColsAtCompileTime = internal::traits<HouseholderSequence>::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon383
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    ColsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon382
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon387
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon390
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon396
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon397
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon398
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon442
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon439
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon440
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon441
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon443
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    ColsAtCompileTime = IsRowMajor ? MatrixType::ColsAtCompileTime : Size,$/;"	e	enum:Eigen::internal::traits::__anon408
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    ColsAtCompileTime    = Tr ? int(traits<Lhs>::ColsAtCompileTime)     : int(traits<Rhs>::ColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon413
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    ColsAtCompileTime = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon414
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon418
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon417
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    ColsAtCompileTime    = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon424
ColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    ColsAtCompileTime = IsColVector ? 1 : Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon430
ColsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    static const int ColsAtCompileTime = Traits::ColsAtCompileTime;$/;"	m	class:Eigen::MatrixFunction
ColsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon450
ColsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon451
ColsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        ColsAtCompileTime = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
ColsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon456
ColsAtCompileTimeMinusOne	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTimeMinusOne = internal::decrement_size<ColsAtCompileTime>::ret$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon443
ColsBlockXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ColsBlockXpr;$/;"	t
ColsPlusOne	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    ColsPlusOne = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon359
ColumnVectorType	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::EigenSolver
ColumnVectorType	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealSchur
ColumnsNumber	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline unsigned int ColumnsNumber() const { return cols(); };$/;"	f
ColumnsNumber	vcglib/vcg/math/matrix33.h	/^    inline unsigned int ColumnsNumber() const$/;"	f	class:vcg::Matrix33
ColumnsNumber	vcglib/vcg/math/old_deprecated_matrix.h	/^			inline unsigned int ColumnsNumber() const$/;"	f	class:vcg::ndim::Matrix
ColwiseReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;$/;"	t	class:Eigen::DenseBase
CommaInitializer	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^struct CommaInitializer$/;"	s	namespace:Eigen
CommonSourceBetweenBorderCorner	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static VertexPointer CommonSourceBetweenBorderCorner(FacePointer f0, FacePointer f1,  typename MeshType::template PerVertexAttributeHandle<VertexPointer> &sources)$/;"	f	class:vcg::tri::VoronoiProcessing
CompFaceIntegrals	vcglib/vcg/complex/algorithms/inertia.h	/^void CompFaceIntegrals(FaceType &f)$/;"	f	class:vcg::tri::Inertia
CompactConstructionApproach	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		enum		ConstructionApproach { FastConstructionApproach=0, CompactConstructionApproach=1 };$/;"	e	enum:vcg::PerfectSpatialHashing::ConstructionApproach
CompactEdgeVector	vcglib/vcg/complex/allocate.h	/^    static void CompactEdgeVector( MeshType &m  ) {$/;"	f	class:vcg::tri::Allocator
CompactEdgeVector	vcglib/vcg/complex/allocate.h	/^    static void CompactEdgeVector( MeshType &m,   PointerUpdater<EdgePointer> &pu   )$/;"	f	class:vcg::tri::Allocator
CompactEveryVector	vcglib/vcg/complex/allocate.h	/^        static void CompactEveryVector( MeshType &m)$/;"	f	class:vcg::tri::Allocator
CompactFaceVector	vcglib/vcg/complex/allocate.h	/^        static void CompactFaceVector( MeshType &m  ) {$/;"	f	class:vcg::tri::Allocator
CompactFaceVector	vcglib/vcg/complex/allocate.h	/^    static void CompactFaceVector( MeshType &m, PointerUpdater<FacePointer> &pu )$/;"	f	class:vcg::tri::Allocator
CompactVertexVector	vcglib/vcg/complex/allocate.h	/^        static void CompactVertexVector( MeshType &m  ) {$/;"	f	class:vcg::tri::Allocator
CompactVertexVector	vcglib/vcg/complex/allocate.h	/^        static void CompactVertexVector( MeshType &m,   PointerUpdater<VertexPointer> &pu   )$/;"	f	class:vcg::tri::Allocator
CompanionMatrixType	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef Matrix<Scalar,_Deg,_Deg>                 CompanionMatrixType;$/;"	t	class:Eigen::PolynomialSolver
CompareAreaFP	vcglib/vcg/complex/algorithms/clean.h	/^      struct CompareAreaFP {$/;"	s	class:vcg::tri::Clean
CompareClosest	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^		class CompareClosest {$/;"	c	class:vcg::AABBBinaryTreeKClosest
CompareVertex	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^inline bool CompareVertex(const DstMesh & m, const DstVertex & vA, const DstVertex & vB)$/;"	f
CompareVertex	vcglib/wrap/miq/quadrangulator.h	/^inline bool CompareVertex(const MeshType & m,$/;"	f
ComparisonFunctor	vcglib/vcg/space/rasterized_outline2_packer.h	/^    inline ComparisonFunctor( std::vector<RasterizedOutline2> & nv ) : v(nv) { }$/;"	f	class:vcg::ComparisonFunctor
ComparisonFunctor	vcglib/vcg/space/rasterized_outline2_packer.h	/^class ComparisonFunctor$/;"	c	namespace:vcg
ComparisonFunctor	vcglib/vcg/space/rect_packer.h	/^  inline ComparisonFunctor( const std::vector<vcg::Point2i> & nv ) : v(nv) { }$/;"	f	class:vcg::RectPacker::ComparisonFunctor
ComparisonFunctor	vcglib/vcg/space/rect_packer.h	/^class ComparisonFunctor$/;"	c	class:vcg::RectPacker
Compile	vcglib/wrap/gl/shaders.h	/^	bool Compile(void)$/;"	f	class:Shader
CompleteUnrolling	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  CompleteUnrolling$/;"	e	enum:Eigen::__anon261
Complex	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef std::complex<Scalar> Complex;$/;"	t	struct:Eigen::internal::fftw_impl
Complex	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef std::complex<Scalar> Complex;$/;"	t	struct:Eigen::internal::kiss_cpx_fft
Complex	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef std::complex<Scalar> Complex;$/;"	t	struct:Eigen::internal::kissfft_impl
ComplexEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      ComplexEigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver()$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver(Index size)$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^template<typename _MatrixType> class ComplexEigenSolver$/;"	c	namespace:Eigen
ComplexMatrix	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef Matrix<ComplexScalar, Rows, Cols, Options, MaxRows, MaxCols> ComplexMatrix;$/;"	t	class:Eigen::MatrixFunction
ComplexMatrixType	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> ComplexMatrixType;$/;"	t	class:Eigen::ComplexSchur
ComplexScalar	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	struct:Eigen::internal::stem_function
ComplexScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexEigenSolver
ComplexScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexSchur
ComplexScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::EigenSolver
ComplexScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealSchur
ComplexScalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    typedef typename std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::MatrixExponential
ComplexScalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef std::complex<Scalar> ComplexScalar;$/;"	t	class:Eigen::MatrixFunction
ComplexSchur	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::ComplexSchur
ComplexSchur	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::ComplexSchur
ComplexSchur	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^template<typename _MatrixType> class ComplexSchur$/;"	c	namespace:Eigen
ComplexSize	vcglib/vcg/simplex/face/topology.h	/^inline int ComplexSize(FaceType & f, const int e)$/;"	f	namespace:vcg::face
CompressedStorage	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^class CompressedStorage$/;"	c	namespace:Eigen::internal
ComputationInfo	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum ComputationInfo {$/;"	g	namespace:Eigen
Compute	vcglib/apps/unsupported/shadevis/visshader.h	/^void Compute( CallBack *cb)$/;"	f	class:vcg::VisShader
Compute	vcglib/vcg/complex/algorithms/geodesic.h	/^  static bool Compute( MeshType & m,$/;"	f	class:vcg::tri::Geodesic
Compute	vcglib/vcg/complex/algorithms/inertia.h	/^void Compute(MeshType &m)$/;"	f	class:vcg::tri::Inertia
Compute	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    float Compute(Parameters& param)$/;"	f	class:OverlapEstimation
Compute	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^  static void Compute(MeshType &m, Param p, vcg::CallBackPos * cb=0)$/;"	f	class:vcg::tri::PointCloudNormal
ComputeAngle	vcglib/vcg/complex/algorithms/harmonic.h	/^	static ScalarT ComputeAngle(const VertexType * a, const VertexType * b, const VertexType * c)$/;"	f	class:vcg::tri::Harmonic
ComputeAngle	vcglib/vcg/complex/algorithms/hole.h	/^  void ComputeAngle()$/;"	f	class:vcg::tri::TrivialEar
ComputeAspectRatio	vcglib/vcg/space/tetra3.h	/^ScalarType ComputeAspectRatio()$/;"	f	class:vcg::Tetra3
ComputeAverageVisibilityDirection	vcglib/apps/unsupported/shadevis/visshader.h	/^void ComputeAverageVisibilityDirection()$/;"	f	class:vcg::VisShader
ComputeAvgLightness	vcglib/vcg/complex/algorithms/update/color.h	/^static float ComputeAvgLightness(Color4b c)$/;"	f	class:vcg::tri::UpdateColor
ComputeBarycenter	vcglib/vcg/space/tetra3.h	/^ CoordType ComputeBarycenter()$/;"	f	class:vcg::Tetra3
ComputeCVertex	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            inline void ComputeCVertex(VertexPointer &v12)$/;"	f	class:vcg::tri::MarchingCubes
ComputeConsensus	vcglib/vcg/complex/algorithms/create/resampler.h	/^		void ComputeConsensus(int slice, field_value *slice_values)$/;"	f	class:vcg::tri::Resampler::Walker
ComputeCovarianceMatrix	vcglib/vcg/space/fitting3.h	/^void ComputeCovarianceMatrix(const std::vector<Point3<S> > &pointVec, Point3<S> &barycenter, Eigen::Matrix<S,3,3> &m)$/;"	f	namespace:vcg
ComputeCrossCovarianceMatrix	vcglib/vcg/space/point_matching.h	/^void ComputeCrossCovarianceMatrix(const std::vector<Point3<S> > &spVec, Point3<S> &spBarycenter,$/;"	f	namespace:vcg
ComputeDihedralAngle	vcglib/vcg/complex/algorithms/hole.h	/^    static float ComputeDihedralAngle(CoordType  p1,CoordType  p2,CoordType  p3,CoordType  p4)$/;"	f	class:vcg::tri::Hole
ComputeDimAndVoxel	vcglib/vcg/space/index/grid_util.h	/^	void ComputeDimAndVoxel()$/;"	f	class:vcg::BasicGrid
ComputeDimAndVoxel	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		void ComputeDimAndVoxel()$/;"	f	class:vcg::BasicGrid2D
ComputeE1E2	vcglib/vcg/math/quadric5.h	/^void ComputeE1E2 (const ScalarType p[5],	const	ScalarType q[5],	const	ScalarType r[5], ScalarType e1[5], ScalarType e2[5]) const$/;"	f	class:vcg::Quadric5
ComputeEdgeLengthAverage	vcglib/vcg/complex/algorithms/stat.h	/^  static ScalarType ComputeEdgeLengthAverage(MeshType & m)$/;"	f	class:vcg::tri::Stat
ComputeEdgeLengthHistogram	vcglib/vcg/complex/algorithms/stat.h	/^  static void ComputeEdgeLengthHistogram( MeshType & m, Histogramf &h)$/;"	f	class:vcg::tri::Stat
ComputeEdgePlane	vcglib/vcg/complex/algorithms/update/component_ep.h	/^		static void ComputeEdgePlane(FaceType &f)$/;"	f	class:vcg::tri::UpdateComponentEP
ComputeEigenvectors	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  ComputeEigenvectors = 0x80,$/;"	e	enum:Eigen::DecompositionOptions
ComputeError	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  ScalarType ComputeError()$/;"	f	class:vcg::tetra::TetraEdgeCollapse
ComputeFaceEdgeLengthAverage	vcglib/vcg/complex/algorithms/stat.h	/^  static ScalarType ComputeFaceEdgeLengthAverage(MeshType & m)$/;"	f	class:vcg::tri::Stat
ComputeFaceEdgeLengthDistribution	vcglib/vcg/complex/algorithms/stat.h	/^  static void ComputeFaceEdgeLengthDistribution( MeshType & m, Distribution<float> &h)$/;"	f	class:vcg::tri::Stat
ComputeFullU	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  ComputeFullU        = 0x04,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullV	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  ComputeFullV        = 0x10,$/;"	e	enum:Eigen::DecompositionOptions
ComputeHalf	vcglib/apps/unsupported/shadevis/visshader.h	/^void ComputeHalf(int nn, Point3x &dir, CallBack *cb)$/;"	f	class:vcg::VisShader
ComputeLightness	vcglib/vcg/complex/algorithms/update/color.h	/^static float ComputeLightness(Color4b c)$/;"	f	class:vcg::tri::UpdateColor
ComputeLuminosity	vcglib/vcg/complex/algorithms/update/color.h	/^static float ComputeLuminosity(Color4b c)$/;"	f	class:vcg::tri::UpdateColor
ComputeMeshArea	vcglib/apps/metro/sampling.h	/^inline double Sampling<MetroMesh>::ComputeMeshArea(MetroMesh & mesh)$/;"	f	class:vcg::Sampling
ComputeMeshArea	vcglib/vcg/complex/algorithms/stat.h	/^  static ScalarType ComputeMeshArea(MeshType & m)$/;"	f	class:vcg::tri::Stat
ComputeMinimal	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^ CoordType ComputeMinimal()$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
ComputeMinimal	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    inline void ComputeMinimal(double vv[5],const double v0[5],const double v1[5], const Quadric5<double> qsum,BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
ComputeMinimalWithGeoContraints	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    inline void ComputeMinimalWithGeoContraints(double vv[5],const double v0[5],const double v1[5], const Quadric5<double> qsum, const double geo[5],BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
ComputeMinimalsAndPriority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    inline ScalarType ComputeMinimalsAndPriority(double dest_1[5],$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
ComputeNormal	vcglib/vcg/simplex/face/component.h	/^void ComputeNormal(T &f) {	f.N().Import(vcg::Normal<T>(f)); }$/;"	f	namespace:vcg::face
ComputeNormalizedNormal	vcglib/vcg/simplex/face/component.h	/^void ComputeNormalizedNormal(T &f) {	f.N().Import(vcg::NormalizedNormal<T>(f)); }$/;"	f	namespace:vcg::face
ComputePerFaceQualityDistribution	vcglib/vcg/complex/algorithms/stat.h	/^  static void ComputePerFaceQualityDistribution( MeshType & m, Distribution<float> &h, bool selectionOnly = false)    \/\/ V1.0$/;"	f	class:vcg::tri::Stat
ComputePerFaceQualityHistogram	vcglib/vcg/complex/algorithms/stat.h	/^  static void ComputePerFaceQualityHistogram( MeshType & m, Histogramf &h, bool selectionOnly=false,int HistSize=10000 )$/;"	f	class:vcg::tri::Stat
ComputePerFaceQualityMinMax	vcglib/vcg/complex/algorithms/stat.h	/^  static std::pair<float,float> ComputePerFaceQualityMinMax( MeshType & m)$/;"	f	class:vcg::tri::Stat
ComputePerFaceQualityMinMax	vcglib/vcg/complex/algorithms/stat.h	/^  static void ComputePerFaceQualityMinMax( MeshType & m, float &minV, float &maxV)$/;"	f	class:vcg::tri::Stat
ComputePerVertexQualityDistribution	vcglib/vcg/complex/algorithms/stat.h	/^  static void ComputePerVertexQualityDistribution( MeshType & m, Distribution<float> &h, bool selectionOnly = false)    \/\/ V1.0$/;"	f	class:vcg::tri::Stat
ComputePerVertexQualityHistogram	vcglib/vcg/complex/algorithms/stat.h	/^  static void ComputePerVertexQualityHistogram( MeshType & m, Histogramf &h, bool selectionOnly = false, int HistSize=10000 )    \/\/ V1.0$/;"	f	class:vcg::tri::Stat
ComputePerVertexQualityMinMax	vcglib/vcg/complex/algorithms/stat.h	/^  static std::pair<float,float> ComputePerVertexQualityMinMax( MeshType & m)$/;"	f	class:vcg::tri::Stat
ComputePerVertexQualityMinMax	vcglib/vcg/complex/algorithms/stat.h	/^  static void ComputePerVertexQualityMinMax( MeshType & m, float &minV, float &maxV)$/;"	f	class:vcg::tri::Stat
ComputePerVertexSources	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void ComputePerVertexSources(MeshType &m, std::vector<VertexType *> &seedVec, DistanceFunctor &df)$/;"	f	class:vcg::tri::VoronoiProcessing
ComputePoissonDiskRadius	vcglib/vcg/complex/algorithms/point_sampling.h	/^static ScalarType ComputePoissonDiskRadius(MetroMesh &origMesh, int sampleNum)$/;"	f	class:vcg::tri::SurfaceSampling
ComputePoissonSampleNum	vcglib/vcg/complex/algorithms/point_sampling.h	/^static int ComputePoissonSampleNum(MetroMesh &origMesh, ScalarType diskRadius)$/;"	f	class:vcg::tri::SurfaceSampling
ComputePoissonSampleRadii	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void ComputePoissonSampleRadii(MetroMesh &sampleMesh, ScalarType diskRadius, ScalarType radiusVariance, bool invert)$/;"	f	class:vcg::tri::SurfaceSampling
ComputePriority	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            ScalarType ComputePriority()$/;"	f	class:vcg::tri::QuadDiagonalCollapse
ComputePriority	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            ScalarType ComputePriority()$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
ComputePriority	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  ScalarType ComputePriority()$/;"	f	class:vcg::tetra::TetraEdgeCollapse
ComputePriority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  inline ScalarType ComputePriority(BaseParameterClass *)$/;"	f	class:vcg::tri::TriEdgeCollapse
ComputePriority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  ScalarType ComputePriority(BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
ComputePriority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    ScalarType ComputePriority(BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
ComputePriority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  ScalarType ComputePriority(BaseParameterClass *)$/;"	f	class:vcg::tri::PlanarEdgeFlip
ComputePriority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  ScalarType ComputePriority(BaseParameterClass *)$/;"	f	class:vcg::tri::TopoEdgeFlip
ComputePriority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  ScalarType ComputePriority(BaseParameterClass *)$/;"	f	class:vcg::tri::TriEdgeFlip
ComputeQuadricFromE1E2	vcglib/vcg/math/quadric5.h	/^void ComputeQuadricFromE1E2(ScalarType e1[5], ScalarType e2[5], ScalarType p[5] )$/;"	f	class:vcg::Quadric5
ComputeQuality	vcglib/vcg/complex/algorithms/hole.h	/^  virtual	void ComputeQuality() {	quality = QualityFace(*this) ; }$/;"	f	class:vcg::tri::TrivialEar
ComputeQuality	vcglib/vcg/complex/algorithms/hole.h	/^  virtual void ComputeQuality()$/;"	f	class:vcg::tri::MinimumWeightEar
ComputeR1R2	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^FourPCS<MeshType>::ComputeR1R2(ScalarType d1,ScalarType d2){$/;"	f	class:vcg::tri::FourPCS
ComputeRigidMatchMatrix	vcglib/vcg/space/point_matching.h	/^void ComputeRigidMatchMatrix(std::vector<Point3<S> > &Pfix,$/;"	f	namespace:vcg
ComputeScalarField	vcglib/vcg/complex/algorithms/harmonic.h	/^	static bool ComputeScalarField(MeshType & m, const ConstraintVec & constraints, ACCESSOR field)$/;"	f	class:vcg::tri::Harmonic
ComputeShellBarycenter	vcglib/vcg/complex/algorithms/stat.h	/^  static Point3<ScalarType> ComputeShellBarycenter(MeshType & m)$/;"	f	class:vcg::tri::Stat
ComputeSimilarityMatchMatrix	vcglib/vcg/space/point_matching.h	/^void ComputeSimilarityMatchMatrix(std::vector<Point3<S> > &Pfix,$/;"	f	namespace:vcg
ComputeSingle	vcglib/apps/unsupported/shadevis/visshader.h	/^void ComputeSingle(Point3x &dir, std::vector<Point3x> &vv,CallBack *cb)$/;"	f	class:vcg::VisShader
ComputeSingleDirection	vcglib/apps/unsupported/shadevis/visshader.h	/^void ComputeSingleDirection(Point3x BaseDir, std::vector<int> &PixSeen, CallBack *cb=DummyCallBack)$/;"	f	class:vcg::VisShader
ComputeSingleVertexCurvature	vcglib/vcg/complex/algorithms/update/curvature.h	/^    static float ComputeSingleVertexCurvature(VertexPointer v, bool norm = true)$/;"	f	class:vcg::tri::UpdateCurvature
ComputeSliceValues	vcglib/vcg/complex/algorithms/create/resampler.h	/^		void ComputeSliceValues(int slice,field_value *slice_values)$/;"	f	class:vcg::tri::Resampler::Walker
ComputeTexPriority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    ScalarType ComputeTexPriority(const double vv[5],Quadric5<double> &qsum, BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
ComputeThinU	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  ComputeThinU        = 0x08,$/;"	e	enum:Eigen::DecompositionOptions
ComputeThinV	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  ComputeThinV        = 0x20,$/;"	e	enum:Eigen::DecompositionOptions
ComputeUndirectedNormal	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^  static void ComputeUndirectedNormal(MeshType &m, int nn, float maxDist, KdTree<float> &tree,vcg::CallBackPos * cb=0)$/;"	f	class:vcg::tri::PointCloudNormal
ComputeUniform	vcglib/apps/unsupported/shadevis/visshader.h	/^void ComputeUniform(int nn, std::vector<Point3x> &vv, CallBack *cb)$/;"	f	class:vcg::VisShader
ComputeUniformCone	vcglib/apps/unsupported/shadevis/visshader.h	/^void ComputeUniformCone(int nn, std::vector<Point3x> &vv, ScalarType AngleRad, Point3x &ConeDir, CallBack *cb)$/;"	f	class:vcg::VisShader
ComputeVolume	vcglib/vcg/space/tetra3.h	/^typename TetraType::ScalarType ComputeVolume( const TetraType &  t){$/;"	f	namespace:vcg
ComputeWeightedCovarianceMatrix	vcglib/vcg/space/fitting3.h	/^void ComputeWeightedCovarianceMatrix(const std::vector<Point3<S> > &pointVec, const std::vector<S> &weightVec, Point3<S> &bp, Eigen::Matrix<S,3,3> &m)$/;"	f	namespace:vcg
ComputeZOrder	vcglib/vcg/space/index/octree_template.h	/^	ZOrderType ComputeZOrder(const CoordinateType &query) const { return ZOrder(CenterType::Construct(Interize(query)), maximumDepth); };$/;"	f	class:vcg::OctreeTemplate
ConditionMatrixNested	vcglib/eigenlib/Eigen/src/Core/Select.h	/^  typedef typename ConditionMatrixType::Nested ConditionMatrixNested;$/;"	t	struct:Eigen::internal::traits
Cone	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Cone( MeshType& in,$/;"	f	namespace:vcg::tri
Cone	vcglib/wrap/gl/addons.h	/^		static void Cone(int slices,float lenght,float width,bool useDisplList)$/;"	f	class:vcg::Add_Ons
ConeAngleRad	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^float ConeAngleRad = math::ToRad(180.0f);$/;"	v
ConeResponse	vcglib/vcg/space/colorspace.h	/^	enum ConeResponse	{	BRADFORD = 0,	VON_KRIES = 1, XYZ_SCALING = 2};$/;"	g	class:vcg::ColorSpace
Conj	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Conj = NumTraits<LhsScalar>::IsComplex$/;"	e	enum:Eigen::internal::scalar_conj_product_op::__anon73
ConjLhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
ConjLhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
ConjLhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon200
ConjLhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
ConjRhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
ConjRhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon200
ConjRhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
ConjRhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
Conjugate	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^        Conjugate = ReturnOpposite && NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon47
ConjugateGradient	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient() : Base() {}$/;"	f	class:Eigen::ConjugateGradient
ConjugateGradient	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient(const MatrixType& A) : Base(A) {}$/;"	f	class:Eigen::ConjugateGradient
ConjugateGradient	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^class ConjugateGradient : public IterativeSolverBase<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	c	namespace:Eigen
ConjugateReturnType	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    > ConjugateReturnType;$/;"	t	class:Eigen::HouseholderSequence
ConjugateReturnType	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type ConjugateReturnType;$/;"	t
ConnectedComponentIterator	vcglib/vcg/complex/algorithms/clean.h	/^class ConnectedComponentIterator$/;"	c	namespace:vcg::tri
ConnectedComponents	vcglib/vcg/complex/algorithms/clean.h	/^      static int ConnectedComponents(MeshType &m, std::vector< std::pair<int,FacePointer> > &CCV)$/;"	f	class:vcg::tri::Clean
ConstAffinePart	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^                              const Block<const MatrixType,Dim,HDim> >::type ConstAffinePart;$/;"	t	class:Eigen::Transform
ConstAffinePart	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::ConstAffinePart ConstAffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part
ConstAlignedMapType	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;$/;"	t	class:Eigen::PlainObjectBase
ConstColXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ConstColXpr;$/;"	t
ConstColsBlockXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ConstColsBlockXpr;$/;"	t
ConstColwiseReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;$/;"	t	class:Eigen::DenseBase
ConstDataWrapper	vcglib/vcg/space/index/kdtree/kdtree.h	/^		inline ConstDataWrapper()$/;"	f	class:ConstDataWrapper
ConstDataWrapper	vcglib/vcg/space/index/kdtree/kdtree.h	/^		inline ConstDataWrapper(const DataType* pData, int size, int stride = sizeof(DataType))$/;"	f	class:ConstDataWrapper
ConstDataWrapper	vcglib/vcg/space/index/kdtree/kdtree.h	/^class ConstDataWrapper$/;"	c
ConstDiagonalIndexReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase
ConstDiagonalReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef const Diagonal<const Derived> ConstDiagonalReturnType;$/;"	t	class:Eigen::MatrixBase
ConstEdgeIterator	vcglib/vcg/complex/base.h	/^                                typedef typename EdgeContainer::const_iterator ConstEdgeIterator;$/;"	t	struct:vcg::tri::MeshTypeHolder
ConstEdgeIterator	vcglib/vcg/complex/base.h	/^                typedef typename CONTE::const_iterator	ConstEdgeIterator;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
ConstEdgeIterator	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::ConstEdgeIterator			ConstEdgeIterator;$/;"	t	class:vcg::tri::TriMesh
ConstFaceIterator	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^typedef typename MeshType::ConstFaceIterator ConstFaceIterator;$/;"	t	class:vcg::tri::BitQuadCreation
ConstFaceIterator	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::ConstFaceIterator   ConstFaceIterator;$/;"	t	class:vcg::tri::Clean
ConstFaceIterator	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::ConstFaceIterator   ConstFaceIterator;$/;"	t	class:vcg::tri::ConnectedComponentIterator
ConstFaceIterator	vcglib/vcg/complex/algorithms/inertia.h	/^	typedef typename MeshType::ConstFaceIterator   ConstFaceIterator;$/;"	t	class:vcg::tri::Inertia
ConstFaceIterator	vcglib/vcg/complex/base.h	/^                                typedef typename FaceContainer::const_iterator ConstFaceIterator;$/;"	t	struct:vcg::tri::MeshTypeHolder
ConstFaceIterator	vcglib/vcg/complex/base.h	/^                typedef typename CONTF::const_iterator				ConstFaceIterator;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
ConstFaceIterator	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::ConstFaceIterator			ConstFaceIterator;$/;"	t	class:vcg::tri::TriMesh
ConstFaceIterator	vcglib/wrap/io_trimesh/export_idtf.h	/^typedef typename SaveMeshType::ConstFaceIterator ConstFaceIterator;$/;"	t	class:vcg::tri::io::ExporterIDTF
ConstFacePointer	vcglib/vcg/complex/base.h	/^                                typedef const FaceType * ConstFacePointer;$/;"	t	struct:vcg::tri::MeshTypeHolder
ConstFacePointer	vcglib/vcg/complex/base.h	/^                typedef const typename TYPESPOOL::FacePointer		ConstFacePointer;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
ConstFacePointer	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::ConstFacePointer			ConstFacePointer;$/;"	t	class:vcg::tri::TriMesh
ConstFixedSegmentReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	s	class:Eigen::DenseBase
ConstHEdgeIterator	vcglib/vcg/complex/base.h	/^                                typedef typename HEdgeContainer::const_iterator ConstHEdgeIterator;$/;"	t	struct:vcg::tri::MeshTypeHolder
ConstHEdgeIterator	vcglib/vcg/complex/base.h	/^                typedef typename CONTH::const_iterator	ConstHEdgeIterator;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
ConstHEdgeIterator	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::ConstHEdgeIterator		ConstHEdgeIterator;$/;"	t	class:vcg::tri::TriMesh
ConstIterator	vcglib/wrap/glw/framebuffer.h	/^		typedef Map::const_iterator            ConstIterator;$/;"	t	class:glw::RenderTargetMapping
ConstIterator	vcglib/wrap/glw/framebuffer.h	/^		typedef Map::const_iterator      ConstIterator;$/;"	t	class:glw::RenderTargetBinding
ConstIterator	vcglib/wrap/glw/program.h	/^		typedef Map::const_iterator           ConstIterator;$/;"	t	class:glw::FragmentOutputBinding
ConstIterator	vcglib/wrap/glw/program.h	/^		typedef Map::const_iterator           ConstIterator;$/;"	t	class:glw::VertexAttributeBinding
ConstLinearPart	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,Dim> ConstLinearPart;$/;"	t	class:Eigen::Transform
ConstLinearPart	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,Dim,int(Mode)==(AffineCompact)> ConstLinearPart;$/;"	t	class:Eigen::Transform
ConstMapType	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;$/;"	t	class:Eigen::PlainObjectBase
ConstMatrixType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef const MatrixType ConstMatrixType;$/;"	t	class:Eigen::Transform
ConstNColsBlockXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
ConstNRowsBlockXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
ConstNormalReturnType	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  typedef const Block<const Coefficients,AmbientDimAtCompileTime,1> ConstNormalReturnType;$/;"	t	class:Eigen::Hyperplane
ConstReverseReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;$/;"	t	class:Eigen::DenseBase
ConstRowXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowXpr;$/;"	t
ConstRowsBlockXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowsBlockXpr;$/;"	t
ConstRowwiseReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;$/;"	t	class:Eigen::DenseBase
ConstSegmentReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef const VectorBlock<const Derived> ConstSegmentReturnType;$/;"	t	class:Eigen::DenseBase
ConstSelfAdjointViewReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase
ConstStartMinusOne	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMinusOne;$/;"	t	class:Eigen::MatrixBase
ConstTranslationPart	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,1> ConstTranslationPart;$/;"	t	class:Eigen::Transform
ConstTranslationPart	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,1,int(Mode)==(AffineCompact)> ConstTranslationPart;$/;"	t	class:Eigen::Transform
ConstTransposeReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef const Transpose<const Derived> ConstTransposeReturnType;$/;"	t	class:Eigen::DenseBase
ConstTransposeReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;$/;"	t	class:Eigen::MatrixBase
ConstTriangularViewReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase
ConstVertexIterator	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::ConstVertexIterator ConstVertexIterator;$/;"	t	class:vcg::tri::Clean
ConstVertexIterator	vcglib/vcg/complex/base.h	/^                                typedef typename VertContainer::const_iterator ConstVertexIterator;$/;"	t	struct:vcg::tri::MeshTypeHolder
ConstVertexIterator	vcglib/vcg/complex/base.h	/^                typedef typename CONTV::const_iterator	ConstVertexIterator;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
ConstVertexIterator	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::ConstVertexIterator		ConstVertexIterator;$/;"	t	class:vcg::tri::TriMesh
ConstVertexIterator	vcglib/wrap/io_trimesh/export_idtf.h	/^typedef typename SaveMeshType::ConstVertexIterator ConstVertexIterator;$/;"	t	class:vcg::tri::io::ExporterIDTF
ConstVertexPointer	vcglib/vcg/complex/base.h	/^                                typedef const VertexType * ConstVertexPointer;$/;"	t	struct:vcg::tri::MeshTypeHolder
ConstVertexPointer	vcglib/vcg/complex/base.h	/^                typedef const typename TYPESPOOL::VertexPointer ConstVertexPointer;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
ConstVertexPointer	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::ConstVertexPointer		ConstVertexPointer;$/;"	t	class:vcg::tri::TriMesh
Constant	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index rows, Index cols, const Scalar& value)$/;"	f	class:Eigen::DenseBase
Constant	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index size, const Scalar& value)$/;"	f	class:Eigen::DenseBase
Constant	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(const Scalar& value)$/;"	f	class:Eigen::DenseBase
ConstantReturnType	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::ArrayBase
ConstantReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::DenseBase
ConstantReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::MatrixBase
ConstantReturnType	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Matrix<Scalar,Dynamic,Dynamic> > ConstantReturnType;$/;"	t	class:Eigen::SparseMatrixBase
Constraint	vcglib/vcg/complex/algorithms/harmonic.h	/^	typedef typename std::pair<VertexType *, Scalar> Constraint;$/;"	t	class:vcg::tri::Harmonic
ConstraintIt	vcglib/vcg/complex/algorithms/harmonic.h	/^	typedef typename ConstraintVec::const_iterator   ConstraintIt;$/;"	t	class:vcg::tri::Harmonic
ConstraintVec	vcglib/vcg/complex/algorithms/harmonic.h	/^	typedef typename std::vector<Constraint>         ConstraintVec;$/;"	t	class:vcg::tri::Harmonic
Construct	vcglib/vcg/math/eigen_matrix_addons.h	/^static inline Matrix Construct(const MatrixBase<OtherDerived>& b)$/;"	f
Construct	vcglib/vcg/math/matrix44.h	/^	static inline Matrix44 Construct( const Matrix44<Q> & b )$/;"	f	class:vcg::Matrix44
Construct	vcglib/vcg/math/quaternion.h	/^  static inline Quaternion Construct( const Quaternion<Q> & b )$/;"	f	class:vcg::Quaternion
Construct	vcglib/vcg/space/box.h	/^	static Box Construct( const Box<N0,S0> & b )$/;"	f	class:vcg::Box
Construct	vcglib/vcg/space/box3.h	/^    static inline Box3 Construct( const Box3<Q> & b )$/;"	f	class:vcg::Box3
Construct	vcglib/vcg/space/color4.h	/^  static inline Color4 Construct( const Color4<Q> & b )$/;"	f	class:vcg::Color4
Construct	vcglib/vcg/space/color4.h	/^inline Color4<float> Color4<float>::Construct( const Color4<unsigned char> & b )$/;"	f	class:vcg::Color4
Construct	vcglib/vcg/space/color4.h	/^inline Color4<unsigned char> Color4<unsigned char>::Construct( const Color4<float> & b )$/;"	f	class:vcg::Color4
Construct	vcglib/vcg/space/deprecated_point.h	/^  static inline PointType Construct( const Point<N-1,S2> & b )$/;"	f	class:vcg::ndim::Point
Construct	vcglib/vcg/space/deprecated_point.h	/^  static inline PointType Construct( const Point<N2,S2> & b )$/;"	f	class:vcg::ndim::Point
Construct	vcglib/vcg/space/deprecated_point2.h	/^	static Point2 Construct( const Point2<T> & b )$/;"	f	class:vcg::Point2
Construct	vcglib/vcg/space/deprecated_point3.h	/^  static inline Point3 Construct( const Point3<Q> & b )$/;"	f	class:vcg::Point3
Construct	vcglib/vcg/space/deprecated_point3.h	/^  static inline Point3 Construct( const Point3<ScalarType> & b )$/;"	f	class:vcg::Point3
Construct	vcglib/vcg/space/deprecated_point3.h	/^  static inline Point3 Construct( const Q & P0, const Q & P1, const Q & P2)$/;"	f	class:vcg::Point3
Construct	vcglib/vcg/space/deprecated_point4.h	/^  static inline Point4 Construct( const Point4<Q> & b )$/;"	f	class:vcg::Point4
Construct	vcglib/vcg/space/line2.h	/^	static LineType Construct( const Line2<Q,K> & b )$/;"	f	class:vcg::Line2
Construct	vcglib/vcg/space/line3.h	/^	static LineType Construct( const Line3<Q,K> & b )$/;"	f	class:vcg::Line3
Construct	vcglib/vcg/space/point3.h	/^  static inline Point3 Construct( const Q & P0, const Q & P1, const Q & P2)$/;"	f	class:vcg::Point3
Construct	vcglib/vcg/space/ray2.h	/^	static RayType Construct( const Ray2<Q,K> & b )$/;"	f	class:vcg::Ray2
Construct	vcglib/vcg/space/ray3.h	/^	static RayType Construct( const Ray3<Q,K> & b )$/;"	f	class:vcg::Ray3
Construct	vcglib/vcg/space/segment2.h	/^	static SegmentType Construct( const Segment2<Q> & b )$/;"	f	class:vcg::Segment2
Construct	vcglib/vcg/space/segment3.h	/^	static SegmentType Construct( const Segment3<Q> & b )$/;"	f	class:vcg::Segment3
ConstructHomo	vcglib/vcg/math/eigen_matrix_addons.h	/^static inline Matrix ConstructHomo(const MatrixBase<OtherDerived>& b)$/;"	f
ConstructionApproach	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		enum		ConstructionApproach { FastConstructionApproach=0, CompactConstructionApproach=1 };$/;"	g	class:vcg::PerfectSpatialHashing
ContainedLeaves	vcglib/vcg/space/index/octree_template.h	/^	void ContainedLeaves($/;"	f	class:vcg::OctreeTemplate
ContainedNodes	vcglib/vcg/space/index/octree_template.h	/^	void ContainedNodes$/;"	f	class:vcg::OctreeTemplate
Contains	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    static bool Contains(VertexType *v,vcg::TexCoord2f &coord)$/;"	f	class:vcg::tri::QuadricTexHelper
ContainsData	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 inline bool ContainsData(const typename UniformGrid::CellCoordinate &at) const { return GetFlag(at)==true;}$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
Context	vcglib/wrap/glw/context.h	/^		Context(void)$/;"	f	class:glw::Context
Context	vcglib/wrap/glw/context.h	/^class Context : public detail::NonCopyable$/;"	c	namespace:glw
ContinuityLoopWeight	vcglib/vcg/complex/algorithms/refine_loop.h	/^struct ContinuityLoopWeight {$/;"	s	namespace:vcg::tri
ContributorTag	vcglib/wrap/dae/colladaformat.h	/^		ContributorTag()$/;"	f	class:Collada::Tags::ContributorTag
ContributorTag	vcglib/wrap/dae/colladaformat.h	/^	class ContributorTag : public XMLTag$/;"	c	namespace:Collada::Tags
ControlPointVectorType	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    typedef typename SplineTraits<Spline>::ControlPointVectorType ControlPointVectorType;$/;"	t	class:Eigen::Spline
ControlPointVectorType	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,Dimension,Dynamic> ControlPointVectorType;$/;"	t	struct:Eigen::SplineTraits
Controller	vcglib/wrap/gcache/controller.h	/^  Controller(): paused(false), stopped(true) {}$/;"	f	class:vcg::Controller
Controller	vcglib/wrap/gcache/controller.h	/^class Controller {$/;"	c	namespace:vcg
ConvertCameraToWorldCoordinates	vcglib/vcg/math/shot.h	/^vcg::Point3<S> Shot<S,RotationType>::ConvertCameraToWorldCoordinates(const vcg::Point3<S> & p) const$/;"	f	class:vcg::Shot
ConvertCameraToWorldCoordinates_Substitute	vcglib/vcg/math/shot.h	/^vcg::Point3<S> Shot<S,RotationType>::ConvertCameraToWorldCoordinates_Substitute(const vcg::Point3<S> & p) const$/;"	f	class:vcg::Shot
ConvertDelaunayTriangulationToMesh	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void ConvertDelaunayTriangulationToMesh(MeshType &m,$/;"	f	class:vcg::tri::VoronoiProcessing
ConvertFocalToMM	vcglib/vcg/math/shot.h	/^void Shot<S, RotationType>::ConvertFocalToMM(S ccdwidth)$/;"	f	class:vcg::Shot
ConvertMeshBoundaryToEdgeMesh	vcglib/vcg/complex/algorithms/outline_support.h	/^  static void ConvertMeshBoundaryToEdgeMesh(MeshType &m, MeshType &em)$/;"	f	class:vcg::tri::OutlineUtil
ConvertMeshBoundaryToOutline3Vec	vcglib/vcg/complex/algorithms/outline_support.h	/^  static int ConvertMeshBoundaryToOutline3Vec(MeshType &m, std::vector< std::vector<Point3f> > &outline3Vec)$/;"	f	class:vcg::tri::OutlineUtil
ConvertOutline3VecToEdgeMesh	vcglib/vcg/complex/algorithms/outline_support.h	/^  static bool ConvertOutline3VecToEdgeMesh(std::vector< Point3f> &outline, MeshType &m)$/;"	f	class:vcg::tri::OutlineUtil
ConvertOutline3VecToEdgeMesh	vcglib/vcg/complex/algorithms/outline_support.h	/^  static bool ConvertOutline3VecToEdgeMesh(std::vector< std::vector< Point3f> > &outlineVec, MeshType &m)$/;"	f	class:vcg::tri::OutlineUtil
ConvertOutline3VecToOutline2Vec	vcglib/vcg/complex/algorithms/outline_support.h	/^  static bool ConvertOutline3VecToOutline2Vec(std::vector< std::vector< PointType> > &outline3Vec, std::vector< std::vector< Point2f> > &outline2Vec )$/;"	f	class:vcg::tri::OutlineUtil
ConvertPerVertexSeedToPerFaceSeed	vcglib/vcg/complex/algorithms/geodesic.h	/^  static bool ConvertPerVertexSeedToPerFaceSeed(MeshType &m, const std::vector<VertexPointer> &vertexSeedVec,$/;"	f	class:vcg::tri::Geodesic
ConvertVoronoiDiagramToMesh	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void ConvertVoronoiDiagramToMesh(MeshType &m,$/;"	f	class:vcg::tri::VoronoiProcessing
ConvertWorldToCameraCoordinates	vcglib/vcg/math/shot.h	/^vcg::Point3<S> Shot<S,RotationType>::ConvertWorldToCameraCoordinates(const vcg::Point3<S> & p) const$/;"	f	class:vcg::Shot
Convex	vcglib/vcg/space/intersection2.h	/^	inline bool Convex(const Point2<SCALAR_TYPE> & p0,const Point2<SCALAR_TYPE> & p1,const Point2<SCALAR_TYPE> & p2)$/;"	f	namespace:vcg
Coord	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef typename MESH_TYPE::CoordType Coord;$/;"	t	struct:vcg::tri::Centroid
Coord	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef typename MESH_TYPE::CoordType Coord;$/;"	t	struct:vcg::tri::LS3Projection
Coord	vcglib/vcg/simplex/vertex/component.h	/^template <class A, class T> class Coord: public T {$/;"	c	namespace:vcg::vertex
Coord3DtoUV	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			static UVCoordType Coord3DtoUV(FaceType &f,const CoordType &dir)$/;"	f	class:vcg::tri::UV_Utils
Coord3d	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class Coord3d: public Coord<vcg::Point3d, T> {$/;"	c	namespace:vcg::vertex
Coord3dOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class Coord3dOcc: public CoordOcc<vcg::Point3d, T> {};$/;"	c	namespace:vcg::vertex
Coord3f	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class Coord3f: public Coord<vcg::Point3f, T> {$/;"	c	namespace:vcg::vertex
Coord3fOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class Coord3fOcc: public CoordOcc<vcg::Point3f, T> {};$/;"	c	namespace:vcg::vertex
CoordLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::CoordType				CoordLeft;$/;"	t	class:vcg::tri::Append
CoordNumber	vcglib/wrap/dae/colladaformat.h	/^struct CoordNumber{public:	static unsigned int coord()	{		return 0; 	}};$/;"	s
CoordNumber	vcglib/wrap/dae/colladaformat.h	/^template<> struct CoordNumber<vcg::Color4b> { public:	static unsigned int coord() { return 4;	} };$/;"	s
CoordNumber	vcglib/wrap/dae/colladaformat.h	/^template<> struct CoordNumber<vcg::Point2f> { public:	static unsigned int coord() { return 2;	} };$/;"	s
CoordNumber	vcglib/wrap/dae/colladaformat.h	/^template<> struct CoordNumber<vcg::Point3f> { public:	static unsigned int coord() {	return 3;	} };$/;"	s
CoordNumber	vcglib/wrap/dae/colladaformat.h	/^template<> struct CoordNumber<vcg::Point4f> { public: static unsigned int coord() {	return 4;	} };$/;"	s
CoordOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class A, class T> class CoordOcc: public T {$/;"	c	namespace:vcg::vertex
CoordPointer	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef typename TRIMESH_TYPE::CoordType*			CoordPointer;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
CoordPointer	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef typename TRIMESH_TYPE::CoordType*			CoordPointer;$/;"	t	class:vcg::tri::MarchingCubes
CoordRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::CoordType			CoordRight;$/;"	t	class:vcg::tri::Append
CoordType	vcglib/apps/metro/sampling.h	/^      typedef typename MetroMesh::CoordType				CoordType;$/;"	t	class:vcg::Sampling
CoordType	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^    typedef vcg::Point2<ScalarType> CoordType;$/;"	t	class:MySegmentType	file:
CoordType	vcglib/apps/unsupported/shadevis/visshader.h	/^    typedef typename MESH_TYPE::CoordType CoordType;$/;"	t	class:vcg::VisShader
CoordType	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::FourPCS
CoordType	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::BitQuadCreation
CoordType	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::BitQuadOptimization
CoordType	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::BitQuad
CoordType	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::CoordType   CoordType;$/;"	t	class:vcg::tri::Clean
CoordType	vcglib/vcg/complex/algorithms/clip.h	/^	typedef typename VertexType::CoordType CoordType;$/;"	t	class:vcg::tri::TriMeshClipper
CoordType	vcglib/vcg/complex/algorithms/clip.h	/^    typedef typename VertexType::CoordType CoordType;$/;"	t	class:vcg::tri::GenericVertexInterpolator
CoordType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::AverageColorCell
CoordType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::Clustering
CoordType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::NearestToCenter
CoordType	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef typename TRIMESH_TYPE::CoordType			CoordType;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
CoordType	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef typename TRIMESH_TYPE::CoordType			CoordType;$/;"	t	class:vcg::tri::MarchingCubes
CoordType	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef typename MeshType::CoordType           CoordType;$/;"	t	class:vcg::tri::CylinderClipping
CoordType	vcglib/vcg/complex/algorithms/edge_collapse.h	/^    typedef	typename FaceType::VertexType::CoordType CoordType;$/;"	t	class:vcg::tri::EdgeCollapser
CoordType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::CoordType  CoordType;$/;"	t	class:vcg::tri::Geodesic
CoordType	vcglib/vcg/complex/algorithms/harmonic.h	/^	typedef typename MeshType::CoordType  CoordType;$/;"	t	class:vcg::tri::Harmonic
CoordType	vcglib/vcg/complex/algorithms/hole.h	/^            typedef typename MESH::CoordType				CoordType;$/;"	t	class:vcg::tri::Hole
CoordType	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename MESH::CoordType CoordType;$/;"	t	class:vcg::tri::SelfIntersectionEar
CoordType	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename MESH::CoordType CoordType;$/;"	t	class:vcg::tri::TrivialEar
CoordType	vcglib/vcg/complex/algorithms/inertia.h	/^	typedef typename MeshType::CoordType  CoordType;$/;"	t	class:vcg::tri::Inertia
CoordType	vcglib/vcg/complex/algorithms/inside.h	/^			typedef typename FaceSpatialIndexing::CoordType CoordType;$/;"	t	class:vcg::tri::Inside
CoordType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::QuadDiagonalCollapse
CoordType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::QuadDiagonalCollapseBase
CoordType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::CoordType CoordType;$/;"	t	class:vcg::tri::FeasibilityCheck
CoordType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::CoordType CoordType;$/;"	t	class:vcg::tri::FitmapsCollapse
CoordType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::CoordType CoordType;$/;"	t	class:vcg::tri::OperationWeight
CoordType	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  typedef	typename TetraType::VertexType::CoordType CoordType;$/;"	t	class:vcg::tetra::TetraEdgeCollapse
CoordType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  typedef	typename FaceType::VertexType::CoordType CoordType;$/;"	t	class:vcg::tri::TriEdgeCollapse
CoordType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^		typedef typename TriMeshType::CoordType CoordType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadric
CoordType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef typename TriMeshType::CoordType CoordType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadricTex
CoordType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::CoordType CoordType;$/;"	t	class:vcg::tri::PlanarEdgeFlip
CoordType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::CoordType CoordType;$/;"	t	class:vcg::tri::TopoEdgeFlip
CoordType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::CoordType CoordType;$/;"	t	class:vcg::tri::TriEdgeFlip
CoordType	vcglib/vcg/complex/algorithms/nring.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::Nring
CoordType	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:OverlapEstimation
CoordType	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::Distortion
CoordType	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::PoissonSolver
CoordType	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::CrossField
CoordType	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^		  typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::UV_Utils
CoordType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MeshType::CoordType   CoordType;$/;"	t	class:vcg::tri::MeshSampler
CoordType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MeshType::CoordType  CoordType;$/;"	t	class:vcg::tri::TrivialSampler
CoordType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MetroMesh::CoordType       CoordType;$/;"	t	class:vcg::tri::SurfaceSampling
CoordType	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^  typedef typename MeshType::VertexType::CoordType     CoordType;$/;"	t	class:vcg::tri::PointCloudNormal
CoordType	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  typedef typename PolyMeshType::CoordType      CoordType;$/;"	t	class:vcg::tri::PolychordCollapse
CoordType	vcglib/vcg/complex/algorithms/smooth.h	/^            typedef typename MeshType::VertexType::CoordType     CoordType;$/;"	t	class:vcg::tri::Smooth
CoordType	vcglib/vcg/complex/algorithms/symmetry.h	/^    typedef typename TriMeshType::CoordType CoordType;$/;"	t	class:vcg::tri::ExtrinsicPlaneSymmetry
CoordType	vcglib/vcg/complex/algorithms/update/curvature.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::UpdateCurvature
CoordType	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^	typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
CoordType	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::Fitmaps
CoordType	vcglib/vcg/complex/algorithms/update/normal.h	/^typedef typename MeshType::CoordType     CoordType;$/;"	t	class:vcg::tri::UpdateNormal
CoordType	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::CoordType				CoordType;$/;"	t	class:vcg::tri::VoronoiProcessing
CoordType	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::CoordType     CoordType;$/;"	t	class:vcg::tri::Allocator
CoordType	vcglib/vcg/complex/base.h	/^                                typedef typename VertexType::CoordType CoordType;$/;"	t	struct:vcg::tri::MeshTypeHolder
CoordType	vcglib/vcg/complex/base.h	/^                typedef bool									CoordType;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
CoordType	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::CoordType							CoordType;$/;"	t	class:vcg::tri::TriMesh
CoordType	vcglib/vcg/complex/used_types.h	/^        typedef vcg::Point3<bool> CoordType;$/;"	t	struct:vcg::DummyTypes
CoordType	vcglib/vcg/simplex/edge/pos.h	/^	typedef typename VertexType::CoordType CoordType;$/;"	t	class:vcg::edge::VEIterator
CoordType	vcglib/vcg/simplex/face/component.h	/^  typedef typename T::VertexType::CoordType CoordType;$/;"	t	class:vcg::face::VertexRef
CoordType	vcglib/vcg/simplex/face/component_occ.h	/^  typedef typename T::CoordType CoordType;$/;"	t	class:vcg::face::VertexRefOcc
CoordType	vcglib/vcg/simplex/face/component_polygon.h	/^  typedef typename  T::VertexType::CoordType CoordType;$/;"	t	class:vcg::face::PFVAdj
CoordType	vcglib/vcg/simplex/face/jumping_pos.h	/^			typedef typename	VertexType::CoordType		CoordType;$/;"	t	class:vcg::face::JumpingPos
CoordType	vcglib/vcg/simplex/face/pos.h	/^	typedef typename VertexType::CoordType CoordType;$/;"	t	class:vcg::face::VFIterator
CoordType	vcglib/vcg/simplex/tetrahedron/base.h	/^  typedef typename VertexType::CoordType CoordType;$/;"	t	class:vcg::TetraTypeHolder
CoordType	vcglib/vcg/simplex/tetrahedron/pos.h	/^	typedef	typename TetraType::VertexType::CoordType CoordType;$/;"	t	class:vcg::tetra::Pos
CoordType	vcglib/vcg/simplex/vertex/component.h	/^  typedef A CoordType;$/;"	t	class:vcg::vertex::Coord
CoordType	vcglib/vcg/simplex/vertex/component.h	/^  typedef vcg::Point3f CoordType;$/;"	t	class:vcg::vertex::EmptyCore
CoordType	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef A CoordType;$/;"	t	class:vcg::vertex::CoordOcc
CoordType	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	typedef Point3<ScalarType> CoordType;$/;"	t	class:vcg::AABBBinaryTreeIndex
CoordType	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		typedef Point3<ScalarType> CoordType;$/;"	t	class:vcg::AABBBinaryTree
CoordType	vcglib/vcg/space/index/aabb_binary_tree/closest.h	/^	typedef typename TreeType::CoordType CoordType;$/;"	t	class:vcg::AABBBinaryTreeClosest
CoordType	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	typedef typename TreeType::CoordType CoordType;$/;"	t	class:vcg::AABBBinaryTreeFrustumCull
CoordType	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^	typedef typename TreeType::CoordType CoordType;$/;"	t	class:vcg::AABBBinaryTreeKClosest
CoordType	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^	typedef typename TreeType::CoordType CoordType;$/;"	t	class:vcg::AABBBinaryTreeRay
CoordType	vcglib/vcg/space/index/base.h	/^	typedef Point3<ScalarType> CoordType;$/;"	t	class:vcg::SpatialIndex
CoordType	vcglib/vcg/space/index/grid_static_ptr.h	/^		typedef Point3<ScalarType> CoordType;$/;"	t	class:vcg::GridStaticPtr
CoordType	vcglib/vcg/space/index/grid_util.h	/^	typedef Point3<ScalarType> CoordType;$/;"	t	class:vcg::BasicGrid
CoordType	vcglib/vcg/space/index/index2D/base_2d.h	/^	typedef Point2<ScalarType> CoordType;$/;"	t	class:vcg::SpatialIndex2D
CoordType	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		typedef Point2<ScalarType> CoordType;$/;"	t	class:vcg::BasicGrid2D
CoordType	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        typedef Point2<ScalarType> CoordType;$/;"	t	class:vcg::SpatialHashTable2D
CoordType	vcglib/vcg/space/index/octree.h	/^        typedef typename TemplatedOctree::CoordinateType			CoordType;$/;"	t	class:vcg::Octree
CoordType	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename vcg::Point3<ScalarType>  CoordType;$/;"	t	class:vcg::ClosestIterator
CoordType	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename vcg::Point3<ScalarType>  CoordType;$/;"	t	class:vcg::RayIterator
CoordType	vcglib/vcg/space/index/spatial_hashing.h	/^		typedef typename SpatialHashTable<ContainerType,FLT>::CoordType CoordType;$/;"	t	class:vcg::DynamicSpatialHashTable
CoordType	vcglib/vcg/space/index/spatial_hashing.h	/^	typedef Point3<ScalarType> CoordType;$/;"	t	class:vcg::SpatialHashTable
CoordType	vcglib/vcg/space/tetra3.h	/^  typedef  Point3< ScalarType > CoordType;$/;"	t	class:vcg::Tetra3
CoordType	vcglib/vcg/space/triangle2.h	/^  typedef Point2< ScalarType > CoordType;$/;"	t	class:vcg::Triangle2
CoordType	vcglib/vcg/space/triangle3.h	/^	typedef Point3< ScalarType > CoordType;$/;"	t	class:vcg::Triangle3
CoordType	vcglib/wrap/gl/gl_field.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::GLField
CoordType	vcglib/wrap/io_trimesh/export_fbx.h	/^	typedef typename SaveMeshType::CoordType CoordType;$/;"	t	class:ExporterFBX
CoordType	vcglib/wrap/io_trimesh/export_field.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::io::ExporterFIELD
CoordType	vcglib/wrap/io_trimesh/export_idtf.h	/^typedef typename SaveMeshType::CoordType CoordType;$/;"	t	class:vcg::tri::io::ExporterIDTF
CoordType	vcglib/wrap/io_trimesh/export_obj.h	/^  typedef typename SaveMeshType::CoordType CoordType;$/;"	t	class:vcg::tri::io::ExporterOBJ
CoordType	vcglib/wrap/io_trimesh/import_fbx.h	/^	typedef typename OpenMeshType::CoordType CoordType;$/;"	t	class:ImporterFBX
CoordType	vcglib/wrap/io_trimesh/import_field.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:vcg::tri::io::ImporterFIELD
CoordType	vcglib/wrap/io_trimesh/import_gts.h	/^				typedef typename MESH_TYPE::CoordType				CoordType;$/;"	t	class:vcg::tri::io::ImporterGTS
CoordType	vcglib/wrap/io_trimesh/import_obj.h	/^                typedef typename OpenMeshType::CoordType CoordType;$/;"	t	class:vcg::tri::io::ImporterOBJ
CoordType	vcglib/wrap/io_trimesh/import_off.h	/^  typedef typename MESH_TYPE::CoordType				CoordType;$/;"	t	class:vcg::tri::io::ImporterOFF
CoordType	vcglib/wrap/miq/core/poisson_solver.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:PoissonSolver
CoordType	vcglib/wrap/miq/core/seams_initializer.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:SeamsInitializer
CoordType	vcglib/wrap/miq/core/stiffening.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:StiffeningInitializer
CoordType	vcglib/wrap/miq/core/vertex_indexing.h	/^    typedef typename MeshType::CoordType CoordType;$/;"	t	class:VertexIndexing
CoordType	vcglib/wrap/miq/quadrangulator.h	/^        typedef typename MESH_TYPE::CoordType CoordType;$/;"	t	struct:Quadrangulator::SplitMidPoint
CoordType	vcglib/wrap/miq/quadrangulator.h	/^    typedef typename TriMesh::CoordType CoordType;$/;"	t	class:Quadrangulator
CoordType	vcglib/wrap/opensg/vertex_component.h	/^	typedef A CoordType;															\/\/\/ Must be a OSG::Pnt3 type as : OSG::Pnt3s, OSG:Pnt3f, OSG::Pnt3d etc...$/;"	t	class:vcg::vert::OSGCoord
CoordType	vcglib/wrap/opensg/vertex_component.h	/^	typedef OSG::Pnt3f CoordType;$/;"	t	class:vcg::vert::EmptyOSGCoord
CoordType	vcglib/wrap/opensg/vertex_component.h	/^	typedef T CoordType;$/;"	t	class:vcg::vert::OSGCoordCore
CoordinateFrame	vcglib/wrap/gui/coordinateframe.cpp	/^CoordinateFrame::CoordinateFrame(float s)$/;"	f	class:CoordinateFrame
CoordinateFrame	vcglib/wrap/gui/coordinateframe.h	/^class CoordinateFrame$/;"	c	namespace:vcg
CoordinateType	vcglib/vcg/space/index/octree_template.h	/^	typedef vcg::Point3<ScalarType>	CoordinateType;$/;"	t	class:vcg::OctreeTemplate
CoordinateType	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		typedef typename	vcg::Point3< ScalarType >						CoordinateType;$/;"	t	class:vcg::PerfectSpatialHashing
CoplanarAngleThresholdDeg	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  float CoplanarAngleThresholdDeg;$/;"	m	class:vcg::tri::PlanarEdgeFlipParameter
CopyCDStringToClient	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void TW_CALL CopyCDStringToClient(char **destPtr, const char *src)$/;"	f
CopyCDStringToClient	vcglib/wrap/qt/anttweakbarMapper.cpp	/^void TW_CALL CopyCDStringToClient(char **destPtr, const char *src)$/;"	f
CopyCDStringToClient	vcglib/wrap/qt/anttweakbarMapperNew.cpp	/^void TW_CALL CopyCDStringToClient(char **destPtr, const char *src)$/;"	f
CopyQueryResults	vcglib/vcg/space/index/octree.h	/^        inline int CopyQueryResults$/;"	f	class:vcg::Octree
CopyStdStringToClient	vcglib/wrap/qt/anttweakbarMapper.cpp	/^void TW_CALL CopyStdStringToClient(std::string& destClientString, const std::string& srcLibraryString)$/;"	f
CopyStdStringToClient	vcglib/wrap/qt/anttweakbarMapperNew.cpp	/^void TW_CALL CopyStdStringToClient(std::string& destClientString, const std::string& srcLibraryString)$/;"	f
CopyTopology	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static void CopyTopology(FaceType *fnew, FaceType * fold)$/;"	f	class:vcg::tri::BitQuadCreation
CopyVertex	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^inline void CopyVertex(const DstMesh & m, const DstVertex & vSrc, DstVertex & vDst)$/;"	f
CoreType	vcglib/wrap/opensg/vertex_component.h	/^	typedef typename OSGColorCore< ColorType > CoreType;$/;"	t	class:vcg::vert::OSGColor
CoreType	vcglib/wrap/opensg/vertex_component.h	/^	typedef typename OSGCoordCore< CoordType > CoreType;$/;"	t	class:vcg::vert::OSGCoord
CoreType	vcglib/wrap/opensg/vertex_component.h	/^	typedef typename OSGNormalCore< NormalType > CoreType;$/;"	t	class:vcg::vert::OSGNormal
CornerType	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	g	namespace:Eigen
CornerType	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  enum CornerType$/;"	g	class:Eigen::AlignedBox
CorrVec	vcglib/wrap/io_trimesh/import_nvm.h	/^        typedef std::vector<Correspondence> CorrVec;$/;"	t	namespace:vcg::tri::io
CorrVec	vcglib/wrap/io_trimesh/import_out.h	/^        typedef std::vector<Correspondence> CorrVec;$/;"	t	namespace:vcg::tri::io
Correspondence	vcglib/wrap/io_trimesh/import_out.h	/^                Correspondence(unsigned int id_img_,unsigned int key_,float x_,float y_):id_img(id_img_),key(key_),x(x_),y(y_){}$/;"	f	struct:vcg::tri::io::Correspondence
Correspondence	vcglib/wrap/io_trimesh/import_out.h	/^  struct Correspondence{$/;"	s	namespace:vcg::tri::io
Cos	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static ScalarType Cos(const CoordType &a, const CoordType &b, const CoordType &c )$/;"	f	class:vcg::tri::BitQuad
Cos	vcglib/vcg/math/base.h	/^  inline double Cos(const double v)   { return cos(v); }$/;"	f	namespace:vcg::math
Cos	vcglib/vcg/math/base.h	/^  inline float Cos(const float v)   { return cosf(v); }$/;"	f	namespace:vcg::math
CosWedge	vcglib/vcg/space/triangle3.h	/^typename TriangleType::ScalarType CosWedge(const TriangleType &t, int k)$/;"	f	namespace:vcg
CosineThr	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  double    CosineThr;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
CosineThr	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  double  CosineThr;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
CosinusTooSmall	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        CosinusTooSmall = 4,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)\/2, \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon72
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = 2 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon80
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon106
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon107
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon108
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon109
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon110
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon111
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<LhsScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon74
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon70
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon75
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon76
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon79
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon83
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon84
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,$/;"	e	enum:Eigen::internal::functor_traits::__anon86
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon81
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon82
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon78
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon77
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon134
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon135
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon136
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon137
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon88
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon89
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon90
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon91
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon132
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon133
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon121
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon122
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon123
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon124
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon125
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon126
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon127
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon128
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon129
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon99
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon97
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon96
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon115
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon112
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon92
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon93
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon95
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon98
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon105
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon85
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon113
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon114
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon94
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon118
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon119
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon120
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon116
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon117
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon139
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon138
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon130
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon131
Cost	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon87
Cost	vcglib/eigenlib/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon222
Cost	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    Cost = (  Derived::SizeAtCompileTime == Dynamic$/;"	e	enum:Eigen::internal::redux_traits::__anon226
Cost	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  template<typename _Scalar, int Size> struct Cost$/;"	s	struct:Eigen::internal::member_redux
Cost	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon327
Cost	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon328
CostOpType	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,TraversalSize> CostOpType;$/;"	t	struct:Eigen::internal::traits
CostOpType	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;$/;"	t	struct:Eigen::internal::traits
CotangentWeight	vcglib/vcg/complex/algorithms/harmonic.h	/^	static ScalarT CotangentWeight(const FaceType &f, int edge)$/;"	f	class:vcg::tri::Harmonic
CotangentWeightIfNotVisited	vcglib/vcg/complex/algorithms/harmonic.h	/^	static WeightInfo CotangentWeightIfNotVisited(const FaceType &f, int edge, ScalarT & weight)$/;"	f	class:vcg::tri::Harmonic
CountBitLargePolygons	vcglib/vcg/complex/algorithms/clean.h	/^  static int CountBitLargePolygons(MeshType &m)$/;"	f	class:vcg::tri::Clean
CountBitPolygonInternalValency	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static int CountBitPolygonInternalValency(const FaceType& f, int wedge){$/;"	f	class:vcg::tri::BitQuad
CountBitPolygons	vcglib/vcg/complex/algorithms/clean.h	/^  static int CountBitPolygons(const MeshType &m)$/;"	f	class:vcg::tri::Clean
CountBitQuads	vcglib/vcg/complex/algorithms/clean.h	/^  static int CountBitQuads(const MeshType &m)$/;"	f	class:vcg::tri::Clean
CountBitTris	vcglib/vcg/complex/algorithms/clean.h	/^  static int CountBitTris(const MeshType &m)$/;"	f	class:vcg::tri::Clean
CountConnectedComponents	vcglib/vcg/complex/algorithms/clean.h	/^      static int CountConnectedComponents(MeshType &m)$/;"	f	class:vcg::tri::Clean
CountEdges	vcglib/vcg/complex/algorithms/clean.h	/^      static void CountEdges( MeshType & m, int &count_e, int &boundary_e )$/;"	f	class:vcg::tri::Clean
CountHoles	vcglib/vcg/complex/algorithms/clean.h	/^  static int CountHoles( MeshType & m)$/;"	f	class:vcg::tri::Clean
CountInSphere	vcglib/vcg/space/index/spatial_hashing.h	/^        int CountInSphere(const Point3<ScalarType> &p, const ScalarType radius, std::vector<HashIterator> &inSphVec)$/;"	f	class:vcg::SpatialHashTable
CountNonManifoldEdgeEE	vcglib/vcg/complex/algorithms/clean.h	/^  static int CountNonManifoldEdgeEE( MeshType & m, bool SelectFlag=false)$/;"	f	class:vcg::tri::Clean
CountNonManifoldEdgeFF	vcglib/vcg/complex/algorithms/clean.h	/^      static int CountNonManifoldEdgeFF( MeshType & m, bool SelectFlag=false)$/;"	f	class:vcg::tri::Clean
CountNonManifoldVertexFF	vcglib/vcg/complex/algorithms/clean.h	/^      static int CountNonManifoldVertexFF( MeshType & m, bool selectVert = true )$/;"	f	class:vcg::tri::Clean
CountPointSet	vcglib/vcg/complex/algorithms/clustering.h	/^  int CountPointSet() {return GridCell.size(); }$/;"	f	class:vcg::tri::Clustering
CountSharedVertex	vcglib/vcg/simplex/face/topology.h	/^int CountSharedVertex(FaceType *f0,FaceType *f1)$/;"	f	namespace:vcg::face
CountUnreferencedVertex	vcglib/vcg/complex/algorithms/clean.h	/^            static int CountUnreferencedVertex( MeshType& m)$/;"	f	class:vcg::tri::Clean
CounterDiag	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static CoordType CounterDiag(const FaceType* f){$/;"	f	class:vcg::tri::BitQuad
Couple	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    Couple(const int & i, const int & j, float d):std::pair<int,int>(i,j),dist(d){}$/;"	f	struct:vcg::tri::FourPCS::Couple
Couple	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    Couple(float d):std::pair<int,int>(0,0),dist(d){}$/;"	f	struct:vcg::tri::FourPCS::Couple
Couple	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  struct Couple: public std::pair<int,int>$/;"	s	class:vcg::tri::FourPCS
Covariance	vcglib/vcg/complex/algorithms/inertia.h	/^static void Covariance(const MeshType & m, vcg::Point3<ScalarType> & bary, vcg::Matrix33<ScalarType> &C)$/;"	f	class:vcg::tri::Inertia
Covariance	vcglib/vcg/math/matrix33.h	/^void Covariance(const STLPOINTCONTAINER &points, Point3<S> &bp) {$/;"	f	class:vcg::Matrix33
CreaseCut	vcglib/vcg/complex/algorithms/crease_cut.h	/^void CreaseCut(MESH_TYPE &m, float angleRad)$/;"	f	namespace:vcg::tri
Create	vcglib/apps/unsupported/shadevis/simplepic.h	/^   void Create(int tx,int ty)$/;"	f	class:vcg::SimplePic
Create	vcglib/vcg/space/index/grid_static_obj.h	/^	void Create( const Point3i &_siz, const ObjType & init )$/;"	f	class:vcg::GridStaticObj
Create	vcglib/vcg/space/index/grid_static_obj.h	/^	void Create(const Box3<FLT2> & b, int ncell, const ObjType & init, bool Inflate = true )$/;"	f	class:vcg::GridStaticObj
Create	vcglib/wrap/bmt/bmt.cpp	/^bool BmtBuilder::Create(unsigned int sign) {$/;"	f	class:BmtBuilder
CreateFromBox	vcglib/vcg/space/sphere3.h	/^ template <class T> int Sphere3<T>::CreateFromBox(int n,  const Point3<T> *points) {$/;"	f	class:vcg::Sphere3
CreateLoops	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  void CreateLoops()$/;"	f	class:vcg::tri::AdvancingFront
CreateMesh	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^static void CreateMesh(void) {$/;"	f	file:
CreateNewMaterial	vcglib/wrap/io_trimesh/io_material.h	/^		inline static int CreateNewMaterial(SaveMeshType &m, std::vector<Material> &materials, unsigned int index, FaceIterator &fi)$/;"	f	class:vcg::tri::io::Materials
CreateSparse	vcglib/wrap/math/sparse_matrix.h	/^virtual void CreateSparse(std::vector<IndexType> Entries)$/;"	f	class:SparseMatrix
CreateSparse	vcglib/wrap/math/system_interface_ldl.h	/^void CreateSparse(std::vector<IndexType> Entries)$/;"	f	class:SystemLDL
CreateTight	vcglib/vcg/space/sphere3.h	/^ template <class T> int Sphere3<T>::CreateTight(int n, const Point3<T> *points, $/;"	f	class:vcg::Sphere3
CreateTight	vcglib/vcg/space/sphere3.h	/^template <class T> int Sphere3<T>::CreateTight(const std::vector<Point3<T> > & points,$/;"	f	class:vcg::Sphere3
CreatedTag	vcglib/wrap/dae/colladaformat.h	/^		CreatedTag()$/;"	f	class:Collada::Tags::CreatedTag
CreatedTag	vcglib/wrap/dae/colladaformat.h	/^	class CreatedTag : public XMLLeafTag\/\/added$/;"	c	namespace:Collada::Tags
Cross	vcglib/vcg/space/planar_polygon_tessellation.h	/^	bool Cross(	 const Point2<ScalarType> & p00,$/;"	f	namespace:vcg
CrossCovariance	vcglib/vcg/math/matrix33.h	/^void CrossCovariance(const STLPOINTCONTAINER &P, const STLPOINTCONTAINER &X,$/;"	f	class:vcg::Matrix33
CrossCovariance	vcglib/vcg/math/old_matrix33.h	/^	void CrossCovariance(const STLPOINTCONTAINER &P, const STLPOINTCONTAINER &X,$/;"	f	class:vcg::Matrix33
CrossField	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^		class CrossField$/;"	c	namespace:vcg::tri
CrossPoint	vcglib/vcg/complex/algorithms/clip.h	/^	static inline void CrossPoint(int mode, const ScalarType & value, const CoordType & SP, const CoordType & PP, CoordType & p_out)$/;"	f	class:vcg::tri::TriMeshClipper
CrossProdGradient	vcglib/vcg/complex/algorithms/smooth.h	/^static CoordType CrossProdGradient(CoordType &p, CoordType &p0, CoordType &p1, CoordType &m)$/;"	f	class:vcg::tri::Smooth
CrossReturnType	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::PlainObject CrossReturnType;$/;"	t	class:Eigen::VectorwiseOp
CrossToUV	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static vcg::Point2<ScalarType> CrossToUV(FaceType &f)$/;"	f	class:vcg::tri::CrossField
CrossType	vcglib/wrap/ply/plylib.cpp	/^static char CrossType[9][9]=$/;"	m	namespace:vcg::ply	file:
CrossVector	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static CoordType CrossVector(const FaceType &f,$/;"	f	class:vcg::tri::CrossField
CrossVector	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static CoordType CrossVector(const VertexType &v,$/;"	f	class:vcg::tri::CrossField
CrossVector	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static void CrossVector(const CoordType &dir0,$/;"	f	class:vcg::tri::CrossField
CrossVector	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static void CrossVector(const FaceType &f,$/;"	f	class:vcg::tri::CrossField
CrossVector	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static void CrossVector(const VertexType &v,$/;"	f	class:vcg::tri::CrossField
CuDV	vcglib/vcg/simplex/vertex/component_ocf.h	/^  std::vector<typename VALUE_TYPE::CurvatureDirType> CuDV;$/;"	m	class:vcg::vertex::vector_ocf
CuV	vcglib/vcg/simplex/vertex/component_ocf.h	/^  std::vector<typename VALUE_TYPE::CurvatureType> CuV;$/;"	m	class:vcg::vertex::vector_ocf
CullFlag	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^bool CullFlag=false;$/;"	v
CullFlag	vcglib/apps/unsupported/shadevis/visshader.h	/^	 bool CullFlag;   \/\/ Enable the frustum culling. Useful when the splitting value is larger than 2 $/;"	m	class:vcg::VisShader
Curr	vcglib/vcg/container/container_allocation_table.h	/^static typename std::list<ENTRY_TYPE>::iterator	 & Curr(){		\/\/ container that was last accessed$/;"	f	class:vcg::CATEntry
CurrentCell	vcglib/vcg/space/index/space_iterators.h	/^		vcg::Point3i CurrentCell;						\/\/current cell$/;"	m	class:vcg::RayIterator
CurrentElem	vcglib/vcg/space/index/space_iterators.h	/^		ElemIterator CurrentElem;	\/\/iterator to current element$/;"	m	class:vcg::ClosestIterator
CurrentElem	vcglib/vcg/space/index/space_iterators.h	/^		ElemIterator CurrentElem;	\/\/iterator to current element$/;"	m	class:vcg::RayIterator
CurrentSlice	vcglib/vcg/complex/algorithms/create/resampler.h	/^		int	CurrentSlice;$/;"	m	class:vcg::tri::Resampler::Walker
Curvature	vcglib/vcg/simplex/vertex/component.h	/^  template <class A, class TT> class Curvature: public TT {$/;"	c	namespace:vcg::vertex
CurvatureDir	vcglib/vcg/simplex/face/component.h	/^template <class A, class TT> class CurvatureDir: public TT {$/;"	c	namespace:vcg::face
CurvatureDir	vcglib/vcg/simplex/vertex/component.h	/^template <class A, class TT> class CurvatureDir: public TT {$/;"	c	namespace:vcg::vertex
CurvatureDirBaseType	vcglib/vcg/simplex/face/component.h	/^        CurvatureDirBaseType () {}$/;"	f	struct:vcg::face::CurvatureDirBaseType
CurvatureDirBaseType	vcglib/vcg/simplex/face/component.h	/^struct CurvatureDirBaseType{$/;"	s	namespace:vcg::face
CurvatureDirBaseType	vcglib/vcg/simplex/vertex/component.h	/^          CurvatureDirBaseType () {}$/;"	f	struct:vcg::vertex::CurvatureDirBaseType
CurvatureDirBaseType	vcglib/vcg/simplex/vertex/component.h	/^  struct CurvatureDirBaseType{$/;"	s	namespace:vcg::vertex
CurvatureDirEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  bool CurvatureDirEnabled;$/;"	m	class:vcg::face::vector_ocf
CurvatureDirEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  bool CurvatureDirEnabled;$/;"	m	class:vcg::vertex::vector_ocf
CurvatureDirOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class A, class TT> class CurvatureDirOcc: public TT {$/;"	c	namespace:vcg::vertex
CurvatureDirOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class A, class T> class CurvatureDirOcf: public T {$/;"	c	namespace:vcg::face
CurvatureDirOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class A, class TT> class CurvatureDirOcf: public TT {$/;"	c	namespace:vcg::vertex
CurvatureDirOcfBaseType	vcglib/vcg/simplex/face/component_ocf.h	/^        CurvatureDirOcfBaseType () {}$/;"	f	struct:vcg::face::CurvatureDirOcfBaseType
CurvatureDirOcfBaseType	vcglib/vcg/simplex/face/component_ocf.h	/^struct CurvatureDirOcfBaseType{$/;"	s	namespace:vcg::face
CurvatureDirType	vcglib/vcg/simplex/face/component.h	/^  typedef A CurvatureDirType;$/;"	t	class:vcg::face::CurvatureDir
CurvatureDirType	vcglib/vcg/simplex/face/component.h	/^  typedef int CurvatureDirType;$/;"	t	class:vcg::face::EmptyCore
CurvatureDirType	vcglib/vcg/simplex/face/component_ocf.h	/^  typedef A CurvatureDirType;$/;"	t	class:vcg::face::CurvatureDirOcf
CurvatureDirType	vcglib/vcg/simplex/vertex/component.h	/^  typedef A CurvatureDirType;$/;"	t	class:vcg::vertex::CurvatureDir
CurvatureDirType	vcglib/vcg/simplex/vertex/component.h	/^  typedef CurvatureDirBaseType<float> CurvatureDirType;$/;"	t	class:vcg::vertex::EmptyCore
CurvatureDirType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef A CurvatureDirType;$/;"	t	class:vcg::vertex::CurvatureDirOcf
CurvatureDirTypeOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^	CurvatureDirTypeOcc () {}$/;"	f	struct:vcg::vertex::CurvatureDirTypeOcc
CurvatureDirTypeOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef A CurvatureDirTypeOcc;$/;"	t	class:vcg::vertex::CurvatureDirOcc
CurvatureDirTypeOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^struct CurvatureDirTypeOcc{$/;"	s	namespace:vcg::vertex
CurvatureDirTypeOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^	CurvatureDirTypeOcf () {}$/;"	f	struct:vcg::vertex::CurvatureDirTypeOcf
CurvatureDirTypeOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^struct CurvatureDirTypeOcf{$/;"	s	namespace:vcg::vertex
CurvatureDird	vcglib/vcg/simplex/face/component.h	/^template <class T> class CurvatureDird: public CurvatureDir<CurvatureDirBaseType<double>, T> {$/;"	c	namespace:vcg::face
CurvatureDird	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class CurvatureDird: public CurvatureDir<CurvatureDirBaseType<double>, T> {$/;"	c	namespace:vcg::vertex
CurvatureDirdOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class CurvatureDirdOcc: public CurvatureDirOcc<CurvatureDirTypeOcc<double>, T> {$/;"	c	namespace:vcg::vertex
CurvatureDirdOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class CurvatureDirdOcf: public CurvatureDirOcf<CurvatureDirOcfBaseType<double>, T> {$/;"	c	namespace:vcg::face
CurvatureDirdOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class CurvatureDirdOcf: public CurvatureDirOcf<CurvatureDirTypeOcf<double>, T> {$/;"	c	namespace:vcg::vertex
CurvatureDirf	vcglib/vcg/simplex/face/component.h	/^template <class T> class CurvatureDirf: public CurvatureDir<CurvatureDirBaseType<float>, T> {$/;"	c	namespace:vcg::face
CurvatureDirf	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class CurvatureDirf: public CurvatureDir<CurvatureDirBaseType<float>, T> {$/;"	c	namespace:vcg::vertex
CurvatureDirfOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class CurvatureDirfOcc: public CurvatureDirOcc<CurvatureDirTypeOcc<float>, T> {$/;"	c	namespace:vcg::vertex
CurvatureDirfOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class CurvatureDirfOcf: public CurvatureDirOcf<CurvatureDirOcfBaseType<float>, T> {$/;"	c	namespace:vcg::face
CurvatureDirfOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class CurvatureDirfOcf: public CurvatureDirOcf<CurvatureDirTypeOcf<float>, T> {$/;"	c	namespace:vcg::vertex
CurvatureEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  bool CurvatureEnabled;$/;"	m	class:vcg::vertex::vector_ocf
CurvatureOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class A, class TT> class CurvatureOcc: public TT {$/;"	c	namespace:vcg::vertex
CurvatureOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class A, class TT> class CurvatureOcf: public TT {$/;"	c	namespace:vcg::vertex
CurvatureType	vcglib/vcg/simplex/vertex/component.h	/^    typedef Point2<A> CurvatureType;$/;"	t	class:vcg::vertex::Curvature
CurvatureType	vcglib/vcg/simplex/vertex/component.h	/^  typedef Point2f CurvatureType;$/;"	t	class:vcg::vertex::EmptyCore
CurvatureType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef Point2<A> CurvatureType;$/;"	t	class:vcg::vertex::CurvatureOcf
CurvatureTypeOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef Point2<A> CurvatureTypeOcc;$/;"	t	class:vcg::vertex::CurvatureOcc
Curvatured	vcglib/vcg/simplex/vertex/component.h	/^  template <class T> class Curvatured: public Curvature<double , T> {$/;"	c	namespace:vcg::vertex
CurvaturedOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class CurvaturedOcc: public CurvatureOcc<double, T> {$/;"	c	namespace:vcg::vertex
CurvaturedOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class CurvaturedOcf: public CurvatureOcf<double, T> {public: static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvaturedOcf"));T::Name(name);} };$/;"	c	namespace:vcg::vertex
Curvaturef	vcglib/vcg/simplex/vertex/component.h	/^  template <class T> class Curvaturef: public Curvature< float, T> {$/;"	c	namespace:vcg::vertex
CurvaturefOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class CurvaturefOcc: public CurvatureOcc<float, T> {$/;"	c	namespace:vcg::vertex
CurvaturefOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class CurvaturefOcf: public CurvatureOcf<float, T> {public: static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvaturefOcf"));T::Name(name);} };$/;"	c	namespace:vcg::vertex
Cwise	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^    inline Cwise(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Cwise
Cwise	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^template<typename ExpressionType> class Cwise$/;"	c	namespace:Eigen
CwiseBinaryOp	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE CwiseBinaryOp(const Lhs& lhs, const Rhs& rhs, const BinaryOp& func = BinaryOp())$/;"	f	class:Eigen::CwiseBinaryOp
CwiseBinaryOp	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen
CwiseBinaryOpImpl	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Dense>$/;"	c	namespace:Eigen
CwiseBinaryOpImpl	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CwiseBinaryOpImpl()$/;"	f	class:Eigen::CwiseBinaryOpImpl
CwiseBinaryOpImpl	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Sparse>$/;"	c	namespace:Eigen
CwiseBinaryXpr	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryFunc, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
CwiseBinaryXpr	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
CwiseNullaryOp	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    CwiseNullaryOp(Index rows, Index cols, const NullaryOp& func = NullaryOp())$/;"	f	class:Eigen::CwiseNullaryOp
CwiseNullaryOp	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^class CwiseNullaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen
CwiseUnaryOp	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    inline CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())$/;"	f	class:Eigen::CwiseUnaryOp
CwiseUnaryOp	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen
CwiseUnaryOpImpl	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,XprType,Dense>$/;"	c	namespace:Eigen
CwiseUnaryOpImpl	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>$/;"	c	namespace:Eigen
CwiseUnaryView	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    inline CwiseUnaryView(const MatrixType& mat, const ViewOp& func = ViewOp())$/;"	f	class:Eigen::CwiseUnaryView
CwiseUnaryView	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryView : internal::no_assignment_operator,$/;"	c	namespace:Eigen
CwiseUnaryViewImpl	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Dense>$/;"	c	namespace:Eigen
CwiseUnaryViewImpl	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>$/;"	c	namespace:Eigen
Cyan	vcglib/vcg/space/color4.h	/^	  Cyan    = 0xffffff00,$/;"	e	enum:vcg::Color4::ColorConstant
CylMidPoint	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    CylMidPoint() {assert(0);}$/;"	f	class:vcg::tri::CylinderClipping::CylMidPoint
CylMidPoint	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    CylMidPoint(CylPred &ep) : newPtMap(&(ep.newPtMap)) {$/;"	f	class:vcg::tri::CylinderClipping::CylMidPoint
CylMidPoint	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  class CylMidPoint : public   std::unary_function<PosType, CoordType>$/;"	c	class:vcg::tri::CylinderClipping
CylPred	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    CylPred(CoordType &_origin, CoordType &_end, ScalarType _radius, ScalarType _maxDist, ScalarType _minEdgeLen):$/;"	f	class:vcg::tri::CylinderClipping::CylPred
CylPred	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  class CylPred$/;"	c	class:vcg::tri::CylinderClipping
Cylinder	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Cylinder(int slices, int stacks, MeshType & m)$/;"	f	namespace:vcg::tri
Cylinder	vcglib/wrap/gl/addons.h	/^		static void Cylinder(int slices,float lenght,float width,bool useDisplList)$/;"	f	class:vcg::Add_Ons
CylinderClipping	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^class CylinderClipping$/;"	c	namespace:vcg::tri
CylinderMode	vcglib/wrap/gui/trackmode.h	/^  CylinderMode (Line3fN & ln,float s=0.0f)$/;"	f	class:vcg::CylinderMode
CylinderMode	vcglib/wrap/gui/trackmode.h	/^  CylinderMode (const Point3f & origin, const Point3f & direction,float s=0.0f)$/;"	f	class:vcg::CylinderMode
CylinderMode	vcglib/wrap/gui/trackmode.h	/^class CylinderMode:public TrackMode {$/;"	c	namespace:vcg
D	vcglib/wrap/gl/tetramesh.h	/^			Point3x D;$/;"	m	class:vcg::tetra::GlTetramesh::ClipPlane
D	vcglib/wrap/math/system_interface_ldl.h	/^	std::vector<double> Lx,D,Y ;$/;"	m	class:SystemLDL
D0	vcglib/wrap/gl/tetramesh.h	/^			Point3x D0;$/;"	m	class:vcg::tetra::GlTetramesh::ClipPlane
D1	vcglib/vcg/complex/algorithms/geodesic.h	/^  Point3f D1(VertexType &v) { return v.PD1(); }$/;"	f	struct:vcg::tri::BasicCrossFunctor
D2	vcglib/vcg/complex/algorithms/geodesic.h	/^  Point3f D2(VertexType &v) { return v.PD1(); }$/;"	f	struct:vcg::tri::BasicCrossFunctor
DAEError	vcglib/wrap/dae/util_dae.h	/^		enum DAEError $/;"	g	class:vcg::tri::io::UtilDAE
DD_HEAP_H	vcglib/wrap/gcache/dheap.h	/^#define DD_HEAP_H$/;"	d
DEADS	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  enum ListID {FRONT,DEADS};$/;"	e	enum:vcg::tri::AdvancingFront::ListID
DEBUG	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define DEBUG /;"	d	file:
DECL_GSISX	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^#define DECL_GSISX(/;"	d
DECL_GSSVX	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^#define DECL_GSSVX(/;"	d
DEFAULT_GRANULARITY	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define DEFAULT_GRANULARITY /;"	d	file:
DEFAULT_MMAP_THRESHOLD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define DEFAULT_MMAP_THRESHOLD /;"	d	file:
DEFAULT_NAME	vcglib/apps/trimeshinfo/XMLTree.h	/^	static const char *DEFAULT_NAME;$/;"	m	class:XMLTree
DEFAULT_NAME	vcglib/apps/trimeshinfo/XMLTree.h	/^const char * XMLTree::DEFAULT_NAME = "XmlTree.xml";$/;"	m	class:XMLTree
DEFAULT_TRIM_THRESHOLD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define DEFAULT_TRIM_THRESHOLD /;"	d	file:
DEFERRED_SHADING_BIT	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		DEFERRED_SHADING_BIT	= 0x000001,$/;"	e	enum:SplatRenderer::__anon519
DELETED	vcglib/vcg/connectors/hedge.h	/^		DELETED    = 0x0001,		\/\/ This bit indicate that the edge is deleted from the mesh$/;"	e	enum:vcg::HEdgeArityMax::__anon484
DELETED	vcglib/vcg/simplex/edge/base.h	/^		DELETED    = 0x0001,		\/\/ This bit indicate that the edge is deleted from the mesh$/;"	e	enum:vcg::EdgeArityMax::__anon496
DELETED	vcglib/vcg/simplex/face/base.h	/^		DELETED     = 0x00000001,		\/\/ Face is deleted from the mesh$/;"	e	enum:vcg::FaceArityMax::__anon497
DELETED	vcglib/vcg/simplex/tetrahedron/base.h	/^		DELETED     = 0x00000001,		\/\/ Face is deleted from the mesh$/;"	e	enum:vcg::TetraArityMax::__anon498
DELETED	vcglib/vcg/simplex/vertex/base.h	/^		DELETED    = 0x0001,		\/\/ This bit indicate that the vertex is deleted from the mesh$/;"	e	enum:vcg::VertexArityMax::__anon499
DELETE_VERTICES	vcglib/vcg/complex/algorithms/bitquad_support.h	/^#define DELETE_VERTICES /;"	d
DEPTH	vcglib/wrap/gl/fbo.h	/^		DEPTH,$/;"	e	enum:FrameBufferSemantic::__anon515
DEPTH_CORRECTION_BIT	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		DEPTH_CORRECTION_BIT	= 0x000002,$/;"	e	enum:SplatRenderer::__anon519
DEVICE_TO_LOGICAL_H	vcglib/wrap/qt/device_to_logical.h	/^#define DEVICE_TO_LOGICAL_H$/;"	d
DH	vcglib/wrap/gui/trackutils.h	/^DrawingHint DH;$/;"	m	namespace:vcg::trackutils
DHeap	vcglib/wrap/gcache/dheap.h	/^class DHeap: public std::vector<T> {$/;"	c
DIJKDist	vcglib/vcg/complex/algorithms/geodesic.h	/^    DIJKDist(VertexPointer _v):v(_v){}$/;"	f	struct:vcg::tri::Geodesic::DIJKDist
DIJKDist	vcglib/vcg/complex/algorithms/geodesic.h	/^  struct DIJKDist{$/;"	s	class:vcg::tri::Geodesic
DIRECT_MMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define DIRECT_MMAP(/;"	d	file:
DIRECT_MMAP_DEFAULT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define DIRECT_MMAP_DEFAULT(/;"	d	file:
DIR_SEP	vcglib/wrap/ply/plystuff.h	/^#define DIR_SEP /;"	d
DLMALLOC_VERSION	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define DLMALLOC_VERSION /;"	d	file:
DMBox	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	e	enum:vcg::GLW::DrawMode
DMFlat	vcglib/wrap/gl/addons.h	/^		enum DrawMode  {DMUser,DMWire,DMSolid,DMFlat} ;$/;"	e	enum:vcg::Add_Ons::DrawMode
DMFlat	vcglib/wrap/gl/tetramesh.h	/^  enum DrawMode  {DMNone, DMSmallTetra,DMFlat,DMWire, DMHidden,DMTransparent,DMFlatWire} ;$/;"	e	enum:vcg::tetra::GLW::DrawMode
DMFlat	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	e	enum:vcg::GLW::DrawMode
DMFlatWire	vcglib/wrap/gl/tetramesh.h	/^  enum DrawMode  {DMNone, DMSmallTetra,DMFlat,DMWire, DMHidden,DMTransparent,DMFlatWire} ;$/;"	e	enum:vcg::tetra::GLW::DrawMode
DMFlatWire	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	e	enum:vcg::GLW::DrawMode
DMHidden	vcglib/wrap/gl/tetramesh.h	/^  enum DrawMode  {DMNone, DMSmallTetra,DMFlat,DMWire, DMHidden,DMTransparent,DMFlatWire} ;$/;"	e	enum:vcg::tetra::GLW::DrawMode
DMHidden	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	e	enum:vcg::GLW::DrawMode
DMLast	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	e	enum:vcg::GLW::DrawMode
DMNone	vcglib/wrap/gl/tetramesh.h	/^  enum DrawMode  {DMNone, DMSmallTetra,DMFlat,DMWire, DMHidden,DMTransparent,DMFlatWire} ;$/;"	e	enum:vcg::tetra::GLW::DrawMode
DMNone	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	e	enum:vcg::GLW::DrawMode
DMPoints	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	e	enum:vcg::GLW::DrawMode
DMRadar	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	e	enum:vcg::GLW::DrawMode
DMSmallTetra	vcglib/wrap/gl/tetramesh.h	/^  enum DrawMode  {DMNone, DMSmallTetra,DMFlat,DMWire, DMHidden,DMTransparent,DMFlatWire} ;$/;"	e	enum:vcg::tetra::GLW::DrawMode
DMSmooth	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	e	enum:vcg::GLW::DrawMode
DMSolid	vcglib/wrap/gl/addons.h	/^		enum DrawMode  {DMUser,DMWire,DMSolid,DMFlat} ;$/;"	e	enum:vcg::Add_Ons::DrawMode
DMTransparent	vcglib/wrap/gl/tetramesh.h	/^  enum DrawMode  {DMNone, DMSmallTetra,DMFlat,DMWire, DMHidden,DMTransparent,DMFlatWire} ;$/;"	e	enum:vcg::tetra::GLW::DrawMode
DMUser	vcglib/wrap/gl/addons.h	/^		enum DrawMode  {DMUser,DMWire,DMSolid,DMFlat} ;$/;"	e	enum:vcg::Add_Ons::DrawMode
DMWire	vcglib/wrap/gl/addons.h	/^		enum DrawMode  {DMUser,DMWire,DMSolid,DMFlat} ;$/;"	e	enum:vcg::Add_Ons::DrawMode
DMWire	vcglib/wrap/gl/tetramesh.h	/^  enum DrawMode  {DMNone, DMSmallTetra,DMFlat,DMWire, DMHidden,DMTransparent,DMFlatWire} ;$/;"	e	enum:vcg::tetra::GLW::DrawMode
DMWire	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	e	enum:vcg::GLW::DrawMode
DON_RGB4	vcglib/vcg/space/colorspace.h	/^		DON_RGB4 = 7,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
DOT	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define DOT(/;"	d
DOT	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef DOT$/;"	d
DST_CHAN	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define DST_CHAN /;"	d
DST_CTRL	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define DST_CTRL(/;"	d
DarkBlue	vcglib/vcg/space/color4.h	/^	  DarkBlue    =0xff400000$/;"	e	enum:vcg::Color4::ColorConstant
DarkGray	vcglib/vcg/space/color4.h	/^	  DarkGray    =0xff404040,$/;"	e	enum:vcg::Color4::ColorConstant
DarkGreen	vcglib/vcg/space/color4.h	/^	  DarkGreen   =0xff004000,$/;"	e	enum:vcg::Color4::ColorConstant
DarkRed	vcglib/vcg/space/color4.h	/^	  DarkRed     =0xff000040,$/;"	e	enum:vcg::Color4::ColorConstant
Data	vcglib/vcg/container/entries_allocation_table.h	/^std::vector<ATTR_TYPE> & Data(){return data;}$/;"	f	struct:vcg::EntryCAT
Data	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				Data(std::vector< ObjectPointer > *data) $/;"	f	struct:vcg::PerfectSpatialHashing::HashTable::Data
Data	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			struct Data$/;"	s	class:vcg::PerfectSpatialHashing::HashTable
DataBegin	vcglib/vcg/container/simple_temporary_data.h	/^    void * DataBegin() {return data.empty()?NULL:&(*data.begin());}$/;"	f	class:vcg::SimpleTempData
DataBegin	vcglib/vcg/container/simple_temporary_data.h	/^    void * DataBegin(){return attribute;}$/;"	f	class:vcg::Attribute
DataRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic))$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon46
DataRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon48
DataRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon49
DataType	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  enum DataType$/;"	g	class:vcg::RawVolumeImporter
DataType	vcglib/vcg/space/index/kdtree/kdtree.h	/^		typedef _DataType DataType;$/;"	t	class:ConstDataWrapper
DeInterize	vcglib/vcg/space/index/octree_template.h	/^	CoordinateType DeInterize(const CenterType &pi ) const$/;"	f	class:vcg::OctreeTemplate
Dealloc	vcglib/vcg/simplex/face/base.h	/^	inline void Dealloc(){}$/;"	f	class:vcg::FaceTypeHolder
Dealloc	vcglib/vcg/simplex/face/component.h	/^    inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::Quality
Dealloc	vcglib/vcg/simplex/face/component.h	/^    inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::VFAdj
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::BitFlags
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::Color
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::EFAdj
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::EmptyCore
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::FEAdj
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::FFAdj
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::FHAdj
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::NormalAbs
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::Quality3
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::VertexRef
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::WedgeNormal
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::WedgeRealNormal
Dealloc	vcglib/vcg/simplex/face/component.h	/^  inline void Dealloc(){T::Dealloc();}$/;"	f	class:vcg::face::WedgeTexCoord
Dealloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Dealloc() {	 T::Dealloc();}$/;"	f	class:vcg::face::PFHAdj
Dealloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Dealloc() {	if(_fepP!=NULL) {delete [] _fepP; _fepP = NULL;} T::Dealloc();}$/;"	f	class:vcg::face::PFEAdj
Dealloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Dealloc() {$/;"	f	class:vcg::face::PFFAdj
Dealloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Dealloc() {$/;"	f	class:vcg::face::PFVAdj
Dealloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Dealloc() {$/;"	f	class:vcg::face::PVFAdj
Dealloc	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void Dealloc(){}$/;"	f	class:vcg::face::PolyInfo
Dec	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^  typedef DiagonalPreconditioner<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef BiCGSTAB<_MatrixType, _Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^  typedef IncompleteLUT<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef IterativeSolverBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<_Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef GMRES<_MatrixType, _Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^  typedef IncompleteLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Decompose	vcglib/vcg/math/matrix44.h	/^bool Decompose(Matrix44<T> &M, Point3<T> &ScaleV, Point3<T> &ShearV, Point3<T> &RotV,Point3<T> &TranV)$/;"	f	namespace:vcg
Decompose	vcglib/vcg/math/old_matrix44.h	/^bool Decompose(Matrix44<T> &M, Point3<T> &ScaleV, Point3<T> &ShearV, Point3<T> &RotV,Point3<T> &TranV)$/;"	f	namespace:vcg
DecompositionOptions	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum DecompositionOptions {$/;"	g	namespace:Eigen
DecompositionType	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::image_retval_base
DecompositionType	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::kernel_retval_base
DecompositionType	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::solve_retval_base
DecompositionType	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base
DecreaseValency	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void DecreaseValency(FaceType *f, int wedge, MeshType &m){$/;"	f	class:vcg::tri::BitQuad
DecreaseValencyNoSingletTest	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void DecreaseValencyNoSingletTest(VertexType *v, int dv,  MeshType &m){$/;"	f	class:vcg::tri::BitQuad
DecreaseValencySimple	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void DecreaseValencySimple(VertexType *v, int dv){$/;"	f	class:vcg::tri::BitQuad
DeepestNode	vcglib/vcg/space/index/octree_template.h	/^	NodePointer DeepestNode(CenterType path, int MaxLev)$/;"	f	class:vcg::OctreeTemplate
Default	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	e	enum:Eigen::Default_t
Default	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    void Default(){$/;"	f	struct:vcg::tri::FourPCS::Param
DefaultDeleter	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct DefaultDeleter            { void operator () (T * t) { delete t; }                                  };$/;"	s	namespace:glw::detail
DefaultDeriver	vcglib/vcg/container/derivation_chain.h	/^class DefaultDeriver : public T {};$/;"	c	namespace:vcg
DefaultTraversal	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  DefaultTraversal,$/;"	e	enum:Eigen::__anon260
Default_t	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	g	namespace:Eigen
DefineMap	vcglib/wrap/glw/utility.h	/^		typedef std::map<std::string, std::string>   DefineMap;$/;"	t	class:glw::ShaderHeaderBuilder
DefineMapConstIterator	vcglib/wrap/glw/utility.h	/^		typedef DefineMap::const_iterator            DefineMapConstIterator;$/;"	t	class:glw::ShaderHeaderBuilder
DefineMapIterator	vcglib/wrap/glw/utility.h	/^		typedef DefineMap::iterator                  DefineMapIterator;$/;"	t	class:glw::ShaderHeaderBuilder
DefineMapValue	vcglib/wrap/glw/utility.h	/^		typedef DefineMap::value_type                DefineMapValue;$/;"	t	class:glw::ShaderHeaderBuilder
Deg	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^      Deg = _Deg,$/;"	e	enum:Eigen::internal::companion::__anon449
Deg_1	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^      Deg_1=decrement_if_fixed_size<Deg>::ret$/;"	e	enum:Eigen::internal::companion::__anon449
Degree	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    enum { Degree = _Degree \/*!< The spline curve's degree. *\/ };$/;"	e	enum:Eigen::Spline::__anon465
Degree	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { Degree = _Degree \/*!< The spline curve's degree. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon467
Del	vcglib/wrap/gl/fbo.h	/^	void Del(void)$/;"	f	class:BufferRenderTarget
Del	vcglib/wrap/gl/fbo.h	/^	void Del(void)$/;"	f	class:FrameBuffer
Del	vcglib/wrap/gl/fbo.h	/^	void Del(void)$/;"	f	class:Texture
Del	vcglib/wrap/gl/fbo.h	/^	void Del(void)$/;"	f	class:TextureRenderTarget
Del	vcglib/wrap/gl/shaders.h	/^	void Del(void)$/;"	f	class:Program
Del	vcglib/wrap/gl/shaders.h	/^	void Del(void)$/;"	f	class:Shader
DeleteBitFlag	vcglib/vcg/connectors/hedge.h	/^	static inline bool DeleteBitFlag(int bitval)$/;"	f	class:vcg::HEdgeArityMax
DeleteBitFlag	vcglib/vcg/simplex/edge/base.h	/^	static inline bool DeleteBitFlag(int bitval)$/;"	f	class:vcg::EdgeArityMax
DeleteBitFlag	vcglib/vcg/simplex/face/base.h	/^	static inline bool DeleteBitFlag(int bitval)$/;"	f	class:vcg::FaceArityMax
DeleteBitFlag	vcglib/vcg/simplex/tetrahedron/base.h	/^	static inline bool DeleteBitFlag(int bitval)$/;"	f	class:vcg::TetraArityMax
DeleteBitFlag	vcglib/vcg/simplex/vertex/base.h	/^	static inline bool DeleteBitFlag(int bitval)$/;"	f	class:vcg::VertexArityMax
DeleteEdge	vcglib/vcg/complex/allocate.h	/^            static void DeleteEdge(MeshType &m, EdgeType &e)$/;"	f	class:vcg::tri::Allocator
DeleteFace	vcglib/vcg/complex/allocate.h	/^            static void DeleteFace(MeshType &m, FaceType &f)$/;"	f	class:vcg::tri::Allocator
DeleteHEdge	vcglib/vcg/complex/allocate.h	/^            static void DeleteHEdge(MeshType &m, HEdgeType &h)$/;"	f	class:vcg::tri::Allocator
DeletePerEdgeAttribute	vcglib/vcg/complex/allocate.h	/^        bool DeletePerEdgeAttribute( MeshType & m,  std::string name){$/;"	f	class:vcg::tri::Allocator
DeletePerEdgeAttribute	vcglib/vcg/complex/allocate.h	/^    DeletePerEdgeAttribute( MeshType & m,typename MeshType::template PerEdgeAttributeHandle<ATTR_TYPE> & h){$/;"	f	class:vcg::tri::Allocator
DeletePerFaceAttribute	vcglib/vcg/complex/allocate.h	/^    static bool DeletePerFaceAttribute( MeshType & m,  std::string name){$/;"	f	class:vcg::tri::Allocator
DeletePerFaceAttribute	vcglib/vcg/complex/allocate.h	/^    static void DeletePerFaceAttribute( MeshType & m,typename MeshType::template PerFaceAttributeHandle<ATTR_TYPE> & h){$/;"	f	class:vcg::tri::Allocator
DeletePerMeshAttribute	vcglib/vcg/complex/allocate.h	/^    static void DeletePerMeshAttribute( MeshType & m,  std::string name){$/;"	f	class:vcg::tri::Allocator
DeletePerMeshAttribute	vcglib/vcg/complex/allocate.h	/^    static void DeletePerMeshAttribute( MeshType & m,typename MeshType::template PerMeshAttributeHandle<ATTR_TYPE> & h){$/;"	f	class:vcg::tri::Allocator
DeletePerVertexAttribute	vcglib/vcg/complex/allocate.h	/^        bool DeletePerVertexAttribute( MeshType & m,  std::string name){$/;"	f	class:vcg::tri::Allocator
DeletePerVertexAttribute	vcglib/vcg/complex/allocate.h	/^    DeletePerVertexAttribute( MeshType & m,typename MeshType::template PerVertexAttributeHandle<ATTR_TYPE> & h){$/;"	f	class:vcg::tri::Allocator
DeleteUnreachedRegions	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void DeleteUnreachedRegions(MeshType &m, PerVertexPointerHandle &sources)$/;"	f	class:vcg::tri::VoronoiProcessing
DeleteVertex	vcglib/vcg/complex/allocate.h	/^            static void DeleteVertex(MeshType &m, VertexType &v)$/;"	f	class:vcg::tri::Allocator
DeleterOf	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct DeleterOf                 { typedef typename DeleterOfType<T, typename BaseOf<T>::Type>::Type Type; };$/;"	s	namespace:glw::detail
DeleterOf	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct DeleterOf   <BoundObject> { typedef DefaultDeleter<BoundObject> Type; }; };$/;"	s	namespace:glw::detail
DeleterOf	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct DeleterOf  <SafeObject> { typedef DefaultDeleter<SafeObject> Type; }; };$/;"	s	namespace:glw::detail
DeleterOf	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct DeleterOf <Object> { typedef ObjectDeleter Type; }; };$/;"	s	namespace:glw::detail
DeleterOfType	vcglib/wrap/glw/bookkeeping.h	/^template <typename T, typename B> struct DeleterOfType             { typedef typename DeleterOfType<B, typename BaseOf<B>::Type>::Type Type; };$/;"	s	namespace:glw::detail
DeleterOfType	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct DeleterOfType<T, NoType>  { typedef DefaultDeleter<T>                                         Type; };$/;"	s	namespace:glw::detail
DeleterType	vcglib/wrap/glw/bookkeeping.h	/^		typedef TDeleter                                                                        DeleterType;$/;"	t	class:glw::detail::ObjectSharedPointer
DeleterType	vcglib/wrap/glw/bookkeeping.h	/^		typedef TDeleter                                                                    DeleterType;$/;"	t	class:glw::detail::RefCountedObject
DeleterType	vcglib/wrap/glw/bookkeeping.h	/^		typedef TDeleter                                          DeleterType;$/;"	t	class:glw::detail::ObjectSharedPointer
DeleterType	vcglib/wrap/glw/bookkeeping.h	/^		typedef TDeleter                                    DeleterType;$/;"	t	class:glw::detail::RefCountedObject
Dense	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^struct Dense {};$/;"	s	namespace:Eigen
DenseBase	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    DenseBase()$/;"	f	class:Eigen::DenseBase
DenseBase	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^template<typename Derived> class DenseBase$/;"	c	namespace:Eigen
DenseCoeffsBase	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectWriteAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>$/;"	c	namespace:Eigen
DenseCompanionMatrixType	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix<Scalar, Deg, Deg>               DenseCompanionMatrixType;$/;"	t	class:Eigen::internal::companion
DenseIndex	vcglib/eigenlib/Eigen/src/Core/util/XprHelper.h	/^typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE DenseIndex;$/;"	t	namespace:Eigen
DenseMatrixType	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::internal::BandMatrixBase
DenseMatrixType	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime, 0, MaxRowsAtCompileTime, MaxColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::DiagonalBase
DenseMatrixType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^            DenseMatrixType;$/;"	t	class:Eigen::PermutationBase
DenseMatrixType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Derived::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::Transpose
DenseMatrixType	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits
DenseMatrixType	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename TriangularView<MatrixType,Mode>::DenseMatrixType DenseMatrixType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type
DenseMatrixType	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularBase
DenseMatrixType	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularView
DenseMatrixType	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits
DenseSparseProductReturnType	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct DenseSparseProductReturnType$/;"	s	namespace:Eigen
DenseSparseProductReturnType	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct DenseSparseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex size, DenseIndex rows, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex size, DenseIndex rows, DenseIndex) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(rows)$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex size, DenseIndex, DenseIndex cols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(cols)$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex, DenseIndex rows, DenseIndex cols) : m_rows(rows), m_cols(cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex, DenseIndex rows, DenseIndex) : m_rows(rows) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex, DenseIndex, DenseIndex cols) : m_cols(cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() : m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline explicit DenseStorage() {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Cols, int _Options> class DenseStorage<T, Size, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Options> class DenseStorage<T, Size, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage$/;"	c	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Options> class DenseStorage<T, Size, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, 0, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, 0, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, 0, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseTimeSkylineProduct	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^enum AdditionalProductEvaluationMode {SkylineTimeDenseProduct, SkylineTimeSkylineProduct, DenseTimeSkylineProduct};$/;"	e	enum:Eigen::AdditionalProductEvaluationMode
DenseTimeSparseProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    DenseTimeSparseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseProduct
DenseTimeSparseProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^class DenseTimeSparseProduct$/;"	c	namespace:Eigen
DenseTimeSparseSelfAdjointProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    DenseTimeSparseSelfAdjointProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct
DenseTimeSparseSelfAdjointProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class DenseTimeSparseSelfAdjointProduct$/;"	c	namespace:Eigen
DenseType	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::DiagonalBase
DenseType	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef Derived DenseType;$/;"	t	class:Eigen::PlainObjectBase
DenseType	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::TriangularBase
Depth	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    Depth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon142
Depth	vcglib/vcg/math/shot.h	/^S Shot<S,RotationType>::Depth(const vcg::Point3<S> & p)const$/;"	f	class:vcg::Shot
Depth	vcglib/wrap/gl/fbo.h	/^	GLsizei Depth(void) const$/;"	f	class:Texture3D
DepthFirstCollect	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^	static void DepthFirstCollect(NodeType * node, OBJPOINTDISTANCEFUNCT & getPointDistance, const unsigned int k, const CoordType & p, ScalarType & mindmax, PQueueType & pq) {$/;"	f	class:vcg::AABBBinaryTreeKClosest
DepthFirstRayIsect	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^	static inline void DepthFirstRayIsect(const NodeType * node, OBJRAYISECTFUNCT & rayIntersection, const Ray3Ex & ray, ScalarType & rayT, ObjPtr & closestObj) {$/;"	f	class:vcg::AABBBinaryTreeRay
DepthRenderBuffer	vcglib/wrap/gl/fbo.h	/^	DepthRenderBuffer(void) : DepthRenderTarget(), BufferRenderTarget()$/;"	f	class:DepthRenderBuffer
DepthRenderBuffer	vcglib/wrap/gl/fbo.h	/^class DepthRenderBuffer : public virtual DepthRenderTarget, public virtual BufferRenderTarget$/;"	c
DepthRenderTarget	vcglib/wrap/gl/fbo.h	/^	DepthRenderTarget(void) : RenderTarget()$/;"	f	class:DepthRenderTarget
DepthRenderTarget	vcglib/wrap/gl/fbo.h	/^class DepthRenderTarget : public virtual RenderTarget$/;"	c
DepthRenderTexture	vcglib/wrap/gl/fbo.h	/^	DepthRenderTexture(Texture2D * tex) : DepthRenderTarget(), TextureRenderTarget()$/;"	f	class:DepthRenderTexture
DepthRenderTexture	vcglib/wrap/gl/fbo.h	/^	DepthRenderTexture(void) : DepthRenderTarget(), TextureRenderTarget()$/;"	f	class:DepthRenderTexture
DepthRenderTexture	vcglib/wrap/gl/fbo.h	/^class DepthRenderTexture : public virtual DepthRenderTarget, public virtual TextureRenderTarget$/;"	c
DepthTexture	vcglib/wrap/gl/fbo.h	/^	DepthTexture(void) : Texture()$/;"	f	class:DepthTexture
DepthTexture	vcglib/wrap/gl/fbo.h	/^class DepthTexture : public virtual Texture$/;"	c
DepthTexture2D	vcglib/wrap/gl/fbo.h	/^	DepthTexture2D(void) : DepthTexture(), Texture2D()$/;"	f	class:DepthTexture2D
DepthTexture2D	vcglib/wrap/gl/fbo.h	/^class DepthTexture2D : public virtual DepthTexture, public virtual Texture2D$/;"	c
Der	vcglib/vcg/complex/base.h	/^template <typename T, typename CONT> struct Der: public MeshTypeHolder<T,CONT, typename CONT::value_type::IAm>{};$/;"	s	namespace:vcg::tri
Der	vcglib/wrap/io_trimesh/import_vmi.h	/^    struct Der:public T{$/;"	s	namespace:vcg::tri::io
DerK	vcglib/wrap/io_trimesh/import_vmi.h	/^    struct DerK:public T{$/;"	s	namespace:vcg::tri::io
DerType	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    typedef typename internal::remove_all<_DerType>::type DerType;$/;"	t	class:Eigen::AutoDiffScalar
DerType	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef typename remove_all<_DerType>::type DerType;$/;"	t	struct:Eigen::internal::auto_diff_special_op
Dereferencer	vcglib/vcg/space/index/octree.h	/^    struct Dereferencer$/;"	s	namespace:vcg
Dereferencer	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		struct Dereferencer$/;"	s	class:vcg::PerfectSpatialHashing
DerivativeType	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef Matrix<Scalar,InputsAtCompileTime,1> DerivativeType;$/;"	t	class:Eigen::AutoDiffJacobian
DerivativeType	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,Dimension,Dynamic,ColMajor,Dimension,NumOfDerivativesAtCompileTime> DerivativeType;$/;"	t	struct:Eigen::SplineTraits
DerivativeType	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<_Scalar,_Dim,Dynamic,ColMajor,_Dim,NumOfDerivativesAtCompileTime> DerivativeType;$/;"	t	struct:Eigen::SplineTraits
Derived	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl
Derived	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, XprType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl
Derived	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Derived	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    typedef Product<Lhs, Rhs> Derived;$/;"	t	class:ProductImpl
Derived	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl
Derived	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl
Derived	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl
DesaturationMethods	vcglib/vcg/complex/algorithms/update/color.h	/^enum DesaturationMethods {M_LIGHTNESS = 0, M_LUMINOSITY = 1, M_AVERAGE = 2};$/;"	g	class:vcg::tri::UpdateColor
Deserialize	vcglib/wrap/io_trimesh/import_vmi.h	/^        static int Deserialize(OpenMeshType &m, int & mask)$/;"	f	class:vcg::tri::io::ImporterVMI
Destroy	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>:: Destroy(){$/;"	f	class:SplatRenderer
Destroy	vcglib/wrap/ply/plylib.cpp	/^void PlyFile::Destroy( void )$/;"	f	class:vcg::ply::PlyFile
Detach	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  void Detach(int v) {$/;"	f	class:vcg::tri::AdvancingFront
Detach	vcglib/wrap/gl/fbo.h	/^bool RenderTarget::Detach(void)$/;"	f	class:RenderTarget
Detach	vcglib/wrap/gl/shaders.h	/^	void Detach(Shader * shd)$/;"	f	class:Program
DetachAll	vcglib/wrap/gl/fbo.h	/^	bool DetachAll(void)$/;"	f	class:FrameBuffer
Determinant	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED Scalar Determinant() const { return determinant(); };$/;"	f
Determinant	vcglib/vcg/math/matrix33.h	/^    S Determinant() const$/;"	f	class:vcg::Matrix33
Determinant	vcglib/vcg/math/matrix44.h	/^template <class T> T Matrix44<T>::Determinant() const {$/;"	f	class:vcg::Matrix44
Determinant	vcglib/vcg/math/old_deprecated_matrix.h	/^			TYPE Determinant() const$/;"	f	class:vcg::ndim::Matrix
DevicePixelConvert	vcglib/wrap/gui/rubberband.cpp	/^Point2f Rubberband::DevicePixelConvert(const Point3f p)$/;"	f	class:Rubberband
Diag	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static CoordType Diag(const FaceType* f){$/;"	f	class:vcg::tri::BitQuad
Diag	vcglib/vcg/space/box.h	/^	S Diag() const$/;"	f	class:vcg::Box
Diag	vcglib/vcg/space/box2.h	/^	ScalarType Diag() const$/;"	f	class:vcg::Box2
Diag	vcglib/vcg/space/box3.h	/^    BoxScalarType Diag() const$/;"	f	class:vcg::Box3
DiagSizeAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^      DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon442
DiagVectorType	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1> DiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Diagonal	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline Diagonal(MatrixType& matrix, Index index = DiagIndex) : m_matrix(matrix), m_index(index) {}$/;"	f	class:Eigen::Diagonal
Diagonal	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^template<typename MatrixType, int DiagIndex> class Diagonal$/;"	c	namespace:Eigen
DiagonalBase	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
DiagonalIndexReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase
DiagonalIntReturnType	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    template<int Index> struct DiagonalIntReturnType {$/;"	s	class:Eigen::internal::BandMatrixBase
DiagonalMatrix	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalMatrix(const MatrixBase<OtherDerived>& other) : m_diagonal(other)$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix() {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(Index dim) : m_diagonal(dim) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalBase<OtherDerived>& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalMatrix& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y) : m_diagonal(x,y) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y, const Scalar& z) : m_diagonal(x,y,z) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalMatrix$/;"	c	namespace:Eigen
DiagonalPreconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner() : m_isInitialized(false) {}$/;"	f	class:Eigen::DiagonalPreconditioner
DiagonalPreconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner(const MatType& mat) : m_invdiag(mat.cols())$/;"	f	class:Eigen::DiagonalPreconditioner
DiagonalPreconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class DiagonalPreconditioner$/;"	c	namespace:Eigen
DiagonalProduct	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    inline DiagonalProduct(const MatrixType& matrix, const DiagonalType& diagonal)$/;"	f	class:Eigen::DiagonalProduct
DiagonalProduct	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^class DiagonalProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen
DiagonalReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef Diagonal<Derived> DiagonalReturnType;$/;"	t	class:Eigen::MatrixBase
DiagonalReturnType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type DiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization
DiagonalSize	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^        DiagonalSize = (RowsAtCompileTime==Dynamic || ColsAtCompileTime==Dynamic)$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon47
DiagonalType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type DiagonalType;$/;"	t	class:Eigen::Tridiagonalization
DiagonalVectorType	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalWrapper
DiagonalVectorType	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalBase
DiagonalVectorType	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalMatrix
DiagonalVectorType	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef Matrix<_Scalar,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1> DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits
DiagonalVectorType	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits
DiagonalWrapper	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalWrapper(DiagonalVectorType& diagonal) : m_diagonal(diagonal) {}$/;"	f	class:Eigen::DiagonalWrapper
DiagonalWrapper	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalWrapper$/;"	c	namespace:Eigen
Diamond	vcglib/wrap/gl/addons.h	/^		static void Diamond (float radius,bool useDisplList)$/;"	f	class:vcg::Add_Ons
DiedralAngle	vcglib/vcg/space/tetra3.h	/^	double DiedralAngle(int edgeind)$/;"	f	class:vcg::Tetra3
DiedralWeight	vcglib/vcg/complex/algorithms/hole.h	/^  static float &DiedralWeight() { static float _dw=0.1; return _dw;}$/;"	f	class:vcg::tri::MinimumWeightEar
DifferenceCrossField	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static typename FaceType::ScalarType DifferenceCrossField(const typename FaceType::CoordType &t0,$/;"	f	class:vcg::tri::CrossField
DifferenceCrossField	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static typename FaceType::ScalarType DifferenceCrossField(const typename vcg::Point2<ScalarType> &t0,$/;"	f	class:vcg::tri::CrossField
DiffuseTag	vcglib/wrap/dae/colladaformat.h	/^		DiffuseTag()$/;"	f	class:Collada::Tags::DiffuseTag
DiffuseTag	vcglib/wrap/dae/colladaformat.h	/^	class DiffuseTag : public XMLTag$/;"	c	namespace:Collada::Tags
DihedralAngleRad	vcglib/vcg/simplex/face/topology.h	/^inline typename FaceType::ScalarType DihedralAngleRad(FaceType & f,  const int i )$/;"	f	namespace:vcg::face
Dim	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon330
Dim	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon333
Dim	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon334
Dim	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Scaling::__anon335
Dim	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon336
Dim	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon337
Dim	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon358
Dim	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon368
Dim	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon369
Dim	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon370
Dim	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon371
Dim	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    Dim = Transform::Dim,$/;"	e	enum:Eigen::internal::transform_traits::__anon372
Dim	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon376
Dim	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
Dim	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon373
Dim	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon379
Dim	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::KdBVH::__anon446
Dim	vcglib/vcg/space/box2.h	/^	inline PointType Dim() const { return max-min; }$/;"	f	class:vcg::Box2
Dim	vcglib/vcg/space/box3.h	/^    Point3<BoxScalarType> Dim() const$/;"	f	class:vcg::Box3
DimX	vcglib/vcg/space/box2.h	/^	inline ScalarType DimX() const { return max.X()-min.X(); }$/;"	f	class:vcg::Box2
DimX	vcglib/vcg/space/box3.h	/^    inline BoxScalarType DimX() const { return max.X()-min.X();}$/;"	f	class:vcg::Box3
DimY	vcglib/vcg/space/box2.h	/^	inline ScalarType DimY() const { return max.Y()-min.Y(); }$/;"	f	class:vcg::Box2
DimY	vcglib/vcg/space/box3.h	/^    inline BoxScalarType DimY() const { return max.Y()-min.Y();}$/;"	f	class:vcg::Box3
DimZ	vcglib/vcg/space/box3.h	/^    inline BoxScalarType DimZ() const { return max.Z()-min.Z();}$/;"	f	class:vcg::Box3
Dimension	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    enum { Dimension = _Dim \/*!< The spline curve's dimension. *\/ };$/;"	e	enum:Eigen::Spline::__anon464
Dimension	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { Dimension = _Dim \/*!< The spline curve's dimension. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon466
Dimension	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            enum Dimension		 {X, Y, Z};$/;"	g	class:vcg::tri::MarchingCubes
Dimension	vcglib/vcg/math/eigen_matrix_addons.h	/^enum {Dimension = SizeAtCompileTime};$/;"	e	enum:__anon489
Dimension	vcglib/vcg/math/old_deprecated_matrix.h	/^		const int & Dimension() const {return N;}$/;"	f	class:vcg::ndim::MatrixDiag
Dimension	vcglib/vcg/space/box.h	/^	enum {Dimension=N};$/;"	e	enum:vcg::Box::__anon500
Dimension	vcglib/vcg/space/deprecated_point.h	/^	enum {Dimension=N};$/;"	e	enum:vcg::ndim::Point::__anon501
Dimension	vcglib/vcg/space/deprecated_point2.h	/^	enum {Dimension = 2};$/;"	e	enum:vcg::Point2::__anon502
Dimension	vcglib/vcg/space/deprecated_point3.h	/^    enum {Dimension = 3};$/;"	e	enum:vcg::Point3::__anon503
Dimension	vcglib/vcg/space/deprecated_point4.h	/^	enum {Dimension = 4};$/;"	e	enum:vcg::Point4::__anon504
Dimension	vcglib/vcg/space/space.h	/^	enum {Dimension=N};$/;"	e	enum:vcg::Space::__anon512
Dimensions	vcglib/wrap/gl/fbo.h	/^	GLint Dimensions(void) const$/;"	f	class:Texture1D
Dimensions	vcglib/wrap/gl/fbo.h	/^	GLint Dimensions(void) const$/;"	f	class:Texture2D
Dimensions	vcglib/wrap/gl/fbo.h	/^	GLint Dimensions(void) const$/;"	f	class:Texture3D
DiracPolicy	vcglib/wrap/mt/mt.h	/^  DiracPolicy(Point3f &f = Point3f(0, 0, 0), float e = 0): focus(f), error(e) {}$/;"	f	class:vcg::DiracPolicy
DiracPolicy	vcglib/wrap/mt/mt.h	/^template <class C> class DiracPolicy {$/;"	c	namespace:vcg
DirectAccessBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int DirectAccessBit = 0x40;$/;"	m	namespace:Eigen
DirectAccessors	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  DirectAccessors, $/;"	e	enum:Eigen::AccessorLevels
DirectLinearAccessType	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    >::type DirectLinearAccessType;$/;"	t	struct:Eigen::internal::blas_traits
DirectWriteAccessors	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  DirectWriteAccessors$/;"	e	enum:Eigen::AccessorLevels
DirectedDistance	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	bool DirectedDistance(const vcg::Point3i &p1, const vcg::Point3i &p2, vcg::Point3f &v, vcg::Point3f &n, float &dist)$/;"	f	class:ImplicitSphere
DirectedDistance	vcglib/apps/unsupported/extractors/extractor/SphereDifference.h	/^	inline bool DirectedDistance(const vcg::Point3i p1, const vcg::Point3i p2, vcg::Point3f &p, vcg::Point3f &n, float &d)$/;"	f	class:SphereDifference
DirectedDistance	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^	bool DirectedDistance(const vcg::Point3i &p1, const vcg::Point3i &p2, vcg::Point3f &v, vcg::Point3f &n, float &d)$/;"	f	class:SphereUnion
Direction	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    enum { Direction = _Direction };$/;"	e	enum:Eigen::Homogeneous::__anon360
Direction	vcglib/vcg/space/line2.h	/^  inline const PointType &Direction() const { return _dir; } $/;"	f	class:vcg::Line2
Direction	vcglib/vcg/space/line3.h	/^  inline const PointType &Direction() const { return _dir; } $/;"	f	class:vcg::Line3
Direction	vcglib/vcg/space/plane3.h	/^  const PointType &Direction() const { return _dir; } $/;"	f	class:vcg::Plane3
Direction	vcglib/vcg/space/ray2.h	/^  inline const PointType &Direction() const { return _dir; } $/;"	f	class:vcg::Ray2
Direction	vcglib/vcg/space/ray3.h	/^  inline const PointType &Direction() const { return _dir; } $/;"	f	class:vcg::Ray3
Direction	vcglib/vcg/space/segment3.h	/^	inline PointType Direction( ) const$/;"	f	class:vcg::Segment3
DirectionType	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum DirectionType { $/;"	g	namespace:Eigen
DirectionalLightingEnvironment	vcglib/apps/unsupported/shadevis/visshader.h	/^void DirectionalLightingEnvironment(std::vector<float> &LE, Point3x dir, ScalarType DegAngle1, ScalarType DegAngle2)$/;"	f	class:vcg::VisShader
DirtyCheck	vcglib/vcg/math/histogram.h	/^	void DirtyCheck()$/;"	f	class:vcg::Distribution
Disable	vcglib/vcg/container/vector_occ.h	/^		void Disable(){$/;"	f	class:vcg::vector_occ
Disable	vcglib/wrap/glw/utility.h	/^			Disable,$/;"	e	enum:glw::ShaderHeaderBuilder::ExtensionMode
DisableColor	vcglib/vcg/simplex/face/component_ocf.h	/^void DisableColor() {$/;"	f	class:vcg::face::vector_ocf
DisableColor	vcglib/vcg/simplex/vertex/component_ocf.h	/^void DisableColor() {$/;"	f	class:vcg::vertex::vector_ocf
DisableCurvature	vcglib/vcg/simplex/vertex/component_ocf.h	/^void DisableCurvature() {$/;"	f	class:vcg::vertex::vector_ocf
DisableCurvatureDir	vcglib/vcg/simplex/face/component_ocf.h	/^void DisableCurvatureDir() {$/;"	f	class:vcg::face::vector_ocf
DisableCurvatureDir	vcglib/vcg/simplex/vertex/component_ocf.h	/^void DisableCurvatureDir() {$/;"	f	class:vcg::vertex::vector_ocf
DisableFFAdjacency	vcglib/vcg/simplex/face/component_ocf.h	/^void DisableFFAdjacency() {$/;"	f	class:vcg::face::vector_ocf
DisableMark	vcglib/vcg/simplex/face/component_ocf.h	/^void DisableMark() {$/;"	f	class:vcg::face::vector_ocf
DisableMark	vcglib/vcg/simplex/vertex/component_ocf.h	/^void DisableMark() {$/;"	f	class:vcg::vertex::vector_ocf
DisableNormal	vcglib/vcg/simplex/face/component_ocf.h	/^void DisableNormal() {$/;"	f	class:vcg::face::vector_ocf
DisableNormal	vcglib/vcg/simplex/vertex/component_ocf.h	/^void DisableNormal() {$/;"	f	class:vcg::vertex::vector_ocf
DisableQuality	vcglib/vcg/simplex/face/component_ocf.h	/^void DisableQuality() {$/;"	f	class:vcg::face::vector_ocf
DisableQuality	vcglib/vcg/simplex/vertex/component_ocf.h	/^void DisableQuality() {$/;"	f	class:vcg::vertex::vector_ocf
DisableRadius	vcglib/vcg/simplex/vertex/component_ocf.h	/^void DisableRadius() {$/;"	f	class:vcg::vertex::vector_ocf
DisableTexCoord	vcglib/vcg/simplex/vertex/component_ocf.h	/^void DisableTexCoord() {$/;"	f	class:vcg::vertex::vector_ocf
DisableVFAdjacency	vcglib/vcg/simplex/face/component_ocf.h	/^void DisableVFAdjacency() {$/;"	f	class:vcg::face::vector_ocf
DisableVFAdjacency	vcglib/vcg/simplex/vertex/component_ocf.h	/^void DisableVFAdjacency() {$/;"	f	class:vcg::vertex::vector_ocf
DisableWedgeColor	vcglib/vcg/simplex/face/component_ocf.h	/^void DisableWedgeColor() {$/;"	f	class:vcg::face::vector_ocf
DisableWedgeNormal	vcglib/vcg/simplex/face/component_ocf.h	/^void DisableWedgeNormal() {$/;"	f	class:vcg::face::vector_ocf
DisableWedgeTexCoord	vcglib/vcg/simplex/face/component_ocf.h	/^void DisableWedgeTexCoord() {$/;"	f	class:vcg::face::vector_ocf
DiscretizeFlag	vcglib/vcg/complex/algorithms/create/resampler.h	/^		bool DiscretizeFlag; \/\/ if the extracted surface should be discretized or not.$/;"	m	class:vcg::tri::Resampler::Walker
DisjointSet	vcglib/vcg/math/disjoint_set.h	/^		DisjointSet() {}$/;"	f	class:vcg::DisjointSet
DisjointSet	vcglib/vcg/math/disjoint_set.h	/^	class DisjointSet$/;"	c	namespace:vcg
DisjointSetNode	vcglib/vcg/math/disjoint_set.h	/^			DisjointSetNode(OBJECT_TYPE *x) {obj=x; parent=obj; rank=0;}$/;"	f	struct:vcg::DisjointSet::DisjointSetNode
DisjointSetNode	vcglib/vcg/math/disjoint_set.h	/^		struct DisjointSetNode$/;"	s	class:vcg::DisjointSet
Disk	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Disk(MeshType & m, int slices)$/;"	f	namespace:vcg::tri
Display	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void Display(){$/;"	f
Dist	vcglib/vcg/space/index/space_iterators.h	/^		ScalarType Dist()$/;"	f	class:vcg::ClosestIterator
Dist	vcglib/vcg/space/index/space_iterators.h	/^		ScalarType Dist()$/;"	f	class:vcg::RayIterator
DistType	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			enum DistType{AreaDist,EdgeDist,AngleDist};$/;"	g	class:vcg::tri::Distortion
Distance	vcglib/vcg/complex/algorithms/geodesic.h	/^  static ScalarType Distance(DistanceFunctor &distFunc,$/;"	f	class:vcg::tri::Geodesic
Distance	vcglib/vcg/math/eigen.h	/^Distance(const Eigen::MatrixBase<Derived1>& p1, const Eigen::MatrixBase<Derived2> & p2)$/;"	f	namespace:vcg
Distance	vcglib/vcg/space/deprecated_point.h	/^inline S Distance( Point<N,S> const & p1,Point<N,S> const & p2 )$/;"	f	namespace:vcg::ndim
Distance	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType Distance( Point2 const & p ) const$/;"	f	class:vcg::Point2
Distance	vcglib/vcg/space/deprecated_point2.h	/^inline T Distance( Point2<T> const & p1,Point2<T> const & p2 ){$/;"	f	namespace:vcg
Distance	vcglib/vcg/space/deprecated_point3.h	/^inline P3ScalarType Distance( Point3<P3ScalarType> const & p1,Point3<P3ScalarType> const & p2 )$/;"	f	namespace:vcg
Distance	vcglib/vcg/space/deprecated_point4.h	/^inline T Distance( const Point4<T> & p1, const Point4<T> & p2 )$/;"	f	namespace:vcg
Distance	vcglib/vcg/space/line2.h	/^ScalarType Distance(const Line2<ScalarType, NORM> &l, $/;"	f	namespace:vcg
Distance	vcglib/vcg/space/line3.h	/^ScalarType Distance(const Line3<ScalarType, NORM> &l, $/;"	f	namespace:vcg
Distance	vcglib/wrap/gui/frustum.h	/^template <class T> T Frustum<T>::Distance(Point3<T> &point, int plane) {    $/;"	f	class:vcg::Frustum
DistanceFromBorder	vcglib/vcg/complex/algorithms/geodesic.h	/^  static bool DistanceFromBorder(	MeshType & m, typename MeshType::template PerVertexAttributeHandle<VertexPointer> * sources = NULL)$/;"	f	class:vcg::tri::Geodesic
DistanceFromBorder	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^    DistanceFromBorder=2,$/;"	e	enum:vcg::tri::VoronoiProcessingParameter::__anon483
DistanceFromMesh	vcglib/vcg/complex/algorithms/create/resampler.h	/^	field_value DistanceFromMesh(Point3f &pp,Old_Mesh *\/*mesh*\/)$/;"	f	class:vcg::tri::Resampler::Walker
DistanceFromSeed	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^    DistanceFromSeed=1,$/;"	e	enum:vcg::tri::VoronoiProcessingParameter::__anon483
DistancePoint2Box2	vcglib/vcg/space/box2.h	/^ScalarType DistancePoint2Box2(const Point2<ScalarType> &test,$/;"	f	namespace:vcg
DistorCenterPx	vcglib/vcg/math/camera.h	/^    Point2<S>	DistorCenterPx;		\/\/\/ Position of the radial distortion center on the image plane in pixels$/;"	m	class:vcg::Camera
DistortedToUndistorted	vcglib/vcg/math/camera.h	/^vcg::Point2<S> Camera<S>::DistortedToUndistorted(vcg::Point2<S> d) const$/;"	f	class:vcg::Camera
Distortion	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^		class Distortion$/;"	c	namespace:vcg::tri
Distortion	vcglib/wrap/miq/core/param_stats.h	/^typename FaceType::ScalarType Distortion(FaceType &f,typename FaceType::ScalarType h)$/;"	f
Distribution	vcglib/vcg/math/histogram.h	/^	Distribution() { Clear(); }$/;"	f	class:vcg::Distribution
Distribution	vcglib/vcg/math/histogram.h	/^class Distribution $/;"	c	namespace:vcg
Do	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  static int Do(TriMeshType &m, VertexPair & c, const Point3<ScalarType> &p)$/;"	f	class:vcg::tri::EdgeCollapser
DoBind	vcglib/wrap/gl/fbo.h	/^	void DoBind(void)$/;"	f	class:BufferRenderTarget
DoBind	vcglib/wrap/gl/fbo.h	/^	void DoBind(void)$/;"	f	class:FrameBuffer
DoBind	vcglib/wrap/gl/fbo.h	/^	void DoBind(void)$/;"	f	class:Texture
DoBind	vcglib/wrap/gl/fbo.h	/^	void DoBind(void)$/;"	f	class:Texture2D
DoBind	vcglib/wrap/gl/fbo.h	/^	void DoBind(void)$/;"	f	class:Texture3D
DoBind	vcglib/wrap/gl/fbo.h	/^	void DoBind(void)$/;"	f	class:TextureRenderTarget
DoBind	vcglib/wrap/gl/shaders.h	/^	void DoBind(void)$/;"	f	class:Program
DoBind	vcglib/wrap/gl/shaders.h	/^	void DoBind(void)$/;"	f	class:ProgramVF
DoBind	vcglib/wrap/gl/shaders.h	/^	void DoBind(void)$/;"	f	class:Shader
DoGFilter	vcglib/img/img_filter.h	/^inline void DoGFilter(const Image<Channels,SrcScalarType,SrcSafe> &source,Image<Channels,DestScalarType,DestSafe> &destination,int radius1,int radius2)$/;"	f	namespace:img
DoOptimization	vcglib/vcg/complex/algorithms/local_optimization.h	/^  bool DoOptimization()$/;"	f	class:vcg::LocalOptimization
DoParameterize	vcglib/wrap/miq/MIQ.h	/^  static void DoParameterize(MeshType &mesh,StiffMode stiffMode,$/;"	f	class:MIQ_parametrization
DoRay	vcglib/vcg/complex/algorithms/closest.h	/^			typename GRID::ObjPtr DoRay(MESH & mesh,GRID & gr, const Ray3<typename GRID::ScalarType> & _ray,$/;"	f	namespace:vcg::tri
DoRay	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	inline ObjPtr DoRay(OBJRAYISECTFUNCTOR & _rayIntersector, OBJMARKER & _marker, const Ray3<ScalarType> & _ray, const ScalarType & _maxDist, ScalarType & _t) {$/;"	f	class:vcg::AABBBinaryTreeIndex
DoRay	vcglib/vcg/space/index/base.h	/^	ObjPtr DoRay(OBJRAYISECTFUNCTOR & _rayIntersector, OBJMARKER & _marker, const Ray3<ScalarType> & _ray, const ScalarType & _maxDist, ScalarType & _t) {$/;"	f	class:vcg::SpatialIndex
DoRay	vcglib/vcg/space/index/grid_static_ptr.h	/^			ObjPtr DoRay(OBJRAYISECTFUNCTOR & _rayIntersector, OBJMARKER & _marker, const Ray3<ScalarType> & _ray, const ScalarType & _maxDist, ScalarType & _t) $/;"	f	class:vcg::GridStaticPtr
DoRay	vcglib/vcg/space/index/spatial_hashing.h	/^			ObjPtr DoRay(OBJRAYISECTFUNCTOR & _rayIntersector, OBJMARKER & _marker, const Ray3<ScalarType> & _ray, const ScalarType & _maxDist, ScalarType & _t)$/;"	f	class:vcg::SpatialHashTable
DoUnbind	vcglib/wrap/gl/fbo.h	/^	void DoUnbind(void)$/;"	f	class:BufferRenderTarget
DoUnbind	vcglib/wrap/gl/fbo.h	/^	void DoUnbind(void)$/;"	f	class:FrameBuffer
DoUnbind	vcglib/wrap/gl/fbo.h	/^	void DoUnbind(void)$/;"	f	class:Texture
DoUnbind	vcglib/wrap/gl/fbo.h	/^	void DoUnbind(void)$/;"	f	class:Texture2D
DoUnbind	vcglib/wrap/gl/fbo.h	/^	void DoUnbind(void)$/;"	f	class:Texture3D
DoUnbind	vcglib/wrap/gl/fbo.h	/^	void DoUnbind(void)$/;"	f	class:TextureRenderTarget
DoUnbind	vcglib/wrap/gl/shaders.h	/^	void DoUnbind(void)$/;"	f	class:Program
DoUnbind	vcglib/wrap/gl/shaders.h	/^	void DoUnbind(void)$/;"	f	class:ProgramVF
DoUnbind	vcglib/wrap/gl/shaders.h	/^	void DoUnbind(void)$/;"	f	class:Shader
DocumentManager	vcglib/wrap/dae/colladaformat.h	/^class DocumentManager$/;"	c	namespace:Collada
Dodecahedron	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Dodecahedron(DodMeshType & in)$/;"	f	namespace:vcg::tri
DomainToHashTable	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			EntryCoordinate DomainToHashTable(const typename UniformGrid::CellCoordinate &p)$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
DomainToOffsetTable	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			EntryCoordinate DomainToOffsetTable(const typename UniformGrid::CellCoordinate &coord)$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
DontAlign	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  DontAlign = 0x2$/;"	e	enum:Eigen::__anon263
DontAlignCols	vcglib/eigenlib/Eigen/src/Core/IO.h	/^enum { DontAlignCols = 1 };$/;"	e	enum:Eigen::__anon171
DontCare	vcglib/wrap/glw/program.h	/^			DontCare = 0,$/;"	e	enum:glw::RasterizerSettings::RasterizerExecution
DontCare	vcglib/wrap/glw/utility.h	/^			DontCare = 0,$/;"	e	enum:glw::ShaderHeaderBuilder::ExtensionMode
Dot	vcglib/vcg/space/index/kdtree/mlsutils.h	/^inline Scalar Dot(Point3<Scalar> const & p1, Point3<Scalar> const & p2)$/;"	f	namespace:vcg
DotProduct	vcglib/vcg/math/old_deprecated_matrix.h	/^			void DotProduct(Point<N,TYPE> &m,Point<M,TYPE> &result)$/;"	f	class:vcg::ndim::Matrix
DoubleArea	vcglib/vcg/space/triangle3.h	/^typename TriangleType::ScalarType DoubleArea(const TriangleType &t) $/;"	f	namespace:vcg
DoublePacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  struct DoublePacket$/;"	s	class:Eigen::internal::gebp_traits
Drag	vcglib/wrap/gui/rubberband.cpp	/^void Rubberband::Drag(QPoint p)$/;"	f	class:Rubberband
Draw	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void Draw(AMesh &mm)$/;"	f
Draw	vcglib/wrap/gl/pos.h	/^			static void Draw(PosType & p){$/;"	f	struct:vcg::GlPos
Draw	vcglib/wrap/gl/pos.h	/^			static void Draw(VfIteType & v){$/;"	f	struct:vcg::GlVfIterator
Draw	vcglib/wrap/gl/tetramesh.h	/^    void	Draw(){$/;"	f	class:vcg::tetra::GlTetramesh
Draw	vcglib/wrap/gl/trimesh.h	/^void Draw()$/;"	f	class:vcg::GlTrimesh
Draw	vcglib/wrap/gl/trimesh.h	/^void Draw(ColorMode cm, TextureMode tm)$/;"	f	class:vcg::GlTrimesh
Draw	vcglib/wrap/gl/trimesh.h	/^void Draw(DrawMode dm ,ColorMode cm, TextureMode tm)$/;"	f	class:vcg::GlTrimesh
Draw	vcglib/wrap/gl/trimesh.h	/^void Draw(TextureMode tm)$/;"	f	class:vcg::GlTrimesh
Draw	vcglib/wrap/gui/trackmode.cpp	/^void AreaMode::Draw(Trackball * tb)$/;"	f	class:AreaMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void AxisMode::Draw(Trackball * tb){$/;"	f	class:AxisMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void CylinderMode::Draw(Trackball * tb){$/;"	f	class:CylinderMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void InactiveMode::Draw(Trackball * tb){$/;"	f	class:InactiveMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void PanMode::Draw(Trackball * tb){$/;"	f	class:PanMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void PathMode::Draw(Trackball * tb){$/;"	f	class:PathMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void PlaneMode::Draw(Trackball * tb){$/;"	f	class:PlaneMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void PolarMode::Draw(Trackball * tb){$/;"	f	class:PolarMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void ScaleMode::Draw(Trackball * tb){$/;"	f	class:ScaleMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void SphereMode::Draw(Trackball * tb){$/;"	f	class:SphereMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void TrackMode::Draw(Trackball * ){}$/;"	f	class:TrackMode
Draw	vcglib/wrap/gui/trackmode.cpp	/^void ZMode::Draw(Trackball * tb){$/;"	f	class:ZMode
DrawBBox	vcglib/wrap/gl/trimesh.h	/^void DrawBBox(ColorMode cm)$/;"	f	class:vcg::GlTrimesh
DrawCircle	vcglib/wrap/gui/trackutils.h	/^void DrawCircle (bool planehandle=true)$/;"	f	namespace:vcg::trackutils
DrawFill	vcglib/apps/unsupported/shadevis/visshader.h	/^void DrawFill (MESH_TYPE &mm)$/;"	f	class:vcg::VertexVisShader
DrawFill	vcglib/wrap/gl/trimesh.h	/^void DrawFill()$/;"	f	class:vcg::GlTrimesh
DrawFlatWire	vcglib/wrap/gl/trimesh.h	/^void DrawFlatWire()$/;"	f	class:vcg::GlTrimesh
DrawFramebufferBindingParams	vcglib/wrap/glw/framebuffer.h	/^		DrawFramebufferBindingParams(void)$/;"	f	class:glw::DrawFramebufferBindingParams
DrawFramebufferBindingParams	vcglib/wrap/glw/framebuffer.h	/^class DrawFramebufferBindingParams : public FramebufferBindingParams$/;"	c	namespace:glw
DrawHidden	vcglib/wrap/gl/trimesh.h	/^void DrawHidden()$/;"	f	class:vcg::GlTrimesh
DrawLightVector	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void DrawLightVector()$/;"	f
DrawMode	vcglib/apps/sample/trimesh_QT/glarea.h	/^  enum DrawMode{SMOOTH=0,POINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	g	class:GLArea
DrawMode	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^enum DrawMode{SMOOTH=0,PERPOINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	g	file:
DrawMode	vcglib/wrap/gl/addons.h	/^		enum DrawMode  {DMUser,DMWire,DMSolid,DMFlat} ;$/;"	g	class:vcg::Add_Ons
DrawMode	vcglib/wrap/gl/tetramesh.h	/^  enum DrawMode  {DMNone, DMSmallTetra,DMFlat,DMWire, DMHidden,DMTransparent,DMFlatWire} ;$/;"	g	class:vcg::tetra::GLW
DrawMode	vcglib/wrap/gl/trimesh.h	/^    enum DrawMode	{DMNone, DMBox, DMPoints, DMWire, DMHidden, DMFlat, DMSmooth, DMFlatWire, DMRadar, DMLast} ;$/;"	g	class:vcg::GLW
DrawOctree	vcglib/vcg/space/index/octree.h	/^    void DrawOctree(vcg::Box3f &boundingBox, NodePointer n)$/;"	f	namespace:vcg
DrawPlaneHandle	vcglib/wrap/gui/trackutils.h	/^void DrawPlaneHandle ()$/;"	f	namespace:vcg::trackutils
DrawPoints	vcglib/wrap/gl/trimesh.h	/^void DrawPoints()$/;"	f	class:vcg::GlTrimesh
DrawPointsBase	vcglib/wrap/gl/trimesh.h	/^void DrawPointsBase()$/;"	f	class:vcg::GlTrimesh
DrawPolygonMask	vcglib/wrap/qt/Outline2ToQImage.cpp	/^void Outline2Dumper::DrawPolygonMask(const vector< vector<Point2f> > &polyVec,$/;"	f	class:Outline2Dumper
DrawPostApply	vcglib/wrap/gui/trackball.cpp	/^void Trackball::DrawPostApply() {$/;"	f	class:Trackball
DrawRadar	vcglib/wrap/gl/trimesh.h	/^void DrawRadar()$/;"	f	class:vcg::GlTrimesh
DrawSphereIcon	vcglib/wrap/gui/trackutils.h	/^void DrawSphereIcon (Trackball * tb, bool active, bool planeshandle=false)$/;"	f	namespace:vcg::trackutils
DrawTexture_NPV_TPW2	vcglib/wrap/gl/trimesh.h	/^void DrawTexture_NPV_TPW2()$/;"	f	class:vcg::GlTrimesh
DrawTrack	vcglib/wrap/gui/trackutils.h	/^  bool DrawTrack;$/;"	m	class:vcg::trackutils::DrawingHint
DrawUglyAreaMode	vcglib/wrap/gui/trackutils.h	/^void DrawUglyAreaMode(Trackball * tb,const std::vector < Point3f > &points,$/;"	f	namespace:vcg::trackutils
DrawUglyAxisMode	vcglib/wrap/gui/trackutils.h	/^void DrawUglyAxisMode(Trackball * tb,Line3f axis)$/;"	f	namespace:vcg::trackutils
DrawUglyCylinderMode	vcglib/wrap/gui/trackutils.h	/^void DrawUglyCylinderMode(Trackball * tb,Line3f axis)$/;"	f	namespace:vcg::trackutils
DrawUglyLetter	vcglib/wrap/gui/trackutils.h	/^void DrawUglyLetter(Trackball * tb,std::vector<Point3f> ugly_letter)$/;"	f	namespace:vcg::trackutils
DrawUglyPanMode	vcglib/wrap/gui/trackutils.h	/^void DrawUglyPanMode(Trackball * tb)$/;"	f	namespace:vcg::trackutils
DrawUglyPathMode	vcglib/wrap/gui/trackutils.h	/^void DrawUglyPathMode(Trackball * tb,const std::vector < Point3f > &points,$/;"	f	namespace:vcg::trackutils
DrawUglyPlaneMode	vcglib/wrap/gui/trackutils.h	/^void DrawUglyPlaneMode(Trackball * tb,Plane3f plane)$/;"	f	namespace:vcg::trackutils
DrawUglyScaleMode	vcglib/wrap/gui/trackutils.h	/^void DrawUglyScaleMode(Trackball * tb)$/;"	f	namespace:vcg::trackutils
DrawUglyZMode	vcglib/wrap/gui/trackutils.h	/^void DrawUglyZMode(Trackball * tb)$/;"	f	namespace:vcg::trackutils
DrawViewVector	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void DrawViewVector()$/;"	f
DrawWire	vcglib/wrap/gl/trimesh.h	/^void DrawWire()$/;"	f	class:vcg::GlTrimesh
DrawWirePolygonal	vcglib/wrap/gl/trimesh.h	/^void DrawWirePolygonal()$/;"	f	class:vcg::GlTrimesh
DrawingHint	vcglib/wrap/gui/trackutils.h	/^  DrawingHint () {$/;"	f	class:vcg::trackutils::DrawingHint
DrawingHint	vcglib/wrap/gui/trackutils.h	/^class DrawingHint {$/;"	c	namespace:vcg::trackutils
DstFace	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^typedef SrcFace   DstFace;$/;"	t	file:
DstHasDirectAccess	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    DstHasDirectAccess = Derived::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon34
DstHasDirectAccess	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      DstHasDirectAccess = Dst::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
DstIsAligned	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    DstIsAligned = Derived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon34
DstMesh	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^typedef SrcMesh   DstMesh;$/;"	t	file:
DstVertex	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^typedef SrcVertex DstVertex;$/;"	t	file:
DumClass	vcglib/vcg/container/derivation_chain.h	/^class DumClass {};$/;"	c	namespace:vcg
DummyCallBack	vcglib/wrap/callback.h	/^inline bool DummyCallBack( const char * ) {return true;}$/;"	f	namespace:vcg
DummyCallBackPos	vcglib/wrap/callback.h	/^inline bool DummyCallBackPos(const int ,  const char * ) {return true;}$/;"	f	namespace:vcg
DummyContainer	vcglib/vcg/complex/base.h	/^struct DummyContainer{struct value_type{ typedef int IAm;}; };$/;"	s	namespace:vcg::tri
DummyPolarFunctor	vcglib/vcg/math/spherical_harmonics.h	/^class DummyPolarFunctor{$/;"	c	namespace:vcg::math
DummyType	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <int N> struct DummyType{ char placeholder[N]; };$/;"	s	namespace:vcg::tri::io
DummyTypes	vcglib/vcg/complex/used_types.h	/^struct DummyTypes{$/;"	s	namespace:vcg
Dump	vcglib/vcg/complex/algorithms/hole.h	/^  const char * Dump() {$/;"	f	class:vcg::tri::MinimumWeightEar
Dump	vcglib/vcg/complex/algorithms/hole.h	/^  const char * Dump() {return 0;}$/;"	f	class:vcg::tri::TrivialEar
Dump	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void Dump()$/;"	f
Dump	vcglib/vcg/math/old_deprecated_matrix.h	/^			void Dump()$/;"	f	class:vcg::ndim::Matrix
DumpToMem	vcglib/wrap/io_trimesh/export_vmi.h	/^        static int DumpToMem(const SaveMeshType &m,char * ptr){$/;"	f	class:vcg::tri::io::ExporterVMI
DuplicateFaceParam	vcglib/vcg/complex/algorithms/clustering.h	/^  bool DuplicateFaceParam;$/;"	m	class:vcg::tri::Clustering
DuplicateVert_Compare	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^class DuplicateVert_Compare{$/;"	c	file:
DuplicateVertex	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^static int DuplicateVertex( MyMesh & m )    \/\/ V1.0$/;"	f	file:
DynMatrixType	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef Matrix<Scalar, Dynamic, Dynamic, Options, RowsAtCompileTime, ColsAtCompileTime> DynMatrixType;$/;"	t	class:Eigen::MatrixFunction
Dynamic	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const int Dynamic = -1;$/;"	m	namespace:Eigen
DynamicIntVectorType	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef Matrix<Index, Dynamic, 1> DynamicIntVectorType;$/;"	t	class:Eigen::MatrixFunction
DynamicLegendre	vcglib/vcg/math/legendre.h	/^	DynamicLegendre() : _x(2), _sin_theta(2) {}$/;"	f	class:vcg::math::DynamicLegendre
DynamicLegendre	vcglib/vcg/math/legendre.h	/^class DynamicLegendre : public Legendre<ScalarType>$/;"	c	namespace:vcg::math
DynamicSparseMatrix	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED explicit inline DynamicSparseMatrix(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::DynamicSparseMatrix
DynamicSparseMatrix	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED inline DynamicSparseMatrix()$/;"	f	class:Eigen::DynamicSparseMatrix
DynamicSparseMatrix	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED inline DynamicSparseMatrix(Index rows, Index cols)$/;"	f	class:Eigen::DynamicSparseMatrix
DynamicSparseMatrix	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline DynamicSparseMatrix(const DynamicSparseMatrix& other)$/;"	f	class:Eigen::DynamicSparseMatrix
DynamicSparseMatrix	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^ class  DynamicSparseMatrix$/;"	c	namespace:Eigen
DynamicSpatialHashTable	vcglib/vcg/space/index/spatial_hashing.h	/^	class DynamicSpatialHashTable: public SpatialHashTable<ContainerType,FLT>$/;"	c	namespace:vcg
E	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  int E() const {return e;}$/;"	f	class:vcg::tri::BitQuad::Pos
E	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  int& E(){return e;}$/;"	f	class:vcg::tri::BitQuad::Pos
E	vcglib/vcg/connectors/halfedge_pos.h	/^            EdgePointer E()$/;"	f	class:vcg::hedge::Pos
E	vcglib/vcg/simplex/edge/pos.h	/^	VFIEdgeType * &E() { return e;}$/;"	f	class:vcg::edge::VEIterator
E	vcglib/vcg/simplex/edge/pos.h	/^   EDGETYPE  *& E(){ return e; }$/;"	f	class:vcg::edge::Pos
E	vcglib/vcg/simplex/face/pos.h	/^     int         & E(){ return z; }$/;"	f	class:vcg::face::Pos
E	vcglib/vcg/simplex/face/pos.h	/^   int          E() const { return z; }$/;"	f	class:vcg::face::Pos
E	vcglib/vcg/simplex/tetrahedron/pos.h	/^	inline char & E()$/;"	f	class:vcg::tetra::Pos
E	vcglib/vcg/simplex/tetrahedron/pos.h	/^	inline const char & E() const$/;"	f	class:vcg::tetra::Pos
ECI_RGB	vcglib/vcg/space/colorspace.h	/^		ECI_RGB = 8,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
EDGE_AGAINST_TRI_EDGE	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef EDGE_AGAINST_TRI_EDGE$/;"	d
EDGE_AGAINST_TRI_EDGES	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define EDGE_AGAINST_TRI_EDGES(/;"	d
EDGE_EDGE_TEST	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define EDGE_EDGE_TEST(/;"	d
EDGE_EDGE_TEST	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef EDGE_EDGE_TEST$/;"	d
EDGE_SAMPLING	vcglib/apps/metro/sampling.h	/^						EDGE_SAMPLING										= 0x0004,$/;"	e	enum:vcg::SamplingFlags::__anon1
EEAdj	vcglib/vcg/simplex/edge/component.h	/^  EEAdj(){_ep[0]=0;_ep[1]=0;_zp[0]=-1;_zp[1]=-1;}$/;"	f	class:vcg::edge::EEAdj
EEAdj	vcglib/vcg/simplex/edge/component.h	/^template <class T> class EEAdj: public T {$/;"	c	namespace:vcg::edge
EEi	vcglib/vcg/connectors/hedge_component.h	/^  int &EEi(){static int z=0; return z;}$/;"	f	class:vcg::hedge::EmptyHOppAdj
EEi	vcglib/vcg/connectors/hedge_component.h	/^  int &EEi(){static int z=0; return z;}$/;"	f	class:vcg::hedge::EmptyHPrevAdj
EEi	vcglib/vcg/connectors/hedge_component.h	/^  int &EEi(const int & i) {return this->_nei[i]; }$/;"	f	class:vcg::hedge::HPrevAdj
EEi	vcglib/vcg/simplex/edge/component.h	/^    int &EEi(const int &){static int z=0; assert(0); return z;}$/;"	f	class:vcg::edge::EmptyCore
EEi	vcglib/vcg/simplex/edge/component.h	/^  int &EEi(const int & i){ return _zp[i];}$/;"	f	class:vcg::edge::EEAdj
EEp	vcglib/vcg/simplex/edge/component.h	/^    typename T::EdgePointer &EEp(const int &  ) { static typename T::EdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::edge::EmptyCore
EEp	vcglib/vcg/simplex/edge/component.h	/^  typename T::EdgePointer &EEp(const int & i) {return _ep[i]; }$/;"	f	class:vcg::edge::EEAdj
EFAdj	vcglib/vcg/simplex/edge/component.h	/^  EFAdj(){_fp=0;}$/;"	f	class:vcg::edge::EFAdj
EFAdj	vcglib/vcg/simplex/edge/component.h	/^template <class T> class EFAdj: public T {$/;"	c	namespace:vcg::edge
EFAdj	vcglib/vcg/simplex/face/component.h	/^    EFAdj(){$/;"	f	class:vcg::face::EFAdj
EFAdj	vcglib/vcg/simplex/face/component.h	/^template <class T> class EFAdj: public T {$/;"	c	namespace:vcg::face
EFStarFF	vcglib/vcg/simplex/face/topology.h	/^void EFStarFF( FaceType* fp, int ei,$/;"	f	namespace:vcg::face
EFi	vcglib/vcg/connectors/hedge_component.h	/^  int &EFi() {return _zp; }$/;"	f	class:vcg::hedge::HFAdj
EFi	vcglib/vcg/connectors/hedge_component.h	/^  int &EFi(){static int z=0; return z;}$/;"	f	class:vcg::hedge::EmptyHFAdj
EFi	vcglib/vcg/simplex/edge/component.h	/^    int &EFi()   {static int z=0; return z;}$/;"	f	class:vcg::edge::EmptyCore
EFi	vcglib/vcg/simplex/edge/component.h	/^  int &EFi()   {static int z=0; return z;}$/;"	f	class:vcg::edge::EFAdj
EFp	vcglib/vcg/simplex/edge/component.h	/^    typename T::FacePointer &EFp() { static typename T::FacePointer fp=0;  assert(0); return fp; }$/;"	f	class:vcg::edge::EmptyCore
EFp	vcglib/vcg/simplex/edge/component.h	/^  typename T::FacePointer &EFp() {return _fp; }$/;"	f	class:vcg::edge::EFAdj
EFp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer &EFp(const int j)       { assert(j>=0 && j<3);  return _efp[j]; }$/;"	f	class:vcg::face::EFAdj
EHAdj	vcglib/vcg/simplex/edge/component.h	/^  EHAdj(){_hp=0;}$/;"	f	class:vcg::edge::EHAdj
EHAdj	vcglib/vcg/simplex/edge/component.h	/^template <class T> class EHAdj: public T {$/;"	c	namespace:vcg::edge
EHp	vcglib/vcg/simplex/edge/component.h	/^    typename T::HEdgePointer &EHp(  ) { static typename T::HEdgePointer hp=0;  assert(0); return hp; }$/;"	f	class:vcg::edge::EmptyCore
EHp	vcglib/vcg/simplex/edge/component.h	/^  typename T::HEdgePointer &EHp( ) {return _hp ; }$/;"	f	class:vcg::edge::EHAdj
EIGEN2_GEOMETRY_MODULE_H	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define EIGEN2_GEOMETRY_MODULE_H$/;"	d
EIGEN2_LEASTSQUARES_H	vcglib/eigenlib/Eigen/src/Eigen2Support/LeastSquares.h	/^#define EIGEN2_LEASTSQUARES_H$/;"	d
EIGEN2_LU_H	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^#define EIGEN2_LU_H$/;"	d
EIGEN2_MACROS_H	vcglib/eigenlib/Eigen/src/Eigen2Support/Macros.h	/^#define EIGEN2_MACROS_H$/;"	d
EIGEN2_MATH_FUNCTIONS_H	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^#define EIGEN2_MATH_FUNCTIONS_H$/;"	d
EIGEN2_MEMORY_H	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^#define EIGEN2_MEMORY_H$/;"	d
EIGEN2_META_H	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^#define EIGEN2_META_H$/;"	d
EIGEN2_QR_H	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^#define EIGEN2_QR_H$/;"	d
EIGEN2_SVD_H	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^#define EIGEN2_SVD_H$/;"	d
EIGEN2_VECTORBLOCK_H	vcglib/eigenlib/Eigen/src/Eigen2Support/VectorBlock.h	/^#define EIGEN2_VECTORBLOCK_H$/;"	d
EIGEN_ALIGN	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ALIGN /;"	d
EIGEN_ALIGN16	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_ALIGN16 /;"	d
EIGEN_ALIGNEDBOX_H	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^#define EIGEN_ALIGNEDBOX_H$/;"	d
EIGEN_ALIGNED_ALLOCA	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    #define EIGEN_ALIGNED_ALLOCA(/;"	d
EIGEN_ALIGNED_ALLOCATOR	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^  #define EIGEN_ALIGNED_ALLOCATOR /;"	d
EIGEN_ALIGN_128	vcglib/eigenlib/Eigen/src/Eigen2Support/Macros.h	/^#define EIGEN_ALIGN_128 /;"	d
EIGEN_ALIGN_STATICALLY	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ALIGN_STATICALLY /;"	d
EIGEN_ALIGN_TO_BOUNDARY	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ALIGN_TO_BOUNDARY(/;"	d
EIGEN_ALLANDANY_H	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^#define EIGEN_ALLANDANY_H$/;"	d
EIGEN_ALLOCA	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    #define EIGEN_ALLOCA /;"	d
EIGEN_ALWAYS_INLINE	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_ALWAYS_INLINE /;"	d
EIGEN_AMBIVECTOR_H	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^#define EIGEN_AMBIVECTOR_H$/;"	d
EIGEN_ANGLEAXIS_H	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^#define EIGEN_ANGLEAXIS_H$/;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS /;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	vcglib/eigenlib/Eigen/src/Core/arch/Default/Settings.h	/^#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS /;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS /;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS /;"	d
EIGEN_ARCH_WANTS_ALIGNMENT	vcglib/eigenlib/Eigen/src/Eigen2Support/Macros.h	/^#define EIGEN_ARCH_WANTS_ALIGNMENT /;"	d
EIGEN_ARCH_WANTS_STACK_ALIGNMENT	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_WANTS_STACK_ALIGNMENT /;"	d
EIGEN_ARRAYBASE_H	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^#define EIGEN_ARRAYBASE_H$/;"	d
EIGEN_ARRAYWRAPPER_H	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^#define EIGEN_ARRAYWRAPPER_H$/;"	d
EIGEN_ARRAY_CWISE_OPERATORS_H	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^#define EIGEN_ARRAY_CWISE_OPERATORS_H$/;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_EIGEN_UNARY	vcglib/eigenlib/Eigen/src/Core/GlobalFunctions.h	/^#define EIGEN_ARRAY_DECLARE_GLOBAL_EIGEN_UNARY(/;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_STD_UNARY	vcglib/eigenlib/Eigen/src/Core/GlobalFunctions.h	/^#define EIGEN_ARRAY_DECLARE_GLOBAL_STD_UNARY(/;"	d
EIGEN_ARRAY_H	vcglib/eigenlib/Eigen/src/Core/Array.h	/^#define EIGEN_ARRAY_H$/;"	d
EIGEN_ASM_COMMENT	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_ASM_COMMENT(/;"	d
EIGEN_ASSIGN_H	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^#define EIGEN_ASSIGN_H$/;"	d
EIGEN_ASSIGN_VML_H	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_ASSIGN_VML_H$/;"	d
EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^#define EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(/;"	d
EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^#undef EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY$/;"	d
EIGEN_AUTODIFF_JACOBIAN_H	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^#define EIGEN_AUTODIFF_JACOBIAN_H$/;"	d
EIGEN_AUTODIFF_SCALAR_H	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^#define EIGEN_AUTODIFF_SCALAR_H$/;"	d
EIGEN_AUTODIFF_VECTOR_H	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^#define EIGEN_AUTODIFF_VECTOR_H$/;"	d
EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  #define EIGEN_AVOID_CUSTOM_UNALIGNED_LOADS /;"	d
EIGEN_BANDMATRIX_H	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^#define EIGEN_BANDMATRIX_H$/;"	d
EIGEN_BASIC_PRECONDITIONERS_H	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^#define EIGEN_BASIC_PRECONDITIONERS_H$/;"	d
EIGEN_BICGSTAB_H	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^#define EIGEN_BICGSTAB_H$/;"	d
EIGEN_BIDIAGONALIZATION_H	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^#define EIGEN_BIDIAGONALIZATION_H$/;"	d
EIGEN_BLASUTIL_H	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^#define EIGEN_BLASUTIL_H$/;"	d
EIGEN_BLOCK2_H	vcglib/eigenlib/Eigen/src/Eigen2Support/Block.h	/^#define EIGEN_BLOCK2_H$/;"	d
EIGEN_BLOCKMETHODS_H	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^#define EIGEN_BLOCKMETHODS_H$/;"	d
EIGEN_BLOCK_H	vcglib/eigenlib/Eigen/src/Core/Block.h	/^#define EIGEN_BLOCK_H$/;"	d
EIGEN_BLOCK_HOUSEHOLDER_H	vcglib/eigenlib/Eigen/src/Householder/BlockHouseholder.h	/^#define EIGEN_BLOCK_HOUSEHOLDER_H$/;"	d
EIGEN_BROWSE_MATRICES_H	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^#define EIGEN_BROWSE_MATRICES_H$/;"	d
EIGEN_BVALGORITHMS_H	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^#define EIGEN_BVALGORITHMS_H$/;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD /;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	vcglib/eigenlib/Eigen/src/Core/arch/Default/Settings.h	/^#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD /;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD /;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD /;"	d
EIGEN_CAT	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_CAT(/;"	d
EIGEN_CAT2	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_CAT2(/;"	d
EIGEN_CHECK_BINARY_COMPATIBILIY	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^#define EIGEN_CHECK_BINARY_COMPATIBILIY(/;"	d
EIGEN_CHOLMODSUPPORT_H	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^#define EIGEN_CHOLMODSUPPORT_H$/;"	d
EIGEN_COEFFBASED_PRODUCT_H	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^#define EIGEN_COEFFBASED_PRODUCT_H$/;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_H	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^#define EIGEN_COLPIVOTINGHOUSEHOLDERQR_H$/;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_MKL_H	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR_MKL.h	/^#define EIGEN_COLPIVOTINGHOUSEHOLDERQR_MKL_H$/;"	d
EIGEN_COMMAINITIALIZER_H	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^#define EIGEN_COMMAINITIALIZER_H$/;"	d
EIGEN_COMPANION_H	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^#define EIGEN_COMPANION_H$/;"	d
EIGEN_COMPLEX_ALTIVEC_H	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^#define EIGEN_COMPLEX_ALTIVEC_H$/;"	d
EIGEN_COMPLEX_EIGEN_SOLVER_H	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^#define EIGEN_COMPLEX_EIGEN_SOLVER_H$/;"	d
EIGEN_COMPLEX_NEON_H	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^#define EIGEN_COMPLEX_NEON_H$/;"	d
EIGEN_COMPLEX_SCHUR_H	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^#define EIGEN_COMPLEX_SCHUR_H$/;"	d
EIGEN_COMPLEX_SCHUR_MKL_H	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur_MKL.h	/^#define EIGEN_COMPLEX_SCHUR_MKL_H$/;"	d
EIGEN_COMPLEX_SSE_H	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^#define EIGEN_COMPLEX_SSE_H$/;"	d
EIGEN_COMPRESSED_STORAGE_H	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^#define EIGEN_COMPRESSED_STORAGE_H$/;"	d
EIGEN_CONJUGATE_GRADIENT_H	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^#define EIGEN_CONJUGATE_GRADIENT_H$/;"	d
EIGEN_CONSERVATIVESPARSESPARSEPRODUCT_H	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^#define EIGEN_CONSERVATIVESPARSESPARSEPRODUCT_H$/;"	d
EIGEN_CONSTANTS_H	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^#define EIGEN_CONSTANTS_H$/;"	d
EIGEN_CONSTRAINEDCG_H	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h	/^#define EIGEN_CONSTRAINEDCG_H$/;"	d
EIGEN_COREITERATORS_H	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^#define EIGEN_COREITERATORS_H$/;"	d
EIGEN_CPUID	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^#      define EIGEN_CPUID(/;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^#define EIGEN_CURRENT_STORAGE_BASE_CLASS /;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^#undef EIGEN_CURRENT_STORAGE_BASE_CLASS$/;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^#define EIGEN_CURRENT_STORAGE_BASE_CLASS /;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^#undef EIGEN_CURRENT_STORAGE_BASE_CLASS$/;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^#define EIGEN_CURRENT_STORAGE_BASE_CLASS /;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^#undef EIGEN_CURRENT_STORAGE_BASE_CLASS$/;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^#   undef EIGEN_CURRENT_STORAGE_BASE_CLASS$/;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^#define EIGEN_CURRENT_STORAGE_BASE_CLASS /;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^#undef EIGEN_CURRENT_STORAGE_BASE_CLASS$/;"	d
EIGEN_CWISE_BINARY_OP_H	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^#define EIGEN_CWISE_BINARY_OP_H$/;"	d
EIGEN_CWISE_BINOP_RETURN_TYPE	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^#define EIGEN_CWISE_BINOP_RETURN_TYPE(/;"	d
EIGEN_CWISE_COMP_TO_SCALAR_RETURN_TYPE	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^#define EIGEN_CWISE_COMP_TO_SCALAR_RETURN_TYPE(/;"	d
EIGEN_CWISE_H	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^#define EIGEN_CWISE_H$/;"	d
EIGEN_CWISE_NULLARY_OP_H	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^#define EIGEN_CWISE_NULLARY_OP_H$/;"	d
EIGEN_CWISE_PRODUCT_RETURN_TYPE	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_CWISE_PRODUCT_RETURN_TYPE(/;"	d
EIGEN_CWISE_UNARY_OP_H	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^#define EIGEN_CWISE_UNARY_OP_H$/;"	d
EIGEN_CWISE_UNARY_VIEW_H	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^#define EIGEN_CWISE_UNARY_VIEW_H$/;"	d
EIGEN_CWISE_UNOP_RETURN_TYPE	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^#define EIGEN_CWISE_UNOP_RETURN_TYPE(/;"	d
EIGEN_DBG_SKYLINE	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^#define EIGEN_DBG_SKYLINE(/;"	d
EIGEN_DBG_SPARSE	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_DBG_SPARSE(/;"	d
EIGEN_DEBUG_ALIGNED_LOAD	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^#define EIGEN_DEBUG_ALIGNED_LOAD$/;"	d
EIGEN_DEBUG_ALIGNED_STORE	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^#define EIGEN_DEBUG_ALIGNED_STORE$/;"	d
EIGEN_DEBUG_UNALIGNED_LOAD	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^#define EIGEN_DEBUG_UNALIGNED_LOAD$/;"	d
EIGEN_DEBUG_UNALIGNED_STORE	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^#define EIGEN_DEBUG_UNALIGNED_STORE$/;"	d
EIGEN_DEBUG_VAR	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_DEBUG_VAR(/;"	d
EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS$/;"	d
EIGEN_DEFAULT_DENSE_INDEX_TYPE	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_DEFAULT_DENSE_INDEX_TYPE /;"	d
EIGEN_DEFAULT_IO_FORMAT	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_DEFAULT_IO_FORMAT /;"	d
EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION /;"	d
EIGEN_DEFAULT_SETTINGS_H	vcglib/eigenlib/Eigen/src/Core/arch/Default/Settings.h	/^#define EIGEN_DEFAULT_SETTINGS_H$/;"	d
EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS /;"	d
EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^#define EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION(/;"	d
EIGEN_DEFINE_STL_LIST_SPECIALIZATION	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^#define EIGEN_DEFINE_STL_LIST_SPECIALIZATION(/;"	d
EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^#define EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION(/;"	d
EIGEN_DENSEBASE_H	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^#define EIGEN_DENSEBASE_H$/;"	d
EIGEN_DENSECOEFFSBASE_H	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^#define EIGEN_DENSECOEFFSBASE_H$/;"	d
EIGEN_DENSESTORAGEBASE_H	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^#define EIGEN_DENSESTORAGEBASE_H$/;"	d
EIGEN_DENSE_PUBLIC_INTERFACE	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_DENSE_PUBLIC_INTERFACE(/;"	d
EIGEN_DEPRECATED	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^    #define EIGEN_DEPRECATED /;"	d
EIGEN_DETERMINANT_H	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^#define EIGEN_DETERMINANT_H$/;"	d
EIGEN_DIAGONALMATRIX_H	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^#define EIGEN_DIAGONALMATRIX_H$/;"	d
EIGEN_DIAGONALPRODUCT_H	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^#define EIGEN_DIAGONALPRODUCT_H$/;"	d
EIGEN_DIAGONAL_H	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^#define EIGEN_DIAGONAL_H$/;"	d
EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^    #define EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT$/;"	d
EIGEN_DONT_ALIGN_STATICALLY	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^    #define EIGEN_DONT_ALIGN_STATICALLY$/;"	d
EIGEN_DONT_INLINE	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_DONT_INLINE /;"	d
EIGEN_DONT_INLINE	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_DONT_INLINE$/;"	d
EIGEN_DOT_H	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^#define EIGEN_DOT_H$/;"	d
EIGEN_DYNAMIC_SPARSEMATRIX_H	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^#define EIGEN_DYNAMIC_SPARSEMATRIX_H$/;"	d
EIGEN_EIGENBASE_H	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^#define EIGEN_EIGENBASE_H$/;"	d
EIGEN_EIGENSOLVER_H	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^#define EIGEN_EIGENSOLVER_H$/;"	d
EIGEN_EMPTY	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_EMPTY$/;"	d
EIGEN_EMPTY_STRUCT_CTOR	vcglib/eigenlib/Eigen/src/Core/util/XprHelper.h	/^  #define EIGEN_EMPTY_STRUCT_CTOR(/;"	d
EIGEN_EULERANGLES_H	vcglib/eigenlib/Eigen/src/Geometry/EulerAngles.h	/^#define EIGEN_EULERANGLES_H$/;"	d
EIGEN_EXPLICIT_STL_DEQUE_INSTANTIATION	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^  #define EIGEN_EXPLICIT_STL_DEQUE_INSTANTIATION(/;"	d
EIGEN_EXPLICIT_STL_LIST_INSTANTIATION	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^  #define EIGEN_EXPLICIT_STL_LIST_INSTANTIATION(/;"	d
EIGEN_FAST_MATH	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_FAST_MATH /;"	d
EIGEN_FLAGGED_H	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^#define EIGEN_FLAGGED_H$/;"	d
EIGEN_FLATTEN_ATTRIB	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_FLATTEN_ATTRIB /;"	d
EIGEN_FLATTEN_ATTRIB	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_FLATTEN_ATTRIB$/;"	d
EIGEN_FORCEALIGNEDACCESS_H	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^#define EIGEN_FORCEALIGNEDACCESS_H$/;"	d
EIGEN_FORWARDDECLARATIONS_H	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^#define EIGEN_FORWARDDECLARATIONS_H$/;"	d
EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^  #define EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED /;"	d
EIGEN_FULLPIVOTINGHOUSEHOLDERQR_H	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^#define EIGEN_FULLPIVOTINGHOUSEHOLDERQR_H$/;"	d
EIGEN_FUNCTORS_H	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^#define EIGEN_FUNCTORS_H$/;"	d
EIGEN_FUZZY_H	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^#define EIGEN_FUZZY_H$/;"	d
EIGEN_GCC3_OR_OLDER	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_GCC3_OR_OLDER /;"	d
EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT /;"	d
EIGEN_GENERALIZEDSELFADJOINTEIGENSOLVER_H	vcglib/eigenlib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^#define EIGEN_GENERALIZEDSELFADJOINTEIGENSOLVER_H$/;"	d
EIGEN_GENERAL_BLOCK_PANEL_H	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^#define EIGEN_GENERAL_BLOCK_PANEL_H$/;"	d
EIGEN_GENERAL_MATRIX_MATRIX_H	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^#define EIGEN_GENERAL_MATRIX_MATRIX_H$/;"	d
EIGEN_GENERAL_MATRIX_MATRIX_MKL_H	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^#define EIGEN_GENERAL_MATRIX_MATRIX_MKL_H$/;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_H	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^#define EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_H$/;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_MKL_H	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^#define EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_MKL_H$/;"	d
EIGEN_GENERAL_MATRIX_VECTOR_H	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^#define EIGEN_GENERAL_MATRIX_VECTOR_H$/;"	d
EIGEN_GENERAL_MATRIX_VECTOR_MKL_H	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^#define EIGEN_GENERAL_MATRIX_VECTOR_MKL_H$/;"	d
EIGEN_GENERAL_PRODUCT_H	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^#define EIGEN_GENERAL_PRODUCT_H$/;"	d
EIGEN_GENERIC_PACKET_MATH_H	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^#define EIGEN_GENERIC_PACKET_MATH_H$/;"	d
EIGEN_GENERIC_PUBLIC_INTERFACE	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_GENERIC_PUBLIC_INTERFACE(/;"	d
EIGEN_GEOMETRY_SSE_H	vcglib/eigenlib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^#define EIGEN_GEOMETRY_SSE_H$/;"	d
EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^  #define EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED /;"	d
EIGEN_GLOBAL_FUNCTIONS_H	vcglib/eigenlib/Eigen/src/Core/GlobalFunctions.h	/^#define EIGEN_GLOBAL_FUNCTIONS_H$/;"	d
EIGEN_GMRES_H	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^#define EIGEN_GMRES_H$/;"	d
EIGEN_GNUC_AT_LEAST	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^  #define EIGEN_GNUC_AT_LEAST(/;"	d
EIGEN_GNUC_AT_MOST	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^  #define EIGEN_GNUC_AT_MOST(/;"	d
EIGEN_HAS_FUSE_CJMADD	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define EIGEN_HAS_FUSE_CJMADD /;"	d
EIGEN_HAS_MM_MALLOC	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^  #define EIGEN_HAS_MM_MALLOC /;"	d
EIGEN_HAS_POSIX_MEMALIGN	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^  #define EIGEN_HAS_POSIX_MEMALIGN /;"	d
EIGEN_HESSENBERGDECOMPOSITION_H	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^#define EIGEN_HESSENBERGDECOMPOSITION_H$/;"	d
EIGEN_HOMOGENEOUS_H	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^#define EIGEN_HOMOGENEOUS_H$/;"	d
EIGEN_HOUSEHOLDER_H	vcglib/eigenlib/Eigen/src/Householder/Householder.h	/^#define EIGEN_HOUSEHOLDER_H$/;"	d
EIGEN_HOUSEHOLDER_SEQUENCE_H	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^#define EIGEN_HOUSEHOLDER_SEQUENCE_H$/;"	d
EIGEN_HYBRIDNONLINEARSOLVER_H	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^#define EIGEN_HYBRIDNONLINEARSOLVER_H$/;"	d
EIGEN_HYPERPLANE_H	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^#define EIGEN_HYPERPLANE_H$/;"	d
EIGEN_IMPLIES	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_IMPLIES(/;"	d
EIGEN_INCOMPLETE_LUT_H	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^#define EIGEN_INCOMPLETE_LUT_H$/;"	d
EIGEN_INCOMPLETE_LU_H	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^#define EIGEN_INCOMPLETE_LU_H$/;"	d
EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR(/;"	d
EIGEN_INHERIT_ASSIGNMENT_OPERATORS	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_INHERIT_ASSIGNMENT_OPERATORS(/;"	d
EIGEN_INITIALIZE_BY_ZERO_IF_THAT_OPTION_IS_ENABLED	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^# define EIGEN_INITIALIZE_BY_ZERO_IF_THAT_OPTION_IS_ENABLED /;"	d
EIGEN_INITIALIZE_BY_ZERO_IF_THAT_OPTION_IS_ENABLED	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^# define EIGEN_INITIALIZE_BY_ZERO_IF_THAT_OPTION_IS_ENABLED$/;"	d
EIGEN_INIT_NEON_PACKET2	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^  #define EIGEN_INIT_NEON_PACKET2(/;"	d
EIGEN_INIT_NEON_PACKET4	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^  #define EIGEN_INIT_NEON_PACKET4(/;"	d
EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^  #define EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN /;"	d
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^  #define EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN$/;"	d
EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
EIGEN_INVERSE_H	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^#define EIGEN_INVERSE_H$/;"	d
EIGEN_INVERSE_SSE_H	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^#define EIGEN_INVERSE_SSE_H$/;"	d
EIGEN_IO_H	vcglib/eigenlib/Eigen/src/Core/IO.h	/^#define EIGEN_IO_H$/;"	d
EIGEN_ITERATION_CONTROLLER_H	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^#define EIGEN_ITERATION_CONTROLLER_H$/;"	d
EIGEN_ITERATIVE_SOLVER_BASE_H	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^#define EIGEN_ITERATIVE_SOLVER_BASE_H$/;"	d
EIGEN_JACOBISVD_H	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^#define EIGEN_JACOBISVD_H$/;"	d
EIGEN_JACOBISVD_MKL_H	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD_MKL.h	/^#define EIGEN_JACOBISVD_MKL_H$/;"	d
EIGEN_JACOBI_H	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^#define EIGEN_JACOBI_H$/;"	d
EIGEN_LAZY_H	vcglib/eigenlib/Eigen/src/Eigen2Support/Lazy.h	/^#define EIGEN_LAZY_H$/;"	d
EIGEN_LDLT_H	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^#define EIGEN_LDLT_H$/;"	d
EIGEN_LEVENBERGMARQUARDT__H	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^#define EIGEN_LEVENBERGMARQUARDT__H$/;"	d
EIGEN_LLT_H	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^#define EIGEN_LLT_H$/;"	d
EIGEN_LLT_MKL_H	vcglib/eigenlib/Eigen/src/Cholesky/LLT_MKL.h	/^#define EIGEN_LLT_MKL_H$/;"	d
EIGEN_LOGICAL_XOR	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_LOGICAL_XOR(/;"	d
EIGEN_LU_H	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^#define EIGEN_LU_H$/;"	d
EIGEN_MACROS_H	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_MACROS_H$/;"	d
EIGEN_MAJOR_VERSION	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_MAJOR_VERSION /;"	d
EIGEN_MAKESTRING	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_MAKESTRING(/;"	d
EIGEN_MAKESTRING2	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_MAKESTRING2(/;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW /;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^  #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(/;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE(/;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW(/;"	d
EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS	vcglib/eigenlib/Eigen/src/Core/Array.h	/^#define EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS(/;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	vcglib/eigenlib/Eigen/src/Core/Array.h	/^#define EIGEN_MAKE_ARRAY_TYPEDEFS(/;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	vcglib/eigenlib/Eigen/src/Core/Array.h	/^#undef EIGEN_MAKE_ARRAY_TYPEDEFS$/;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	vcglib/eigenlib/Eigen/src/Core/Array.h	/^#define EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES(/;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	vcglib/eigenlib/Eigen/src/Core/Array.h	/^#undef EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES$/;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_LARGE	vcglib/eigenlib/Eigen/src/Core/Array.h	/^#undef EIGEN_MAKE_ARRAY_TYPEDEFS_LARGE$/;"	d
EIGEN_MAKE_CWISE_BINARY_OP	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_MAKE_CWISE_BINARY_OP(/;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^#define EIGEN_MAKE_FIXED_TYPEDEFS(/;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^#undef EIGEN_MAKE_FIXED_TYPEDEFS$/;"	d
EIGEN_MAKE_IMAGE_HELPERS	vcglib/eigenlib/Eigen/src/misc/Image.h	/^#define EIGEN_MAKE_IMAGE_HELPERS(/;"	d
EIGEN_MAKE_KERNEL_HELPERS	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^#define EIGEN_MAKE_KERNEL_HELPERS(/;"	d
EIGEN_MAKE_SCALAR_CWISE_UNARY_OP	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^#define EIGEN_MAKE_SCALAR_CWISE_UNARY_OP(/;"	d
EIGEN_MAKE_SOLVE_HELPERS	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^#define EIGEN_MAKE_SOLVE_HELPERS(/;"	d
EIGEN_MAKE_SPARSE_SOLVE_HELPERS	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^#define EIGEN_MAKE_SPARSE_SOLVE_HELPERS(/;"	d
EIGEN_MAKE_TYPEDEFS	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^#define EIGEN_MAKE_TYPEDEFS(/;"	d
EIGEN_MAKE_TYPEDEFS	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^#undef EIGEN_MAKE_TYPEDEFS$/;"	d
EIGEN_MAKE_TYPEDEFS	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^#define EIGEN_MAKE_TYPEDEFS(/;"	d
EIGEN_MAKE_TYPEDEFS	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^#undef EIGEN_MAKE_TYPEDEFS$/;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^#define EIGEN_MAKE_TYPEDEFS_ALL_SIZES(/;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^#undef EIGEN_MAKE_TYPEDEFS_ALL_SIZES$/;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^#define EIGEN_MAKE_TYPEDEFS_ALL_SIZES(/;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^#undef EIGEN_MAKE_TYPEDEFS_ALL_SIZES$/;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^  #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(/;"	d
EIGEN_MALLOC_ALREADY_ALIGNED	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^  #define EIGEN_MALLOC_ALREADY_ALIGNED /;"	d
EIGEN_MAPBASE_H	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^#define EIGEN_MAPBASE_H$/;"	d
EIGEN_MAPPED_SPARSEMATRIX_H	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^#define EIGEN_MAPPED_SPARSEMATRIX_H$/;"	d
EIGEN_MAP_H	vcglib/eigenlib/Eigen/src/Core/Map.h	/^#define EIGEN_MAP_H$/;"	d
EIGEN_MATHFUNCTIONS_H	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^#define EIGEN_MATHFUNCTIONS_H$/;"	d
EIGEN_MATHFUNC_IMPL	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^#define EIGEN_MATHFUNC_IMPL(/;"	d
EIGEN_MATHFUNC_RETVAL	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^#define EIGEN_MATHFUNC_RETVAL(/;"	d
EIGEN_MATHFUNC_STANDARD_REAL_UNARY	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^#define EIGEN_MATHFUNC_STANDARD_REAL_UNARY(/;"	d
EIGEN_MATH_FUNCTIONS_SSE_H	vcglib/eigenlib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^#define EIGEN_MATH_FUNCTIONS_SSE_H$/;"	d
EIGEN_MATRIXBASEEIGENVALUES_H	vcglib/eigenlib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^#define EIGEN_MATRIXBASEEIGENVALUES_H$/;"	d
EIGEN_MATRIXBASE_H	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^#define EIGEN_MATRIXBASE_H$/;"	d
EIGEN_MATRIXBASE_PLUGIN	vcglib/vcg/math/eigen.h	/^#define EIGEN_MATRIXBASE_PLUGIN /;"	d
EIGEN_MATRIXSTORAGE_H	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^#define EIGEN_MATRIXSTORAGE_H$/;"	d
EIGEN_MATRIX_EXPONENTIAL	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^#define EIGEN_MATRIX_EXPONENTIAL$/;"	d
EIGEN_MATRIX_FUNCTION	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^#define EIGEN_MATRIX_FUNCTION$/;"	d
EIGEN_MATRIX_FUNCTION_ATOMIC	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^#define EIGEN_MATRIX_FUNCTION_ATOMIC$/;"	d
EIGEN_MATRIX_H	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^#define EIGEN_MATRIX_H$/;"	d
EIGEN_MATRIX_LOGARITHM	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^#define EIGEN_MATRIX_LOGARITHM$/;"	d
EIGEN_MATRIX_PLUGIN	vcglib/vcg/math/eigen.h	/^#define EIGEN_MATRIX_PLUGIN /;"	d
EIGEN_MATRIX_SQUARE_ROOT	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^#define EIGEN_MATRIX_SQUARE_ROOT$/;"	d
EIGEN_MEMBER_FUNCTOR	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^#define EIGEN_MEMBER_FUNCTOR(/;"	d
EIGEN_MEMORY_H	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^#define EIGEN_MEMORY_H$/;"	d
EIGEN_META_H	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^#define EIGEN_META_H$/;"	d
EIGEN_MINOR_H	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^#define EIGEN_MINOR_H$/;"	d
EIGEN_MINOR_VERSION	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_MINOR_VERSION /;"	d
EIGEN_MISC_IMAGE_H	vcglib/eigenlib/Eigen/src/misc/Image.h	/^#define EIGEN_MISC_IMAGE_H$/;"	d
EIGEN_MISC_KERNEL_H	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^#define EIGEN_MISC_KERNEL_H$/;"	d
EIGEN_MISC_SOLVE_H	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^#define EIGEN_MISC_SOLVE_H$/;"	d
EIGEN_MKL_EIG_SELFADJ	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	/^#define EIGEN_MKL_EIG_SELFADJ(/;"	d
EIGEN_MKL_GEMV_SPECIALIZATION	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^#define EIGEN_MKL_GEMV_SPECIALIZATION(/;"	d
EIGEN_MKL_GEMV_SPECIALIZE	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^#define EIGEN_MKL_GEMV_SPECIALIZE(/;"	d
EIGEN_MKL_HEMM_L	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^#define EIGEN_MKL_HEMM_L(/;"	d
EIGEN_MKL_HEMM_R	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^#define EIGEN_MKL_HEMM_R(/;"	d
EIGEN_MKL_LLT	vcglib/eigenlib/Eigen/src/Cholesky/LLT_MKL.h	/^#define EIGEN_MKL_LLT(/;"	d
EIGEN_MKL_LU_PARTPIV	vcglib/eigenlib/Eigen/src/LU/PartialPivLU_MKL.h	/^#define EIGEN_MKL_LU_PARTPIV(/;"	d
EIGEN_MKL_QR_COLPIV	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR_MKL.h	/^#define EIGEN_MKL_QR_COLPIV(/;"	d
EIGEN_MKL_QR_NOPIV	vcglib/eigenlib/Eigen/src/QR/HouseholderQR_MKL.h	/^#define EIGEN_MKL_QR_NOPIV(/;"	d
EIGEN_MKL_RANKUPDATE_C	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^#define EIGEN_MKL_RANKUPDATE_C(/;"	d
EIGEN_MKL_RANKUPDATE_R	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^#define EIGEN_MKL_RANKUPDATE_R(/;"	d
EIGEN_MKL_RANKUPDATE_SPECIALIZE	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^#define EIGEN_MKL_RANKUPDATE_SPECIALIZE(/;"	d
EIGEN_MKL_SCHUR_COMPLEX	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur_MKL.h	/^#define EIGEN_MKL_SCHUR_COMPLEX(/;"	d
EIGEN_MKL_SCHUR_REAL	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur_MKL.h	/^#define EIGEN_MKL_SCHUR_REAL(/;"	d
EIGEN_MKL_SUPPORT_H	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^#define EIGEN_MKL_SUPPORT_H$/;"	d
EIGEN_MKL_SVD	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD_MKL.h	/^#define EIGEN_MKL_SVD(/;"	d
EIGEN_MKL_SYMM_L	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^#define EIGEN_MKL_SYMM_L(/;"	d
EIGEN_MKL_SYMM_R	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^#define EIGEN_MKL_SYMM_R(/;"	d
EIGEN_MKL_SYMV_SPECIALIZATION	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^#define EIGEN_MKL_SYMV_SPECIALIZATION(/;"	d
EIGEN_MKL_SYMV_SPECIALIZE	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^#define EIGEN_MKL_SYMV_SPECIALIZE(/;"	d
EIGEN_MKL_TRMM_L	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^#define EIGEN_MKL_TRMM_L(/;"	d
EIGEN_MKL_TRMM_R	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^#define EIGEN_MKL_TRMM_R(/;"	d
EIGEN_MKL_TRMM_SPECIALIZE	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^#define EIGEN_MKL_TRMM_SPECIALIZE(/;"	d
EIGEN_MKL_TRMV_CM	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^#define EIGEN_MKL_TRMV_CM(/;"	d
EIGEN_MKL_TRMV_RM	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^#define EIGEN_MKL_TRMV_RM(/;"	d
EIGEN_MKL_TRMV_SPECIALIZE	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^#define EIGEN_MKL_TRMV_SPECIALIZE(/;"	d
EIGEN_MKL_TRSM_L	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^#define EIGEN_MKL_TRSM_L(/;"	d
EIGEN_MKL_TRSM_R	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^#define EIGEN_MKL_TRSM_R(/;"	d
EIGEN_MKL_VML_DECLARE_POW_CALL	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_POW_CALL(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALL	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALL(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX_LA	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX_LA(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_LA	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_LA(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL_LA	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL_LA(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALL_LA	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALL_LA(/;"	d
EIGEN_MKL_VML_MODE	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define  EIGEN_MKL_VML_MODE /;"	d
EIGEN_MKL_VML_SPECIALIZE_ASSIGN	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_SPECIALIZE_ASSIGN(/;"	d
EIGEN_MKL_VML_THRESHOLD	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^#define EIGEN_MKL_VML_THRESHOLD /;"	d
EIGEN_MOREVECTORIZATION_MATHFUNCTIONS_H	vcglib/eigenlib/unsupported/Eigen/src/MoreVectorization/MathFunctions.h	/^#define EIGEN_MOREVECTORIZATION_MATHFUNCTIONS_H$/;"	d
EIGEN_NESTBYVALUE_H	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^#define EIGEN_NESTBYVALUE_H$/;"	d
EIGEN_NOALIAS_H	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^#define EIGEN_NOALIAS_H$/;"	d
EIGEN_NO_DEBUG	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#  define EIGEN_NO_DEBUG$/;"	d
EIGEN_NO_DEPRECATED_WARNING	vcglib/eigenlib/unsupported/test/sparse_extra.cpp	/^#define EIGEN_NO_DEPRECATED_WARNING$/;"	d	file:
EIGEN_NUMERICAL_DIFF_H	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^#define EIGEN_NUMERICAL_DIFF_H$/;"	d
EIGEN_NUMTRAITS_H	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^#define EIGEN_NUMTRAITS_H$/;"	d
EIGEN_ONLY_USED_FOR_DEBUG	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_ONLY_USED_FOR_DEBUG(/;"	d
EIGEN_ORTHOMETHODS_H	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^#define EIGEN_ORTHOMETHODS_H$/;"	d
EIGEN_PACKET_MATH_ALTIVEC_H	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define EIGEN_PACKET_MATH_ALTIVEC_H$/;"	d
EIGEN_PACKET_MATH_NEON_H	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^#define EIGEN_PACKET_MATH_NEON_H$/;"	d
EIGEN_PACKET_MATH_SSE_H	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define EIGEN_PACKET_MATH_SSE_H$/;"	d
EIGEN_PARALLELIZER_H	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^#define EIGEN_PARALLELIZER_H$/;"	d
EIGEN_PARAMETRIZEDLINE_H	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^#define EIGEN_PARAMETRIZEDLINE_H$/;"	d
EIGEN_PARDISOSUPPORT_H	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^#define EIGEN_PARDISOSUPPORT_H$/;"	d
EIGEN_PARTIALLU_H	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^#define EIGEN_PARTIALLU_H$/;"	d
EIGEN_PARTIALLU_LAPACK_H	vcglib/eigenlib/Eigen/src/LU/PartialPivLU_MKL.h	/^#define EIGEN_PARTIALLU_LAPACK_H$/;"	d
EIGEN_PARTIAL_REDUX_H	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^#define EIGEN_PARTIAL_REDUX_H$/;"	d
EIGEN_PASTIXSUPPORT_H	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^#define EIGEN_PASTIXSUPPORT_H$/;"	d
EIGEN_PERMUTATIONMATRIX_H	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^#define EIGEN_PERMUTATIONMATRIX_H$/;"	d
EIGEN_PLAIN_ENUM_MAX	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_PLAIN_ENUM_MAX(/;"	d
EIGEN_PLAIN_ENUM_MIN	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_PLAIN_ENUM_MIN(/;"	d
EIGEN_POLYNOMIAL_SOLVER_BASE_INHERITED_TYPES	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^#define EIGEN_POLYNOMIAL_SOLVER_BASE_INHERITED_TYPES(/;"	d
EIGEN_POLYNOMIAL_SOLVER_H	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^#define EIGEN_POLYNOMIAL_SOLVER_H$/;"	d
EIGEN_POLYNOMIAL_UTILS_H	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^#define EIGEN_POLYNOMIAL_UTILS_H$/;"	d
EIGEN_PREDICATE_SAME_MATRIX_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_PREDICATE_SAME_MATRIX_SIZE(/;"	d
EIGEN_PRODUCTBASE_H	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^#define EIGEN_PRODUCTBASE_H$/;"	d
EIGEN_PRODUCT_H	vcglib/eigenlib/Eigen/src/Core/Product.h	/^#define EIGEN_PRODUCT_H$/;"	d
EIGEN_PRODUCT_PUBLIC_INTERFACE	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^#define EIGEN_PRODUCT_PUBLIC_INTERFACE(/;"	d
EIGEN_QR_H	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^#define EIGEN_QR_H$/;"	d
EIGEN_QR_MKL_H	vcglib/eigenlib/Eigen/src/QR/HouseholderQR_MKL.h	/^#define EIGEN_QR_MKL_H$/;"	d
EIGEN_QUATERNION_H	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^#define EIGEN_QUATERNION_H$/;"	d
EIGEN_RANDOMSETTER_H	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^#define EIGEN_RANDOMSETTER_H$/;"	d
EIGEN_RANDOM_H	vcglib/eigenlib/Eigen/src/Core/Random.h	/^#define EIGEN_RANDOM_H$/;"	d
EIGEN_REAL_SCHUR_H	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^#define EIGEN_REAL_SCHUR_H$/;"	d
EIGEN_REAL_SCHUR_MKL_H	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur_MKL.h	/^#define EIGEN_REAL_SCHUR_MKL_H$/;"	d
EIGEN_REDUX_H	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^#define EIGEN_REDUX_H$/;"	d
EIGEN_REPLICATE_H	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^#define EIGEN_REPLICATE_H$/;"	d
EIGEN_RESTRICT	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^  #define EIGEN_RESTRICT /;"	d
EIGEN_RESTRICT	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^  #define EIGEN_RESTRICT$/;"	d
EIGEN_RETURNBYVALUE_H	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^#define EIGEN_RETURNBYVALUE_H$/;"	d
EIGEN_REVERSE_H	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^#define EIGEN_REVERSE_H$/;"	d
EIGEN_ROTATION2D_H	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^#define EIGEN_ROTATION2D_H$/;"	d
EIGEN_ROTATIONBASE_H	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^#define EIGEN_ROTATIONBASE_H$/;"	d
EIGEN_SAEIGENSOLVER_MKL_H	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	/^#define EIGEN_SAEIGENSOLVER_MKL_H$/;"	d
EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^  #define EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO /;"	d
EIGEN_SCALING_H	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^#define EIGEN_SCALING_H$/;"	d
EIGEN_SCALING_H	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^#define EIGEN_SCALING_H$/;"	d
EIGEN_SELECT_H	vcglib/eigenlib/Eigen/src/Core/Select.h	/^#define EIGEN_SELECT_H$/;"	d
EIGEN_SELFADJOINTEIGENSOLVER_H	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^#define EIGEN_SELFADJOINTEIGENSOLVER_H$/;"	d
EIGEN_SELFADJOINTMATRIX_H	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^#define EIGEN_SELFADJOINTMATRIX_H$/;"	d
EIGEN_SELFADJOINTRANK2UPTADE_H	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^#define EIGEN_SELFADJOINTRANK2UPTADE_H$/;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_H	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^#define EIGEN_SELFADJOINT_MATRIX_MATRIX_H$/;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_MKL_H	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^#define EIGEN_SELFADJOINT_MATRIX_MATRIX_MKL_H$/;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_H	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^#define EIGEN_SELFADJOINT_MATRIX_VECTOR_H$/;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_MKL_H	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^#define EIGEN_SELFADJOINT_MATRIX_VECTOR_MKL_H$/;"	d
EIGEN_SELFADJOINT_PRODUCT_H	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointProduct.h	/^#define EIGEN_SELFADJOINT_PRODUCT_H$/;"	d
EIGEN_SELFCWISEBINARYOP_H	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^#define EIGEN_SELFCWISEBINARYOP_H$/;"	d
EIGEN_SIMPLICIAL_CHOLESKY_H	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^#define EIGEN_SIMPLICIAL_CHOLESKY_H$/;"	d
EIGEN_SIZE_MAX	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_SIZE_MAX(/;"	d
EIGEN_SIZE_MIN_PREFER_DYNAMIC	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_SIZE_MIN_PREFER_DYNAMIC(/;"	d
EIGEN_SIZE_MIN_PREFER_FIXED	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_SIZE_MIN_PREFER_FIXED(/;"	d
EIGEN_SKYLINEINPLACELU_H	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^#define EIGEN_SKYLINEINPLACELU_H$/;"	d
EIGEN_SKYLINEMATRIXBASE_H	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^#define EIGEN_SKYLINEMATRIXBASE_H$/;"	d
EIGEN_SKYLINEMATRIX_H	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^#define EIGEN_SKYLINEMATRIX_H$/;"	d
EIGEN_SKYLINEPRODUCT_H	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^#define EIGEN_SKYLINEPRODUCT_H$/;"	d
EIGEN_SKYLINEUTIL_H	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^#define EIGEN_SKYLINEUTIL_H$/;"	d
EIGEN_SKYLINE_GENERIC_PUBLIC_INTERFACE	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^#define EIGEN_SKYLINE_GENERIC_PUBLIC_INTERFACE(/;"	d
EIGEN_SKYLINE_INHERIT_ASSIGNMENT_OPERATOR	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^#define EIGEN_SKYLINE_INHERIT_ASSIGNMENT_OPERATOR(/;"	d
EIGEN_SKYLINE_INHERIT_ASSIGNMENT_OPERATORS	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^#define EIGEN_SKYLINE_INHERIT_ASSIGNMENT_OPERATORS(/;"	d
EIGEN_SKYLINE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^#define EIGEN_SKYLINE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR(/;"	d
EIGEN_SKYLINE_STORAGE_H	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^#define EIGEN_SKYLINE_STORAGE_H$/;"	d
EIGEN_SOLVETRIANGULAR_H	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^#define EIGEN_SOLVETRIANGULAR_H$/;"	d
EIGEN_SPARSEDENSEPRODUCT_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^#define EIGEN_SPARSEDENSEPRODUCT_H$/;"	d
EIGEN_SPARSEMATRIXBASE_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^#define EIGEN_SPARSEMATRIXBASE_H$/;"	d
EIGEN_SPARSEMATRIX_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^#define EIGEN_SPARSEMATRIX_H$/;"	d
EIGEN_SPARSEPRODUCT_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^#define EIGEN_SPARSEPRODUCT_H$/;"	d
EIGEN_SPARSEREDUX_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseRedux.h	/^#define EIGEN_SPARSEREDUX_H$/;"	d
EIGEN_SPARSESPARSEPRODUCTWITHPRUNING_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^#define EIGEN_SPARSESPARSEPRODUCTWITHPRUNING_H$/;"	d
EIGEN_SPARSETRANSPOSE_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^#define EIGEN_SPARSETRANSPOSE_H$/;"	d
EIGEN_SPARSETRIANGULARSOLVER_H	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^#define EIGEN_SPARSETRIANGULARSOLVER_H$/;"	d
EIGEN_SPARSEUTIL_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_SPARSEUTIL_H$/;"	d
EIGEN_SPARSEVECTOR_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^#define EIGEN_SPARSEVECTOR_H$/;"	d
EIGEN_SPARSEVIEW_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^#define EIGEN_SPARSEVIEW_H$/;"	d
EIGEN_SPARSE_AMD_H	vcglib/eigenlib/Eigen/src/OrderingMethods/Amd.h	/^#define EIGEN_SPARSE_AMD_H$/;"	d
EIGEN_SPARSE_BLOCKFORDYNAMICMATRIX_H	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^#define EIGEN_SPARSE_BLOCKFORDYNAMICMATRIX_H$/;"	d
EIGEN_SPARSE_BLOCK_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^#define EIGEN_SPARSE_BLOCK_H$/;"	d
EIGEN_SPARSE_CWISE_BINARY_OP_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^#define EIGEN_SPARSE_CWISE_BINARY_OP_H$/;"	d
EIGEN_SPARSE_CWISE_PRODUCT_RETURN_TYPE	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    #define EIGEN_SPARSE_CWISE_PRODUCT_RETURN_TYPE /;"	d
EIGEN_SPARSE_CWISE_UNARY_OP_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^#define EIGEN_SPARSE_CWISE_UNARY_OP_H$/;"	d
EIGEN_SPARSE_DIAGONAL_PRODUCT_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^#define EIGEN_SPARSE_DIAGONAL_PRODUCT_H$/;"	d
EIGEN_SPARSE_DOT_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseDot.h	/^#define EIGEN_SPARSE_DOT_H$/;"	d
EIGEN_SPARSE_FUZZY_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseFuzzy.h	/^#define EIGEN_SPARSE_FUZZY_H$/;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR(/;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATORS	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATORS(/;"	d
EIGEN_SPARSE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_SPARSE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR(/;"	d
EIGEN_SPARSE_MARKET_IO_H	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^#define EIGEN_SPARSE_MARKET_IO_H$/;"	d
EIGEN_SPARSE_PERMUTATION_H	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^#define EIGEN_SPARSE_PERMUTATION_H$/;"	d
EIGEN_SPARSE_PUBLIC_INTERFACE	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_SPARSE_PUBLIC_INTERFACE(/;"	d
EIGEN_SPARSE_SELFADJOINTVIEW_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^#define EIGEN_SPARSE_SELFADJOINTVIEW_H$/;"	d
EIGEN_SPARSE_SOLVE_H	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^#define EIGEN_SPARSE_SOLVE_H$/;"	d
EIGEN_SPARSE_TRIANGULARVIEW_H	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^#define EIGEN_SPARSE_TRIANGULARVIEW_H$/;"	d
EIGEN_SPLINES_FWD_H	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^#define EIGEN_SPLINES_FWD_H$/;"	d
EIGEN_SPLINE_FITTING_H	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFitting.h	/^#define EIGEN_SPLINE_FITTING_H$/;"	d
EIGEN_SPLINE_H	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^#define EIGEN_SPLINE_H$/;"	d
EIGEN_STABLENORM_H	vcglib/eigenlib/Eigen/src/Core/StableNorm.h	/^#define EIGEN_STABLENORM_H$/;"	d
EIGEN_STACK_ALLOCATION_LIMIT	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_STACK_ALLOCATION_LIMIT /;"	d
EIGEN_STATIC_ASSERT	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^      #define EIGEN_STATIC_ASSERT(/;"	d
EIGEN_STATIC_ASSERT	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^    #define EIGEN_STATIC_ASSERT(/;"	d
EIGEN_STATIC_ASSERT_ARRAYXPR	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_ARRAYXPR(/;"	d
EIGEN_STATIC_ASSERT_DYNAMIC_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(/;"	d
EIGEN_STATIC_ASSERT_FIXED_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_FIXED_SIZE(/;"	d
EIGEN_STATIC_ASSERT_H	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_H$/;"	d
EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^#define EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(/;"	d
EIGEN_STATIC_ASSERT_LVALUE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_LVALUE(/;"	d
EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE(/;"	d
EIGEN_STATIC_ASSERT_NON_INTEGER	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^  #define EIGEN_STATIC_ASSERT_NON_INTEGER(/;"	d
EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(/;"	d
EIGEN_STATIC_ASSERT_SAME_VECTOR_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_SAME_VECTOR_SIZE(/;"	d
EIGEN_STATIC_ASSERT_SAME_XPR_KIND	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_SAME_XPR_KIND(/;"	d
EIGEN_STATIC_ASSERT_SIZE_1x1	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_SIZE_1x1(/;"	d
EIGEN_STATIC_ASSERT_VECTOR_ONLY	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_VECTOR_ONLY(/;"	d
EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(/;"	d
EIGEN_STDDEQUE_H	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^#define EIGEN_STDDEQUE_H$/;"	d
EIGEN_STDLIST_H	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^#define EIGEN_STDLIST_H$/;"	d
EIGEN_STDVECTOR_H	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^#define EIGEN_STDVECTOR_H$/;"	d
EIGEN_STD_DEQUE_SPECIALIZATION_BODY	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^#define EIGEN_STD_DEQUE_SPECIALIZATION_BODY /;"	d
EIGEN_STD_LIST_SPECIALIZATION_BODY	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^#define EIGEN_STD_LIST_SPECIALIZATION_BODY /;"	d
EIGEN_STD_VECTOR_SPECIALIZATION_BODY	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^#define EIGEN_STD_VECTOR_SPECIALIZATION_BODY /;"	d
EIGEN_STEM_FUNCTION	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^#define EIGEN_STEM_FUNCTION$/;"	d
EIGEN_STL_DETAILS_H	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^#define EIGEN_STL_DETAILS_H$/;"	d
EIGEN_STRIDE_H	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^#define EIGEN_STRIDE_H$/;"	d
EIGEN_STRONG_INLINE	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_STRONG_INLINE /;"	d
EIGEN_SUPERLUSUPPORT_H	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^#define EIGEN_SUPERLUSUPPORT_H$/;"	d
EIGEN_SUPERLU_HAS_ILU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^#define EIGEN_SUPERLU_HAS_ILU$/;"	d
EIGEN_SWAP_H	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^#define EIGEN_SWAP_H$/;"	d
EIGEN_TRANSFORM_H	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^#define EIGEN_TRANSFORM_H$/;"	d
EIGEN_TRANSLATION_H	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^#define EIGEN_TRANSLATION_H$/;"	d
EIGEN_TRANSPOSE_H	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^#define EIGEN_TRANSPOSE_H$/;"	d
EIGEN_TRANSPOSITIONS_H	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^#define EIGEN_TRANSPOSITIONS_H$/;"	d
EIGEN_TRIANGULARMATRIXVECTOR_H	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^#define EIGEN_TRIANGULARMATRIXVECTOR_H$/;"	d
EIGEN_TRIANGULARMATRIX_H	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^#define EIGEN_TRIANGULARMATRIX_H$/;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_H	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^#define EIGEN_TRIANGULAR_MATRIX_MATRIX_H$/;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_MKL_H	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^#define EIGEN_TRIANGULAR_MATRIX_MATRIX_MKL_H$/;"	d
EIGEN_TRIANGULAR_MATRIX_VECTOR_MKL_H	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^#define EIGEN_TRIANGULAR_MATRIX_VECTOR_MKL_H$/;"	d
EIGEN_TRIANGULAR_SOLVER2_H	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^#define EIGEN_TRIANGULAR_SOLVER2_H$/;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_H	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^#define EIGEN_TRIANGULAR_SOLVER_MATRIX_H$/;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_MKL_H	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^#define EIGEN_TRIANGULAR_SOLVER_MATRIX_MKL_H$/;"	d
EIGEN_TRIANGULAR_SOLVER_VECTOR_H	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverVector.h	/^#define EIGEN_TRIANGULAR_SOLVER_VECTOR_H$/;"	d
EIGEN_TRIDIAGONALIZATION_H	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^#define EIGEN_TRIDIAGONALIZATION_H$/;"	d
EIGEN_TUNE_TRIANGULAR_PANEL_WIDTH	vcglib/eigenlib/Eigen/src/Core/arch/Default/Settings.h	/^#define EIGEN_TUNE_TRIANGULAR_PANEL_WIDTH /;"	d
EIGEN_UMEYAMA_H	vcglib/eigenlib/Eigen/src/Geometry/Umeyama.h	/^#define EIGEN_UMEYAMA_H$/;"	d
EIGEN_UMFPACKSUPPORT_H	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^#define EIGEN_UMFPACKSUPPORT_H$/;"	d
EIGEN_UNROLLING_LIMIT	vcglib/eigenlib/Eigen/src/Core/arch/Default/Settings.h	/^#define EIGEN_UNROLLING_LIMIT /;"	d
EIGEN_UNUSED	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_UNUSED /;"	d
EIGEN_UNUSED_VARIABLE	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_UNUSED_VARIABLE(/;"	d
EIGEN_USER_ALIGN16	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_USER_ALIGN16 /;"	d
EIGEN_USER_ALIGN_TO_BOUNDARY	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_USER_ALIGN_TO_BOUNDARY(/;"	d
EIGEN_USE_BLAS	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^    #define EIGEN_USE_BLAS$/;"	d
EIGEN_USE_LAPACKE	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^    #define EIGEN_USE_LAPACKE$/;"	d
EIGEN_USE_LAPACKE	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^  #define EIGEN_USE_LAPACKE$/;"	d
EIGEN_USE_MKL	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^  #define EIGEN_USE_MKL$/;"	d
EIGEN_USE_MKL_VML	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^    #define EIGEN_USE_MKL_VML$/;"	d
EIGEN_USING_ARRAY_TYPEDEFS	vcglib/eigenlib/Eigen/src/Core/Array.h	/^#define EIGEN_USING_ARRAY_TYPEDEFS /;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE	vcglib/eigenlib/Eigen/src/Core/Array.h	/^#define EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE(/;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE_AND_SIZE	vcglib/eigenlib/Eigen/src/Core/Array.h	/^#define EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE_AND_SIZE(/;"	d
EIGEN_VCGLIB	vcglib/vcg/math/eigen.h	/^#define EIGEN_VCGLIB$/;"	d
EIGEN_VECTORBLOCK_H	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^#define EIGEN_VECTORBLOCK_H$/;"	d
EIGEN_VERSION_AT_LEAST	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_VERSION_AT_LEAST(/;"	d
EIGEN_VISITOR_H	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^#define EIGEN_VISITOR_H$/;"	d
EIGEN_WARNINGS_DISABLED	vcglib/eigenlib/Eigen/src/Core/util/DisableStupidWarnings.h	/^#define EIGEN_WARNINGS_DISABLED$/;"	d
EIGEN_WARNINGS_DISABLED	vcglib/eigenlib/Eigen/src/Core/util/ReenableStupidWarnings.h	/^#undef EIGEN_WARNINGS_DISABLED$/;"	d
EIGEN_WORKAROUND_MSVC_STL_SUPPORT	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^#define EIGEN_WORKAROUND_MSVC_STL_SUPPORT(/;"	d
EIGEN_WORLD_VERSION	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define EIGEN_WORLD_VERSION /;"	d
EIGEN_XPRHELPER_H	vcglib/eigenlib/Eigen/src/Core/util/XprHelper.h	/^#define EIGEN_XPRHELPER_H$/;"	d
EKTA_SPACE	vcglib/vcg/space/colorspace.h	/^		EKTA_SPACE = 9,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
EMCLookUpTable	vcglib/vcg/complex/algorithms/create/emc_lookup_table.h	/^		class EMCLookUpTable$/;"	c	namespace:vcg::tri
EN	vcglib/vcg/complex/base.h	/^    inline int EN() const { return en; }$/;"	f	class:vcg::tri::TriMesh
ENTRY_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		ENTRY_NODE=				4; $/;"	v
EPSIL	vcglib/vcg/space/intersection3.h	/^	#define EPSIL /;"	d
EPSILON	vcglib/wrap/miq/core/auxmath.h	/^const double EPSILON = 1.0e-8;$/;"	v
EPoint	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    EPoint(vcg::Point3<ScalarType> _p, int _i):pos(_p),pi(_i){}$/;"	f	struct:vcg::tri::FourPCS::EPoint
EPoint	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  struct EPoint{$/;"	s	class:vcg::tri::FourPCS
EVAdj	vcglib/vcg/simplex/edge/component.h	/^template <class T> class EVAdj : public VertexRef<T>{};$/;"	c	namespace:vcg::edge
EXECUTABLE	Makefile	/^EXECUTABLE = ..\/..\/bin\/poissonDisk$/;"	m
EXPANSION_FACTOR	vcglib/vcg/space/index/octree_template.h	/^	static const ScalarType						EXPANSION_FACTOR;$/;"	m	class:vcg::OctreeTemplate
EXPANSION_FACTOR	vcglib/vcg/space/index/octree_template.h	/^const SCALAR_TYPE OctreeTemplate<VOXEL_TYPE, SCALAR_TYPE>::EXPANSION_FACTOR  = SCALAR_TYPE(0.035);$/;"	m	class:vcg::OctreeTemplate
EXPORTER_DAE_H	vcglib/wrap/io_trimesh/export_dae.h	/^#define EXPORTER_DAE_H$/;"	d
EXPORT_CTM_H	vcglib/wrap/io_trimesh/export_ctm.h	/^#define EXPORT_CTM_H$/;"	d
EXPORT_FBX	vcglib/wrap/io_trimesh/export_fbx.h	/^#define EXPORT_FBX$/;"	d
EXTERN_BIT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define EXTERN_BIT /;"	d	file:
EXTRUDE_H	vcglib/vcg/complex/algorithms/create/extrude.h	/^#define EXTRUDE_H$/;"	d
E_ABORTED	vcglib/wrap/io_trimesh/export_3ds.h	/^			E_ABORTED,					\/\/ 4$/;"	e	enum:vcg::tri::io::Exporter3DS::SaveError
E_ABORTED	vcglib/wrap/io_trimesh/export_obj.h	/^    E_ABORTED,					\/\/ 4$/;"	e	enum:vcg::tri::io::ExporterOBJ::SaveError
E_ABORTED	vcglib/wrap/io_trimesh/import_ctm.h	/^  E_ABORTED,								\/\/ 3$/;"	e	enum:vcg::tri::io::ImporterCTM::CTMError
E_ABORTED	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_ABORTED                           = 8*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_ABORTED_CONVERSION	vcglib/wrap/io_trimesh/export_u3d.h	/^		E_ABORTED_CONVERSION \/\/1$/;"	e	enum:vcg::tri::io::ExporterU3D::U3DError
E_BADCAST	vcglib/wrap/ply/plylib.h	/^	E_BADCAST,				\/\/ 12$/;"	e	enum:vcg::ply::PlyError
E_BADTYPE	vcglib/wrap/ply/plylib.h	/^	E_BADTYPE,				\/\/ 10$/;"	e	enum:vcg::ply::PlyError
E_BADTYPENAME	vcglib/wrap/ply/plylib.h	/^	E_BADTYPENAME,			\/\/ 7$/;"	e	enum:vcg::ply::PlyError
E_BAD_TEX_VERT_INDEX	vcglib/wrap/io_trimesh/import_ctm.h	/^  E_BAD_TEX_VERT_INDEX 			\/\/ 8$/;"	e	enum:vcg::tri::io::ImporterCTM::CTMError
E_BAD_VERTEX_STATEMENT	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_BAD_VERTEX_STATEMENT              =11*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_BAD_VERT_INDEX	vcglib/wrap/io_tetramesh/io_ply.h	/^	E_BAD_VERT_INDEX,		\/\/ 18$/;"	e	enum:vcg::tetra::io::PlyInfo::Error
E_BAD_VERT_INDEX	vcglib/wrap/io_trimesh/import_ctm.h	/^  E_BAD_VERT_INDEX,					\/\/ 7$/;"	e	enum:vcg::tri::io::ImporterCTM::CTMError
E_BAD_VERT_INDEX	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_BAD_VERT_INDEX                    =14*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_BAD_VERT_INDEX	vcglib/wrap/io_trimesh/io_ply.h	/^	E_BAD_VERT_INDEX  = ply::E_MAXPLYERRORS+5,		\/\/ 18$/;"	e	enum:vcg::tri::io::PlyInfo::Error
E_BAD_VERT_INDEX_EDGE	vcglib/wrap/io_trimesh/io_ply.h	/^	E_BAD_VERT_INDEX_EDGE  = ply::E_MAXPLYERRORS+8,		\/\/ 18$/;"	e	enum:vcg::tri::io::PlyInfo::Error
E_BAD_VERT_NORMAL_INDEX	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_BAD_VERT_NORMAL_INDEX             =16*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_BAD_VERT_NORMAL_STATEMENT	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_BAD_VERT_NORMAL_STATEMENT         =13*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_BAD_VERT_TEX_INDEX	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_BAD_VERT_TEX_INDEX                =15*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_BAD_VERT_TEX_STATEMENT	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_BAD_VERT_TEX_STATEMENT            =12*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_CANTCLOSEFILE	vcglib/wrap/io_trimesh/export_3ds.h	/^			E_CANTCLOSEFILE,			\/\/ 2$/;"	e	enum:vcg::tri::io::Exporter3DS::SaveError
E_CANTCLOSEFILE	vcglib/wrap/io_trimesh/export_obj.h	/^    E_CANTCLOSEFILE,			\/\/ 2$/;"	e	enum:vcg::tri::io::ExporterOBJ::SaveError
E_CANTCREATEFBXIMPORTER	vcglib/wrap/io_trimesh/import_fbx.h	/^		E_CANTCREATEFBXIMPORTER	= 3,		$/;"	e	enum:ImporterFBX::FBXError
E_CANTCREATEFBXMANAGER	vcglib/wrap/io_trimesh/import_fbx.h	/^		E_CANTCREATEFBXMANAGER	= 1,	$/;"	e	enum:ImporterFBX::FBXError
E_CANTCREATEFBXSCENE	vcglib/wrap/io_trimesh/import_fbx.h	/^		E_CANTCREATEFBXSCENE	= 2,$/;"	e	enum:ImporterFBX::FBXError
E_CANTFINDFBXFILE	vcglib/wrap/io_trimesh/import_fbx.h	/^		E_CANTFINDFBXFILE		= 5,$/;"	e	enum:ImporterFBX::FBXError
E_CANTFINDFILE	vcglib/wrap/io_trimesh/import_fbx.h	/^		E_CANTFINDFILE			= 4,	$/;"	e	enum:ImporterFBX::FBXError
E_CANTIMPORTFBXFILE	vcglib/wrap/io_trimesh/import_fbx.h	/^		E_CANTIMPORTFBXFILE		= 6	$/;"	e	enum:ImporterFBX::FBXError
E_CANTOPEN	vcglib/wrap/dae/util_dae.h	/^			E_CANTOPEN,				\/\/ 1$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_CANTOPEN	vcglib/wrap/io_trimesh/import_asc.h	/^	E_CANTOPEN,				\/\/ 1$/;"	e	enum:vcg::tri::io::ImporterASC::RAWError
E_CANTOPEN	vcglib/wrap/io_trimesh/import_ctm.h	/^  E_CANTOPEN,								\/\/ 1$/;"	e	enum:vcg::tri::io::ImporterCTM::CTMError
E_CANTOPEN	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_CANTOPEN                          = 6*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_CANTOPEN	vcglib/wrap/io_trimesh/import_raw.h	/^	E_CANTOPEN,				\/\/ 1$/;"	e	enum:vcg::tri::io::ImporterRAW::RAWError
E_CANTOPEN	vcglib/wrap/io_trimesh/import_smf.h	/^			E_CANTOPEN,				\/\/ 1$/;"	e	enum:vcg::tri::io::ImporterSMF::SMFError
E_CANTOPEN	vcglib/wrap/io_trimesh/import_stl.h	/^	E_CANTOPEN,				\/\/ 1$/;"	e	enum:vcg::tri::io::ImporterSTL::STLError
E_CANTOPEN	vcglib/wrap/ply/plylib.h	/^	E_CANTOPEN,				\/\/ 1$/;"	e	enum:vcg::ply::PlyError
E_CANTOPENFILE	vcglib/wrap/io_trimesh/export_3ds.h	/^			E_CANTOPENFILE,				\/\/ 1$/;"	e	enum:vcg::tri::io::Exporter3DS::SaveError
E_CANTOPENFILE	vcglib/wrap/io_trimesh/export_obj.h	/^    E_CANTOPENFILE,				\/\/ 1$/;"	e	enum:vcg::tri::io::ExporterOBJ::SaveError
E_CANTSAVE	vcglib/wrap/dae/util_dae.h	/^			E_CANTSAVE, \/\/10$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_DIFFER_COLORS	vcglib/wrap/io_tetramesh/io_ply.h	/^	E_DIFFER_COLORS,		\/\/ 20$/;"	e	enum:vcg::tetra::io::PlyInfo::Error
E_DIFFER_COLORS	vcglib/wrap/io_trimesh/io_ply.h	/^	E_DIFFER_COLORS   = ply::E_MAXPLYERRORS+7,	$/;"	e	enum:vcg::tri::io::PlyInfo::Error
E_ELEMNOTFOUND	vcglib/wrap/ply/plylib.h	/^	E_ELEMNOTFOUND,			\/\/ 8$/;"	e	enum:vcg::ply::PlyError
E_INCOMPATIBLECOLLADA141FORMAT	vcglib/wrap/dae/util_dae.h	/^			E_INCOMPATIBLECOLLADA141FORMAT, \/\/7$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_INCOMPATIBLETYPE	vcglib/wrap/ply/plylib.h	/^	E_INCOMPATIBLETYPE,		\/\/ 11$/;"	e	enum:vcg::ply::PlyError
E_INVALIDLINEDESC	vcglib/wrap/io_trimesh/import_raw.h	/^	E_INVALIDLINEDESC,      \/\/ 3$/;"	e	enum:vcg::tri::io::ImporterRAW::RAWError
E_LESS_THAN_3VERTINFACE	vcglib/wrap/io_trimesh/import_ctm.h	/^  E_LESS_THAN_3VERTINFACE,	\/\/ 6$/;"	e	enum:vcg::tri::io::ImporterCTM::CTMError
E_LESS_THAN_3_VERT_IN_FACE	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_LESS_THAN_3_VERT_IN_FACE          = 5*2+1,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_LESS_THAN_4_VERT_IN_QUAD	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_LESS_THAN_4_VERT_IN_QUAD          =17*2+0$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_LINEERROR	vcglib/wrap/io_trimesh/import_raw.h	/^	E_LINEERROR,            \/\/ 4$/;"	e	enum:vcg::tri::io::ImporterRAW::RAWError
E_MATERIAL_FILE_NOT_FOUND	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_MATERIAL_FILE_NOT_FOUND           = 1*2+1,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_MATERIAL_NOT_FOUND	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_MATERIAL_NOT_FOUND                = 2*2+1,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_MAXPLYERRORS	vcglib/wrap/ply/plylib.h	/^	E_MAXPLYERRORS$/;"	e	enum:vcg::ply::PlyError
E_MAXPLYINFOERRORS	vcglib/wrap/io_trimesh/io_ply.h	/^  E_MAXPLYINFOERRORS= ply::E_MAXPLYERRORS+9\/\/ 20$/;"	e	enum:vcg::tri::io::PlyInfo::Error
E_NO3DSCENE	vcglib/wrap/dae/util_dae.h	/^			E_NO3DSCENE, \/\/ 6$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_NO3DVERTEXPOSITION	vcglib/wrap/dae/util_dae.h	/^			E_NO3DVERTEXPOSITION,			\/\/ 5$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_NOACCESSORELEMENT	vcglib/wrap/dae/util_dae.h	/^			E_NOACCESSORELEMENT$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_NOERROR	vcglib/wrap/dae/util_dae.h	/^			E_NOERROR,				\/\/ 0$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_NOERROR	vcglib/wrap/io_trimesh/export_3ds.h	/^			E_NOERROR,					\/\/ 0$/;"	e	enum:vcg::tri::io::Exporter3DS::SaveError
E_NOERROR	vcglib/wrap/io_trimesh/export_idtf.h	/^		E_NOERROR				\/\/ 0$/;"	e	enum:vcg::tri::io::ExporterIDTF::IDTFError
E_NOERROR	vcglib/wrap/io_trimesh/export_obj.h	/^    E_NOERROR,					\/\/ 0$/;"	e	enum:vcg::tri::io::ExporterOBJ::SaveError
E_NOERROR	vcglib/wrap/io_trimesh/export_u3d.h	/^		E_NOERROR,				\/\/ 0$/;"	e	enum:vcg::tri::io::ExporterU3D::U3DError
E_NOERROR	vcglib/wrap/io_trimesh/import_asc.h	/^	E_NOERROR,				\/\/ 0$/;"	e	enum:vcg::tri::io::ImporterASC::RAWError
E_NOERROR	vcglib/wrap/io_trimesh/import_ctm.h	/^  E_NOERROR,								\/\/ 0$/;"	e	enum:vcg::tri::io::ImporterCTM::CTMError
E_NOERROR	vcglib/wrap/io_trimesh/import_fbx.h	/^		E_NOERROR = 0,													$/;"	e	enum:ImporterFBX::FBXError
E_NOERROR	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_NOERROR                           = 0*2+0,  \/\/  A*2+B  (A position of correspondig string in the array, B=1 if not critical)$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_NOERROR	vcglib/wrap/io_trimesh/import_raw.h	/^	E_NOERROR,				\/\/ 0$/;"	e	enum:vcg::tri::io::ImporterRAW::RAWError
E_NOERROR	vcglib/wrap/io_trimesh/import_smf.h	/^			E_NOERROR,				\/\/ 0$/;"	e	enum:vcg::tri::io::ImporterSMF::SMFError
E_NOERROR	vcglib/wrap/io_trimesh/import_stl.h	/^	E_NOERROR,				\/\/ 0$/;"	e	enum:vcg::tri::io::ImporterSTL::STLError
E_NOERROR	vcglib/wrap/ply/plylib.h	/^	E_NOERROR,				\/\/ 0$/;"	e	enum:vcg::ply::PlyError
E_NOFORMAT	vcglib/wrap/ply/plylib.h	/^	E_NOFORMAT,				\/\/ 4$/;"	e	enum:vcg::ply::PlyError
E_NOGEOMETRYLIBRARY	vcglib/wrap/dae/util_dae.h	/^			E_NOGEOMETRYLIBRARY,     \/\/ 2 $/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_NOMESH	vcglib/wrap/dae/util_dae.h	/^			E_NOMESH,      \/\/ 3$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_NON_CRITICAL_ERROR	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_NON_CRITICAL_ERROR                = 0*2+1,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_NOPOLYGONALMESH	vcglib/wrap/dae/util_dae.h	/^			E_NOPOLYGONALMESH, \/\/9$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_NOTDEFINITION	vcglib/wrap/io_trimesh/export_3ds.h	/^			E_NOTDEFINITION,			\/\/ 5$/;"	e	enum:vcg::tri::io::Exporter3DS::SaveError
E_NOTDEFINITION	vcglib/wrap/io_trimesh/export_obj.h	/^    E_NOTDEFINITION,			\/\/ 5$/;"	e	enum:vcg::tri::io::ExporterOBJ::SaveError
E_NOTEXCOORDVALID	vcglib/wrap/io_trimesh/export_3ds.h	/^			E_NOTEXCOORDVALID,			\/\/ 8$/;"	e	enum:vcg::tri::io::Exporter3DS::SaveError
E_NOTFACESVALID	vcglib/wrap/io_trimesh/export_3ds.h	/^			E_NOTFACESVALID,			\/\/ 7$/;"	e	enum:vcg::tri::io::Exporter3DS::SaveError
E_NOTFACESVALID	vcglib/wrap/io_trimesh/export_obj.h	/^    E_NOTFACESVALID				\/\/ 7$/;"	e	enum:vcg::tri::io::ExporterOBJ::SaveError
E_NOTHEADER	vcglib/wrap/ply/plylib.h	/^	E_NOTHEADER,			\/\/ 2$/;"	e	enum:vcg::ply::PlyError
E_NOTNUMBERVERTVALID	vcglib/wrap/io_trimesh/export_3ds.h	/^			E_NOTNUMBERVERTVALID		\/\/ 9$/;"	e	enum:vcg::tri::io::Exporter3DS::SaveError
E_NOTVEXTEXVALID	vcglib/wrap/io_trimesh/export_3ds.h	/^			E_NOTVEXTEXVALID,			\/\/ 6$/;"	e	enum:vcg::tri::io::Exporter3DS::SaveError
E_NOTVEXTEXVALID	vcglib/wrap/io_trimesh/export_obj.h	/^    E_NOTVEXTEXVALID,			\/\/ 6$/;"	e	enum:vcg::tri::io::ExporterOBJ::SaveError
E_NOVERTEXPOSITION	vcglib/wrap/dae/util_dae.h	/^			E_NOVERTEXPOSITION,            \/\/ 4$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_NO_3VERTINFACE	vcglib/wrap/io_tetramesh/io_ply.h	/^	E_NO_3VERTINFACE,		\/\/ 17$/;"	e	enum:vcg::tetra::io::PlyInfo::Error
E_NO_3VERTINFACE	vcglib/wrap/io_trimesh/io_ply.h	/^	E_NO_3VERTINFACE  = ply::E_MAXPLYERRORS+4,		\/\/ 17$/;"	e	enum:vcg::tri::io::PlyInfo::Error
E_NO_6TCOORD	vcglib/wrap/io_tetramesh/io_ply.h	/^	E_NO_6TCOORD,			\/\/ 19$/;"	e	enum:vcg::tetra::io::PlyInfo::Error
E_NO_6TCOORD	vcglib/wrap/io_trimesh/io_ply.h	/^	E_NO_6TCOORD      = ply::E_MAXPLYERRORS+6,			\/\/ 19$/;"	e	enum:vcg::tri::io::PlyInfo::Error
E_NO_FACE	vcglib/wrap/io_tetramesh/io_ply.h	/^	E_NO_FACE,				\/\/ 15$/;"	e	enum:vcg::tetra::io::PlyInfo::Error
E_NO_FACE	vcglib/wrap/io_trimesh/import_ctm.h	/^  E_NO_FACE,								\/\/ 5$/;"	e	enum:vcg::tri::io::ImporterCTM::CTMError
E_NO_FACE	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_NO_FACE                           =10*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_NO_FACE	vcglib/wrap/io_trimesh/io_ply.h	/^	E_NO_FACE         = ply::E_MAXPLYERRORS+2,				\/\/ 15$/;"	e	enum:vcg::tri::io::PlyInfo::Error
E_NO_POINTS	vcglib/wrap/io_trimesh/import_asc.h	/^	E_NO_POINTS,				\/\/3$/;"	e	enum:vcg::tri::io::ImporterASC::RAWError
E_NO_VERTEX	vcglib/wrap/io_tetramesh/io_ply.h	/^	E_NO_VERTEX,			\/\/ 14$/;"	e	enum:vcg::tetra::io::PlyInfo::Error
E_NO_VERTEX	vcglib/wrap/io_trimesh/import_ctm.h	/^  E_NO_VERTEX,							\/\/ 4$/;"	e	enum:vcg::tri::io::ImporterCTM::CTMError
E_NO_VERTEX	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_NO_VERTEX                         = 9*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_NO_VERTEX	vcglib/wrap/io_trimesh/io_ply.h	/^  E_NO_VERTEX       = ply::E_MAXPLYERRORS+1,			\/\/ 14$/;"	e	enum:vcg::tri::io::PlyInfo::Error
E_PROPNOTFOUND	vcglib/wrap/ply/plylib.h	/^	E_PROPNOTFOUND,			\/\/ 9$/;"	e	enum:vcg::ply::PlyError
E_PROPOUTOFELEMENT	vcglib/wrap/ply/plylib.h	/^	E_PROPOUTOFELEMENT,		\/\/ 6$/;"	e	enum:vcg::ply::PlyError
E_SHORTFILE	vcglib/wrap/io_tetramesh/io_ply.h	/^	E_SHORTFILE,			\/\/ 16$/;"	e	enum:vcg::tetra::io::PlyInfo::Error
E_SHORTFILE	vcglib/wrap/io_trimesh/io_ply.h	/^	E_SHORTFILE       = ply::E_MAXPLYERRORS+3,			\/\/ 16$/;"	e	enum:vcg::tri::io::PlyInfo::Error
E_SYNTAX	vcglib/wrap/ply/plylib.h	/^	E_SYNTAX,				\/\/ 5$/;"	e	enum:vcg::ply::PlyError
E_TEXTURE_NOT_FOUND	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_TEXTURE_NOT_FOUND                 = 3*2+1,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_UNESPECTEDEOF	vcglib/wrap/io_trimesh/export_3ds.h	/^			E_UNESPECTEDEOF,			\/\/ 3$/;"	e	enum:vcg::tri::io::Exporter3DS::SaveError
E_UNESPECTEDEOF	vcglib/wrap/io_trimesh/export_obj.h	/^    E_UNESPECTEDEOF,			\/\/ 3$/;"	e	enum:vcg::tri::io::ExporterOBJ::SaveError
E_UNESPECTEDEOF	vcglib/wrap/io_trimesh/import_asc.h	/^	E_UNESPECTEDEOF,        \/\/ 2$/;"	e	enum:vcg::tri::io::ImporterASC::RAWError
E_UNESPECTEDEOF	vcglib/wrap/io_trimesh/import_ctm.h	/^  E_UNESPECTEDEOF,					\/\/ 2$/;"	e	enum:vcg::tri::io::ImporterCTM::CTMError
E_UNESPECTEDEOF	vcglib/wrap/io_trimesh/import_raw.h	/^	E_UNESPECTEDEOF,        \/\/ 2$/;"	e	enum:vcg::tri::io::ImporterRAW::RAWError
E_UNESPECTEDEOF	vcglib/wrap/io_trimesh/import_smf.h	/^			E_UNESPECTEDEOF       	\/\/ 2$/;"	e	enum:vcg::tri::io::ImporterSMF::SMFError
E_UNESPECTEDEOF	vcglib/wrap/io_trimesh/import_stl.h	/^	E_UNESPECTEDEOF       		        \/\/ 2$/;"	e	enum:vcg::tri::io::ImporterSTL::STLError
E_UNESPECTEDEOF	vcglib/wrap/ply/plylib.h	/^	E_UNESPECTEDEOF,		\/\/ 3$/;"	e	enum:vcg::ply::PlyError
E_UNEXPECTED_EOF	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_UNEXPECTED_EOF                     = 7*2+0,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_UNREFERENCEBLEDCOLLADAATTRIBUTE	vcglib/wrap/dae/util_dae.h	/^			E_UNREFERENCEBLEDCOLLADAATTRIBUTE, \/\/ 8$/;"	e	enum:vcg::tri::io::UtilDAE::DAEError
E_VERTICES_WITH_SAME_IDX_IN_FACE	vcglib/wrap/io_trimesh/import_obj.h	/^                    E_VERTICES_WITH_SAME_IDX_IN_FACE    = 4*2+1,$/;"	e	enum:vcg::tri::io::ImporterOBJ::OBJError
E_WRONGPOINTNUM	vcglib/wrap/io_trimesh/import_raw.h	/^	E_WRONGPOINTNUM			\/\/ 5$/;"	e	enum:vcg::tri::io::ImporterRAW::RAWError
EarCuttingFill	vcglib/vcg/complex/algorithms/hole.h	/^    static int EarCuttingFill(MESH &m, int sizeHole, bool Selected = false, CallBackPos *cb=0)$/;"	f	class:vcg::tri::Hole
EarCuttingIntersectionFill	vcglib/vcg/complex/algorithms/hole.h	/^    static int EarCuttingIntersectionFill(MESH &m, const int maxSizeHole, bool Selected, CallBackPos *cb=0)$/;"	f	class:vcg::tri::Hole
Edge	vcglib/vcg/simplex/edge/base.h	/^                            class Edge: public EdgeArityMax<UserTypes, A, B, C, D, E, F, G, H, I, J>  {$/;"	c	namespace:vcg
Edge	vcglib/vcg/simplex/face/component_ep.h	/^  typename T::VertexType::CoordType &Edge(const int j) {$/;"	f	class:vcg::face::EdgePlane
Edge	vcglib/vcg/simplex/face/component_ep.h	/^typename T::VertexType::CoordType &Edge(const int ) { assert(0);  static typename T::VertexType::CoordType dum; return dum;}$/;"	f	class:vcg::face::EmptyEdgePlane
EdgeAll	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t EdgeAll(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
EdgeAlreadyVisited	vcglib/vcg/complex/algorithms/harmonic.h	/^		EdgeAlreadyVisited$/;"	e	enum:vcg::tri::Harmonic::WeightInfo
EdgeArityMax	vcglib/vcg/simplex/edge/base.h	/^class EdgeArityMax: public Arity10<edge::EmptyCore<UserTypes>, A, B, C, D, E, F, G, H, I, J> {$/;"	c	namespace:vcg
EdgeBarycentricToFaceBarycentric	vcglib/vcg/complex/algorithms/update/topology.h	/^  inline Point3<ScalarType> EdgeBarycentricToFaceBarycentric(ScalarType u) const$/;"	f	class:vcg::tri::UpdateTopology::PEdge
EdgeClear	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void EdgeClear(MeshType &m, unsigned int FlagMask = 0xffffffff)$/;"	f	class:vcg::tri::UpdateFlags
EdgeClear	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t EdgeClear(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
EdgeClearV	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void EdgeClearV(MeshType &m) { EdgeClear(m,EdgeType::VISITED);}$/;"	f	class:vcg::tri::UpdateFlags
EdgeCollapser	vcglib/vcg/complex/algorithms/edge_collapse.h	/^class EdgeCollapser$/;"	c	namespace:vcg::tri
EdgeContainer	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::EdgeContainer EdgeContainer;$/;"	t	class:vcg::tri::Allocator
EdgeContainer	vcglib/vcg/complex/base.h	/^                                typedef CONT EdgeContainer;$/;"	t	struct:vcg::tri::MeshTypeHolder
EdgeContainer	vcglib/vcg/complex/base.h	/^                typedef CONTE										EdgeContainer;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
EdgeContainer	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::EdgeContainer EdgeContainer;$/;"	t	class:vcg::tri::TriMesh
EdgeCount	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t EdgeCount(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
EdgeDesc	vcglib/wrap/io_trimesh/import_ply.h	/^static const PropDescriptor &EdgeDesc(int i)$/;"	f	class:vcg::tri::io::ImporterPLY
EdgeDist	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			enum DistType{AreaDist,EdgeDist,AngleDist};$/;"	e	enum:vcg::tri::Distortion::DistType
EdgeDistortion	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^            static ScalarType EdgeDistortion(const FaceType *f,int e,$/;"	f	class:vcg::tri::Distortion
EdgeEdge	vcglib/vcg/complex/algorithms/update/topology.h	/^static void EdgeEdge(MeshType &m)$/;"	f	class:vcg::tri::UpdateTopology
EdgeFlipPriority	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^        template <class MeshType> class EdgeFlipPriority$/;"	c	namespace:vcg::tri
EdgeIntersections	vcglib/vcg/complex/algorithms/clip.h	/^    EdgeIntersections(void)$/;"	f	class:vcg::tri::TriMeshClipper::EdgeIntersections
EdgeIntersections	vcglib/vcg/complex/algorithms/clip.h	/^  class EdgeIntersections$/;"	c	class:vcg::tri::TriMeshClipper
EdgeIsect	vcglib/vcg/complex/algorithms/clip.h	/^  class EdgeIsect$/;"	c	class:vcg::tri::TriMeshClipper
EdgeIterator	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::EdgeIterator   EdgeIterator;$/;"	t	class:vcg::tri::Clean
EdgeIterator	vcglib/vcg/complex/algorithms/create/extrude.h	/^  typedef typename MeshType::EdgeIterator EdgeIterator;$/;"	t	class:vcg::tri::Extrude
EdgeIterator	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::EdgeIterator EdgeIterator;$/;"	t	class:vcg::tri::HalfedgeQuadClean
EdgeIterator	vcglib/vcg/complex/algorithms/stat.h	/^  typedef typename MeshType::EdgeIterator   EdgeIterator;$/;"	t	class:vcg::tri::Stat
EdgeIterator	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef typename MeshType::EdgeIterator   EdgeIterator;$/;"	t	class:vcg::tri::UpdateFlags
EdgeIterator	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::EdgeIterator EdgeIterator;$/;"	t	class:vcg::tri::UpdateHalfEdges
EdgeIterator	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                typedef typename MeshType::EdgeIterator EdgeIterator;$/;"	t	class:vcg::tri::HalfEdgeTopology
EdgeIterator	vcglib/vcg/complex/algorithms/update/selection.h	/^typedef typename MeshType::EdgeIterator   EdgeIterator;$/;"	t	class:vcg::tri::UpdateSelection
EdgeIterator	vcglib/vcg/complex/algorithms/update/topology.h	/^typedef typename MeshType::EdgeIterator    EdgeIterator;$/;"	t	class:vcg::tri::UpdateTopology
EdgeIterator	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::EdgeIterator EdgeIterator;$/;"	t	class:vcg::tri::Allocator
EdgeIterator	vcglib/vcg/complex/base.h	/^                                typedef typename EdgeContainer::iterator EdgeIterator;$/;"	t	struct:vcg::tri::MeshTypeHolder
EdgeIterator	vcglib/vcg/complex/base.h	/^                typedef typename CONTE::iterator				EdgeIterator;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
EdgeIterator	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::EdgeIterator					EdgeIterator;$/;"	t	class:vcg::tri::TriMesh
EdgeIterator	vcglib/wrap/io_trimesh/export_obj.h	/^  typedef typename SaveMeshType::EdgeIterator EdgeIterator;$/;"	t	class:vcg::tri::io::ExporterOBJ
EdgeIterator	vcglib/wrap/io_trimesh/export_ply.h	/^typedef typename SaveMeshType::EdgeIterator EdgeIterator;$/;"	t	class:vcg::tri::io::ExporterPLY
EdgeIterator	vcglib/wrap/io_trimesh/import_nvm.h	/^typedef typename OpenMeshType::EdgeIterator EdgeIterator;$/;"	t	class:vcg::tri::io::ImporterNVM
EdgeIterator	vcglib/wrap/io_trimesh/import_out.h	/^typedef typename OpenMeshType::EdgeIterator EdgeIterator;$/;"	t	class:vcg::tri::io::ImporterOUT
EdgeIterator	vcglib/wrap/io_trimesh/import_ply.h	/^typedef typename OpenMeshType::EdgeIterator EdgeIterator;$/;"	t	class:vcg::tri::io::ImporterPLY
EdgeIteratorLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::EdgeIterator		EdgeIteratorLeft;$/;"	t	class:vcg::tri::Append
EdgeIteratorRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::EdgeIterator   EdgeIteratorRight;$/;"	t	class:vcg::tri::Append
EdgeLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::EdgeType				EdgeLeft;$/;"	t	class:vcg::tri::Append
EdgeLen	vcglib/vcg/complex/algorithms/refine.h	/^    EdgeLen(){};$/;"	f	class:vcg::tri::EdgeLen
EdgeLen	vcglib/vcg/complex/algorithms/refine.h	/^    EdgeLen(FLT threshold) {setThr(threshold);}$/;"	f	class:vcg::tri::EdgeLen
EdgeLen	vcglib/vcg/complex/algorithms/refine.h	/^class EdgeLen$/;"	c	namespace:vcg::tri
EdgeLenght3D	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^            static ScalarType EdgeLenght3D(const FaceType *f,int e)$/;"	f	class:vcg::tri::Distortion
EdgeLenghtUV	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^            static ScalarType EdgeLenghtUV(const FaceType *f,int e)$/;"	f	class:vcg::tri::Distortion
EdgeLenghtVariationIfVertexRotated	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static ScalarType EdgeLenghtVariationIfVertexRotated(const FaceType &f, int w0)$/;"	f	class:vcg::tri::BitQuad
EdgeMap	vcglib/vcg/complex/algorithms/clip.h	/^  typedef STDEXT::hash_map<unsigned int, UIntHMap> EdgeMap;$/;"	t	class:vcg::tri::TriMeshClipper
EdgeMap_i	vcglib/vcg/complex/algorithms/clip.h	/^  typedef typename EdgeMap::iterator EdgeMap_i;$/;"	t	class:vcg::tri::TriMeshClipper
EdgeMap_v	vcglib/vcg/complex/algorithms/clip.h	/^  typedef typename EdgeMap::value_type EdgeMap_v;$/;"	t	class:vcg::tri::TriMeshClipper
EdgeMontecarlo	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void EdgeMontecarlo(MetroMesh & m, VertexSampler &ps, int sampleNum, bool sampleAllEdges)$/;"	f	class:vcg::tri::SurfaceSampling
EdgePlane	vcglib/vcg/simplex/face/component_ep.h	/^template <class T> class EdgePlane: public T {$/;"	c	namespace:vcg::face
EdgePlaneInfo	vcglib/vcg/simplex/face/component_ep.h	/^struct EdgePlaneInfo{$/;"	s	namespace:vcg::face
EdgePlaneType	vcglib/vcg/simplex/face/component_ep.h	/^	typedef EdgePlaneInfo<typename T::VertexType::CoordType> EdgePlaneType;$/;"	t	class:vcg::face::EdgePlane
EdgePlaneType	vcglib/vcg/simplex/face/component_ep.h	/^typedef EdgePlaneInfo<typename T::VertexType::CoordType> EdgePlaneType;$/;"	t	class:vcg::face::EmptyEdgePlane
EdgePointer	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::EdgePointer  EdgePointer;$/;"	t	class:vcg::tri::Clean
EdgePointer	vcglib/vcg/complex/algorithms/create/extrude.h	/^  typedef typename MeshType::EdgePointer EdgePointer;$/;"	t	class:vcg::tri::Extrude
EdgePointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::EdgePointer EdgePointer;$/;"	t	class:vcg::tri::HalfedgeQuadClean
EdgePointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::EdgePointer EdgePointer;$/;"	t	class:vcg::tri::Homeometry
EdgePointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::EdgePointer EdgePointer;$/;"	t	class:vcg::tri::VertReg
EdgePointer	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef typename MeshType::EdgePointer    EdgePointer;$/;"	t	class:vcg::tri::UpdateFlags
EdgePointer	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::EdgePointer EdgePointer;$/;"	t	class:vcg::tri::UpdateHalfEdges
EdgePointer	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                typedef typename MeshType::EdgePointer EdgePointer;$/;"	t	class:vcg::tri::HalfEdgeTopology
EdgePointer	vcglib/vcg/complex/algorithms/update/topology.h	/^typedef typename MeshType::EdgePointer    EdgePointer;$/;"	t	class:vcg::tri::UpdateTopology
EdgePointer	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::EdgePointer  EdgePointer;$/;"	t	class:vcg::tri::Allocator
EdgePointer	vcglib/vcg/complex/base.h	/^                                typedef typename EdgeContainer::value_type *  EdgePointer;$/;"	t	struct:vcg::tri::MeshTypeHolder
EdgePointer	vcglib/vcg/complex/base.h	/^                typedef typename  TYPESPOOL::EdgePointer	EdgePointer;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
EdgePointer	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::EdgePointer						EdgePointer;$/;"	t	class:vcg::tri::TriMesh
EdgePointer	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsEdgeType: public T{typedef A EdgeType;			typedef EdgeType *	EdgePointer			;};$/;"	t	struct:vcg::Use::AsEdgeType
EdgePointer	vcglib/vcg/complex/used_types.h	/^        typedef EdgeType *	EdgePointer		;$/;"	t	struct:vcg::DummyTypes
EdgePointer	vcglib/vcg/connectors/halfedge_pos.h	/^            typedef typename MeshType::EdgePointer EdgePointer;$/;"	t	class:vcg::hedge::Pos
EdgePointer	vcglib/vcg/simplex/tetrahedron/base.h	/^  typedef BET *EdgePointer;$/;"	t	class:vcg::TetraTypeHolder
EdgePredicate	vcglib/wrap/miq/quadrangulator.h	/^    class EdgePredicate$/;"	c	class:Quadrangulator
EdgeRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::EdgeType				EdgeRight;$/;"	t	class:vcg::tri::Append
EdgeSampling	vcglib/apps/metro/sampling.h	/^void Sampling<MetroMesh>::EdgeSampling()$/;"	f	class:vcg::Sampling
EdgeSeamInfo	vcglib/wrap/miq/core/vertex_indexing.h	/^    std::vector<SeamInfo> EdgeSeamInfo;$/;"	m	struct:MeshSystemInfo
EdgeSet	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  struct EdgeSet$/;"	s	class:vcg::tri::EdgeCollapser
EdgeSet	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void EdgeSet(MeshType &m, unsigned int FlagMask)$/;"	f	class:vcg::tri::UpdateFlags
EdgeSetV	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void EdgeSetV(MeshType &m) { EdgeSet(m,EdgeType::VISITED);}$/;"	f	class:vcg::tri::UpdateFlags
EdgeSorter	vcglib/vcg/complex/algorithms/update/flag.h	/^    EdgeSorter() {} \/\/ Nothing to do$/;"	f	class:vcg::tri::UpdateFlags::EdgeSorter
EdgeSorter	vcglib/vcg/complex/algorithms/update/flag.h	/^  class EdgeSorter$/;"	c	class:vcg::tri::UpdateFlags
EdgeSplSphere	vcglib/vcg/complex/algorithms/refine.h	/^class EdgeSplSphere$/;"	c	namespace:vcg::tri
EdgeTable	vcglib/vcg/complex/algorithms/create/emc_lookup_table.h	/^			static int EdgeTable(unsigned char cubetype)$/;"	f	class:vcg::tri::EMCLookUpTable
EdgeToBeAvoided	vcglib/vcg/complex/algorithms/hole.h	/^          EdgeToBeAvoided(VertexPointer _v0, VertexPointer _v1):v0(_v0),v1(_v1)$/;"	f	class:vcg::tri::Hole::EdgeToBeAvoided
EdgeToBeAvoided	vcglib/vcg/complex/algorithms/hole.h	/^        class EdgeToBeAvoided$/;"	c	class:vcg::tri::Hole
EdgeType	vcglib/apps/tridecimator/tridecimator.cpp	/^            typedef  MyMesh::VertexType::EdgeType EdgeType;$/;"	t	class:MyTriEdgeCollapse	file:
EdgeType	vcglib/vcg/complex/algorithms/create/extrude.h	/^  typedef typename MeshType::EdgeType EdgeType;$/;"	t	class:vcg::tri::Extrude
EdgeType	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef typename MeshType::EdgeType       EdgeType;$/;"	t	class:vcg::tri::UpdateFlags
EdgeType	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::EdgeType EdgeType;$/;"	t	class:vcg::tri::UpdateHalfEdges
EdgeType	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::EdgeType     EdgeType;$/;"	t	class:vcg::tri::Allocator
EdgeType	vcglib/vcg/complex/base.h	/^                                typedef typename EdgeContainer::value_type EdgeType;$/;"	t	struct:vcg::tri::MeshTypeHolder
EdgeType	vcglib/vcg/complex/base.h	/^                typedef typename CONTE::value_type					EdgeType;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
EdgeType	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::EdgeType							EdgeType;$/;"	t	class:vcg::tri::TriMesh
EdgeType	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsEdgeType: public T{typedef A EdgeType;			typedef EdgeType *	EdgePointer			;};$/;"	t	struct:vcg::Use::AsEdgeType
EdgeType	vcglib/vcg/complex/used_types.h	/^        typedef _Edge EdgeType;$/;"	t	struct:vcg::DummyTypes
EdgeType	vcglib/vcg/simplex/face/component_polygon.h	/^  typedef typename T::EdgeType EdgeType;$/;"	t	class:vcg::face::PFEAdj
EdgeType	vcglib/vcg/simplex/tetrahedron/base.h	/^  typedef BET EdgeType;$/;"	t	class:vcg::TetraTypeHolder
EdgeTypeHolder	vcglib/vcg/simplex/edge/base.h	/^				class EdgeTypeHolder: public UserTypes{$/;"	c	namespace:vcg
EdgeUniform	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void EdgeUniform(MetroMesh & m, VertexSampler &ps,int sampleNum, bool sampleFauxEdge=true)$/;"	f	class:vcg::tri::SurfaceSampling
EdgeVectorHasPerEdgeColor	vcglib/vcg/complex/base.h	/^template < class EdgeType> bool EdgeVectorHasPerEdgeColor       (const std::vector<EdgeType> &) {  return EdgeType::HasColor       (); }$/;"	f	namespace:vcg::tri
EdgeVectorHasPerEdgeFlags	vcglib/vcg/complex/base.h	/^template < class EdgeType> bool EdgeVectorHasPerEdgeFlags       (const std::vector<EdgeType> &) {  return EdgeType::HasFlags       (); }$/;"	f	namespace:vcg::tri
EdgeVectorHasPerEdgeMark	vcglib/vcg/complex/base.h	/^template < class EdgeType> bool EdgeVectorHasPerEdgeMark        (const std::vector<EdgeType> &) {  return EdgeType::HasMark        (); }$/;"	f	namespace:vcg::tri
EdgeVectorHasPerEdgeNormal	vcglib/vcg/complex/base.h	/^template < class EdgeType> bool EdgeVectorHasPerEdgeNormal      (const std::vector<EdgeType> &) {  return EdgeType::HasNormal      (); }$/;"	f	namespace:vcg::tri
EdgeVectorHasPerEdgeQuality	vcglib/vcg/complex/base.h	/^template < class EdgeType> bool EdgeVectorHasPerEdgeQuality     (const std::vector<EdgeType> &) {  return EdgeType::HasQuality     (); }$/;"	f	namespace:vcg::tri
EffectTag	vcglib/wrap/dae/colladaformat.h	/^		EffectTag(const QString& id)$/;"	f	class:Collada::Tags::EffectTag
EffectTag	vcglib/wrap/dae/colladaformat.h	/^	class EffectTag : public XMLTag$/;"	c	namespace:Collada::Tags
EigVecMask	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  EigVecMask = EigenvaluesOnly | ComputeEigenvectors,$/;"	e	enum:Eigen::DecompositionOptions
Eigen	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Cholesky/LLT_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Array.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Block.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/GlobalFunctions.h	/^namespace Eigen$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/IO.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Map.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Random.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Select.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/StableNorm.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointProduct.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverVector.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^    namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^    namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Core/util/XprHelper.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Block.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Lazy.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/LeastSquares.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigen2Support/VectorBlock.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/EulerAngles.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/Umeyama.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Householder/BlockHouseholder.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Householder/Householder.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/LU/PartialPivLU_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/OrderingMethods/Amd.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/QR/HouseholderQR_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD_MKL.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseDot.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseRedux.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/misc/Image.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^namespace Eigen$/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/MoreVectorization/MathFunctions.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/chkder.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/covar.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/dogleg.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/fdjac1.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/lmpar.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/qrsolv.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/r1mpyq.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/r1updt.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/rwupdt.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^namespace Eigen { $/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^namespace Eigen$/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFitting.h	/^namespace Eigen$/;"	n
Eigen	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^namespace Eigen$/;"	n
Eigen	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	vcglib/eigenlib/unsupported/test/BVH.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	vcglib/eigenlib/unsupported/test/polynomialsolver.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	vcglib/eigenlib/unsupported/test/polynomialutils.cpp	/^namespace Eigen {$/;"	n	file:
Eigen	vcglib/vcg/math/eigen.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/vcg/math/old_matrix.h	/^namespace Eigen{$/;"	n
Eigen	vcglib/vcg/math/old_matrix33.h	/^namespace Eigen{$/;"	n
Eigen	vcglib/vcg/math/old_matrix44.h	/^namespace Eigen{$/;"	n
Eigen	vcglib/vcg/space/point2.h	/^namespace Eigen {$/;"	n
Eigen	vcglib/vcg/space/point3.h	/^namespace Eigen{$/;"	n
Eigen	vcglib/vcg/space/point4.h	/^namespace Eigen {$/;"	n
EigenBase	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^template<typename Derived> struct EigenBase$/;"	s	namespace:Eigen
EigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver(Index size)$/;"	f	class:Eigen::EigenSolver
EigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::EigenSolver
EigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^ EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_realSchur(), m_matT(), m_tmp() {}$/;"	f	class:Eigen::EigenSolver
EigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^template<typename _MatrixType> class EigenSolver$/;"	c	namespace:Eigen
EigenSolverType	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef EigenSolver<CompanionMatrixType>         EigenSolverType;$/;"	t	class:Eigen::PolynomialSolver
EigenVectorContainer	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^enum { StdVectorContainer, EigenVectorContainer };$/;"	e	enum:__anon473	file:
Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl;$/;"	t	class:Eigen::ArrayBase
EigenvalueType	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options&(~RowMajor), MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::ComplexEigenSolver
EigenvalueType	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::EigenSolver
EigenvalueType	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealSchur
EigenvaluesOnly	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  EigenvaluesOnly     = 0x40,$/;"	e	enum:Eigen::DecompositionOptions
EigenvaluesReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::DenseBase
EigenvaluesReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef Matrix<std::complex<RealScalar>, internal::traits<Derived>::ColsAtCompileTime, 1, ColMajor> EigenvaluesReturnType;$/;"	t	class:Eigen::MatrixBase
EigenvaluesReturnType	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    typedef Matrix<RealScalar, internal::traits<MatrixType>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::SelfAdjointView
EigenvectorType	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorType;$/;"	t	class:Eigen::ComplexEigenSolver
EigenvectorsType	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::EigenSolver
Elect	vcglib/vcg/complex/algorithms/symmetry.h	/^    void Elect(CoordType p0,CoordType p1)$/;"	f	class:vcg::tri::ExtrinsicPlaneSymmetry
Elem	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline ObjPtr & Elem() {$/;"	f	class:vcg::GridStaticPtr::Link
ElemIterator	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename std::vector<Entry_Type>::reverse_iterator ElemIterator;$/;"	t	class:vcg::ClosestIterator
ElemIterator	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename std::vector<Entry_Type>::reverse_iterator ElemIterator;$/;"	t	class:vcg::RayIterator
ElemName	vcglib/wrap/ply/plylib.cpp	/^const char * PlyFile::ElemName( int i )$/;"	f	class:vcg::ply::PlyFile
ElemNumber	vcglib/wrap/ply/plylib.cpp	/^int PlyFile::ElemNumber( int i ) const$/;"	f	class:vcg::ply::PlyFile
Element	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	struct Element$/;"	s	class:HeapMaxPriorityQueue
ElementAt	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar ElementAt(unsigned int i, unsigned int j) const { return (*this)(i,j); };$/;"	f
ElementAt	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar& ElementAt(unsigned int i, unsigned int j) { return (*this)(i,j); };$/;"	f
ElementAt	vcglib/vcg/math/matrix44.h	/^template <class T> T &Matrix44<T>::ElementAt(const int row, const int col) {$/;"	f	class:vcg::Matrix44
ElementAt	vcglib/vcg/math/matrix44.h	/^template <class T> T Matrix44<T>::ElementAt(const int row, const int col) const {$/;"	f	class:vcg::Matrix44
ElementAt	vcglib/vcg/math/old_deprecated_matrix.h	/^			inline TYPE ElementAt(unsigned int i, unsigned int j)$/;"	f	class:vcg::ndim::Matrix
Elems	vcglib/vcg/space/index/space_iterators.h	/^		std::vector<Entry_Type> Elems;					\/\/element loaded from curren cell$/;"	m	class:vcg::RayIterator
Elems	vcglib/vcg/space/index/space_iterators.h	/^		std::vector<Entry_Type> Elems; \/\/element loaded from the current sphere$/;"	m	class:vcg::ClosestIterator
ElseMatrixNested	vcglib/eigenlib/Eigen/src/Core/Select.h	/^  typedef typename ElseMatrixType::Nested ElseMatrixNested;$/;"	t	struct:Eigen::internal::traits
EmEdge	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^class EmEdge    : public Edge< EmUsedTypes, edge::VertexRef> {};$/;"	c	file:
EmFace	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^class EmFace    : public Face< EmUsedTypes,   face::VertexRef, face::BitFlags, face::VFAdj > {};$/;"	c	file:
EmMesh	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^class EmMesh    : public tri::TriMesh< vector<EmVertex>, vector<EmEdge>, vector<EmFace>   > {};$/;"	c	file:
EmUsedTypes	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^struct EmUsedTypes : public UsedTypes<	Use<EmVertex>   ::AsVertexType,$/;"	s	file:
EmVertex	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^class EmVertex  : public Vertex<EmUsedTypes,  vertex::Coord3f, vertex::Normal3f, vertex::VFAdj , vertex::Qualityf, vertex::Color4b, vertex::BitFlags  >{};$/;"	c	file:
EmissionTag	vcglib/wrap/dae/colladaformat.h	/^		EmissionTag()$/;"	f	class:Collada::Tags::EmissionTag
EmissionTag	vcglib/wrap/dae/colladaformat.h	/^	class EmissionTag : public XMLTag$/;"	c	namespace:Collada::Tags
Empty	vcglib/vcg/container/entries_allocation_table.h	/^virtual bool Empty(){return true;};$/;"	f	class:vcg::EntryCATBase
Empty	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	bool Empty()$/;"	f	class:vcg::AABBBinaryTreeIndex
Empty	vcglib/vcg/space/index/base.h	/^  bool Empty() {$/;"	f	class:vcg::SpatialIndex
Empty	vcglib/vcg/space/index/grid_static_ptr.h	/^    bool Empty() const {return links.empty();}$/;"	f	class:vcg::GridStaticPtr
Empty	vcglib/vcg/space/index/index2D/base_2d.h	/^  bool Empty() {$/;"	f	class:vcg::SpatialIndex2D
Empty	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        inline bool Empty() const$/;"	f	class:vcg::SpatialHashTable2D
Empty	vcglib/vcg/space/index/spatial_hashing.h	/^  inline bool Empty() const$/;"	f	class:vcg::SpatialHashTable
EmptyAdj	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class EmptyAdj: public T {$/;"	c	namespace:vcg::tetra
EmptyBitFlags	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class EmptyBitFlags: public T {$/;"	c	namespace:vcg::hedge
EmptyBitFlags	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class EmptyBitFlags: public T {$/;"	c	namespace:vcg::tetra
EmptyCell	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        inline bool EmptyCell(const Point3i &cell) const$/;"	f	class:vcg::SpatialHashTable2D
EmptyCell	vcglib/vcg/space/index/spatial_hashing.h	/^		inline bool EmptyCell(const Point3i &cell) const$/;"	f	class:vcg::SpatialHashTable
EmptyClass	vcglib/wrap/utils.h	/^class EmptyClass {$/;"	c	namespace:vcg
EmptyCore	vcglib/vcg/simplex/edge/component.h	/^template <class T> class EmptyCore: public T$/;"	c	namespace:vcg::edge
EmptyCore	vcglib/vcg/simplex/face/component.h	/^template <class T> class EmptyCore: public T {$/;"	c	namespace:vcg::face
EmptyCore	vcglib/vcg/simplex/vertex/component.h	/^template <class TT> class EmptyCore: public TT {$/;"	c	namespace:vcg::vertex
EmptyEdgePlane	vcglib/vcg/simplex/face/component_ep.h	/^template <class T> class EmptyEdgePlane: public T {$/;"	c	namespace:vcg::face
EmptyFaceNormal	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class A, class T> class EmptyFaceNormal: public T {$/;"	c	namespace:vcg::tetra
EmptyHEAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class EmptyHEAdj: public T {$/;"	c	namespace:vcg::hedge
EmptyHEdgeData	vcglib/vcg/connectors/hedge_component.h	/^class EmptyHEdgeData : public	EmptyHFAdj<		\/\/ pointer to the face$/;"	c	namespace:vcg::hedge
EmptyHFAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class EmptyHFAdj: public T {$/;"	c	namespace:vcg::hedge
EmptyHHAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class EmptyHHAdj: public T {$/;"	c	namespace:vcg::hedge
EmptyHNextAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class EmptyHNextAdj: public T {$/;"	c	namespace:vcg::hedge
EmptyHOppAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class EmptyHOppAdj: public T {$/;"	c	namespace:vcg::hedge
EmptyHPrevAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class EmptyHPrevAdj: public T {$/;"	c	namespace:vcg::hedge
EmptyHVAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class EmptyHVAdj: public T {$/;"	c	namespace:vcg::hedge
EmptyMark	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class EmptyMark: public T {$/;"	c	namespace:vcg::hedge
EmptyMark	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class EmptyMark: public T {$/;"	c	namespace:vcg::tetra
EmptyOSGColor	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class EmptyOSGColor : public T $/;"	c	namespace:vcg::vert
EmptyOSGCoord	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class EmptyOSGCoord : public T $/;"	c	namespace:vcg::vert
EmptyOSGInfo	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class EmptyOSGInfo : public T { public : OSG::GeometryPtr Geo() { assert(0); return NULL; } };$/;"	c	namespace:vcg::vert
EmptyOSGNormal	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class EmptyOSGNormal : public T $/;"	c	namespace:vcg::vert
EmptyVertexRef	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class EmptyVertexRef: public T {$/;"	c	namespace:vcg::tetra
Enable	vcglib/vcg/container/vector_occ.h	/^		void Enable(){$/;"	f	class:vcg::vector_occ
Enable	vcglib/wrap/glw/utility.h	/^			Enable,$/;"	e	enum:glw::ShaderHeaderBuilder::ExtensionMode
EnableColor	vcglib/vcg/simplex/face/component_ocf.h	/^void EnableColor() {$/;"	f	class:vcg::face::vector_ocf
EnableColor	vcglib/vcg/simplex/vertex/component_ocf.h	/^void EnableColor() {$/;"	f	class:vcg::vertex::vector_ocf
EnableCurvature	vcglib/vcg/simplex/vertex/component_ocf.h	/^void EnableCurvature() {$/;"	f	class:vcg::vertex::vector_ocf
EnableCurvatureDir	vcglib/vcg/simplex/face/component_ocf.h	/^void EnableCurvatureDir() {$/;"	f	class:vcg::face::vector_ocf
EnableCurvatureDir	vcglib/vcg/simplex/vertex/component_ocf.h	/^void EnableCurvatureDir() {$/;"	f	class:vcg::vertex::vector_ocf
EnableFFAdjacency	vcglib/vcg/simplex/face/component_ocf.h	/^void EnableFFAdjacency() {$/;"	f	class:vcg::face::vector_ocf
EnableMark	vcglib/vcg/simplex/face/component_ocf.h	/^void EnableMark() {$/;"	f	class:vcg::face::vector_ocf
EnableMark	vcglib/vcg/simplex/vertex/component_ocf.h	/^void EnableMark() {$/;"	f	class:vcg::vertex::vector_ocf
EnableNormal	vcglib/vcg/simplex/face/component_ocf.h	/^void EnableNormal() {$/;"	f	class:vcg::face::vector_ocf
EnableNormal	vcglib/vcg/simplex/vertex/component_ocf.h	/^void EnableNormal() {$/;"	f	class:vcg::vertex::vector_ocf
EnableQuality	vcglib/vcg/simplex/face/component_ocf.h	/^void EnableQuality() {$/;"	f	class:vcg::face::vector_ocf
EnableQuality	vcglib/vcg/simplex/vertex/component_ocf.h	/^void EnableQuality() {$/;"	f	class:vcg::vertex::vector_ocf
EnableRadius	vcglib/vcg/simplex/vertex/component_ocf.h	/^void EnableRadius() {$/;"	f	class:vcg::vertex::vector_ocf
EnableTexCoord	vcglib/vcg/simplex/vertex/component_ocf.h	/^void EnableTexCoord() {$/;"	f	class:vcg::vertex::vector_ocf
EnableVFAdjacency	vcglib/vcg/simplex/face/component_ocf.h	/^void EnableVFAdjacency() {$/;"	f	class:vcg::face::vector_ocf
EnableVFAdjacency	vcglib/vcg/simplex/vertex/component_ocf.h	/^void EnableVFAdjacency() {$/;"	f	class:vcg::vertex::vector_ocf
EnableWedgeColor	vcglib/vcg/simplex/face/component_ocf.h	/^void EnableWedgeColor() {$/;"	f	class:vcg::face::vector_ocf
EnableWedgeNormal	vcglib/vcg/simplex/face/component_ocf.h	/^void EnableWedgeNormal() {$/;"	f	class:vcg::face::vector_ocf
EnableWedgeTexCoord	vcglib/vcg/simplex/face/component_ocf.h	/^void EnableWedgeTexCoord() {$/;"	f	class:vcg::face::vector_ocf
End	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  bool End() const {$/;"	f	class:vcg::tri::BitQuad::Iterator
End	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    inline bool End () {$/;"	f	class:vcg::tri::PolychordCollapse::PC_Chords
End	vcglib/vcg/simplex/edge/pos.h	/^  bool End() const {return e==0;}$/;"	f	class:vcg::edge::VEIterator
End	vcglib/vcg/simplex/face/pos.h	/^  bool End() const {return f==0;}$/;"	f	class:vcg::face::VFIterator
End	vcglib/vcg/simplex/tetrahedron/pos.h	/^inline bool End(){return (Vt()==NULL);}$/;"	f	class:vcg::tetra::VTIterator
End	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			EntryIterator End()		{ return EntryIterator(this, CellCoordinate(-1, -1, -1)); }$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
End	vcglib/vcg/space/index/space_iterators.h	/^		bool End()$/;"	f	class:vcg::ClosestIterator
End	vcglib/vcg/space/index/space_iterators.h	/^		bool End()$/;"	f	class:vcg::RayIterator
EntryCAT	vcglib/vcg/container/entries_allocation_table.h	/^EntryCAT(STL_CONT & _c) : EntryCATBase<STL_CONT>(_c){};$/;"	f	struct:vcg::EntryCAT
EntryCAT	vcglib/vcg/container/entries_allocation_table.h	/^struct EntryCAT: public EntryCATBase<STL_CONT>{$/;"	s	namespace:vcg
EntryCATBase	vcglib/vcg/container/entries_allocation_table.h	/^EntryCATBase(STL_CONT & _c):c(_c){};$/;"	f	class:vcg::EntryCATBase
EntryCATBase	vcglib/vcg/container/entries_allocation_table.h	/^class EntryCATBase{$/;"	c	namespace:vcg
EntryCoordinate	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			typedef vcg::Point3i						EntryCoordinate;$/;"	t	class:vcg::PerfectSpatialHashing::OffsetTable
EntryCoordinate	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			typedef vcg::Point3i EntryCoordinate;$/;"	t	class:vcg::PerfectSpatialHashing::HashTable
EntryIterator	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				EntryIterator(UniformGrid *uniform_grid, const CellCoordinate &position)$/;"	f	struct:vcg::PerfectSpatialHashing::UniformGrid::EntryIterator
EntryIterator	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			struct EntryIterator$/;"	s	class:vcg::PerfectSpatialHashing::UniformGrid
EntryNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^	EntryNode(void){node_type = ENTRY_NODE; type = "empty";};$/;"	f	class:EntryNode
EntryNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^class EntryNode: public Node$/;"	c
EntryType	vcglib/vcg/container/container_allocation_table.h	/^typedef  ENTRY_TYPE EntryType;$/;"	t	class:vcg::CATEntry
Entry_Type	vcglib/vcg/space/index/space_iterators.h	/^			Entry_Type(ObjType* _elem,ScalarType _dist,CoordType _intersection)$/;"	f	struct:vcg::ClosestIterator::Entry_Type
Entry_Type	vcglib/vcg/space/index/space_iterators.h	/^			Entry_Type(ObjType* _elem,ScalarType _dist,CoordType _intersection)$/;"	f	struct:vcg::RayIterator::Entry_Type
Entry_Type	vcglib/vcg/space/index/space_iterators.h	/^		struct Entry_Type$/;"	s	class:vcg::ClosestIterator
Entry_Type	vcglib/vcg/space/index/space_iterators.h	/^		struct Entry_Type$/;"	s	class:vcg::RayIterator
Env	vcglib/vcg/container/container_allocation_table.h	/^struct Env{$/;"	s	namespace:vcg
EofF	vcglib/vcg/space/tetra3.h	/^ static int EofF(const int &indexF,const int &indexE) $/;"	f	class:vcg::Tetra
EofFF	vcglib/vcg/space/tetra3.h	/^static int EofFF(const int &indexF0,const int &indexF1)$/;"	f	class:vcg::Tetra
EofV	vcglib/vcg/space/tetra3.h	/^  static int EofV(const int &indexV,const int &indexE) $/;"	f	class:vcg::Tetra
EofVV	vcglib/vcg/space/tetra3.h	/^static int EofVV(const int &indexV0,const int &indexV1) $/;"	f	class:vcg::Tetra
EquivVcgType	vcglib/vcg/math/eigen_matrix_addons.h	/^typedef typename ei_to_vcgtype<Matrix>::type EquivVcgType;$/;"	t
Erase	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  void Erase(std::list<FrontEdge>::iterator e) {$/;"	f	class:vcg::tri::AdvancingFront
EraseIntegerEdge	vcglib/wrap/miq/quadrangulator.h	/^    void EraseIntegerEdge(const std::vector<std::pair<TriFaceType*,int> > &to_erase)$/;"	f	class:Quadrangulator
EraseIntegerEdge	vcglib/wrap/miq/quadrangulator.h	/^    void EraseIntegerEdge(const vcg::face::Pos<TriFaceType> &ep)$/;"	f	class:Quadrangulator
Error	vcglib/wrap/bmt/bmt.h	/^    float Error() { return error; }$/;"	f	class:vcg::Bmt::Cell
Error	vcglib/wrap/io_tetramesh/io_ply.h	/^enum Error$/;"	g	class:vcg::tetra::io::PlyInfo
Error	vcglib/wrap/io_trimesh/io_ply.h	/^enum Error$/;"	g	class:vcg::tri::io::PlyInfo
ErrorCritical	vcglib/wrap/io_trimesh/import.h	/^static bool ErrorCritical(int error)$/;"	f	class:vcg::tri::io::Importer
ErrorCritical	vcglib/wrap/io_trimesh/import_fbx.h	/^	static bool ErrorCritical(int err)$/;"	f	class:ImporterFBX
ErrorCritical	vcglib/wrap/io_trimesh/import_obj.h	/^                static bool ErrorCritical(int err)$/;"	f	class:vcg::tri::io::ImporterOBJ
ErrorCritical	vcglib/wrap/io_trimesh/import_ply.h	/^static bool ErrorCritical(int err)$/;"	f	class:vcg::tri::io::ImporterPLY
ErrorDegenerateFace	vcglib/wrap/io_trimesh/import_off.h	/^                 UnsupportedFormat, ErrorNotTriangularFace,ErrorHighDimension,ErrorDegenerateFace};$/;"	e	enum:vcg::tri::io::ImporterOFF::OFFCodes
ErrorHighDimension	vcglib/wrap/io_trimesh/import_off.h	/^                 UnsupportedFormat, ErrorNotTriangularFace,ErrorHighDimension,ErrorDegenerateFace};$/;"	e	enum:vcg::tri::io::ImporterOFF::OFFCodes
ErrorMsg	vcglib/wrap/dae/util_dae.h	/^		static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::UtilDAE
ErrorMsg	vcglib/wrap/io_trimesh/export.h	/^static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::Exporter
ErrorMsg	vcglib/wrap/io_trimesh/export_3ds.h	/^		static const char* ErrorMsg(int error)$/;"	f	class:vcg::tri::io::Exporter3DS
ErrorMsg	vcglib/wrap/io_trimesh/export_ctm.h	/^                static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterCTM
ErrorMsg	vcglib/wrap/io_trimesh/export_dxf.h	/^  static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterDXF
ErrorMsg	vcglib/wrap/io_trimesh/export_gts.h	/^        static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterGTS
ErrorMsg	vcglib/wrap/io_trimesh/export_idtf.h	/^	static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterIDTF
ErrorMsg	vcglib/wrap/io_trimesh/export_obj.h	/^  static const char* ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterOBJ
ErrorMsg	vcglib/wrap/io_trimesh/export_off.h	/^        static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterOFF
ErrorMsg	vcglib/wrap/io_trimesh/export_ply.h	/^static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterPLY
ErrorMsg	vcglib/wrap/io_trimesh/export_smf.h	/^		static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterSMF
ErrorMsg	vcglib/wrap/io_trimesh/export_stl.h	/^static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterSTL
ErrorMsg	vcglib/wrap/io_trimesh/export_u3d.h	/^	static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterU3D
ErrorMsg	vcglib/wrap/io_trimesh/export_vmi.h	/^        static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterVMI
ErrorMsg	vcglib/wrap/io_trimesh/export_vrml.h	/^	static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ExporterWRL
ErrorMsg	vcglib/wrap/io_trimesh/import.h	/^static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::Importer
ErrorMsg	vcglib/wrap/io_trimesh/import_asc.h	/^static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ImporterASC
ErrorMsg	vcglib/wrap/io_trimesh/import_ctm.h	/^static const char* ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ImporterCTM
ErrorMsg	vcglib/wrap/io_trimesh/import_fbx.h	/^	static const char* ErrorMsg(int error)$/;"	f	class:ImporterFBX
ErrorMsg	vcglib/wrap/io_trimesh/import_gts.h	/^				static const char* ErrorMsg(int message_code)$/;"	f	class:vcg::tri::io::ImporterGTS
ErrorMsg	vcglib/wrap/io_trimesh/import_obj.h	/^                static const char* ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ImporterOBJ
ErrorMsg	vcglib/wrap/io_trimesh/import_off.h	/^  static const char* ErrorMsg(int message_code)$/;"	f	class:vcg::tri::io::ImporterOFF
ErrorMsg	vcglib/wrap/io_trimesh/import_ply.h	/^static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ImporterPLY
ErrorMsg	vcglib/wrap/io_trimesh/import_ptx.h	/^		static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ImporterPTX
ErrorMsg	vcglib/wrap/io_trimesh/import_raw.h	/^static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ImporterRAW
ErrorMsg	vcglib/wrap/io_trimesh/import_smf.h	/^		static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ImporterSMF
ErrorMsg	vcglib/wrap/io_trimesh/import_stl.h	/^static const char *ErrorMsg(int error)$/;"	f	class:vcg::tri::io::ImporterSTL
ErrorMsg	vcglib/wrap/io_trimesh/import_vmi.h	/^        static const char* ErrorMsg(int message_code)$/;"	f	class:vcg::tri::io::ImporterVMI
ErrorNotTriangularFace	vcglib/wrap/io_trimesh/import_gts.h	/^					UnsupportedFormat, ErrorNotTriangularFace};$/;"	e	enum:vcg::tri::io::ImporterGTS::GTSCodes
ErrorNotTriangularFace	vcglib/wrap/io_trimesh/import_off.h	/^                 UnsupportedFormat, ErrorNotTriangularFace,ErrorHighDimension,ErrorDegenerateFace};$/;"	e	enum:vcg::tri::io::ImporterOFF::OFFCodes
EssentialVectorType	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^            EssentialVectorType;$/;"	t	class:Eigen::HouseholderSequence
EssentialVectorType	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef Block<const VectorsType, Dynamic, 1> EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
EssentialVectorType	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef Transpose<Block<const VectorsType, 1, Dynamic> > EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
EuclideanDistance	vcglib/vcg/complex/algorithms/geodesic.h	/^  EuclideanDistance(){}$/;"	f	struct:vcg::tri::EuclideanDistance
EuclideanDistance	vcglib/vcg/complex/algorithms/geodesic.h	/^struct EuclideanDistance{$/;"	s	namespace:vcg::tri
Eval	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  ScalarType Eval(CoordType p) const$/;"	f	struct:vcg::tri::VoronoiProcessing::QuadricSumDistance
EvalBeforeAssigningBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeAssigningBit = 0x4;$/;"	m	namespace:Eigen
EvalBeforeNestingBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeNestingBit = 0x2;$/;"	m	namespace:Eigen
EvalPlane	vcglib/apps/sample/trimesh_fitting/trimesh_fitting.cpp	/^float EvalPlane(vcg::Plane3f &pl, std::vector<vcg::Point3f> posVec)$/;"	f
EvalPlane	vcglib/apps/sample/trimesh_pointmatching/trimesh_pointmatching.cpp	/^float EvalPlane(vcg::Plane3f &pl, std::vector<vcg::Point3f> posVec)$/;"	f
EvalReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;$/;"	t	class:Eigen::DenseBase
EvalToKnownPointType	vcglib/wrap/gl/deprecated_space.h	/^template<typename Derived> struct EvalToKnownPointType<Derived,2,1>$/;"	s	namespace:vcg
EvalToKnownPointType	vcglib/wrap/gl/deprecated_space.h	/^template<typename Derived> struct EvalToKnownPointType<Derived,3,1>$/;"	s	namespace:vcg
EvalToKnownPointType	vcglib/wrap/gl/deprecated_space.h	/^template<typename Derived> struct EvalToKnownPointType<Derived,4,1>$/;"	s	namespace:vcg
EvalToKnownPointType	vcglib/wrap/gl/space.h	/^template<typename Derived> struct EvalToKnownPointType<Derived,2,1>$/;"	s	namespace:vcg
EvalToKnownPointType	vcglib/wrap/gl/space.h	/^template<typename Derived> struct EvalToKnownPointType<Derived,3,1>$/;"	s	namespace:vcg
EvalToKnownPointType	vcglib/wrap/gl/space.h	/^template<typename Derived> struct EvalToKnownPointType<Derived,4,1>$/;"	s	namespace:vcg
EvalToRowMajor	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon194
EvalToRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    EvalToRowMajor = (RhsFlags & LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon424
EvalToRowMajor	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        EvalToRowMajor = (RhsFlags & LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon452
EvaluateAlignment	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^FourPCS<MeshType>::EvaluateAlignment(Candidate  & fp){$/;"	f	class:vcg::tri::FourPCS
EvaluateSample	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^int FourPCS<MeshType>::EvaluateSample(Candidate & fp, CoordType & tp, CoordType & np, const float &  cosAngle)$/;"	f	class:vcg::tri::FourPCS
EvenPointLoop	vcglib/vcg/complex/algorithms/refine_loop.h	/^struct EvenPointLoop : EvenPointLoopGeneric<MESH_TYPE, Centroid<MESH_TYPE> >$/;"	s	namespace:vcg::tri
EvenPointLoopGeneric	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline EvenPointLoopGeneric(Projection proj = Projection(), Weight weight = Weight()) :$/;"	f	struct:vcg::tri::EvenPointLoopGeneric
EvenPointLoopGeneric	vcglib/vcg/complex/algorithms/refine_loop.h	/^struct EvenPointLoopGeneric : public std::unary_function<face::Pos<typename MESH_TYPE::FaceType> , typename MESH_TYPE::VertexType>$/;"	s	namespace:vcg::tri
Execute	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            inline void Execute(MeshType &m)$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
Execute	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  void Execute(TETRA_MESH_TYPE &tm)$/;"	f	class:vcg::tetra::TetraEdgeCollapse
Execute	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  inline void Execute(TriMeshType &m, BaseParameterClass *)$/;"	f	class:vcg::tri::TriEdgeCollapse
Execute	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^    void Execute(TriMeshType &m, BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
Execute	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  void Execute(TriMeshType &m, BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
Execute	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	void Execute(TRIMESH_TYPE &m)$/;"	f	class:vcg::tri::TopoEdgeFlip
Execute	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  void Execute(TRIMESH_TYPE &m, BaseParameterClass *)$/;"	f	class:vcg::tri::PlanarEdgeFlip
Exist	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	bool Exist(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:Walker
Exist	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    bool Exist(const vcg::Point3i &p0, const vcg::Point3i &p1, VertexPointer &v)$/;"	f	class:vcg::tri::TrivialWalker
Exist	vcglib/vcg/complex/algorithms/create/resampler.h	/^		bool Exist(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:vcg::tri::Resampler::Walker
Expand	vcglib/wrap/mt/mt.h	/^  bool Expand(Cell *cell) {$/;"	f	class:vcg::DiracPolicy
Expand	vcglib/wrap/mt/mt.h	/^  bool Expand(Cell *cell) {$/;"	f	class:vcg::FrustumPolicy
Exporter	vcglib/wrap/io_trimesh/export.h	/^class Exporter$/;"	c	namespace:vcg::tri::io
Exporter3DS	vcglib/wrap/io_trimesh/export_3ds.h	/^	class Exporter3DS$/;"	c	namespace:vcg::tri::io
ExporterCTM	vcglib/wrap/io_trimesh/export_ctm.h	/^            class ExporterCTM$/;"	c	namespace:vcg::tri::io
ExporterDAE	vcglib/wrap/io_trimesh/export_dae.h	/^	class ExporterDAE$/;"	c	namespace:vcg::tri::io
ExporterDXF	vcglib/wrap/io_edgemesh/export_dxf.h	/^	ExporterDXF(void){}$/;"	f	class:vcg::edg::io::ExporterDXF
ExporterDXF	vcglib/wrap/io_edgemesh/export_dxf.h	/^class ExporterDXF$/;"	c	namespace:vcg::edg::io
ExporterDXF	vcglib/wrap/io_trimesh/export_dxf.h	/^class ExporterDXF$/;"	c	namespace:vcg::tri::io
ExporterFBX	vcglib/wrap/io_trimesh/export_fbx.h	/^class ExporterFBX$/;"	c
ExporterFIELD	vcglib/wrap/io_trimesh/export_field.h	/^class ExporterFIELD$/;"	c	namespace:vcg::tri::io
ExporterGTS	vcglib/wrap/io_trimesh/export_gts.h	/^			class ExporterGTS$/;"	c	namespace:vcg::tri::io
ExporterIDTF	vcglib/wrap/io_trimesh/export_idtf.h	/^class ExporterIDTF$/;"	c	namespace:vcg::tri::io
ExporterOBJ	vcglib/wrap/io_trimesh/export_obj.h	/^class ExporterOBJ$/;"	c	namespace:vcg::tri::io
ExporterOFF	vcglib/wrap/io_trimesh/export_off.h	/^			class ExporterOFF$/;"	c	namespace:vcg::tri::io
ExporterPLY	vcglib/wrap/io_tetramesh/export_ply.h	/^class ExporterPLY$/;"	c	namespace:vcg::tetra::io
ExporterPLY	vcglib/wrap/io_trimesh/export_ply.h	/^class ExporterPLY$/;"	c	namespace:vcg::tri::io
ExporterSMF	vcglib/wrap/io_trimesh/export_smf.h	/^	class ExporterSMF$/;"	c	namespace:vcg::tri::io
ExporterSTL	vcglib/wrap/io_trimesh/export_stl.h	/^class ExporterSTL$/;"	c	namespace:vcg::tri::io
ExporterSVG	vcglib/wrap/io_edgemesh/export_svg.h	/^class ExporterSVG$/;"	c	namespace:vcg::tri::io
ExporterTS	vcglib/wrap/io_tetramesh/export_ts.h	/^struct ExporterTS{$/;"	s	namespace:vcg::tetra::io
ExporterU3D	vcglib/wrap/io_trimesh/export_u3d.h	/^class ExporterU3D$/;"	c	namespace:vcg::tri::io
ExporterVMI	vcglib/wrap/io_trimesh/export_vmi.h	/^    class ExporterVMI$/;"	c	namespace:vcg::tri::io
ExporterWRL	vcglib/wrap/io_trimesh/export_vrml.h	/^			class ExporterWRL$/;"	c	namespace:vcg::tri::io
ExpressionType	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits
ExpressionType	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits
ExpressionTypeNested	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Flagged
ExpressionTypeNested	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^        ExpressionType, ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::VectorwiseOp
ExpressionTypeNested	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Cwise
ExpressionTypeNestedCleaned	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::remove_all<ExpressionTypeNested>::type ExpressionTypeNestedCleaned;$/;"	t	class:Eigen::VectorwiseOp
Ext	vcglib/vcg/math/eigen_matrixbase_addons.h	/^inline Scalar Ext( const int i ) const$/;"	f
Ext	vcglib/vcg/space/deprecated_point.h	/^    inline S Ext( const int i ) const$/;"	f	class:vcg::ndim::Point
Ext	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType Ext( const int i ) const$/;"	f	class:vcg::Point2
Ext	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType Ext( const int i ) const$/;"	f	class:vcg::Point3
Ext	vcglib/vcg/space/deprecated_point4.h	/^    inline T Ext( const int i ) const$/;"	f	class:vcg::Point4
ExtB	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  std::vector<VertexType*> ExtB[4]; \/\/ selection of vertices "close" to the four point$/;"	m	class:vcg::tri::FourPCS
ExtendedMarchingCubes	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            ExtendedMarchingCubes(TRIMESH_TYPE &mesh, WALKER_TYPE &walker, ScalarType angle=30)$/;"	f	class:vcg::tri::ExtendedMarchingCubes
ExtendedMarchingCubes	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^        class ExtendedMarchingCubes$/;"	c	namespace:vcg::tri
ExtendedType	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct ExtendedType {$/;"	s	class:Eigen::VectorwiseOp
ExtensionMap	vcglib/wrap/glw/utility.h	/^		typedef std::map<std::string, ExtensionMode> ExtensionMap;$/;"	t	class:glw::ShaderHeaderBuilder
ExtensionMapConstIterator	vcglib/wrap/glw/utility.h	/^		typedef ExtensionMap::const_iterator         ExtensionMapConstIterator;$/;"	t	class:glw::ShaderHeaderBuilder
ExtensionMapIterator	vcglib/wrap/glw/utility.h	/^		typedef ExtensionMap::iterator               ExtensionMapIterator;$/;"	t	class:glw::ShaderHeaderBuilder
ExtensionMapValue	vcglib/wrap/glw/utility.h	/^		typedef ExtensionMap::value_type             ExtensionMapValue;$/;"	t	class:glw::ShaderHeaderBuilder
ExtensionMode	vcglib/wrap/glw/utility.h	/^		enum ExtensionMode$/;"	g	class:glw::ShaderHeaderBuilder
ExternalProduct	vcglib/vcg/math/matrix33.h	/^void ExternalProduct(const Point3<S> &a, const Point3<S> &b)$/;"	f	class:vcg::Matrix33
ExternalProduct	vcglib/vcg/math/old_matrix33.h	/^	void ExternalProduct(const Point3<Scalar> &a, const Point3<Scalar> &b) { *this = a * b.transpose(); }$/;"	f	class:vcg::Matrix33
ExtraTCoordWeight	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  float   ExtraTCoordWeight;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
Extract	vcglib/wrap/mt/mt.h	/^  template <class CONT, class POLICY> void Extract(CONT &selected, POLICY &policy) {$/;"	f	class:vcg::MT
Extract	vcglib/wrap/mt/mt.h	/^  template <class CONT> void Extract(CONT &selected) {$/;"	f	class:vcg::MT
Extract	vcglib/wrap/mt/mt.h	/^  template <class CONT> void Extract(CONT &selected, float error) {$/;"	f	class:vcg::MT
ExtractMesh	vcglib/vcg/complex/algorithms/clustering.h	/^  void ExtractMesh(MeshType &m)$/;"	f	class:vcg::tri::Clustering
ExtractPointSet	vcglib/vcg/complex/algorithms/clustering.h	/^  void ExtractPointSet(MeshType &m)$/;"	f	class:vcg::tri::Clustering
ExtractPolygon	vcglib/vcg/complex/algorithms/polygon_support.h	/^	static void ExtractPolygon(typename TriMeshType::FacePointer tfp, std::vector<typename TriMeshType::VertexPointer> &vs)$/;"	f	struct:vcg::tri::PolygonSupport
ExtractType	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType>  ExtractType; \/\/ const to get rid of a compile error; anyway blas traits are only used on the RHS$/;"	t	struct:Eigen::internal::blas_traits
ExtractType	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef const XprType& ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
ExtractType	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename Base::ExtractType ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
ExtractVertex	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^inline void ExtractVertex(const SrcMesh & srcMesh, const SrcFace & f, int whichWedge, const DstMesh & dstMesh, DstVertex & v)$/;"	f
ExtractVertex	vcglib/wrap/miq/quadrangulator.h	/^inline void ExtractVertex(const MeshType & srcMesh,$/;"	f
ExtrinsicPlaneSymmetry	vcglib/vcg/complex/algorithms/symmetry.h	/^    ExtrinsicPlaneSymmetry(TriMeshType &_tri_mesh):tri_mesh(_tri_mesh)$/;"	f	class:vcg::tri::ExtrinsicPlaneSymmetry
ExtrinsicPlaneSymmetry	vcglib/vcg/complex/algorithms/symmetry.h	/^class ExtrinsicPlaneSymmetry$/;"	c	namespace:vcg::tri
Extrinsics	vcglib/vcg/math/shot.h	/^  ReferenceFrame<S,RotationType>	Extrinsics;		\/\/ the position and orientation of the camera$/;"	m	class:vcg::Shot
Extrude	vcglib/vcg/complex/algorithms/create/extrude.h	/^template <class MeshType> class Extrude$/;"	c	namespace:vcg::tri
F	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  FaceType* &F(){return f;}$/;"	f	class:vcg::tri::BitQuad::Pos
F	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  FaceType* F() const {return f;}$/;"	f	class:vcg::tri::BitQuad::Pos
F	vcglib/vcg/connectors/halfedge_pos.h	/^            FacePointer F()$/;"	f	class:vcg::hedge::Pos
F	vcglib/vcg/simplex/face/pos.h	/^	VFIFaceType *&	F() { return f;}$/;"	f	class:vcg::face::VFIterator
F	vcglib/vcg/simplex/face/pos.h	/^   FaceType   * F() const { return f; }$/;"	f	class:vcg::face::Pos
F	vcglib/vcg/simplex/face/pos.h	/^   FaceType   *& F(){ return f; }$/;"	f	class:vcg::face::Pos
F	vcglib/vcg/simplex/tetrahedron/pos.h	/^	inline char & F()$/;"	f	class:vcg::tetra::Pos
F	vcglib/vcg/simplex/tetrahedron/pos.h	/^	inline const char & F() const$/;"	f	class:vcg::tetra::Pos
F	vcglib/wrap/io_tetramesh/export_ts.h	/^	static FILE *& F(){static FILE * f; return f;}$/;"	f	struct:vcg::tetra::io::ExporterTS
F	vcglib/wrap/io_tetramesh/import_ts.h	/^	static FILE *& F(){static FILE * f; return f;}$/;"	f	class:vcg::tetra::io::ImporterTS
F	vcglib/wrap/io_trimesh/export_vmi.h	/^        static FILE *& F(){static FILE * f; return f;}$/;"	f	class:vcg::tri::io::ExporterVMI
F	vcglib/wrap/io_trimesh/import_vmi.h	/^        static FILE *& F(){static FILE * f; return f;}$/;"	f	class:vcg::tri::io::ImporterVMI
FABS	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define FABS(/;"	d
FABS	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef FABS$/;"	d
FACENORMAL	vcglib/wrap/dae/colladaformat.h	/^		enum ARRAYSEMANTIC {VERTPOSITION,VERTNORMAL,VERTCOLOR, FACENORMAL,WEDGETEXCOORD};$/;"	e	enum:Collada::Tags::FloatArrayTag::ARRAYSEMANTIC
FACE_SAMPLING	vcglib/apps/metro/sampling.h	/^						FACE_SAMPLING										= 0x0008,$/;"	e	enum:vcg::SamplingFlags::__anon1
FAIL	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^struct FAIL{$/;"	s
FAK_LEN	vcglib/vcg/complex/algorithms/point_sampling.h	/^#define FAK_LEN /;"	d
FAUX0	vcglib/vcg/simplex/face/base.h	/^		FAUX0       = 0x00040000,$/;"	e	enum:vcg::FaceArityMax::__anon497
FAUX012	vcglib/vcg/simplex/face/base.h	/^		FAUX012     = FAUX0 | FAUX1 | FAUX2 ,$/;"	e	enum:vcg::FaceArityMax::__anon497
FAUX1	vcglib/vcg/simplex/face/base.h	/^		FAUX1       = 0x00080000,$/;"	e	enum:vcg::FaceArityMax::__anon497
FAUX2	vcglib/vcg/simplex/face/base.h	/^		FAUX2       = 0x00100000,$/;"	e	enum:vcg::FaceArityMax::__anon497
FBSType	vcglib/wrap/gl/fbo.h	/^	} FBSType;$/;"	t	class:FrameBufferSemantic	typeref:enum:FrameBufferSemantic::__anon515
FBXError	vcglib/wrap/io_trimesh/import_fbx.h	/^	enum FBXError $/;"	g	class:ImporterFBX
FC_FIRST_PLANE_BIT	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^		FC_FIRST_PLANE_BIT					= 0,$/;"	e	enum:vcg::AABBBinaryTreeFrustumCull::__anon505
FC_FULLY_VISIBLE_BIT	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^		FC_FULLY_VISIBLE_BIT				= (1 << (FC_FIRST_PLANE_BIT + 4)),$/;"	e	enum:vcg::AABBBinaryTreeFrustumCull::__anon505
FC_PARTIALLY_VISIBLE_BIT	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^		FC_PARTIALLY_VISIBLE_BIT		= (1 << (FC_FIRST_PLANE_BIT + 3)),$/;"	e	enum:vcg::AABBBinaryTreeFrustumCull::__anon505
FC_PASS_THROUGH_FIRST_BIT	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^		FC_PASS_THROUGH_FIRST_BIT		= (FC_FIRST_PLANE_BIT + 5)$/;"	e	enum:vcg::AABBBinaryTreeFrustumCull::__anon505
FEAdj	vcglib/vcg/simplex/face/component.h	/^  FEAdj(){$/;"	f	class:vcg::face::FEAdj
FEAdj	vcglib/vcg/simplex/face/component.h	/^template <class T> class FEAdj: public T {$/;"	c	namespace:vcg::face
FENCEPOST_HEAD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define FENCEPOST_HEAD /;"	d	file:
FEp	vcglib/vcg/simplex/face/component.h	/^  typename T::EdgePointer &FEp( int j)        { assert(j>=0 && j<3);  return _fep[j]; }$/;"	f	class:vcg::face::FEAdj
FEp	vcglib/vcg/simplex/face/component.h	/^  typename T::EdgePointer &FEp(int)       { static typename T::EdgePointer fp=0; assert(0); return fp; }$/;"	f	class:vcg::face::EmptyCore
FEp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::EdgePointer       &FEp(const int j)        { assert(j>=0 && j<this->VN());  return _fepP[j]; }$/;"	f	class:vcg::face::PFEAdj
FEp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::EdgePointer const  FEp(const int j) const  { assert(j>=0 && j<this->VN());  return _fepP[j]; }$/;"	f	class:vcg::face::PFEAdj::T
FEp1	vcglib/vcg/simplex/face/component.h	/^  typename T::EdgePointer  FEp1( int j ) const { return FEp((j+1)%3);}$/;"	f	class:vcg::face::FEAdj
FEp1	vcglib/vcg/simplex/face/component.h	/^  typename T::EdgePointer &FEp1( int j )       { return FEp((j+1)%3);}$/;"	f	class:vcg::face::FEAdj
FEp2	vcglib/vcg/simplex/face/component.h	/^  typename T::EdgePointer  FEp2( int j ) const { return FEp((j+2)%3);}$/;"	f	class:vcg::face::FEAdj
FEp2	vcglib/vcg/simplex/face/component.h	/^  typename T::EdgePointer &FEp2( int j )       { return FEp((j+2)%3);}$/;"	f	class:vcg::face::FEAdj
FFAdj	vcglib/vcg/simplex/face/component.h	/^  FFAdj(){$/;"	f	class:vcg::face::FFAdj
FFAdj	vcglib/vcg/simplex/face/component.h	/^template <class T> class FFAdj: public T {$/;"	c	namespace:vcg::face
FFAdjOcc	vcglib/vcg/simplex/face/component_occ.h	/^template <class T> class FFAdjOcc : public FFAdjOccBase<FFAdjTypeSup<typename T::FacePointer>,T>{};$/;"	c	namespace:vcg::face
FFAdjOccBase	vcglib/vcg/simplex/face/component_occ.h	/^template <class A, class T> class FFAdjOccBase: public T {$/;"	c	namespace:vcg::face
FFAdjOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class FFAdjOcf: public T {$/;"	c	namespace:vcg::face
FFAdjType	vcglib/vcg/simplex/face/component_occ.h	/^	typedef FFAdjTypeSup<typename T::FacePointer> FFAdjType;$/;"	t	class:vcg::face::FFAdjOccBase
FFAdjTypeSup	vcglib/vcg/simplex/face/component_occ.h	/^struct FFAdjTypeSup {$/;"	s	namespace:vcg::face
FFAdjacencyEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  bool FFAdjacencyEnabled;$/;"	m	class:vcg::face::vector_ocf
FFAttach	vcglib/vcg/simplex/face/topology.h	/^void FFAttach(FaceType * &f, int z1, FaceType *&f2, int z2)$/;"	f	namespace:vcg::face
FFAttachManifold	vcglib/vcg/simplex/face/topology.h	/^void FFAttachManifold(FaceType * &f1, int z1, FaceType *&f2, int z2)$/;"	f	namespace:vcg::face
FFCorrectness	vcglib/vcg/simplex/face/topology.h	/^bool FFCorrectness(FaceType & f, const int e)$/;"	f	namespace:vcg::face
FFDetach	vcglib/vcg/simplex/face/topology.h	/^void FFDetach(FaceType & f, const int e)$/;"	f	namespace:vcg::face
FFDetachManifold	vcglib/vcg/simplex/face/topology.h	/^void FFDetachManifold(FaceType & f, const int e)$/;"	f	namespace:vcg::face
FFEdgeCollapse	vcglib/vcg/simplex/face/topology.h	/^void FFEdgeCollapse(MeshType &m, typename MeshType::FaceType &f, const int z)$/;"	f	namespace:vcg::face
FFExtendedStarFF	vcglib/vcg/simplex/face/topology.h	/^    static void FFExtendedStarFF(FaceType *fp,$/;"	f	namespace:vcg::face
FFLinkCondition	vcglib/vcg/simplex/face/topology.h	/^bool FFLinkCondition(FaceType &f, const int z)$/;"	f	namespace:vcg::face
FFSetBorder	vcglib/vcg/simplex/face/topology.h	/^void FFSetBorder(FaceType * &f1, int z1)$/;"	f	namespace:vcg::face
FFi	vcglib/vcg/simplex/face/component.h	/^  char &FFi(const int j)       { return _ffi[j]; }$/;"	f	class:vcg::face::FFAdj
FFi	vcglib/vcg/simplex/face/component.h	/^  char &FFi(int)       { static char z=0; assert(0); return z;}$/;"	f	class:vcg::face::EmptyCore
FFi	vcglib/vcg/simplex/face/component_occ.h	/^  	char &FFi(const int j) {$/;"	f	class:vcg::face::FFAdjOccBase
FFi	vcglib/vcg/simplex/face/component_ocf.h	/^  char &FFi(const int j)       {$/;"	f	class:vcg::face::FFAdjOcf
FFi	vcglib/vcg/simplex/face/component_polygon.h	/^  char  &FFi(const int j)       { return _ffiP[j]; }$/;"	f	class:vcg::face::PFFAdj
FFlip	vcglib/vcg/simplex/face/pos.h	/^    FaceType *FFlip() const$/;"	f	class:vcg::face::Pos
FFp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer &FFp(const int j)        { assert(j>=0 && j<3);  return _ffp[j]; }$/;"	f	class:vcg::face::FFAdj
FFp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer &FFp(int)       { static typename T::FacePointer fp=0; assert(0); return fp; }$/;"	f	class:vcg::face::EmptyCore
FFp	vcglib/vcg/simplex/face/component_occ.h	/^  	FacePointer &FFp(const int j) {$/;"	f	class:vcg::face::FFAdjOccBase
FFp	vcglib/vcg/simplex/face/component_occ.h	/^   	FacePointer const  FFp(const int j) const { $/;"	f	class:vcg::face::FFAdjOccBase
FFp	vcglib/vcg/simplex/face/component_ocf.h	/^  typename T::FacePointer &FFp(const int j) {$/;"	f	class:vcg::face::FFAdjOcf
FFp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::FacePointer   FFp(const int j) const  { assert(j>=0 && j<this->VN());  return _ffpP[j]; }$/;"	f	class:vcg::face::PFFAdj
FFp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::FacePointer  &FFp(const int j)        { assert(j>=0 && j<this->VN());  return _ffpP[j]; }$/;"	f	class:vcg::face::PFFAdj
FFp1	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer &FFp1( const int j )       { return FFp((j+1)%3);}$/;"	f	class:vcg::face::FFAdj
FFp1	vcglib/vcg/simplex/face/component_ocf.h	/^  typename T::FacePointer  &FFp1( const int j )       { return FFp((j+1)%3);}$/;"	f	class:vcg::face::FFAdjOcf
FFp2	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer &FFp2( const int j )       { return FFp((j+2)%3);}$/;"	f	class:vcg::face::FFAdj
FFp2	vcglib/vcg/simplex/face/component_ocf.h	/^  typename T::FacePointer  &FFp2( const int j )       { return FFp((j+2)%3);}$/;"	f	class:vcg::face::FFAdjOcf
FHAdj	vcglib/vcg/simplex/face/component.h	/^  FHAdj(){_fh=0;}$/;"	f	class:vcg::face::FHAdj
FHAdj	vcglib/vcg/simplex/face/component.h	/^template <class T> class FHAdj: public T {$/;"	c	namespace:vcg::face
FHp	vcglib/vcg/simplex/face/component.h	/^  typename T::HEdgePointer &FHp( )       { return _fh; }$/;"	f	class:vcg::face::FHAdj
FHp	vcglib/vcg/simplex/face/component.h	/^  typename T::HEdgePointer &FHp()       { static typename T::HEdgePointer fp=0; assert(0); return fp; }$/;"	f	class:vcg::face::EmptyCore
FHp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::HEdgePointer       &FHp()        {  return _fhP; }$/;"	f	class:vcg::face::PFHAdj
FILE_EXT_PLY	vcglib/apps/trimeshinfo/defs.h	/^#define FILE_EXT_PLY /;"	d
FILE_EXT_PLY	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define FILE_EXT_PLY /;"	d
FILE_EXT_SMF	vcglib/apps/trimeshinfo/defs.h	/^#define FILE_EXT_SMF /;"	d
FILE_EXT_SMF	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define FILE_EXT_SMF /;"	d
FITMAPS_H	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^#define FITMAPS_H$/;"	d
FLAG4_BIT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define FLAG4_BIT /;"	d	file:
FLAG_BITS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define FLAG_BITS /;"	d	file:
FLAT	vcglib/apps/plyrefine/main.cpp	/^#define FLAT	/;"	d	file:
FLAT	vcglib/apps/sample/trimesh_QT/glarea.h	/^  enum DrawMode{SMOOTH=0,POINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:GLArea::DrawMode
FLAT	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^enum DrawMode{SMOOTH=0,PERPOINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:DrawMode	file:
FLAT	vcglib/apps/sample/trimesh_refine/trimesh_refine.cpp	/^#define FLAT	/;"	d	file:
FLATWIRE	vcglib/apps/sample/trimesh_QT/glarea.h	/^  enum DrawMode{SMOOTH=0,POINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:GLArea::DrawMode
FLATWIRE	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^enum DrawMode{SMOOTH=0,PERPOINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:DrawMode	file:
FLOAT	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  FLOAT=3$/;"	e	enum:vcg::RawVolumeImporter::DataType
FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
FLOAT_BUFFER_BIT	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		FLOAT_BUFFER_BIT			= 0x000010$/;"	e	enum:SplatRenderer::__anon519
FManifold	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool FManifold;$/;"	m	struct:MeshInfo	file:
FN	vcglib/vcg/complex/base.h	/^    inline int FN() const { return fn; }$/;"	f	class:vcg::tri::TriMesh
FOOTERS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define FOOTERS /;"	d	file:
FORCEINLINE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define FORCEINLINE /;"	d	file:
FORCEINLINE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^ #define FORCEINLINE /;"	d	file:
FORCEINLINE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^ #define FORCEINLINE$/;"	d	file:
FORCEINLINE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define FORCEINLINE /;"	d	file:
FOUR_SIZE_T_SIZES	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define FOUR_SIZE_T_SIZES /;"	d	file:
FPS	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^const int FPS = 30; $/;"	v
FPos	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  typedef typename face::Pos<FaceType> FPos;$/;"	t	class:vcg::tri::BitQuad::Iterator
FRAGMENT	vcglib/wrap/gl/shaders.h	/^		FRAGMENT,$/;"	e	enum:Shader::__anon517
FRONT	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  enum ListID {FRONT,DEADS};$/;"	e	enum:vcg::tri::AdvancingFront::ListID
FRUSTUM_H	vcglib/wrap/gui/frustum.h	/^#define FRUSTUM_H$/;"	d
FVectorType	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    typedef Matrix< Scalar, Dynamic, 1 > FVectorType;$/;"	t	class:Eigen::HybridNonLinearSolver
FVectorType	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    typedef Matrix< Scalar, Dynamic, 1 > FVectorType;$/;"	t	class:Eigen::LevenbergMarquardt
FVp	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType * &FVp( const int i )       {	return this->V(i); }$/;"	f	class:vcg::face::EmptyCore
F_ASCII	vcglib/wrap/ply/plylib.h	/^	F_ASCII,$/;"	e	enum:vcg::ply::PlyFormat
F_BINBIG	vcglib/wrap/ply/plylib.h	/^	F_BINBIG$/;"	e	enum:vcg::ply::PlyFormat
F_BINLITTLE	vcglib/wrap/ply/plylib.h	/^	F_BINLITTLE,$/;"	e	enum:vcg::ply::PlyFormat
F_UNSPECIFIED	vcglib/wrap/ply/plylib.h	/^	F_UNSPECIFIED,$/;"	e	enum:vcg::ply::PlyFormat
Fa	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Faa	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Faaa	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Faab	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Face	vcglib/apps/unsupported/extractors/extractor/Definitions.h	/^class Face		: public vcg::FaceAFAVFN< Vertex, Edge, Face> {};$/;"	c
Face	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    struct Face {$/;"	s	class:vcg::tri::Zonohedron
Face	vcglib/vcg/simplex/face/base.h	/^							class Face: public FaceArityMax<UserTypes, A, B, C, D, E, F, G, H, I, J>  {$/;"	c	namespace:vcg
FaceAll	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t FaceAll(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
FaceArea	vcglib/vcg/complex/algorithms/update/quality.h	/^static void FaceArea(MeshType &m)$/;"	f	class:vcg::tri::UpdateQuality
FaceArityMax	vcglib/vcg/simplex/face/base.h	/^					class FaceArityMax: public J<Arity9<FaceBase<UserTypes>, A, B, C, D, E, F, G, H, I> > {$/;"	c	namespace:vcg
FaceAssociateRegion	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void FaceAssociateRegion(MeshType &m)$/;"	f	class:vcg::tri::VoronoiProcessing
FaceBase	vcglib/vcg/simplex/face/base.h	/^class FaceBase: public$/;"	c	namespace:vcg
FaceBorderFromFF	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceBorderFromFF(MeshType &m)$/;"	f	class:vcg::tri::UpdateFlags
FaceBorderFromNone	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceBorderFromNone(MeshType &m)$/;"	f	class:vcg::tri::UpdateFlags
FaceBorderFromVF	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceBorderFromVF(MeshType &m)$/;"	f	class:vcg::tri::UpdateFlags
FaceClear	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceClear(MeshType &m, unsigned int FlagMask = 0xffffffff)$/;"	f	class:vcg::tri::UpdateFlags
FaceClear	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t FaceClear(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
FaceClearB	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceClearB(MeshType &m) { FaceClear(m,FaceType::BORDER012);}$/;"	f	class:vcg::tri::UpdateFlags
FaceClearCreases	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceClearCreases(MeshType &m) { FaceClear(m,FaceType::CREASE0);$/;"	f	class:vcg::tri::UpdateFlags
FaceClearF	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceClearF(MeshType &m) { FaceClear(m,FaceType::FAUX012);}$/;"	f	class:vcg::tri::UpdateFlags
FaceClearS	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceClearS(MeshType &m) {FaceClear(m,FaceType::SELECTED);}$/;"	f	class:vcg::tri::UpdateFlags
FaceClearV	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceClearV(MeshType &m) { FaceClear(m,FaceType::VISITED);}$/;"	f	class:vcg::tri::UpdateFlags
FaceColorLaplacian	vcglib/vcg/complex/algorithms/smooth.h	/^static void FaceColorLaplacian(MeshType &m, int step, bool SmoothSelected=false, vcg::CallBackPos * cb=0)$/;"	f	class:vcg::tri::Smooth
FaceConnectedFF	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t FaceConnectedFF(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
FaceConstant	vcglib/vcg/complex/algorithms/update/quality.h	/^static void FaceConstant(MeshType &m, float q)$/;"	f	class:vcg::tri::UpdateQuality
FaceCont	vcglib/vcg/complex/algorithms/create/resampler.h	/^		typedef typename Old_Mesh::FaceContainer FaceCont;$/;"	t	class:vcg::tri::Resampler::Walker
FaceContainer	vcglib/apps/metro/sampling.h	/^    typedef typename MetroMesh::FaceContainer		FaceContainer;$/;"	t	class:vcg::Sampling
FaceContainer	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^typedef CMesh::FaceContainer FaceContainer;$/;"	t	file:
FaceContainer	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::FaceContainer  FaceContainer;$/;"	t	class:vcg::tri::Clean
FaceContainer	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::FaceContainer  FaceContainer;$/;"	t	class:vcg::tri::ConnectedComponentIterator
FaceContainer	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  typedef typename TriMeshType::FaceContainer FaceContainer;$/;"	t	class:vcg::tri::EdgeCollapser
FaceContainer	vcglib/vcg/complex/algorithms/inertia.h	/^	typedef typename MeshType::FaceContainer  FaceContainer;$/;"	t	class:vcg::tri::Inertia
FaceContainer	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MetroMesh::FaceContainer   FaceContainer;$/;"	t	class:vcg::tri::SurfaceSampling
FaceContainer	vcglib/vcg/complex/algorithms/smooth.h	/^            typedef typename MeshType::FaceContainer  FaceContainer;$/;"	t	class:vcg::tri::Smooth
FaceContainer	vcglib/vcg/complex/algorithms/stat.h	/^  typedef typename MeshType::FaceContainer  FaceContainer;$/;"	t	class:vcg::tri::Stat
FaceContainer	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::FaceContainer		FaceContainer;$/;"	t	class:vcg::tri::VoronoiProcessing
FaceContainer	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::FaceContainer FaceContainer;$/;"	t	class:vcg::tri::Allocator
FaceContainer	vcglib/vcg/complex/base.h	/^                                typedef CONT FaceContainer;$/;"	t	struct:vcg::tri::MeshTypeHolder
FaceContainer	vcglib/vcg/complex/base.h	/^                typedef CONTF														FaceContainer;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
FaceContainer	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::FaceContainer FaceContainer;$/;"	t	class:vcg::tri::TriMesh
FaceContainer	vcglib/wrap/io_trimesh/export_vmi.h	/^        typedef typename SaveMeshType::FaceContainer FaceContainer;$/;"	t	class:vcg::tri::io::ExporterVMI
FaceContainer	vcglib/wrap/io_trimesh/import_vmi.h	/^        typedef typename OpenMeshType::FaceContainer FaceContainer;$/;"	t	class:vcg::tri::io::ImporterVMI
FaceCount	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t FaceCount(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
FaceData	vcglib/wrap/io_trimesh/io_ply.h	/^  PropDescriptor *FaceData;$/;"	m	class:vcg::tri::io::PlyInfo
FaceDesc	vcglib/wrap/io_trimesh/import_ply.h	/^static const  PropDescriptor &FaceDesc(int i)$/;"	f	class:vcg::tri::io::ImporterPLY
FaceDist	vcglib/vcg/complex/algorithms/geodesic.h	/^      FaceDist(FacePointer _f):f(_f){}$/;"	f	struct:vcg::tri::Geodesic::FaceDist
FaceDist	vcglib/vcg/complex/algorithms/geodesic.h	/^    struct FaceDist{$/;"	s	class:vcg::tri::Geodesic
FaceErrorGrad	vcglib/vcg/complex/algorithms/smooth.h	/^static CoordType FaceErrorGrad(CoordType &p,CoordType &p0,CoordType &p1, CoordType &m)$/;"	f	class:vcg::tri::Smooth
FaceFace	vcglib/vcg/complex/algorithms/update/topology.h	/^static void FaceFace(MeshType &m)$/;"	f	class:vcg::tri::UpdateTopology
FaceFaceFromTexCoord	vcglib/vcg/complex/algorithms/update/topology.h	/^static void FaceFaceFromTexCoord(MeshType &m)$/;"	f	class:vcg::tri::UpdateTopology
FaceFauxCrease	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceFauxCrease(MeshType &m,float AngleRad)$/;"	f	class:vcg::tri::UpdateFlags
FaceFauxSignedCrease	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceFauxSignedCrease(MeshType &m, float AngleRadNeg, float AngleRadPos )$/;"	f	class:vcg::tri::UpdateFlags
FaceFromBorderFlag	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t FaceFromBorderFlag(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
FaceFromQualityRange	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t FaceFromQualityRange(MeshType &m,float minq, float maxq)$/;"	f	class:vcg::tri::UpdateSelection
FaceFromVertex	vcglib/vcg/complex/algorithms/update/quality.h	/^static void FaceFromVertex( MeshType &m)$/;"	f	class:vcg::tri::UpdateQuality
FaceFromVertexLoose	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t FaceFromVertexLoose(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
FaceFromVertexStrict	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t FaceFromVertexStrict(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
FaceGrid	vcglib/vcg/complex/algorithms/create/platonic.h	/^void FaceGrid(MeshType & in, const std::vector<int> &grid, int w, int h)$/;"	f	namespace:vcg::tri
FaceGrid	vcglib/vcg/complex/algorithms/create/platonic.h	/^void FaceGrid(MeshType & in, int w, int h)$/;"	f	namespace:vcg::tri
FaceInvert	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t FaceInvert(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
FaceIterator	vcglib/apps/metro/sampling.h	/^    typedef typename MetroMesh::FaceIterator		FaceIterator;$/;"	t	class:vcg::Sampling
FaceIterator	vcglib/apps/unsupported/shadevis/visshader.h	/^    typedef typename MESH_TYPE::FaceIterator   FaceIterator;$/;"	t	class:vcg::VisShader
FaceIterator	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::BitQuadCreation
FaceIterator	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::BitQuadOptimization
FaceIterator	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::BitQuad
FaceIterator	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::Clean
FaceIterator	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::ConnectedComponentIterator
FaceIterator	vcglib/vcg/complex/algorithms/clip.h	/^  typedef typename TriMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::TriMeshClipper
FaceIterator	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::Clustering
FaceIterator	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::FaceIterator       FaceIterator;$/;"	t	class:vcg::tri::AdvancingFront
FaceIterator	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::AdvancingTest
FaceIterator	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef typename TRIMESH_TYPE::FaceIterator		FaceIterator;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
FaceIterator	vcglib/vcg/complex/algorithms/create/extrude.h	/^  typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::Extrude
FaceIterator	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef typename TRIMESH_TYPE::FaceIterator		FaceIterator;$/;"	t	class:vcg::tri::MarchingCubes
FaceIterator	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef typename MeshType::FaceIterator        FaceIterator;$/;"	t	class:vcg::tri::CylinderClipping
FaceIterator	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  typedef	typename TriMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::EdgeCollapser
FaceIterator	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::HalfedgeQuadClean
FaceIterator	vcglib/vcg/complex/algorithms/hole.h	/^            typedef typename MESH::FaceIterator			FaceIterator;$/;"	t	class:vcg::tri::Hole
FaceIterator	vcglib/vcg/complex/algorithms/inertia.h	/^	typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::Inertia
FaceIterator	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::PlanarEdgeFlip
FaceIterator	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::TopoEdgeFlip
FaceIterator	vcglib/vcg/complex/algorithms/nring.h	/^    typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::Nring
FaceIterator	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::UV_Utils
FaceIterator	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^  typedef typename VoroMesh::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::VoronoiAtlas
FaceIterator	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MetroMesh::FaceIterator    FaceIterator;$/;"	t	class:vcg::tri::SurfaceSampling
FaceIterator	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  typedef typename PolyMeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::PolychordCollapse
FaceIterator	vcglib/vcg/complex/algorithms/smooth.h	/^            typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::Smooth
FaceIterator	vcglib/vcg/complex/algorithms/stat.h	/^  typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::Stat
FaceIterator	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef typename MESH_TYPE::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::AreaPreservingTextureOptimizer
FaceIterator	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef typename MESH_TYPE::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::TextureOptimizer
FaceIterator	vcglib/vcg/complex/algorithms/update/color.h	/^  typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::UpdateColor
FaceIterator	vcglib/vcg/complex/algorithms/update/component_ep.h	/^		typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::UpdateComponentEP
FaceIterator	vcglib/vcg/complex/algorithms/update/curvature.h	/^    typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::UpdateCurvature
FaceIterator	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^	typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
FaceIterator	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::Fitmaps
FaceIterator	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::UpdateFlags
FaceIterator	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::UpdateHalfEdges
FaceIterator	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	struct:vcg::tri::UpdateIndexed
FaceIterator	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::HalfEdgeTopology
FaceIterator	vcglib/vcg/complex/algorithms/update/normal.h	/^typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::UpdateNormal
FaceIterator	vcglib/vcg/complex/algorithms/update/position.h	/^typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::UpdatePosition
FaceIterator	vcglib/vcg/complex/algorithms/update/quality.h	/^  typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::UpdateQuality
FaceIterator	vcglib/vcg/complex/algorithms/update/selection.h	/^typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::UpdateSelection
FaceIterator	vcglib/vcg/complex/algorithms/update/texture.h	/^typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::UpdateTexture
FaceIterator	vcglib/vcg/complex/algorithms/update/topology.h	/^typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::UpdateTopology
FaceIterator	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::FaceIterator			FaceIterator;$/;"	t	class:vcg::tri::VoronoiProcessing
FaceIterator	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::FaceIterator   FaceIterator;$/;"	t	class:vcg::tri::Allocator
FaceIterator	vcglib/vcg/complex/base.h	/^                                typedef typename FaceContainer::iterator FaceIterator;$/;"	t	struct:vcg::tri::MeshTypeHolder
FaceIterator	vcglib/vcg/complex/base.h	/^                typedef typename CONTF::iterator					FaceIterator;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
FaceIterator	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::FaceIterator					FaceIterator;$/;"	t	class:vcg::tri::TriMesh
FaceIterator	vcglib/wrap/gl/pick.h	/^	typedef typename MESH_TYPE::FaceIterator FaceIterator;$/;"	t	class:vcg::GLPickTri
FaceIterator	vcglib/wrap/io_tetramesh/import_ts.h	/^	typedef typename Tetramesh::TetraIterator FaceIterator;$/;"	t	class:vcg::tetra::io::ImporterTS
FaceIterator	vcglib/wrap/io_trimesh/export_3ds.h	/^		typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::Exporter3DS
FaceIterator	vcglib/wrap/io_trimesh/export_ctm.h	/^                typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ExporterCTM
FaceIterator	vcglib/wrap/io_trimesh/export_fbx.h	/^	typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:ExporterFBX
FaceIterator	vcglib/wrap/io_trimesh/export_gts.h	/^				typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ExporterGTS
FaceIterator	vcglib/wrap/io_trimesh/export_idtf.h	/^typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ExporterIDTF
FaceIterator	vcglib/wrap/io_trimesh/export_obj.h	/^  typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ExporterOBJ
FaceIterator	vcglib/wrap/io_trimesh/export_off.h	/^				typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ExporterOFF
FaceIterator	vcglib/wrap/io_trimesh/export_ply.h	/^typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ExporterPLY
FaceIterator	vcglib/wrap/io_trimesh/export_smf.h	/^		typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ExporterSMF
FaceIterator	vcglib/wrap/io_trimesh/export_vmi.h	/^        typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ExporterVMI
FaceIterator	vcglib/wrap/io_trimesh/export_vrml.h	/^				typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ExporterWRL
FaceIterator	vcglib/wrap/io_trimesh/import_asc.h	/^typedef typename MESH_TYPE::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterASC
FaceIterator	vcglib/wrap/io_trimesh/import_ctm.h	/^typedef typename OpenMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterCTM
FaceIterator	vcglib/wrap/io_trimesh/import_fbx.h	/^	typedef typename OpenMeshType::FaceIterator FaceIterator;$/;"	t	class:ImporterFBX
FaceIterator	vcglib/wrap/io_trimesh/import_gts.h	/^				typedef typename MESH_TYPE::FaceIterator		FaceIterator;$/;"	t	class:vcg::tri::io::ImporterGTS
FaceIterator	vcglib/wrap/io_trimesh/import_nvm.h	/^typedef typename OpenMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterNVM
FaceIterator	vcglib/wrap/io_trimesh/import_obj.h	/^                typedef typename OpenMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterOBJ
FaceIterator	vcglib/wrap/io_trimesh/import_off.h	/^  typedef typename MESH_TYPE::FaceIterator		FaceIterator;$/;"	t	class:vcg::tri::io::ImporterOFF
FaceIterator	vcglib/wrap/io_trimesh/import_out.h	/^typedef typename OpenMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterOUT
FaceIterator	vcglib/wrap/io_trimesh/import_ply.h	/^typedef typename OpenMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterPLY
FaceIterator	vcglib/wrap/io_trimesh/import_ptx.h	/^		typedef typename OpenMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterPTX
FaceIterator	vcglib/wrap/io_trimesh/import_raw.h	/^typedef typename MESH_TYPE::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterRAW
FaceIterator	vcglib/wrap/io_trimesh/import_smf.h	/^		typedef typename OpenMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterSMF
FaceIterator	vcglib/wrap/io_trimesh/import_stl.h	/^typedef typename OpenMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterSTL
FaceIterator	vcglib/wrap/io_trimesh/import_vmi.h	/^        typedef typename OpenMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::ImporterVMI
FaceIterator	vcglib/wrap/io_trimesh/io_material.h	/^		typedef typename SaveMeshType::FaceIterator FaceIterator;$/;"	t	class:vcg::tri::io::Materials
FaceIterator	vcglib/wrap/miq/core/seams_initializer.h	/^    typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:SeamsInitializer
FaceIterator	vcglib/wrap/miq/core/vertex_indexing.h	/^    typedef typename MeshType::FaceIterator FaceIterator;$/;"	t	class:VertexIndexing
FaceIteratorLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::FaceIterator		FaceIteratorLeft;$/;"	t	class:vcg::tri::Append
FaceIteratorRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::FaceIterator   FaceIteratorRight;$/;"	t	class:vcg::tri::Append
FaceLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::FaceType				FaceLeft;$/;"	t	class:vcg::tri::Append
FaceMaskBitFromString	vcglib/wrap/io_trimesh/import_vmi.h	/^    static int  FaceMaskBitFromString(std::string s){$/;"	f	class:vcg::tri::io::ImporterVMI
FaceNormal	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class A, class T> class FaceNormal:  public T {$/;"	c	namespace:vcg::tetra
FaceNormal3d	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class FaceNormal3d: public FaceNormal<double,T>{$/;"	c	namespace:vcg::tetra
FaceNormal3f	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class FaceNormal3f: public FaceNormal<float,T>{$/;"	c	namespace:vcg::tetra
FaceNormalAngleThreshold	vcglib/vcg/complex/algorithms/smooth.h	/^static void FaceNormalAngleThreshold(MeshType &m,$/;"	f	class:vcg::tri::Smooth
FaceNormalFuzzyVectorSB	vcglib/vcg/complex/algorithms/smooth.h	/^void FaceNormalFuzzyVectorSB(MeshType &m,$/;"	f	class:vcg::tri::Smooth
FaceNormalLaplacianFF	vcglib/vcg/complex/algorithms/smooth.h	/^static void FaceNormalLaplacianFF(MeshType &m, int step=1, bool SmoothSelected=false )$/;"	f	class:vcg::tri::Smooth
FaceNormalLaplacianVF	vcglib/vcg/complex/algorithms/smooth.h	/^static void FaceNormalLaplacianVF(MeshType &m)$/;"	f	class:vcg::tri::Smooth
FaceNormalize	vcglib/vcg/complex/algorithms/update/quality.h	/^static void FaceNormalize(MeshType &m, float qmin=0.0, float qmax=1.0)$/;"	f	class:vcg::tri::UpdateQuality
FaceOutOfRangeEdge	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t FaceOutOfRangeEdge(MeshType &m, ScalarType MinEdgeThr=0, ScalarType MaxEdgeThr=(std::numeric_limits<ScalarType>::max)())$/;"	f	class:vcg::tri::UpdateSelection
FacePointer	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::Clean
FacePointer	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::ConnectedComponentIterator
FacePointer	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef typename TRIMESH_TYPE::FacePointer		FacePointer;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
FacePointer	vcglib/vcg/complex/algorithms/create/extrude.h	/^  typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::Extrude
FacePointer	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef typename TRIMESH_TYPE::FacePointer		FacePointer;$/;"	t	class:vcg::tri::MarchingCubes
FacePointer	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef typename MeshType::FacePointer         FacePointer;$/;"	t	class:vcg::tri::CylinderClipping
FacePointer	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::Geodesic
FacePointer	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::IsotropicDistance
FacePointer	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::FacePointer FacePointer;$/;"	t	struct:vcg::tri::EuclideanDistance
FacePointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::HalfedgeQuadClean
FacePointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::Homeometry
FacePointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::VertReg
FacePointer	vcglib/vcg/complex/algorithms/hole.h	/^            typedef typename MESH::FacePointer			FacePointer;$/;"	t	class:vcg::tri::Hole
FacePointer	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename MESH::FacePointer FacePointer;$/;"	t	class:vcg::tri::SelfIntersectionEar
FacePointer	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename MESH::FacePointer FacePointer;$/;"	t	class:vcg::tri::TrivialEar
FacePointer	vcglib/vcg/complex/algorithms/inertia.h	/^	typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::Inertia
FacePointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::QuadDiagonalCollapse
FacePointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::QuadDiagonalCollapseBase
FacePointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::FitmapsCollapse
FacePointer	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::FacePointer FacePointer;$/;"	t	class:vcg::tri::PlanarEdgeFlip
FacePointer	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::FacePointer FacePointer;$/;"	t	class:vcg::tri::TopoEdgeFlip
FacePointer	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MetroMesh::FacePointer     FacePointer;$/;"	t	class:vcg::tri::SurfaceSampling
FacePointer	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  typedef typename PolyMeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::PolychordCollapse
FacePointer	vcglib/vcg/complex/algorithms/smooth.h	/^            typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::Smooth
FacePointer	vcglib/vcg/complex/algorithms/stat.h	/^  typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::Stat
FacePointer	vcglib/vcg/complex/algorithms/update/color.h	/^  typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::UpdateColor
FacePointer	vcglib/vcg/complex/algorithms/update/component_ep.h	/^		typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::UpdateComponentEP
FacePointer	vcglib/vcg/complex/algorithms/update/curvature.h	/^    typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::UpdateCurvature
FacePointer	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^	typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
FacePointer	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::UpdateFlags
FacePointer	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::HalfEdgeTopology
FacePointer	vcglib/vcg/complex/algorithms/update/normal.h	/^typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::UpdateNormal
FacePointer	vcglib/vcg/complex/algorithms/update/position.h	/^typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::UpdatePosition
FacePointer	vcglib/vcg/complex/algorithms/update/quality.h	/^  typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::UpdateQuality
FacePointer	vcglib/vcg/complex/algorithms/update/selection.h	/^typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::UpdateSelection
FacePointer	vcglib/vcg/complex/algorithms/update/texture.h	/^typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::UpdateTexture
FacePointer	vcglib/vcg/complex/algorithms/update/topology.h	/^typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::UpdateTopology
FacePointer	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::FacePointer			FacePointer;$/;"	t	class:vcg::tri::VoronoiProcessing
FacePointer	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::FacePointer    FacePointer;$/;"	t	class:vcg::tri::Allocator
FacePointer	vcglib/vcg/complex/base.h	/^                                typedef FaceType * FacePointer;$/;"	t	struct:vcg::tri::MeshTypeHolder
FacePointer	vcglib/vcg/complex/base.h	/^                typedef typename TYPESPOOL::FacePointer	FacePointer;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
FacePointer	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::FacePointer						FacePointer;$/;"	t	class:vcg::tri::TriMesh
FacePointer	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsFaceType: public T{typedef A FaceType;			typedef FaceType * FacePointer			;};$/;"	t	struct:vcg::Use::AsFaceType
FacePointer	vcglib/vcg/complex/used_types.h	/^        typedef FaceType * FacePointer		;$/;"	t	struct:vcg::DummyTypes
FacePointer	vcglib/vcg/connectors/halfedge_pos.h	/^            typedef typename MeshType::FacePointer FacePointer;$/;"	t	class:vcg::hedge::Pos
FacePointer	vcglib/vcg/simplex/face/component_occ.h	/^	typedef typename T::FacePointer FacePointer;	$/;"	t	class:vcg::face::VFAdjOccBase
FacePointer	vcglib/vcg/simplex/face/component_occ.h	/^	typedef typename T::FacePointer FacePointer;$/;"	t	class:vcg::face::FFAdjOccBase
FacePointer	vcglib/vcg/simplex/tetrahedron/base.h	/^  typedef BFT *FacePointer;$/;"	t	class:vcg::TetraTypeHolder
FacePointer	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename T::FacePointer FacePointer;	$/;"	t	class:vcg::vertex::VFAdjOcc
FacePointer	vcglib/wrap/gl/pick.h	/^  typedef typename MESH_TYPE::FacePointer  FacePointer;$/;"	t	class:vcg::GLPickTri
FacePointer	vcglib/wrap/io_trimesh/export_fbx.h	/^	typedef typename SaveMeshType::FacePointer FacePointer;$/;"	t	class:ExporterFBX
FacePointer	vcglib/wrap/io_trimesh/export_gts.h	/^				typedef typename SaveMeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::io::ExporterGTS
FacePointer	vcglib/wrap/io_trimesh/export_off.h	/^				typedef typename SaveMeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::io::ExporterOFF
FacePointer	vcglib/wrap/io_trimesh/export_ply.h	/^typedef typename SaveMeshType::FacePointer FacePointer;$/;"	t	class:vcg::tri::io::ExporterPLY
FacePointer	vcglib/wrap/io_trimesh/import_gts.h	/^				typedef typename MESH_TYPE::FacePointer			FacePointer;$/;"	t	class:vcg::tri::io::ImporterGTS
FacePointer	vcglib/wrap/io_trimesh/import_off.h	/^  typedef typename MESH_TYPE::FacePointer			FacePointer;$/;"	t	class:vcg::tri::io::ImporterOFF
FacePointerRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::FacePointer    FacePointerRight;$/;"	t	class:vcg::tri::Append
FacePtrInt	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                FacePtrInt ( FaceType * _f,int _i):f(_f),i(_i){}$/;"	f	struct:vcg::tri::UpdateHalfEdges::FacePtrInt
FacePtrInt	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            struct FacePtrInt{$/;"	s	class:vcg::tri::UpdateHalfEdges
FaceRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::FaceType				FaceRight;$/;"	t	class:vcg::tri::Append
FaceSaturate	vcglib/vcg/complex/algorithms/update/quality.h	/^static void FaceSaturate(MeshType &m, ScalarType gradientThr=1.0)$/;"	f	class:vcg::tri::UpdateQuality
FaceSelectAssociateRegion	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static int FaceSelectAssociateRegion(MeshType &m, VertexPointer vp)$/;"	f	class:vcg::tri::VoronoiProcessing
FaceSelectRegion	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static int FaceSelectRegion(MeshType &m, VertexPointer vp)$/;"	f	class:vcg::tri::VoronoiProcessing
FaceSet	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceSet(MeshType &m, unsigned int FlagMask)$/;"	f	class:vcg::tri::UpdateFlags
FaceSetB	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceSetB(MeshType &m) { FaceSet(m,FaceType::BORDER);}$/;"	f	class:vcg::tri::UpdateFlags
FaceSetF	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceSetF(MeshType &m) { FaceSet(m,FaceType::FAUX012);}$/;"	f	class:vcg::tri::UpdateFlags
FaceSetV	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void FaceSetV(MeshType &m) { FaceSet(m,FaceType::VISITED);}$/;"	f	class:vcg::tri::UpdateFlags
FaceSimilar	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void FaceSimilar(MetroMesh & m, VertexSampler &ps,int sampleNum, bool dualFlag, bool randomFlag)$/;"	f	class:vcg::tri::SurfaceSampling
FaceSplitBorderEdge	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static std::pair<typename MeshType::FaceType *, typename MeshType::VertexType *> FaceSplitBorderEdge(MeshType &m, typename MeshType::FaceType &f, int edge, typename MeshType::FaceType *newFace, typename MeshType::VertexType *newVert )$/;"	f	class:vcg::tri::BitQuadCreation
FaceSubdiv	vcglib/apps/metro/sampling.h	/^void Sampling<MetroMesh>::FaceSubdiv(const Point3x & v0, const Point3x & v1, const Point3x & v2, int maxdepth)$/;"	f	class:vcg::Sampling
FaceSubdivision	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void FaceSubdivision(MetroMesh & m, VertexSampler &ps,int sampleNum, bool randSample)$/;"	f	class:vcg::tri::SurfaceSampling
FaceSubdivisionOld	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void FaceSubdivisionOld(MetroMesh & m, VertexSampler &ps,int sampleNum, bool randSample)$/;"	f	class:vcg::tri::SurfaceSampling
FaceTmark	vcglib/vcg/complex/algorithms/closest.h	/^			FaceTmark(){}$/;"	f	class:vcg::tri::FaceTmark
FaceTmark	vcglib/vcg/complex/algorithms/closest.h	/^			FaceTmark(MESH_TYPE *m) {this->SetMesh(m);}$/;"	f	class:vcg::tri::FaceTmark
FaceTmark	vcglib/vcg/complex/algorithms/closest.h	/^		class FaceTmark:public Tmark<MESH_TYPE,typename MESH_TYPE::FaceType>$/;"	c	namespace:vcg::tri
FaceType	vcglib/apps/metro/sampling.h	/^    typedef typename MetroMesh::FaceType				FaceType;$/;"	t	class:vcg::Sampling
FaceType	vcglib/apps/unsupported/shadevis/visshader.h	/^    typedef typename MESH_TYPE::FaceType   FaceType;$/;"	t	class:vcg::VisShader
FaceType	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::BitQuadCreation
FaceType	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::BitQuadOptimization
FaceType	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::BitQuad
FaceType	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::Clean
FaceType	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::ConnectedComponentIterator
FaceType	vcglib/vcg/complex/algorithms/clip.h	/^	typedef typename TriMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::TriMeshClipper
FaceType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef typename MESH::FaceType FaceType;$/;"	t	class:vcg::tri::ClosestFaceEPIterator
FaceType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef typename MESH::FaceType FaceType;$/;"	t	class:vcg::tri::TriRayIterator
FaceType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::FaceType  FaceType;$/;"	t	class:vcg::tri::AverageColorCell
FaceType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::FaceType  FaceType;$/;"	t	class:vcg::tri::Clustering
FaceType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::FaceType  FaceType;$/;"	t	class:vcg::tri::NearestToCenter
FaceType	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::FaceType       FaceType;$/;"	t	class:vcg::tri::AdvancingFront
FaceType	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::FaceType       FaceType;$/;"	t	class:vcg::tri::AdvancingTest
FaceType	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  typedef typename MESH::FaceType       FaceType;$/;"	t	class:vcg::tri::BallPivoting
FaceType	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef typename TRIMESH_TYPE::FaceType				FaceType;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
FaceType	vcglib/vcg/complex/algorithms/create/extrude.h	/^  typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::Extrude
FaceType	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef typename TRIMESH_TYPE::FaceType				FaceType;$/;"	t	class:vcg::tri::MarchingCubes
FaceType	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef typename MeshType::FaceType            FaceType;$/;"	t	class:vcg::tri::CylinderClipping
FaceType	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  typedef	typename TriMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::EdgeCollapser
FaceType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::FaceType  FaceType;$/;"	t	class:vcg::tri::Geodesic
FaceType	vcglib/vcg/complex/algorithms/harmonic.h	/^	typedef typename MeshType::FaceType   FaceType;$/;"	t	class:vcg::tri::Harmonic
FaceType	vcglib/vcg/complex/algorithms/hole.h	/^            typedef typename MESH::FaceType					FaceType;$/;"	t	class:vcg::tri::Hole
FaceType	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename MESH::FaceType FaceType;$/;"	t	class:vcg::tri::SelfIntersectionEar
FaceType	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename MESH::FaceType FaceType;$/;"	t	class:vcg::tri::TrivialEar
FaceType	vcglib/vcg/complex/algorithms/inertia.h	/^	typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::Inertia
FaceType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  typedef	typename TriMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::TriEdgeCollapse
FaceType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^		typedef typename TriMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadric
FaceType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef typename TriMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadricTex
FaceType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::FaceType FaceType;$/;"	t	class:vcg::tri::PlanarEdgeFlip
FaceType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::FaceType FaceType;$/;"	t	class:vcg::tri::TopoEdgeFlip
FaceType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::FaceType FaceType;$/;"	t	class:vcg::tri::TriEdgeFlip
FaceType	vcglib/vcg/complex/algorithms/nring.h	/^    typedef typename MeshType::FaceType   FaceType;$/;"	t	class:vcg::tri::Nring
FaceType	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    typedef typename MeshType::FaceType FaceType;$/;"	t	class:OverlapEstimation
FaceType	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::Distortion
FaceType	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::PoissonSolver
FaceType	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::CrossField
FaceType	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::UV_Utils
FaceType	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^  typedef typename VoroMesh::FaceType FaceType;$/;"	t	class:vcg::tri::VoronoiAtlas
FaceType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MeshType::FaceType    FaceType;$/;"	t	class:vcg::tri::MeshSampler
FaceType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MeshType::FaceType   FaceType;$/;"	t	class:vcg::tri::TrivialSampler
FaceType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MetroMesh::FaceType        FaceType;$/;"	t	class:vcg::tri::SurfaceSampling
FaceType	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  typedef typename PolyMeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::PolychordCollapse
FaceType	vcglib/vcg/complex/algorithms/refine.h	/^  typedef typename TRIMESH_TYPE::FaceType FaceType;$/;"	t	class:vcg::tri::TriSplit
FaceType	vcglib/vcg/complex/algorithms/smooth.h	/^            typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::Smooth
FaceType	vcglib/vcg/complex/algorithms/stat.h	/^  typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::Stat
FaceType	vcglib/vcg/complex/algorithms/symmetry.h	/^    typedef typename TriMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::ExtrinsicPlaneSymmetry
FaceType	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef typename MESH_TYPE::FaceType FaceType;$/;"	t	class:vcg::tri::AreaPreservingTextureOptimizer
FaceType	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef typename MESH_TYPE::FaceType FaceType;$/;"	t	class:vcg::tri::TextureOptimizer
FaceType	vcglib/vcg/complex/algorithms/update/color.h	/^  typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::UpdateColor
FaceType	vcglib/vcg/complex/algorithms/update/component_ep.h	/^		typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::UpdateComponentEP
FaceType	vcglib/vcg/complex/algorithms/update/curvature.h	/^    typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::UpdateCurvature
FaceType	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^	typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
FaceType	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    typedef typename MeshType::FaceType   FaceType;$/;"	t	class:vcg::tri::Fitmaps
FaceType	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::UpdateFlags
FaceType	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::UpdateHalfEdges
FaceType	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::FaceType FaceType;$/;"	t	struct:vcg::tri::UpdateIndexed
FaceType	vcglib/vcg/complex/algorithms/update/normal.h	/^typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::UpdateNormal
FaceType	vcglib/vcg/complex/algorithms/update/position.h	/^typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::UpdatePosition
FaceType	vcglib/vcg/complex/algorithms/update/quality.h	/^  typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::UpdateQuality
FaceType	vcglib/vcg/complex/algorithms/update/selection.h	/^typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::UpdateSelection
FaceType	vcglib/vcg/complex/algorithms/update/texture.h	/^typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::UpdateTexture
FaceType	vcglib/vcg/complex/algorithms/update/topology.h	/^typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::UpdateTopology
FaceType	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::FaceType					FaceType;$/;"	t	class:vcg::tri::VoronoiProcessing
FaceType	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::FaceType       FaceType;$/;"	t	class:vcg::tri::Allocator
FaceType	vcglib/vcg/complex/base.h	/^                                typedef typename FaceContainer::value_type FaceType;$/;"	t	struct:vcg::tri::MeshTypeHolder
FaceType	vcglib/vcg/complex/base.h	/^                typedef typename CONTF::value_type					FaceType;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
FaceType	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::FaceType							FaceType;$/;"	t	class:vcg::tri::TriMesh
FaceType	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsFaceType: public T{typedef A FaceType;			typedef FaceType * FacePointer			;};$/;"	t	struct:vcg::Use::AsFaceType
FaceType	vcglib/vcg/complex/used_types.h	/^        typedef _Face FaceType;$/;"	t	struct:vcg::DummyTypes
FaceType	vcglib/vcg/simplex/face/component_occ.h	/^		typedef typename T::FaceType FaceType;	$/;"	t	class:vcg::face::ColorOcc
FaceType	vcglib/vcg/simplex/face/component_occ.h	/^		typedef typename T::FaceType FaceType;	$/;"	t	class:vcg::face::InfoOccBase
FaceType	vcglib/vcg/simplex/face/component_occ.h	/^		typedef typename T::FaceType FaceType;	$/;"	t	class:vcg::face::MarkOcc
FaceType	vcglib/vcg/simplex/face/component_occ.h	/^		typedef typename T::FaceType FaceType;	$/;"	t	class:vcg::face::NormalOcc
FaceType	vcglib/vcg/simplex/face/component_occ.h	/^		typedef typename T::FaceType FaceType;$/;"	t	class:vcg::face::WedgeTexCoordOcc
FaceType	vcglib/vcg/simplex/face/component_occ.h	/^	typedef typename T::FaceType FaceType;	$/;"	t	class:vcg::face::VFAdjOccBase
FaceType	vcglib/vcg/simplex/face/component_occ.h	/^	typedef typename T::FaceType FaceType;$/;"	t	class:vcg::face::FFAdjOccBase
FaceType	vcglib/vcg/simplex/face/component_occ.h	/^  typedef typename T::FaceType FaceType;$/;"	t	class:vcg::face::VertexRefOcc
FaceType	vcglib/vcg/simplex/face/component_polygon.h	/^  typedef typename T::FaceType FaceType;$/;"	t	class:vcg::face::PFFAdj
FaceType	vcglib/vcg/simplex/face/component_polygon.h	/^  typedef typename T::FaceType FaceType;$/;"	t	class:vcg::face::PVFAdj
FaceType	vcglib/vcg/simplex/face/jumping_pos.h	/^			typedef						FACE_TYPE								FaceType;$/;"	t	class:vcg::face::JumpingPos
FaceType	vcglib/vcg/simplex/tetrahedron/base.h	/^  typedef BFT FaceType;$/;"	t	class:vcg::TetraTypeHolder
FaceType	vcglib/wrap/dae/poly_triangulator.h	/^		typedef POLYGONAL_TYPE FaceType;$/;"	t	class:vcg::tri::io::PolygonalMesh
FaceType	vcglib/wrap/gl/gl_field.h	/^	typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::GLField
FaceType	vcglib/wrap/io_tetramesh/export_ts.h	/^	typedef typename MESHTYPE::TetraType FaceType;$/;"	t	struct:vcg::tetra::io::ExporterTS
FaceType	vcglib/wrap/io_tetramesh/import_ts.h	/^	typedef typename Tetramesh::TetraType FaceType;$/;"	t	class:vcg::tetra::io::ImporterTS
FaceType	vcglib/wrap/io_trimesh/export_fbx.h	/^	typedef typename SaveMeshType::FaceType FaceType;$/;"	t	class:ExporterFBX
FaceType	vcglib/wrap/io_trimesh/export_field.h	/^    typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ExporterFIELD
FaceType	vcglib/wrap/io_trimesh/export_gts.h	/^				typedef typename SaveMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ExporterGTS
FaceType	vcglib/wrap/io_trimesh/export_idtf.h	/^typedef typename SaveMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ExporterIDTF
FaceType	vcglib/wrap/io_trimesh/export_off.h	/^				typedef typename SaveMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ExporterOFF
FaceType	vcglib/wrap/io_trimesh/export_ply.h	/^typedef typename SaveMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ExporterPLY
FaceType	vcglib/wrap/io_trimesh/export_smf.h	/^		typedef typename SaveMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ExporterSMF
FaceType	vcglib/wrap/io_trimesh/export_stl.h	/^typedef typename SaveMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ExporterSTL
FaceType	vcglib/wrap/io_trimesh/export_vmi.h	/^            typedef typename MeshType::FaceType FaceType;$/;"	t	struct:vcg::tri::io::ExporterVMI::SaveFaceOcf
FaceType	vcglib/wrap/io_trimesh/export_vmi.h	/^        typedef typename SaveMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ExporterVMI
FaceType	vcglib/wrap/io_trimesh/export_vrml.h	/^				typedef typename SaveMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ExporterWRL
FaceType	vcglib/wrap/io_trimesh/import_asc.h	/^typedef typename MESH_TYPE::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterASC
FaceType	vcglib/wrap/io_trimesh/import_ctm.h	/^typedef typename OpenMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterCTM
FaceType	vcglib/wrap/io_trimesh/import_fbx.h	/^	typedef typename OpenMeshType::FaceType FaceType;$/;"	t	class:ImporterFBX
FaceType	vcglib/wrap/io_trimesh/import_field.h	/^    typedef typename MeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterFIELD
FaceType	vcglib/wrap/io_trimesh/import_gts.h	/^				typedef typename MESH_TYPE::FaceType				FaceType;$/;"	t	class:vcg::tri::io::ImporterGTS
FaceType	vcglib/wrap/io_trimesh/import_nvm.h	/^typedef typename OpenMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterNVM
FaceType	vcglib/wrap/io_trimesh/import_obj.h	/^                typedef typename OpenMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterOBJ
FaceType	vcglib/wrap/io_trimesh/import_off.h	/^  typedef typename MESH_TYPE::FaceType				FaceType;$/;"	t	class:vcg::tri::io::ImporterOFF
FaceType	vcglib/wrap/io_trimesh/import_out.h	/^typedef typename OpenMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterOUT
FaceType	vcglib/wrap/io_trimesh/import_ply.h	/^typedef typename OpenMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterPLY
FaceType	vcglib/wrap/io_trimesh/import_ptx.h	/^		typedef typename OpenMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterPTX
FaceType	vcglib/wrap/io_trimesh/import_raw.h	/^typedef typename MESH_TYPE::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterRAW
FaceType	vcglib/wrap/io_trimesh/import_smf.h	/^		typedef typename OpenMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterSMF
FaceType	vcglib/wrap/io_trimesh/import_stl.h	/^typedef typename OpenMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterSTL
FaceType	vcglib/wrap/io_trimesh/import_vmi.h	/^                                                typedef typename OpenMeshType::FaceType FaceType;$/;"	t	struct:vcg::tri::io::ImporterVMI::LoadFaceOcf
FaceType	vcglib/wrap/io_trimesh/import_vmi.h	/^        typedef typename OpenMeshType::FaceType FaceType;$/;"	t	class:vcg::tri::io::ImporterVMI
FaceType	vcglib/wrap/miq/core/poisson_solver.h	/^    typedef typename MeshType::FaceType FaceType;$/;"	t	class:PoissonSolver
FaceType	vcglib/wrap/miq/core/seams_initializer.h	/^    typedef typename MeshType::FaceType FaceType;$/;"	t	class:SeamsInitializer
FaceType	vcglib/wrap/miq/core/stiffening.h	/^    typedef typename MeshType::FaceType FaceType;$/;"	t	class:StiffeningInitializer
FaceType	vcglib/wrap/miq/core/vertex_indexing.h	/^    typedef typename MeshType::FaceType FaceType;$/;"	t	class:VertexIndexing
FaceType	vcglib/wrap/miq/quadrangulator.h	/^        typedef typename MESH_TYPE::FaceType FaceType;$/;"	t	class:Quadrangulator::EdgePredicate
FaceType	vcglib/wrap/miq/quadrangulator.h	/^        typedef typename MESH_TYPE::FaceType FaceType;$/;"	t	struct:Quadrangulator::SplitMidPoint
FaceTypeHolder	vcglib/vcg/simplex/face/base.h	/^				class FaceTypeHolder: public UserTypes {$/;"	c	namespace:vcg
FaceTypeP	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^typedef typename MeshType::FaceType* FaceTypeP;$/;"	t	class:vcg::tri::BitQuadCreation
FaceTypeP	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^typedef typename MeshType::FaceType* FaceTypeP;$/;"	t	class:vcg::tri::BitQuadOptimization
FaceTypeP	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef typename MeshType::FaceType* FaceTypeP;$/;"	t	class:vcg::tri::BitQuad
FaceUniform	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void FaceUniform(MetroMesh & m, VertexSampler &ps, int sampleNum)$/;"	f	class:vcg::tri::SurfaceSampling
FaceVectorHasFEAdjacency	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasFEAdjacency   (const std::vector<FaceType> &) {  return FaceType::HasFEAdjacency(); }$/;"	f	namespace:vcg::tri
FaceVectorHasFFAdjacency	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasFFAdjacency   (const std::vector<FaceType> &) {  return FaceType::HasFFAdjacency(); }$/;"	f	namespace:vcg::tri
FaceVectorHasFFAdjacency	vcglib/vcg/simplex/face/component_ocf.h	/^  bool FaceVectorHasFFAdjacency(const face::vector_ocf<FaceType> &fv)$/;"	f	namespace:vcg::tri
FaceVectorHasFVAdjacency	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasFVAdjacency   (const std::vector<FaceType> &) {  return FaceType::HasFVAdjacency(); }$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceColor	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasPerFaceColor  (const std::vector<FaceType> &) {  return FaceType::HasColor  (); }$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceColor	vcglib/vcg/simplex/face/component_ocf.h	/^  bool FaceVectorHasPerFaceColor(const face::vector_ocf<FaceType> &fv)$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceCurvatureDir	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasPerFaceCurvatureDir   (const std::vector<FaceType> &) {  return FaceType::HasCurvatureDir(); }$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceCurvatureDir	vcglib/vcg/simplex/face/component_ocf.h	/^  bool FaceVectorHasPerFaceCurvatureDir(const face::vector_ocf<FaceType> &fv)$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceFlags	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasPerFaceFlags  (const std::vector<FaceType> &) {  return FaceType::HasFlags  (); }$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceMark	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasPerFaceMark   (const std::vector<FaceType> &) {  return FaceType::HasMark   (); }$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceMark	vcglib/vcg/simplex/face/component_ocf.h	/^  bool FaceVectorHasPerFaceMark(const face::vector_ocf<FaceType> &fv)$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceNormal	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasPerFaceNormal (const std::vector<FaceType> &) {  return FaceType::HasNormal (); }$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceNormal	vcglib/vcg/simplex/face/component_ocf.h	/^  bool FaceVectorHasPerFaceNormal(const face::vector_ocf<FaceType> &fv)$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceQuality	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasPerFaceQuality(const std::vector<FaceType> &) {  return FaceType::HasQuality(); }$/;"	f	namespace:vcg::tri
FaceVectorHasPerFaceQuality	vcglib/vcg/simplex/face/component_ocf.h	/^  bool FaceVectorHasPerFaceQuality(const face::vector_ocf<FaceType> &fv)$/;"	f	namespace:vcg::tri
FaceVectorHasPerWedgeColor	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasPerWedgeColor   (const std::vector<FaceType> &) {  return FaceType::HasWedgeColor   (); }$/;"	f	namespace:vcg::tri
FaceVectorHasPerWedgeNormal	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasPerWedgeNormal  (const std::vector<FaceType> &) {  return FaceType::HasWedgeNormal  (); }$/;"	f	namespace:vcg::tri
FaceVectorHasPerWedgeTexCoord	vcglib/vcg/complex/base.h	/^template < class FaceType>    bool FaceVectorHasPerWedgeTexCoord(const std::vector<FaceType> &) {  return FaceType::HasWedgeTexCoord(); }$/;"	f	namespace:vcg::tri
FaceVectorHasPerWedgeTexCoord	vcglib/vcg/simplex/face/component_ocf.h	/^  bool FaceVectorHasPerWedgeTexCoord(const face::vector_ocf<FaceType> &fv)$/;"	f	namespace:vcg::tri
FaceVectorHasVFAdjacency	vcglib/vcg/complex/base.h	/^template < class FaceType  > bool   FaceVectorHasVFAdjacency     (const std::vector<FaceType  > &) {  return FaceType::HasVFAdjacency(); }$/;"	f	namespace:vcg::tri
FaceVectorHasVFAdjacency	vcglib/vcg/simplex/face/component_ocf.h	/^  bool FaceVectorHasVFAdjacency(const face::vector_ocf<FaceType> &fv)$/;"	f	namespace:vcg::tri
FacetNode	vcglib/apps/trimeshinfo/XMLTree.h	/^class FacetNode: public Node$/;"	c
FacetsNode	vcglib/apps/trimeshinfo/XMLTree.h	/^class FacetsNode: public Node$/;"	c
Factor	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    Factor = (RowFactor==Dynamic || ColFactor==Dynamic) ? Dynamic : RowFactor*ColFactor$/;"	e	enum:Eigen::internal::traits::__anon233
FactorType	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,RowMajor> FactorType;$/;"	t	class:Eigen::IncompleteLUT
FactorType	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef SparseMatrix<Scalar,RowMajor> FactorType;$/;"	t	class:Eigen::IncompleteLU
Factorial	vcglib/vcg/math/factorial.h	/^ScalarType Factorial(unsigned i)$/;"	f	namespace:vcg::math
FailStat	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  class FailStat { $/;"	c	class:vcg::tri::TriEdgeCollapse
FalseColorFlag	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^bool FalseColorFlag=false;$/;"	v
FanTessellator	vcglib/wrap/io_trimesh/io_fan_tessellator.h	/^void FanTessellator(const std::vector< std::vector<PointType> > & outlines, std::vector<int> & indices)$/;"	f	namespace:vcg::tri::io
FastConstructionApproach	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		enum		ConstructionApproach { FastConstructionApproach=0, CompactConstructionApproach=1 };$/;"	e	enum:vcg::PerfectSpatialHashing::ConstructionApproach
FastFitMesh	vcglib/vcg/complex/algorithms/smooth.h	/^static void FastFitMesh(MeshType &m,$/;"	f	class:vcg::tri::Smooth
FastInvert	vcglib/vcg/math/old_matrix33.h	/^	Matrix33 & FastInvert() { return  *this = Base::inverse(); }$/;"	f	class:vcg::Matrix33
FastPreserveBoundary	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      FastPreserveBoundary;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
FauxIndex	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static int FauxIndex(const FaceType* f){$/;"	f	class:vcg::tri::BitQuad
Fb	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Fbb	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Fbbb	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Fbbc	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Fc	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Fcc	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Fcca	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
Fccc	vcglib/vcg/complex/algorithms/inertia.h	/^ double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;$/;"	m	class:vcg::tri::Inertia
FeasibilityCheck	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^        class FeasibilityCheck$/;"	c	namespace:vcg::tri
FeedbackBufferBindingParams	vcglib/wrap/glw/buffer.h	/^		FeedbackBufferBindingParams(GLuint aIndex, GLintptr aOffset, GLsizeiptr aSize)$/;"	f	class:glw::FeedbackBufferBindingParams
FeedbackBufferBindingParams	vcglib/wrap/glw/buffer.h	/^		FeedbackBufferBindingParams(void)$/;"	f	class:glw::FeedbackBufferBindingParams
FeedbackBufferBindingParams	vcglib/wrap/glw/buffer.h	/^class FeedbackBufferBindingParams : public BufferBindingParams$/;"	c	namespace:glw
Fh0	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    PerFaceCoordHandle Fh0,Fh1;$/;"	m	class:vcg::tri::PoissonSolver
Fh1	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    PerFaceCoordHandle Fh0,Fh1;$/;"	m	class:vcg::tri::PoissonSolver
FileExtension	vcglib/wrap/io_trimesh/export.h	/^static bool FileExtension(std::string filename,  std::string extension)$/;"	f	class:vcg::tri::io::Exporter
FileExtension	vcglib/wrap/io_trimesh/import.h	/^static bool FileExtension(std::string filename,  std::string extension)$/;"	f	class:vcg::tri::io::Importer
FileName	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	string FileName;$/;"	m	struct:MeshInfo	file:
FileWrite	vcglib/vcg/math/histogram.h	/^void Histogram<ScalarType>::FileWrite(const std::string &filename)$/;"	f	class:vcg::Histogram
Fileexists	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline bool Fileexists(std::string file)$/;"	f	class:Eigen::MatrixMarketIterator
FillAndShuffleFacePointerVector	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void	FillAndShuffleFacePointerVector(MetroMesh & m, std::vector<FacePointer> &faceVec)$/;"	f	class:vcg::tri::SurfaceSampling
FillAndShuffleVertexPointerVector	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void	FillAndShuffleVertexPointerVector(MetroMesh & m, std::vector<VertexPointer> &vertVec)$/;"	f	class:vcg::tri::SurfaceSampling
FillColor	vcglib/wrap/qt/Outline2ToQImage.h	/^      vcg::Color4b FillColor;$/;"	m	class:Outline2Dumper::Param
FillEdgeVector	vcglib/vcg/complex/algorithms/update/topology.h	/^static void FillEdgeVector(MeshType &m, std::vector<PEdge> &e, bool includeFauxEdge=true)$/;"	f	class:vcg::tri::UpdateTopology
FillHoleEar	vcglib/vcg/complex/algorithms/hole.h	/^    static void FillHoleEar(MESH &m, \/\/ The mesh to be filled$/;"	f	class:vcg::tri::Hole
FillUniqueEdgeVector	vcglib/vcg/complex/algorithms/update/topology.h	/^static void FillUniqueEdgeVector(MeshType &m, std::vector<PEdge> &Edges, bool includeFauxEdge=true)$/;"	f	class:vcg::tri::UpdateTopology
Finalize	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            void Finalize()$/;"	f	class:vcg::tri::ExtendedMarchingCubes
Finalize	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            void Finalize()$/;"	f	class:vcg::tri::MarchingCubes
Finalize	vcglib/vcg/complex/algorithms/local_optimization.h	/^	template <class LocalModificationType> void Finalize()$/;"	f	class:vcg::LocalOptimization
Finalize	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^    static void Finalize(TriMeshType &m, HeapType& \/*h_ret*\/, BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
Finalize	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    static void Finalize(TriMeshType &m,HeapType & \/*h_ret*\/, BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
Finalize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void Finalize()$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
Finalize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void Finalize()$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
Finalize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void Finalize()$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
Finalize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		void Finalize()$/;"	f	class:vcg::PerfectSpatialHashing
FindBase	vcglib/vcg/container/container_allocation_table.h	/^FindBase(const ValueType * pt)$/;"	f	class:vcg::CATEntry
FindBorder	vcglib/vcg/simplex/face/jumping_pos.h	/^      bool FindBorder()$/;"	f	class:vcg::face::JumpingPos
FindCongruent	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^bool FourPCS<MeshType>::FindCongruent() { \/\/ of base B, on Q, with approximation delta$/;"	f	class:vcg::tri::FourPCS
FindElement	vcglib/wrap/ply/plylib.cpp	/^PlyElement * PlyFile::FindElement( const char * na ) $/;"	f	class:vcg::ply::PlyFile
FindFarthestVert	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void FindFarthestVert(VertexType* &v0,VertexType* &v1)$/;"	f	class:vcg::tri::PoissonSolver
FindFeature	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            VertexPointer FindFeature(const std::vector<size_t> &vertices_idx)$/;"	f	class:vcg::tri::ExtendedMarchingCubes
FindFixedVert	vcglib/wrap/miq/core/poisson_solver.h	/^	void FindFixedVert()$/;"	f	class:PoissonSolver
FindFixedVertField	vcglib/wrap/miq/core/poisson_solver.h	/^    void FindFixedVertField()$/;"	f	class:PoissonSolver
FindInitialPos	vcglib/wrap/miq/core/vertex_indexing.h	/^    void FindInitialPos(const VertexType * vert,$/;"	f	class:VertexIndexing
FindPerEdgeAttribute	vcglib/vcg/complex/allocate.h	/^     FindPerEdgeAttribute( MeshType & m, const std::string & name){$/;"	f	class:vcg::tri::Allocator
FindPerFaceAttribute	vcglib/vcg/complex/allocate.h	/^      FindPerFaceAttribute( MeshType & m, const std::string & name){$/;"	f	class:vcg::tri::Allocator
FindPerMeshAttribute	vcglib/vcg/complex/allocate.h	/^      FindPerMeshAttribute( MeshType & m, const std::string & name){$/;"	f	class:vcg::tri::Allocator
FindPerVertexAttribute	vcglib/vcg/complex/allocate.h	/^     FindPerVertexAttribute( MeshType & m, const std::string & name)$/;"	f	class:vcg::tri::Allocator
FindPolygon	vcglib/wrap/miq/quadrangulator.h	/^    bool FindPolygon(vcg::face::Pos<TriFaceType> &ep,$/;"	f	class:Quadrangulator
FindPolygons	vcglib/wrap/miq/quadrangulator.h	/^    void FindPolygons(TriMesh &Tmesh,$/;"	f	class:Quadrangulator
FindProp	vcglib/wrap/ply/plylib.cpp	/^PlyProperty * PlyElement::FindProp( const char * na )$/;"	f	class:vcg::ply::PlyElement
FindSet	vcglib/vcg/math/disjoint_set.h	/^		OBJECT_TYPE* FindSet(OBJECT_TYPE *x)$/;"	f	class:vcg::DisjointSet
FindSets	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  static void FindSets(VertexPair &p, EdgeSet &es)$/;"	f	class:vcg::tri::EdgeCollapser
FindSharedEdge	vcglib/vcg/simplex/face/topology.h	/^bool FindSharedEdge(FaceType *f0,FaceType *f1, int &i, int &j)$/;"	f	namespace:vcg::face
FindSharedFaces	vcglib/vcg/simplex/face/topology.h	/^bool FindSharedFaces(typename FaceType::VertexType *v0,$/;"	f	namespace:vcg::face
FindSharedVertex	vcglib/vcg/simplex/face/topology.h	/^bool FindSharedVertex(FaceType *f0,FaceType *f1, int &i, int &j)$/;"	f	namespace:vcg::face
FindSizes	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void FindSizes()$/;"	f	class:vcg::tri::PoissonSolver
FindSizes	vcglib/wrap/miq/core/poisson_solver.h	/^	void FindSizes()$/;"	f	class:PoissonSolver
FindSphere	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  bool FindSphere(const Point3x &p0, const Point3x &p1, const Point3x &p2, Point3x &center) {$/;"	f	class:vcg::tri::BallPivoting
FindStandardWedgeAttributes	vcglib/wrap/io_trimesh/import_dae.h	/^		static void FindStandardWedgeAttributes(WedgeAttribute& wed,const QDomNode nd,const QDomDocument doc)$/;"	f	class:vcg::tri::io::ImporterDAE
FindType	vcglib/wrap/ply/plylib.cpp	/^int PlyFile::FindType( const char * name ) const$/;"	f	class:vcg::ply::PlyFile
FinishDebug	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    void FinishDebug(){$/;"	f	class:vcg::tri::FourPCS
FintFunct	vcglib/vcg/complex/algorithms/closest.h	/^			typedef vcg::RayTriangleIntersectionFunctor<true> FintFunct;$/;"	t	class:vcg::tri::TriRayIterator
FirstPos	vcglib/wrap/miq/core/vertex_indexing.h	/^    void FirstPos(const VertexType* v,FaceType *&f,int &edge)$/;"	f	class:VertexIndexing
FirstUnusedBitFlag	vcglib/vcg/connectors/hedge.h	/^	static int &FirstUnusedBitFlag()$/;"	f	class:vcg::HEdgeArityMax
FirstUnusedBitFlag	vcglib/vcg/simplex/edge/base.h	/^	static int &FirstUnusedBitFlag()$/;"	f	class:vcg::EdgeArityMax
FirstUnusedBitFlag	vcglib/vcg/simplex/face/base.h	/^	static int &FirstUnusedBitFlag()$/;"	f	class:vcg::FaceArityMax
FirstUnusedBitFlag	vcglib/vcg/simplex/tetrahedron/base.h	/^	static int &FirstUnusedBitFlag()$/;"	f	class:vcg::TetraArityMax
FirstUnusedBitFlag	vcglib/vcg/simplex/vertex/base.h	/^	static int &FirstUnusedBitFlag()$/;"	f	class:vcg::VertexArityMax
FitMesh	vcglib/vcg/complex/algorithms/smooth.h	/^static void FitMesh(MeshType &m,$/;"	f	class:vcg::tri::Smooth
FitPlaneToPointSet	vcglib/vcg/space/fitting3.h	/^void FitPlaneToPointSet(const std::vector< Point3<S> > & pointVec, Plane3<S> & plane)$/;"	f	namespace:vcg
Fitmap_attr	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^typedef CMesh::PerVertexAttributeHandle<float> Fitmap_attr;$/;"	t	file:
Fitmap_attr	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::template PerVertexAttributeHandle<float> Fitmap_attr;$/;"	t	class:vcg::tri::FitmapsCollapse
Fitmaps	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    Fitmaps()$/;"	f	class:vcg::tri::Fitmaps
Fitmaps	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^class Fitmaps$/;"	c	namespace:vcg::tri
FitmapsCollapse	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^        class FitmapsCollapse : public FeasibilityCheck<MeshType, TriMeshType>, public OperationWeight<MeshType, TriMeshType>$/;"	c	namespace:vcg::tri
FixBlockedVertex	vcglib/wrap/miq/core/poisson_solver.h	/^	void FixBlockedVertex()$/;"	f	class:PoissonSolver
FixDefaultVertices	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void FixDefaultVertices()$/;"	f	class:vcg::tri::PoissonSolver
FixPaddedPerEdgeAttribute	vcglib/vcg/complex/allocate.h	/^    static void FixPaddedPerEdgeAttribute (MeshType & m, PointerToAttribute & pa){$/;"	f	class:vcg::tri::Allocator
FixPaddedPerFaceAttribute	vcglib/vcg/complex/allocate.h	/^    static void FixPaddedPerFaceAttribute ( MeshType & m,PointerToAttribute & pa){$/;"	f	class:vcg::tri::Allocator
FixPaddedPerMeshAttribute	vcglib/vcg/complex/allocate.h	/^    static void FixPaddedPerMeshAttribute ( MeshType & \/* m *\/,PointerToAttribute & pa){$/;"	f	class:vcg::tri::Allocator
FixPaddedPerVertexAttribute	vcglib/vcg/complex/allocate.h	/^    static void FixPaddedPerVertexAttribute (MeshType & m, PointerToAttribute & pa){$/;"	f	class:vcg::tri::Allocator
FixPointLSquares	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void FixPointLSquares()$/;"	f	class:vcg::tri::PoissonSolver
FixVertex	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  void FixVertex(const VertexType *v, bool fix=true){$/;"	f	class:vcg::tri::TextureOptimizer
FixVertexVector	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void FixVertexVector(MeshType &m, std::vector<VertexType *> &vertToFixVec)$/;"	f	class:vcg::tri::VoronoiProcessing
FixedSegmentReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	s	class:Eigen::DenseBase
Flag	vcglib/wrap/math/system_interface_ldl.h	/^    std::vector<int> Li,Lp,Parent,Lnz,Flag,Pattern;$/;"	m	class:SystemLDL
FlagOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class FlagOcc:  public T {$/;"	c	namespace:vcg::vertex
FlagType	vcglib/vcg/connectors/hedge_component.h	/^	typedef int FlagType;$/;"	t	class:vcg::hedge::EmptyBitFlags
FlagType	vcglib/vcg/connectors/hedge_component.h	/^  typedef int FlagType;$/;"	t	class:vcg::hedge::BitFlags
FlagType	vcglib/vcg/simplex/edge/component.h	/^    typedef int FlagType;$/;"	t	class:vcg::edge::EmptyCore
FlagType	vcglib/vcg/simplex/edge/component.h	/^  typedef int FlagType;$/;"	t	class:vcg::edge::BitFlags
FlagType	vcglib/vcg/simplex/vertex/component.h	/^  typedef int FlagType;$/;"	t	class:vcg::vertex::BitFlags
FlagType	vcglib/vcg/simplex/vertex/component.h	/^  typedef int FlagType;$/;"	t	class:vcg::vertex::EmptyCore
Flagged	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline Flagged(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Flagged
Flagged	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^template<typename ExpressionType, unsigned int Added, unsigned int Removed> class Flagged$/;"	c	namespace:Eigen
Flags	vcglib/apps/metro/sampling.h	/^	int             Flags;$/;"	m	class:vcg::Sampling
Flags	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon45
Flags	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon48
Flags	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon49
Flags	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    Flags = Flags0 | FlagsLinearAccessBit | FlagsLvalueBit | FlagsRowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon50
Flags	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon54
Flags	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    Flags = (traits<PlainObjectType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon55
Flags	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    Flags = _XprTypeNested::Flags & ($/;"	e	enum:Eigen::internal::traits::__anon56
Flags	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    Flags = (traits<_MatrixTypeNested>::Flags & (HereditaryBits | LvalueBit | LinearAccessBit | DirectAccessBit)),$/;"	e	enum:Eigen::internal::traits::__anon57
Flags	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::DenseBase::__anon58
Flags	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    Flags = (unsigned int)_MatrixTypeNested::Flags & (HereditaryBits | LinearAccessBit | MaskLvalueBit | DirectAccessBit) & ~RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon64
Flags	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^      Flags = 0$/;"	e	enum:Eigen::DiagonalBase::__anon65
Flags	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    Flags =  traits<DiagonalVectorType>::Flags & LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon67
Flags	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    Flags = LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon66
Flags	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    Flags = (HereditaryBits & (unsigned int)(MatrixType::Flags)) | (_Vectorizable ? PacketAccessBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon68
Flags	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^  enum { Flags = (ExpressionType::Flags | Added) & ~Removed };$/;"	e	enum:Eigen::internal::traits::__anon69
Flags	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    Flags = KeepsPacketAccess ? int(Flags3) : (int(Flags3) & ~PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon173
Flags	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,$/;"	e	enum:Eigen::internal::traits::__anon181
Flags	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::PermutationBase::__anon186
Flags	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::Transpose::__anon188
Flags	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon187
Flags	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    Flags = (MaxRowsAtCompileTime==1 ? RowMajorBit : 0), \/\/ TODO should be no storage order$/;"	e	enum:internal::traits::__anon192
Flags	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    Flags = (MaxRowsAtCompileTime==1 ? RowMajorBit : 0)$/;"	e	enum:Eigen::internal::traits::__anon193
Flags	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    Flags = (_MatrixTypeNested::Flags & HereditaryBits & ~RowMajorBit) | (IsRowMajor ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon234
Flags	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    Flags = (traits<typename traits<Derived>::ReturnType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon235
Flags	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    Flags = int(_MatrixTypeNested::Flags) & (HereditaryBits | LvalueBit | PacketAccessBit | LinearAccess),$/;"	e	enum:Eigen::internal::traits::__anon236
Flags	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    Flags = (unsigned int)ThenMatrixType::Flags & ElseMatrixType::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon238
Flags	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    Flags =  MatrixTypeNestedCleaned::Flags & (HereditaryBits)$/;"	e	enum:Eigen::internal::traits::__anon239
Flags	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Flags = traits<CwiseBinaryOp<BinaryOp,Lhs,Rhs> >::Flags | (Lhs::Flags&DirectAccessBit) | (Lhs::Flags&LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon243
Flags	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    Flags = Flags1 ^ RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon248
Flags	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    Flags = (MatrixTypeNestedCleaned::Flags & (HereditaryBits) & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit))) | Mode,$/;"	e	enum:Eigen::internal::traits::__anon252
Flags	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (RowsAtCompileTime == 1 ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon321
Flags	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      Flags = ((unsigned int)(LhsFlags | RhsFlags) & HereditaryBits & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon194
Flags	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    Flags = _MatrixTypeNested::Flags & (HereditaryBits | LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon348
Flags	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    Flags = ColsAtCompileTime==1 ? (TmpFlags & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon359
Flags	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon367
Flags	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags$/;"	e	enum:Eigen::internal::traits::__anon366
Flags	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    Flags = Eigen::internal::traits<Derived>::Flags$/;"	e	enum:Eigen::QuaternionBase::__anon363
Flags	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    Flags = IsAligned ? (AlignedBit | LvalueBit) : LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon364
Flags	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon382
Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    Flags = MatrixType::Flags,$/;"	e	enum:Eigen::internal::traits::__anon408
Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Flags = Tr ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon413
Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    Flags = (SparseFlags&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon414
Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon418
Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon417
Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    Flags = (int(LhsFlags | RhsFlags) & HereditaryBits & RemovedBits)$/;"	e	enum:Eigen::internal::traits::__anon424
Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    Flags = _Options | NestByRefBit | LvalueBit | (IsColVector ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon430
Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^    Flags = int(traits<MatrixType>::Flags) & (RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon433
Flags	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        Flags = SkylineBit | _Options,$/;"	e	enum:Eigen::internal::traits::__anon450
Flags	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon451
Flags	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        Flags = (int(LhsFlags | RhsFlags) & HereditaryBits & RemovedBits)$/;"	e	enum:Eigen::internal::traits::__anon452
Flags	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon456
Flags	vcglib/vcg/connectors/hedge_component.h	/^  int &Flags() { static int dummyflags(0);  assert(0); return dummyflags; }$/;"	f	class:vcg::hedge::EmptyBitFlags
Flags	vcglib/vcg/connectors/hedge_component.h	/^  int &Flags() {return _flags; }$/;"	f	class:vcg::hedge::BitFlags
Flags	vcglib/vcg/connectors/hedge_component.h	/^  int Flags() const { return 0; }$/;"	f	class:vcg::hedge::EmptyBitFlags
Flags	vcglib/vcg/connectors/hedge_component.h	/^  int Flags() const {return _flags; }$/;"	f	class:vcg::hedge::BitFlags
Flags	vcglib/vcg/simplex/edge/component.h	/^    int &Flags() { static int dummyflags(0);  assert(0); return dummyflags; }$/;"	f	class:vcg::edge::EmptyCore
Flags	vcglib/vcg/simplex/edge/component.h	/^    int Flags() const { return 0; }$/;"	f	class:vcg::edge::EmptyCore
Flags	vcglib/vcg/simplex/edge/component.h	/^  int &Flags() {return _flags; }$/;"	f	class:vcg::edge::BitFlags
Flags	vcglib/vcg/simplex/edge/component.h	/^  int Flags() const {return _flags; }$/;"	f	class:vcg::edge::BitFlags
Flags	vcglib/vcg/simplex/face/component.h	/^  int &Flags()       {return _flags; }$/;"	f	class:vcg::face::BitFlags
Flags	vcglib/vcg/simplex/face/component.h	/^  int &Flags() { static int dummyflags(0);  assert(0); return dummyflags; }$/;"	f	class:vcg::face::EmptyCore
Flags	vcglib/vcg/simplex/tetrahedron/component.h	/^   const int Flags() const {return _flags; }$/;"	f	class:vcg::tetra::BitFlags
Flags	vcglib/vcg/simplex/tetrahedron/component.h	/^   int &Flags() {return _flags; }$/;"	f	class:vcg::tetra::BitFlags
Flags	vcglib/vcg/simplex/tetrahedron/component.h	/^  const int Flags() const { return 0; }$/;"	f	class:vcg::tetra::EmptyBitFlags
Flags	vcglib/vcg/simplex/tetrahedron/component.h	/^  int &Flags() { static int dummyflags(0); return dummyflags; }$/;"	f	class:vcg::tetra::EmptyBitFlags
Flags	vcglib/vcg/simplex/vertex/component.h	/^  inline       int &Flags()       {return _flags; }$/;"	f	class:vcg::vertex::BitFlags
Flags	vcglib/vcg/simplex/vertex/component.h	/^  inline const int &Flags() const {return _flags; }$/;"	f	class:vcg::vertex::BitFlags
Flags	vcglib/vcg/simplex/vertex/component.h	/^  int &Flags()       { assert(0); static int dummyflags(0);  return dummyflags; }$/;"	f	class:vcg::vertex::EmptyCore
Flags	vcglib/vcg/simplex/vertex/component_occ.h	/^   const int Flags() const {return CAT< vector_occ<VertType>,int>::Instance()->Get((VertType*)this); }$/;"	f	class:vcg::vertex::FlagOcc
Flags	vcglib/vcg/simplex/vertex/component_occ.h	/^   int &Flags() {return CAT< vector_occ<VertType>,int>::Instance()->Get((VertType*)this); }$/;"	f	class:vcg::vertex::FlagOcc
Flags	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^const unsigned int & AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::Flags(void) const {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
Flags	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^unsigned int & AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::Flags(void) {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
Flags0	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    Flags0 = traits<XprType>::Flags & ( (HereditaryBits & ~RowMajorBit) |$/;"	e	enum:Eigen::internal::traits::__anon50
Flags0	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    Flags0 = (int(LhsFlags) | int(RhsFlags)) & ($/;"	e	enum:Eigen::internal::traits::__anon54
Flags0	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    Flags0 = TraitsBase::Flags & (~NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon173
Flags0	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    Flags0 = MatrixTypeNestedPlain::Flags & ~(LvalueBit | NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon248
Flags0	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    Flags0 = (unsigned int)_MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon321
Flags1	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    Flags1 = IsAligned ? (int(Flags0) | AlignedBit) : (int(Flags0) & ~AlignedBit),$/;"	e	enum:Eigen::internal::traits::__anon173
Flags1	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    Flags1 = Flags0 | FlagsLvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon248
Flags2	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    Flags2 = (bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime))$/;"	e	enum:Eigen::internal::traits::__anon173
Flags3	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    Flags3 = is_lvalue<PlainObjectType>::value ? int(Flags2) : (int(Flags2) & ~LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon173
FlagsLinearAccessBit	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon50
FlagsLvalueBit	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon50
FlagsLvalueBit	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon248
FlagsRowMajorBit	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon50
Flip	vcglib/vcg/space/line2.h	/^	inline void Flip(){$/;"	f	class:vcg::Line2
Flip	vcglib/vcg/space/line3.h	/^	inline void Flip(){$/;"	f	class:vcg::Line3
Flip	vcglib/vcg/space/ray2.h	/^	inline void Flip(){$/;"	f	class:vcg::Ray2
Flip	vcglib/vcg/space/ray3.h	/^	inline void Flip(){$/;"	f	class:vcg::Ray3
Flip	vcglib/vcg/space/segment2.h	/^	void Flip()$/;"	f	class:vcg::Segment2
Flip	vcglib/vcg/space/segment3.h	/^	void Flip()$/;"	f	class:vcg::Segment3
FlipDiag	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void FlipDiag(FaceType &f){$/;"	f	class:vcg::tri::BitQuad
FlipE	vcglib/vcg/connectors/halfedge_pos.h	/^            void FlipE()$/;"	f	class:vcg::hedge::Pos
FlipE	vcglib/vcg/simplex/edge/pos.h	/^	void FlipE()$/;"	f	class:vcg::edge::Pos
FlipE	vcglib/vcg/simplex/face/pos.h	/^	void FlipE()$/;"	f	class:vcg::face::Pos
FlipE	vcglib/vcg/simplex/tetrahedron/pos.h	/^	void FlipE()$/;"	f	class:vcg::tetra::Pos
FlipEdge	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void FlipEdge(FaceType &f, int k, MeshType &m){$/;"	f	class:vcg::tri::BitQuad
FlipEdge	vcglib/vcg/simplex/face/topology.h	/^void FlipEdge(FaceType &f, const int z)$/;"	f	namespace:vcg::face
FlipEdges	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            void FlipEdges()$/;"	f	class:vcg::tri::ExtendedMarchingCubes
FlipF	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  Pos FlipF(){return Pos(f->FFp(e), f->FFi(e)); }$/;"	f	class:vcg::tri::BitQuad::Pos
FlipF	vcglib/vcg/connectors/halfedge_pos.h	/^            void FlipF()$/;"	f	class:vcg::hedge::Pos
FlipF	vcglib/vcg/simplex/face/pos.h	/^	void FlipF()$/;"	f	class:vcg::face::Pos
FlipF	vcglib/vcg/simplex/tetrahedron/pos.h	/^	void FlipF()$/;"	f	class:vcg::tetra::Pos
FlipH	vcglib/wrap/gui/trackmode.cpp	/^void NavigatorWasdMode::FlipH(){$/;"	f	class:NavigatorWasdMode
FlipMesh	vcglib/vcg/complex/algorithms/clean.h	/^            static void FlipMesh(MeshType &m, bool selected=false)$/;"	f	class:vcg::tri::Clean
FlipNormalOutside	vcglib/vcg/complex/algorithms/clean.h	/^      static bool FlipNormalOutside(MeshType &m)$/;"	f	class:vcg::tri::Clean
FlipT	vcglib/vcg/simplex/tetrahedron/pos.h	/^	void FlipT()$/;"	f	class:vcg::tetra::Pos
FlipType	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            enum FlipType { NO_FLIP, CW_FLIP, CCW_FLIP};$/;"	g	class:vcg::tri::EdgeFlipPriority
FlipType	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename Base::FlipType FlipType;$/;"	t	class:vcg::tri::Homeometry
FlipType	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename Base::FlipType FlipType;$/;"	t	class:vcg::tri::VertReg
FlipV	vcglib/vcg/connectors/halfedge_pos.h	/^            void FlipV()$/;"	f	class:vcg::hedge::Pos
FlipV	vcglib/vcg/simplex/edge/pos.h	/^	void FlipV()$/;"	f	class:vcg::edge::Pos
FlipV	vcglib/vcg/simplex/face/pos.h	/^	void FlipV()$/;"	f	class:vcg::face::Pos
FlipV	vcglib/vcg/simplex/tetrahedron/pos.h	/^	void FlipV()$/;"	f	class:vcg::tetra::Pos
FlipV	vcglib/wrap/gui/trackmode.cpp	/^void NavigatorWasdMode::FlipV(){$/;"	f	class:NavigatorWasdMode
FloatArrayTag	vcglib/wrap/dae/colladaformat.h	/^		FloatArrayTag(const QString& id,const int count,const MESHTYPE& m,ARRAYSEMANTIC sem,const unsigned int componenttype)$/;"	f	class:Collada::Tags::FloatArrayTag
FloatArrayTag	vcglib/wrap/dae/colladaformat.h	/^	class FloatArrayTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
FloatTag	vcglib/wrap/dae/colladaformat.h	/^		FloatTag(const float floatnum)$/;"	f	class:Collada::Tags::FloatTag
FloatTag	vcglib/wrap/dae/colladaformat.h	/^	class FloatTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
FloatingPoint	vcglib/vcg/math/eigen.h	/^	typedef wrong_type FloatingPoint;$/;"	t	struct:Eigen::NumTraits
FloatingPoint	vcglib/vcg/math/eigen.h	/^  typedef float FloatingPoint;$/;"	t	struct:Eigen::NumTraits
FloodFill	vcglib/wrap/miq/core/seams_initializer.h	/^    void FloodFill(FaceType* start)$/;"	f	class:SeamsInitializer
FocalMm	vcglib/vcg/math/camera.h	/^    ScalarType	FocalMm;			\/\/\/ Focal Distance: the distance between focal center and image plane. Expressed in mm$/;"	m	class:vcg::Camera
FofE	vcglib/vcg/space/tetra3.h	/^  static int FofE(const int &indexE,const int &indexSide) $/;"	f	class:vcg::Tetra
FofEE	vcglib/vcg/space/tetra3.h	/^static int FofEE(const int &indexE0,const int &indexE1)$/;"	f	class:vcg::Tetra
FofV	vcglib/vcg/space/tetra3.h	/^	static int FofV(const int &indexV,const int &indexF)$/;"	f	class:vcg::Tetra
FofVVV	vcglib/vcg/space/tetra3.h	/^static int FofVVV(const int &indexV0,const int &indexV1,const int &indexV2)$/;"	f	class:vcg::Tetra
Folded	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static bool Folded(const FaceType *f)$/;"	f	class:vcg::tri::Distortion
Folded	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static int Folded(const MeshType &m)$/;"	f	class:vcg::tri::Distortion
FollowDirection	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^            static CoordType FollowDirection(const FaceType &f0,$/;"	f	class:vcg::tri::CrossField
FollowDirection	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^            static int FollowDirection(const FaceType &f0,$/;"	f	class:vcg::tri::CrossField
FollowLineDirection	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^            static int FollowLineDirection(const FaceType &f0,$/;"	f	class:vcg::tri::CrossField
ForceAlignedAccess	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline ForceAlignedAccess(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ForceAlignedAccess
ForceAlignedAccess	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^template<typename ExpressionType> class ForceAlignedAccess$/;"	c	namespace:Eigen
ForceDisabled	vcglib/wrap/glw/program.h	/^			ForceDisabled$/;"	e	enum:glw::RasterizerSettings::RasterizerExecution
ForceEnabled	vcglib/wrap/glw/program.h	/^			ForceEnabled,$/;"	e	enum:glw::RasterizerSettings::RasterizerExecution
Format	vcglib/wrap/gl/fbo.h	/^	GLenum Format(void) const$/;"	f	class:BufferRenderTarget
Format	vcglib/wrap/gl/fbo.h	/^	GLenum Format(void) const$/;"	f	class:Texture
Format	vcglib/wrap/gl/fbo.h	/^	GLenum Format(void) const$/;"	f	class:TextureRenderTarget
FormatTag	vcglib/wrap/dae/colladaformat.h	/^		FormatTag(const QString& format)$/;"	f	class:Collada::Tags::FormatTag
FormatTag	vcglib/wrap/dae/colladaformat.h	/^	class FormatTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
Forward	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    Forward,$/;"	e	enum:Eigen::NumericalDiffMode
Forward	vcglib/wrap/gui/trackball.cpp	/^void Trackball::Forward(){}$/;"	f	class:Trackball
FourPCS	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^class FourPCS {$/;"	c	namespace:vcg::tri
FourPoints	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  typedef vcg::Point4< vcg::Point3<ScalarType> > FourPoints;$/;"	t	class:vcg::tri::FourPCS
Fp	vcglib/vcg/simplex/vertex/component_occ.h	/^ FacePointer &Fp() {return CAT< vector_occ<VertType>,FacePointer>::Instance()->Get((VertType*)this); }$/;"	f	class:vcg::vertex::VFAdjOcc
Frag	vcglib/wrap/mt/mt.h	/^  class Frag:public std::vector<Cell *> {};$/;"	c	class:vcg::MT
FragmentOutputBinding	vcglib/wrap/glw/program.h	/^		FragmentOutputBinding(void)$/;"	f	class:glw::FragmentOutputBinding
FragmentOutputBinding	vcglib/wrap/glw/program.h	/^class FragmentOutputBinding$/;"	c	namespace:glw
FragmentShader	vcglib/wrap/gl/shaders.h	/^	FragmentShader(void) : Shader()$/;"	f	class:FragmentShader
FragmentShader	vcglib/wrap/gl/shaders.h	/^class FragmentShader : public Shader$/;"	c
FragmentShader	vcglib/wrap/glw/fragmentshader.h	/^		FragmentShader(Context * ctx)$/;"	f	class:glw::FragmentShader
FragmentShader	vcglib/wrap/glw/fragmentshader.h	/^class FragmentShader : public Shader$/;"	c	namespace:glw
FragmentShaderArguments	vcglib/wrap/glw/fragmentshader.h	/^		FragmentShaderArguments(void)$/;"	f	class:glw::FragmentShaderArguments
FragmentShaderArguments	vcglib/wrap/glw/fragmentshader.h	/^class FragmentShaderArguments : public ShaderArguments$/;"	c	namespace:glw
FragmentShaderBindingParams	vcglib/wrap/glw/fragmentshader.h	/^		FragmentShaderBindingParams(void)$/;"	f	class:glw::FragmentShaderBindingParams
FragmentShaderBindingParams	vcglib/wrap/glw/fragmentshader.h	/^class FragmentShaderBindingParams : public ShaderBindingParams$/;"	c	namespace:glw
FragmentShaderHandle	vcglib/wrap/glw/fragmentshader.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeFragmentShader> ::Type FragmentShaderHandle;$/;"	t	namespace:glw
FragmentShaderPtr	vcglib/wrap/glw/fragmentshader.h	/^typedef   detail::ObjectSharedPointerTraits  <FragmentShader> ::Type FragmentShaderPtr;$/;"	t	namespace:glw
FragmentShaderType	vcglib/wrap/glw/type.h	/^	FragmentShaderType,$/;"	e	enum:glw::Type
FrameBuffer	vcglib/wrap/gl/fbo.h	/^	FrameBuffer(void) : GLObject(), Bindable()$/;"	f	class:FrameBuffer
FrameBuffer	vcglib/wrap/gl/fbo.h	/^class FrameBuffer : public GLObject, public Bindable$/;"	c
FrameBufferSemantic	vcglib/wrap/gl/fbo.h	/^class FrameBufferSemantic$/;"	c
Framebuffer	vcglib/wrap/glw/framebuffer.h	/^		Framebuffer(Context * ctx)$/;"	f	class:glw::Framebuffer
Framebuffer	vcglib/wrap/glw/framebuffer.h	/^class Framebuffer : public Object$/;"	c	namespace:glw
FramebufferArguments	vcglib/wrap/glw/framebuffer.h	/^		FramebufferArguments(void)$/;"	f	class:glw::FramebufferArguments
FramebufferArguments	vcglib/wrap/glw/framebuffer.h	/^class FramebufferArguments : public ObjectArguments$/;"	c	namespace:glw
FramebufferBindingParams	vcglib/wrap/glw/framebuffer.h	/^		FramebufferBindingParams(GLenum target)$/;"	f	class:glw::FramebufferBindingParams
FramebufferBindingParams	vcglib/wrap/glw/framebuffer.h	/^		FramebufferBindingParams(void)$/;"	f	class:glw::FramebufferBindingParams
FramebufferBindingParams	vcglib/wrap/glw/framebuffer.h	/^class FramebufferBindingParams : public ObjectBindingParams$/;"	c	namespace:glw
FramebufferHandle	vcglib/wrap/glw/framebuffer.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeFramebuffer> ::Type FramebufferHandle;$/;"	t	namespace:glw
FramebufferPtr	vcglib/wrap/glw/framebuffer.h	/^typedef   detail::ObjectSharedPointerTraits  <Framebuffer> ::Type FramebufferPtr;$/;"	t	namespace:glw
FramebufferType	vcglib/wrap/glw/type.h	/^	FramebufferType$/;"	e	enum:glw::Type
Free	vcglib/wrap/io_trimesh/import_vmi.h	/^        static void Free(void * ptr){ if(ptr) free (ptr);}$/;"	f	class:vcg::tri::io::ImporterVMI
FromAxis	vcglib/vcg/math/quaternion.h	/^template <class S> void Quaternion<S>::FromAxis(const S phi, const Point3<S> &a) {$/;"	f	class:vcg::Quaternion
FromEigenMatrix	vcglib/vcg/math/matrix33.h	/^    void FromEigenMatrix(const EigenMatrix33Type & m){$/;"	f	class:vcg::Matrix33
FromEigenMatrix	vcglib/vcg/math/matrix44.h	/^	void FromEigenMatrix(const EigenMatrix44Type & m){$/;"	f	class:vcg::Matrix44
FromEigenVector	vcglib/vcg/space/deprecated_point3.h	/^    inline void FromEigenVector( const EigenVector & b )$/;"	f	class:vcg::Point3
FromEigenVector	vcglib/vcg/space/deprecated_point4.h	/^	inline void FromEigenVector( const EigenVector & b )$/;"	f	class:vcg::Point4
FromEulerAngles	vcglib/vcg/math/matrix44.h	/^void Matrix44<T>::FromEulerAngles(T alpha, T beta, T gamma)$/;"	f	class:vcg::Matrix44
FromEulerAngles	vcglib/vcg/math/old_matrix44.h	/^void Matrix44<T>::FromEulerAngles(Scalar alpha, Scalar beta, Scalar gamma)$/;"	f	class:vcg::Matrix44
FromEulerAngles	vcglib/vcg/math/quaternion.h	/^void Quaternion<S>::FromEulerAngles(S alpha, S beta, S gamma)$/;"	f	class:vcg::Quaternion
FromHalfEdges	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            static void FromHalfEdges(  MeshType & m ){$/;"	f	struct:vcg::tri::UpdateIndexed
FromIndexed	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            static void FromIndexed(MeshType & m){$/;"	f	class:vcg::tri::UpdateHalfEdges
FromMatrix	vcglib/vcg/math/matrix44.h	/^	void FromMatrix(const Matrix44Type & m){for(int i = 0; i < 16; i++) V()[i]=m.V()[i];}$/;"	f	class:vcg::Matrix44
FromMatrix	vcglib/vcg/math/old_matrix44.h	/^	void FromMatrix(const Matrix44Type & m) { for(int i = 0; i < 16; i++) Base::data()[i] = m.data()[i]; }$/;"	f	class:vcg::Matrix44
FromMatrix	vcglib/vcg/math/quaternion.h	/^template <class S> void Quaternion<S>::FromMatrix(const Matrix33<S> &m) {	$/;"	f	class:vcg::Quaternion
FromMatrix	vcglib/vcg/math/quaternion.h	/^template <class S> void Quaternion<S>::FromMatrix(const Matrix44<S> &m) {	$/;"	f	class:vcg::Quaternion
FromMatrix	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> void Similarity<S,RotationType>::FromMatrix(const Matrix44<S> &m) {$/;"	f	class:vcg::Similarity
FromPolar	vcglib/vcg/math/eigen_matrix_addons.h	/^void FromPolar(const Scalar &ro, const Scalar &theta, const Scalar &phi)$/;"	f
FromPolarRad	vcglib/vcg/space/deprecated_point3.h	/^  void FromPolarRad(const P3ScalarType &ro, const P3ScalarType &theta, const P3ScalarType &phi)$/;"	f	class:vcg::Point3
FromTrackball	vcglib/wrap/gl/shot.h	/^static void FromTrackball(const vcg::Trackball & tr, $/;"	f	struct:GlShot
FromTwoVectors	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^Quaternion<Scalar,Options> Quaternion<Scalar,Options>::FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion
FromUnsignedB5G5R5	vcglib/vcg/space/color4.h	/^inline Color4<unsigned char> Color4<unsigned char>::FromUnsignedB5G5R5(unsigned short val)$/;"	f	class:vcg::Color4
FromUnsignedB5G5R5	vcglib/vcg/space/color4.h	/^inline static Color4 FromUnsignedB5G5R5(unsigned short)$/;"	f	class:vcg::Color4
FromUnsignedR5G5B5	vcglib/vcg/space/color4.h	/^inline Color4<unsigned char> Color4<unsigned char>::FromUnsignedR5G5B5(unsigned short val)$/;"	f	class:vcg::Color4
FromUnsignedR5G5B5	vcglib/vcg/space/color4.h	/^inline static Color4 FromUnsignedR5G5B5(unsigned short)$/;"	f	class:vcg::Color4
FrontEdge	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  FrontEdge() {}$/;"	f	class:vcg::tri::FrontEdge
FrontEdge	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  FrontEdge(int _v0, int _v1, int _v2):$/;"	f	class:vcg::tri::FrontEdge
FrontEdge	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^class FrontEdge {$/;"	c	namespace:vcg::tri
Frustum	vcglib/wrap/gui/frustum.h	/^template <class T> class Frustum: public View<T> {$/;"	c	namespace:vcg
FrustumCull	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	inline void FrustumCull(const Plane3<ScalarType> _frustumPlanes[6], const unsigned int _minNodeObjectsCount) {$/;"	f	class:vcg::AABBBinaryTreeIndex
FrustumCull	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	static inline void FrustumCull(TreeType & tree, const Point3<ScalarType> & viewerPosition, const Plane3<ScalarType> frustumPlanes[6], const unsigned int minNodeObjectsCount, NODEAPPLYFUNCTOR & nodeApply) {$/;"	f	class:vcg::AABBBinaryTreeFrustumCull
FrustumPolicy	vcglib/wrap/mt/mt.h	/^template <class C> class FrustumPolicy {$/;"	c	namespace:vcg
Frustumd	vcglib/wrap/gui/frustum.h	/^typedef Frustum<double> Frustumd;$/;"	t	namespace:vcg
Frustumf	vcglib/wrap/gui/frustum.h	/^typedef Frustum<float> Frustumf;$/;"	t	namespace:vcg
FtolTooSmall	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        FtolTooSmall = 6,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
FullPivHouseholderQR	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR()$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename _MatrixType> class FullPivHouseholderQR$/;"	c	namespace:Eigen
FullPivHouseholderQRMatrixQReturnType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  FullPivHouseholderQRMatrixQReturnType(const MatrixType&       qr,$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
FullPivHouseholderQRMatrixQReturnType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename MatrixType> struct FullPivHouseholderQRMatrixQReturnType$/;"	s	namespace:Eigen::internal
FullPivHouseholderQRPreconditioner	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  FullPivHouseholderQRPreconditioner$/;"	e	enum:Eigen::QRPreconditioners
FullPivLU	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU()$/;"	f	class:Eigen::FullPivLU
FullPivLU	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(Index rows, Index cols)$/;"	f	class:Eigen::FullPivLU
FullPivLU	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU
FullPivLU	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^template<typename _MatrixType> class FullPivLU$/;"	c	namespace:Eigen
FullPrecision	vcglib/eigenlib/Eigen/src/Core/IO.h	/^       FullPrecision = -2 };$/;"	e	enum:Eigen::__anon172
FullyLazyCoeffBaseProductType	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef CoeffBasedProduct<LhsNested, RhsNested, 0> FullyLazyCoeffBaseProductType;$/;"	t	class:Eigen::ProductBase
Functor	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    typedef _Functor Functor;$/;"	t	class:Eigen::NumericalDiff
Functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^  Functor() : m_inputs(InputsAtCompileTime), m_values(ValuesAtCompileTime) {}$/;"	f	struct:Functor
Functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^  Functor(int inputs, int values) : m_inputs(inputs), m_values(values) {}$/;"	f	struct:Functor
Functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct Functor$/;"	s	file:
Functor	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^  Functor() : m_inputs(InputsAtCompileTime), m_values(ValuesAtCompileTime) {}$/;"	f	struct:Functor
Functor	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^  Functor(int inputs, int values) : m_inputs(inputs), m_values(values) {}$/;"	f	struct:Functor
Functor	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^struct Functor$/;"	s	file:
FunctorType	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon311
FunctorType	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon312
G	vcglib/wrap/opensg/vertex_component.h	/^	ScalarType G()$/;"	f	class:vcg::vert::OSGColorCore
GAUSSIAN	vcglib/wrap/miq/MIQ.h	/^  enum StiffMode{NO_STIFF = 0,GAUSSIAN = 1,ITERATIVE = 2};$/;"	e	enum:MIQ_parametrization::StiffMode
GCACHE_CACHE_H	vcglib/wrap/gcache/cache.h	/^#define GCACHE_CACHE_H$/;"	d
GCACHE_CONTROLLER_H	vcglib/wrap/gcache/controller.h	/^#define GCACHE_CONTROLLER_H$/;"	d
GCACHE_PROVIDER_H	vcglib/wrap/gcache/provider.h	/^#define GCACHE_PROVIDER_H$/;"	d
GCACHE_TOKEN_H	vcglib/wrap/gcache/token.h	/^#define GCACHE_TOKEN_H$/;"	d
GEMM_SPECIALIZATION	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^#define GEMM_SPECIALIZATION(/;"	d
GEOMETRY	vcglib/wrap/gl/shaders.h	/^		GEOMETRY$/;"	e	enum:Shader::__anon517
GETOPT_H	vcglib/wrap/system/qgetopt.h	/^#define GETOPT_H$/;"	d
GH	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^int GW,GH; \/\/ Grandezza della finestra$/;"	v
GLAElem	vcglib/wrap/gl/trimesh.h	/^    class GLAElem {$/;"	c	class:vcg::GLW
GLAREA_H_	vcglib/apps/sample/trimesh_QT/glarea.h	/^#define GLAREA_H_$/;"	d
GLAccumPixel	vcglib/apps/unsupported/shadevis/visshader.h	/^int GLAccumPixel(	std::vector<int> &PixSeen)$/;"	f	class:vcg::VertexVisShader
GLArea	vcglib/apps/pivoting/glarea.cpp	/^GLArea::GLArea(QWidget *parent): QGLWidget(parent), pivot(NULL), smooth(false), radius(1.2) {$/;"	f	class:GLArea
GLArea	vcglib/apps/pivoting/glarea.h	/^class GLArea : public QGLWidget {$/;"	c
GLArea	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^GLArea::GLArea (QWidget * parent)$/;"	f	class:GLArea
GLArea	vcglib/apps/sample/trimesh_QT/glarea.h	/^class GLArea:public QGLWidget$/;"	c
GLDrawFaceField	vcglib/wrap/gl/gl_field.h	/^	static void GLDrawFaceField(const MeshType &mesh)$/;"	f	class:vcg::GLField
GLDrawFaceField	vcglib/wrap/gl/gl_field.h	/^    static void GLDrawFaceField(const FaceType &f,$/;"	f	class:vcg::GLField
GLDrawFaceSeams	vcglib/wrap/miq/core/glUtils.h	/^    static void GLDrawFaceSeams(const FaceType &f,$/;"	f	class:Miq_Gl_Utils
GLDrawField	vcglib/wrap/gl/gl_field.h	/^	static void GLDrawField(CoordType dir[4],$/;"	f	class:vcg::GLField
GLDrawIntegerLines	vcglib/wrap/miq/core/glUtils.h	/^   static void GLDrawIntegerLines(QuadrangulatorType &Quadr)$/;"	f	class:Miq_Gl_Utils
GLDrawPolygons	vcglib/wrap/miq/core/glUtils.h	/^   static void GLDrawPolygons(QuadrangulatorType &Quadr)$/;"	f	class:Miq_Gl_Utils
GLDrawSeams	vcglib/wrap/miq/core/glUtils.h	/^    static void GLDrawSeams(MeshType &mesh,$/;"	f	class:Miq_Gl_Utils
GLDrawSingularities	vcglib/wrap/miq/core/glUtils.h	/^    static void GLDrawSingularities(MeshType &mesh,$/;"	f	class:Miq_Gl_Utils
GLDrawVertField	vcglib/wrap/gl/gl_field.h	/^	static void GLDrawVertField(const MeshType &mesh)$/;"	f	class:vcg::GLField
GLDrawVertField	vcglib/wrap/gl/gl_field.h	/^	static void GLDrawVertField(const MeshType &mesh,$/;"	f	class:vcg::GLField
GLDrawVertexIndexing	vcglib/wrap/miq/core/glUtils.h	/^   static void GLDrawVertexIndexing(VertexIndexingType &VI)$/;"	f	class:Miq_Gl_Utils
GLField	vcglib/wrap/gl/gl_field.h	/^class GLField$/;"	c	namespace:vcg
GLObject	vcglib/wrap/gl/gl_object.h	/^	GLObject(void)$/;"	f	class:GLObject
GLObject	vcglib/wrap/gl/gl_object.h	/^class GLObject$/;"	c
GLPickTetra	vcglib/wrap/gl/pick.h	/^class GLPickTetra$/;"	c	namespace:vcg
GLPickTri	vcglib/wrap/gl/pick.h	/^class GLPickTri$/;"	c	namespace:vcg
GLUT2VCG	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^static vcg::Trackball::Button GLUT2VCG (int glut_button, int )$/;"	f	file:
GLU_TESSELLATOR_CAP_H	vcglib/wrap/gl/glu_tessellator_cap.h	/^#define GLU_TESSELLATOR_CAP_H$/;"	d
GLW	vcglib/wrap/gl/tetramesh.h	/^class GLW {$/;"	c	namespace:vcg::tetra
GLW	vcglib/wrap/gl/trimesh.h	/^class GLW$/;"	c	namespace:vcg
GLWIDGET_H	vcglib/apps/sample/trimesh_ant_qt/glwidget.h	/^#define GLWIDGET_H$/;"	d
GLWIDGET_H_POS_DEMO	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^#define GLWIDGET_H_POS_DEMO$/;"	d
GLW_ASSERT	vcglib/wrap/glw/config.h	/^#	define GLW_ASSERT /;"	d
GLW_ASSERT_UNIFORM_LOCATION	vcglib/wrap/glw/config.h	/^#	define GLW_ASSERT_UNIFORM_LOCATION /;"	d
GLW_BOOKKEEPING_H	vcglib/wrap/glw/bookkeeping.h	/^#define GLW_BOOKKEEPING_H$/;"	d
GLW_BUFFER_H	vcglib/wrap/glw/buffer.h	/^#define GLW_BUFFER_H$/;"	d
GLW_CARE_OF	vcglib/wrap/glw/common.h	/^#define GLW_CARE_OF(/;"	d
GLW_CHECK_GL_DRAW_FRAMEBUFFER_STATUS	vcglib/wrap/glw/common.h	/^#define GLW_CHECK_GL_DRAW_FRAMEBUFFER_STATUS /;"	d
GLW_CHECK_GL_ERROR	vcglib/wrap/glw/common.h	/^#define GLW_CHECK_GL_ERROR /;"	d
GLW_CHECK_GL_READ_DRAW_FRAMEBUFFER_STATUS	vcglib/wrap/glw/common.h	/^#define GLW_CHECK_GL_READ_DRAW_FRAMEBUFFER_STATUS /;"	d
GLW_CHECK_GL_READ_FRAMEBUFFER_STATUS	vcglib/wrap/glw/common.h	/^#define GLW_CHECK_GL_READ_FRAMEBUFFER_STATUS /;"	d
GLW_COMMON_H	vcglib/wrap/glw/common.h	/^#define GLW_COMMON_H$/;"	d
GLW_CONFIG_H	vcglib/wrap/glw/config.h	/^#define GLW_CONFIG_H$/;"	d
GLW_CONTEXT_H	vcglib/wrap/glw/context.h	/^#define GLW_CONTEXT_H$/;"	d
GLW_DONT_CARE	vcglib/wrap/glw/common.h	/^#define GLW_DONT_CARE /;"	d
GLW_FRAGMENTSHADER_H	vcglib/wrap/glw/fragmentshader.h	/^#define GLW_FRAGMENTSHADER_H$/;"	d
GLW_FRAMEBUFFER_H	vcglib/wrap/glw/framebuffer.h	/^#define GLW_FRAMEBUFFER_H$/;"	d
GLW_GEOMETRYSHADER_H	vcglib/wrap/glw/geometryshader.h	/^#define GLW_GEOMETRYSHADER_H$/;"	d
GLW_GLHEADERS_H	vcglib/wrap/glw/glheaders.h	/^#define GLW_GLHEADERS_H$/;"	d
GLW_GLW_H	vcglib/wrap/glw/glw.h	/^#define GLW_GLW_H$/;"	d
GLW_IMPLEMENT_CUSTOM_UNIFORMS	vcglib/wrap/glw/config.h	/^#	define GLW_IMPLEMENT_CUSTOM_UNIFORMS$/;"	d
GLW_IMPLEMENT_CUSTOM_UNIFORMS	vcglib/wrap/glw/program.h	/^		GLW_IMPLEMENT_CUSTOM_UNIFORMS;$/;"	m	class:glw::Program
GLW_NONCOPYABLE_H	vcglib/wrap/glw/noncopyable.h	/^#define GLW_NONCOPYABLE_H$/;"	d
GLW_OBJECTDELETER_H	vcglib/wrap/glw/objectdeleter.h	/^#define GLW_OBJECTDELETER_H$/;"	d
GLW_OBJECT_H	vcglib/wrap/glw/object.h	/^#define GLW_OBJECT_H$/;"	d
GLW_OFFSET_OF	vcglib/wrap/glw/utility.h	/^#define GLW_OFFSET_OF(/;"	d
GLW_PRINT_LOG_TO_STDERR	vcglib/wrap/glw/config.h	/^#	define GLW_PRINT_LOG_TO_STDERR /;"	d
GLW_PROGRAM_H	vcglib/wrap/glw/program.h	/^#define GLW_PROGRAM_H$/;"	d
GLW_RENDERABLE_H	vcglib/wrap/glw/renderable.h	/^#define GLW_RENDERABLE_H$/;"	d
GLW_RENDERBUFFER_H	vcglib/wrap/glw/renderbuffer.h	/^#define GLW_RENDERBUFFER_H$/;"	d
GLW_SHADER_H	vcglib/wrap/glw/shader.h	/^#define GLW_SHADER_H$/;"	d
GLW_STRINGIFY	vcglib/wrap/glw/utility.h	/^#define GLW_STRINGIFY(/;"	d
GLW_TEXTURE2D_H	vcglib/wrap/glw/texture2d.h	/^#define GLW_TEXTURE2D_H$/;"	d
GLW_TEXTURECUBE_H	vcglib/wrap/glw/texturecube.h	/^#define GLW_TEXTURECUBE_H$/;"	d
GLW_TEXTURE_H	vcglib/wrap/glw/texture.h	/^#define GLW_TEXTURE_H$/;"	d
GLW_TYPE_H	vcglib/wrap/glw/type.h	/^#define GLW_TYPE_H$/;"	d
GLW_UTILITY_H	vcglib/wrap/glw/utility.h	/^#define GLW_UTILITY_H$/;"	d
GLW_VERTEXSHADER_H	vcglib/wrap/glw/vertexshader.h	/^#define GLW_VERTEXSHADER_H$/;"	d
GLWidget	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^GLWidget::GLWidget(QWidget *parent)$/;"	f	class:GLWidget
GLWidget	vcglib/apps/sample/trimesh_ant_qt/glwidget.h	/^class GLWidget : public QGLWidget$/;"	c
GLWidget	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^GLWidget::GLWidget(QWidget *parent)$/;"	f	class:GLWidget
GLWidget	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^class GLWidget : public QGLWidget$/;"	c
GL_FIELD	vcglib/wrap/gl/gl_field.h	/^#define GL_FIELD$/;"	d
GL_TEST_ERR	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^#define GL_TEST_ERR\\/;"	d
GMRES	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  GMRES() : Base(), m_restart(30) {}$/;"	f	class:Eigen::GMRES
GMRES	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  GMRES(const MatrixType& A) : Base(A), m_restart(30) {}$/;"	f	class:Eigen::GMRES
GMRES	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^class GMRES : public IterativeSolverBase<GMRES<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen
GREEN_CHANNEL	vcglib/vcg/complex/algorithms/update/color.h	/^enum rgbChMask {ALL_CHANNELS = 7, RED_CHANNEL = 4, GREEN_CHANNEL = 2, BLUE_CHANNEL = 1, NO_CHANNELS = 0 };$/;"	e	enum:vcg::tri::UpdateColor::rgbChMask
GRID	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^typedef vcg::GridStaticPtr<CMesh::FaceType, TriFaceType::ScalarType> GRID;$/;"	t	file:
GRID	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename vcg::GridStaticPtr<TriFaceType, typename TriFaceType::ScalarType> GRID;$/;"	t	class:vcg::tri::FeasibilityCheck
GRID	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename vcg::GridStaticPtr<TriFaceType, typename TriFaceType::ScalarType> GRID;$/;"	t	class:vcg::tri::FitmapsCollapse
GRID	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename vcg::GridStaticPtr<TriFaceType, typename TriFaceType::ScalarType> GRID;$/;"	t	class:vcg::tri::OperationWeight
GRID	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename vcg::GridStaticPtr<TriFaceType, typename TriFaceType::ScalarType> GRID;$/;"	t	class:vcg::tri::QuadDiagonalCollapse
GRID	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename vcg::GridStaticPtr<TriFaceType, typename TriFaceType::ScalarType> GRID;$/;"	t	class:vcg::tri::QuadDiagonalCollapseBase
GTSCodes	vcglib/wrap/io_trimesh/import_gts.h	/^				enum GTSCodes {NoError=0, CantOpen, InvalidFile,$/;"	g	class:vcg::tri::io::ImporterGTS
GW	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^int GW,GH; \/\/ Grandezza della finestra$/;"	v
GZFILE	vcglib/wrap/ply/plylib.h	/^typedef FILE * GZFILE;$/;"	t	namespace:vcg::ply
GZFILE	vcglib/wrap/ply/plylib.h	/^typedef void * GZFILE;$/;"	t	namespace:vcg::ply
Gamma	vcglib/vcg/simplex/face/distance.h	/^        static ScalarType & Gamma(){static ScalarType gamma = 1.0; return gamma;}$/;"	f	class:vcg::face::PointNormalDistanceFunctor
Gamma	vcglib/vcg/simplex/vertex/distance.h	/^		static ScalarType & Gamma(){static ScalarType gamma= 1.0; return gamma;}$/;"	f	class:vcg::vertex::PointNormalDistanceFunctor
Gather	vcglib/vcg/space/index/grid_static_ptr.h	/^    void Gather(GATHERFUNCTOR gfunctor) {$/;"	f	class:vcg::GridStaticPtr
Gauss	vcglib/wrap/miq/core/stiffening.h	/^ScalarType Gauss(ScalarType &value)$/;"	f
Gauss33	vcglib/vcg/math/quadric.h	/^bool Gauss33( FLTYPE x[], FLTYPE C[3][3+1] )$/;"	f	class:vcg::math::Quadric
Gauss55	vcglib/vcg/math/quadric5.h	/^  static bool Gauss55( ScalarType x[], ScalarType C[5][5+1] )$/;"	f	class:vcg::Quadric5
GaussianSmooth	vcglib/img/img_filter.h	/^inline void GaussianSmooth(const Image<Channels,SrcScalarType,SrcSafe> &source,Image<Channels,DestScalarType,DestSafe> &destination,const int radius)$/;"	f	namespace:img
GemmParallelInfo	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^  GemmParallelInfo() : sync(-1), users(0), rhs_start(0), rhs_length(0) {}$/;"	f	struct:Eigen::internal::GemmParallelInfo
GemmParallelInfo	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^template<typename Index> struct GemmParallelInfo$/;"	s	namespace:Eigen::internal
GemmProduct	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon266
GemvProduct	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon266
Gen	vcglib/wrap/gl/fbo.h	/^	void Gen(void)$/;"	f	class:BufferRenderTarget
Gen	vcglib/wrap/gl/fbo.h	/^	void Gen(void)$/;"	f	class:FrameBuffer
Gen	vcglib/wrap/gl/fbo.h	/^	void Gen(void)$/;"	f	class:Texture
Gen	vcglib/wrap/gl/fbo.h	/^	void Gen(void)$/;"	f	class:TextureRenderTarget
Gen	vcglib/wrap/gl/shaders.h	/^	void Gen(void)$/;"	f	class:Program
Gen	vcglib/wrap/gl/shaders.h	/^	void Gen(void)$/;"	f	class:Shader
GenEigMask	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  GenEigMask = Ax_lBx | ABx_lx | BAx_lx$/;"	e	enum:Eigen::DecompositionOptions
GenMatrix	vcglib/apps/unsupported/shadevis/visshader.h	/^void GenMatrix(Matrix44d &a, Point3d Axis, double angle)$/;"	f	class:vcg::VisShader
GenNormal	vcglib/vcg/math/gen_normal.h	/^class GenNormal $/;"	c	namespace:vcg
GeneralProduct	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct
GeneralProduct	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::GeneralProduct
GeneralProduct	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, GemvProduct>$/;"	c	namespace:Eigen
GeneralProduct	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, InnerProduct>$/;"	c	namespace:Eigen
GeneralProduct	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, OuterProduct>$/;"	c	namespace:Eigen
GeneralProduct	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct
GeneralProduct	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class GeneralProduct<Lhs, Rhs, GemmProduct>$/;"	c	namespace:Eigen
GeneralizedSelfAdjointEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver() : Base() {}$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB,$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^class GeneralizedSelfAdjointEigenSolver : public SelfAdjointEigenSolver<_MatrixType>$/;"	c	namespace:Eigen
GenerateBarycentricUniform	vcglib/vcg/math/random_generator.h	/^vcg::Point3<ScalarType> GenerateBarycentricUniform(GeneratorType &rnd)$/;"	f	namespace:vcg::math
GenerateCameraMesh	vcglib/vcg/complex/algorithms/create/platonic.h	/^void GenerateCameraMesh(MeshType &in){$/;"	f	namespace:vcg::tri
GenerateMaterialBinding	vcglib/wrap/io_trimesh/import_dae.h	/^		static bool GenerateMaterialBinding(QDomNode instanceGeomNode, QMap<QString,QString> &binding)$/;"	f	class:vcg::tri::io::ImporterDAE
GenerateMidPointMap	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void GenerateMidPointMap(MeshType &m,$/;"	f	class:vcg::tri::VoronoiProcessing
GeneratePointInBox3Uniform	vcglib/vcg/math/random_generator.h	/^vcg::Point3<ScalarType> GeneratePointInBox3Uniform(GeneratorType &rnd, const Box3<ScalarType> &bb)$/;"	f	namespace:vcg::math
GeneratePointInUnitBallUniform	vcglib/vcg/math/random_generator.h	/^vcg::Point3<ScalarType> GeneratePointInUnitBallUniform(GeneratorType &rnd)$/;"	f	namespace:vcg::math
GeneratePointOnUnitSphereUniform	vcglib/vcg/math/random_generator.h	/^vcg::Point3<ScalarType> GeneratePointOnUnitSphereUniform(GeneratorType &rnd)$/;"	f	namespace:vcg::math
Generic	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^    Generic = 0x0,$/;"	e	enum:Eigen::Architecture::Type
GenericNumTraits	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^template<typename T> struct GenericNumTraits$/;"	s	namespace:Eigen
GenericVertexInterpolator	vcglib/vcg/complex/algorithms/clip.h	/^    GenericVertexInterpolator(MESH_TYPE &_m) : m(_m) {}$/;"	f	class:vcg::tri::GenericVertexInterpolator
GenericVertexInterpolator	vcglib/vcg/complex/algorithms/clip.h	/^  class GenericVertexInterpolator$/;"	c	namespace:vcg::tri
Genus	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int numcomponents,Genus;$/;"	m	struct:MeshInfo	file:
Geo	vcglib/wrap/opensg/vertex_component.h	/^	OSG::GeometryPtr & Geo() { return _geop; }$/;"	f	class:vcg::vert::OSGInfo
Geo	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class EmptyOSGInfo : public T { public : OSG::GeometryPtr Geo() { assert(0); return NULL; } };$/;"	f	class:vcg::vert::EmptyOSGInfo
Geodesic	vcglib/vcg/complex/algorithms/geodesic.h	/^class Geodesic{$/;"	c	namespace:vcg::tri
GeodesicRelax	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static bool GeodesicRelax(MeshType &m, std::vector<VertexType *> &seedVec, std::vector<VertexPointer> &frontierVec,$/;"	f	class:vcg::tri::VoronoiProcessing
GeometricInterpolator	vcglib/vcg/complex/algorithms/bitquad_support.h	/^class GeometricInterpolator{$/;"	c	namespace:vcg::tri
GeometryShader	vcglib/wrap/gl/shaders.h	/^	GeometryShader(void) : Shader()$/;"	f	class:GeometryShader
GeometryShader	vcglib/wrap/gl/shaders.h	/^class GeometryShader : public Shader$/;"	c
GeometryShader	vcglib/wrap/glw/geometryshader.h	/^		GeometryShader(Context * ctx)$/;"	f	class:glw::GeometryShader
GeometryShader	vcglib/wrap/glw/geometryshader.h	/^class GeometryShader : public Shader$/;"	c	namespace:glw
GeometryShaderArguments	vcglib/wrap/glw/geometryshader.h	/^		GeometryShaderArguments(void)$/;"	f	class:glw::GeometryShaderArguments
GeometryShaderArguments	vcglib/wrap/glw/geometryshader.h	/^class GeometryShaderArguments : public ShaderArguments$/;"	c	namespace:glw
GeometryShaderBindingParams	vcglib/wrap/glw/geometryshader.h	/^		GeometryShaderBindingParams(void)$/;"	f	class:glw::GeometryShaderBindingParams
GeometryShaderBindingParams	vcglib/wrap/glw/geometryshader.h	/^class GeometryShaderBindingParams : public ShaderBindingParams$/;"	c	namespace:glw
GeometryShaderHandle	vcglib/wrap/glw/geometryshader.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeGeometryShader> ::Type GeometryShaderHandle;$/;"	t	namespace:glw
GeometryShaderPtr	vcglib/wrap/glw/geometryshader.h	/^typedef   detail::ObjectSharedPointerTraits  <GeometryShader> ::Type GeometryShaderPtr;$/;"	t	namespace:glw
GeometryShaderType	vcglib/wrap/glw/type.h	/^	GeometryShaderType,$/;"	e	enum:glw::Type
GeometryStage	vcglib/wrap/glw/program.h	/^		GeometryStage(void)$/;"	f	class:glw::GeometryStage
GeometryStage	vcglib/wrap/glw/program.h	/^class GeometryStage$/;"	c	namespace:glw
GeometryTag	vcglib/wrap/dae/colladaformat.h	/^		GeometryTag(const QString& id,const QString& name)$/;"	f	class:Collada::Tags::GeometryTag
GeometryTag	vcglib/wrap/dae/colladaformat.h	/^	class GeometryTag : public XMLTag$/;"	c	namespace:Collada::Tags
Get	vcglib/vcg/container/container_allocation_table.h	/^Get(const ValueType * pt)$/;"	f	class:vcg::CAT
GetAction	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
GetAllPerEdgeAttribute	vcglib/vcg/complex/allocate.h	/^    static void GetAllPerEdgeAttribute(const MeshType & m, std::vector<std::string> &all){$/;"	f	class:vcg::tri::Allocator
GetAllPerFaceAttribute	vcglib/vcg/complex/allocate.h	/^  static void GetAllPerFaceAttribute(MeshType & m, std::vector<std::string> &all){$/;"	f	class:vcg::tri::Allocator
GetAllPerMeshAttribute	vcglib/vcg/complex/allocate.h	/^    static void GetAllPerMeshAttribute(const MeshType & m, std::vector<std::string> &all){$/;"	f	class:vcg::tri::Allocator
GetAllPerVertexAttribute	vcglib/vcg/complex/allocate.h	/^  static void GetAllPerVertexAttribute(MeshType & m, std::vector<std::string> &all){$/;"	f	class:vcg::tri::Allocator
GetArea	vcglib/apps/metro/sampling.h	/^    double          GetArea()                   {return area_S1;}$/;"	f	class:vcg::Sampling
GetAreaAndFrontier	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void GetAreaAndFrontier(MeshType &m, PerVertexPointerHandle &sources,$/;"	f	class:vcg::tri::VoronoiProcessing
GetAttributes	vcglib/wrap/miq/core/poisson_solver.h	/^    void GetAttributes()$/;"	f	class:PoissonSolver
GetBBox	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^	void GetBBox(vcg::Box2<ScalarType> &BB2)$/;"	f	class:MySegmentType
GetBBox	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    void GetBBox(vcg::Box3<ScalarType> & b){b.Add(pos);}$/;"	f	struct:vcg::tri::FourPCS::EPoint
GetBBox	vcglib/vcg/connectors/hedge.h	/^  void GetBBox( BoxType & bb ) const {	$/;"	f	class:vcg::HEdgeArityMax
GetBBox	vcglib/vcg/simplex/edge/base.h	/^  void GetBBox( BoxType & bb ) const {	$/;"	f	class:vcg::EdgeArityMax
GetBBox	vcglib/vcg/simplex/face/base.h	/^  void GetBBox(Box3<ScalarType>& bb ) const$/;"	f	class:vcg::FaceArityMax
GetBBox	vcglib/vcg/simplex/tetrahedron/base.h	/^  void GetBBox( BoxType & bb ) const$/;"	f	class:vcg::TetraArityMax
GetBBox	vcglib/vcg/simplex/vertex/base.h	/^  void GetBBox( BoxType & bb ) const$/;"	f	class:vcg::VertexArityMax
GetBBox	vcglib/vcg/space/box3.h	/^template <class T> Box3<T> Point3<T>::GetBBox(Box3<T> &bb) const {$/;"	f	class:vcg::Point3
GetBarycenter3Functor	vcglib/wrap/utils.h	/^class GetBarycenter3Functor {$/;"	c	namespace:vcg
GetBasePlane	vcglib/vcg/complex/algorithms/symmetry.h	/^    vcg::Plane3<ScalarType> GetBasePlane(int &Index)$/;"	f	class:vcg::tri::ExtrinsicPlaneSymmetry
GetBox3Functor	vcglib/wrap/utils.h	/^class GetBox3Functor {$/;"	c	namespace:vcg
GetCacheName	vcglib/wrap/ply/plystuff.h	/^bool GetCacheName( const char * fname, const char * ext_name, char * cname )$/;"	f	namespace:vcg::ply
GetCellsIndex	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void GetCellsIndex(const ObjectPointer pObject, std::vector< CellCoordinate > & cells_occupied)$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
GetCloseSegments	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^MyScalarType GetCloseSegments(MySegmentType *S,$/;"	f
GetClosest	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	inline ObjPtr GetClosest($/;"	f	class:vcg::AABBBinaryTreeIndex
GetClosest	vcglib/vcg/space/index/base.h	/^	ObjPtr GetClosest($/;"	f	class:vcg::SpatialIndex
GetClosest	vcglib/vcg/space/index/grid_static_ptr.h	/^			ObjPtr  GetClosest(OBJPOINTDISTFUNCTOR & _getPointDistance, OBJMARKER & _marker, $/;"	f	class:vcg::GridStaticPtr
GetClosest	vcglib/vcg/space/index/octree.h	/^        ObjectPointer GetClosest$/;"	f	class:vcg::Octree
GetClosest	vcglib/vcg/space/index/spatial_hashing.h	/^			ObjPtr  GetClosest(OBJPOINTDISTFUNCTOR & _getPointDistance, OBJMARKER & _marker,$/;"	f	class:vcg::SpatialHashTable
GetClosestFaceBase	vcglib/vcg/complex/algorithms/closest.h	/^			typename MESH::FaceType * GetClosestFaceBase( MESH & mesh,GRID & gr,const typename GRID::CoordType & _p,$/;"	f	namespace:vcg::tri
GetClosestFaceEP	vcglib/vcg/complex/algorithms/closest.h	/^			typename MESH::FaceType * GetClosestFaceEP( MESH & mesh, GRID & gr, const typename GRID::CoordType & _p,$/;"	f	namespace:vcg::tri
GetClosestFaceEP	vcglib/vcg/complex/algorithms/closest.h	/^			typename MESH::FaceType * GetClosestFaceEP( MESH & mesh,GRID & gr,const typename GRID::CoordType & _p,$/;"	f	namespace:vcg::tri
GetClosestFaceNormal	vcglib/vcg/complex/algorithms/closest.h	/^		typename MESH::FaceType * GetClosestFaceNormal(MESH & mesh,GRID & gr,const typename MESH::VertexType & _p, $/;"	f	namespace:vcg::tri
GetClosestVertex	vcglib/vcg/complex/algorithms/closest.h	/^			typename MESH::VertexType * GetClosestVertex( MESH & mesh,GRID & gr,const typename GRID::CoordType & _p, $/;"	f	namespace:vcg::tri
GetClosestVertexNormal	vcglib/vcg/complex/algorithms/closest.h	/^			typename MESH::VertexType * GetClosestVertexNormal( MESH & mesh,GRID & gr,const typename MESH::VertexType & _p, $/;"	f	namespace:vcg::tri
GetClosestVertexScale	vcglib/vcg/complex/algorithms/closest.h	/^			typename MESH::VertexType * GetClosestVertexScale( MESH & mesh,GRID & gr,const typename GRID::CoordType & _p, $/;"	f	namespace:vcg::tri
GetColumn	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED ColXpr GetColumn(const unsigned int j) { return col(j); };$/;"	f
GetColumn	vcglib/vcg/math/matrix33.h	/^    Point3<S> GetColumn(const int n) const {$/;"	f	class:vcg::Matrix33
GetColumn	vcglib/vcg/math/old_deprecated_matrix.h	/^			TYPE* GetColumn(const unsigned int j)$/;"	f	class:vcg::ndim::Matrix
GetColumn3	vcglib/vcg/math/matrix44.h	/^	Point3<T> GetColumn3(const int& i)const{$/;"	f	class:vcg::Matrix44
GetColumn3	vcglib/vcg/math/old_matrix44.h	/^	const Eigen::Block<Base,3,1> GetColumn3(const int& i) const { return this->template block<3,1>(0,i); }$/;"	f	class:vcg::Matrix44
GetColumn4	vcglib/vcg/math/matrix44.h	/^	Point4<T> GetColumn4(const int& i)const{$/;"	f	class:vcg::Matrix44
GetColumn4	vcglib/vcg/math/old_matrix44.h	/^	typename Base::ColXpr GetColumn4(const int& i) const { return Base::col(i); }$/;"	f	class:vcg::Matrix44
GetCurrent	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    inline void GetCurrent (std::pair<size_t, unsigned char> &face_edge) {$/;"	f	class:vcg::tri::PolychordCollapse::PC_Chords
GetData	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline Data* GetData	 (const EntryCoordinate &at) const { return m_Table[at.X()][at.Y()][at.Z()]; }$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
GetData	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline Data* GetData	 (const int i, const int j, const int k) const { return m_Table[i][j][k]; }$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
GetData	vcglib/wrap/bmt/bmt.cpp	/^char *Bmt::GetData(unsigned int &size, unsigned int offset) {$/;"	f	class:Bmt
GetDirFromPath	vcglib/wrap/ply/plystuff.h	/^bool GetDirFromPath( const char * path, char * dir, char * name )$/;"	f	namespace:vcg::ply
GetDistMax	vcglib/apps/metro/sampling.h	/^    double          GetDistMax()                {return max_dist;}$/;"	f	class:vcg::Sampling
GetDistMean	vcglib/apps/metro/sampling.h	/^    double          GetDistMean()               {return mean_dist;}$/;"	f	class:vcg::Sampling
GetDistRMS	vcglib/apps/metro/sampling.h	/^    double          GetDistRMS()                {return RMS_dist;}$/;"	f	class:vcg::Sampling
GetDistVolume	vcglib/apps/metro/sampling.h	/^    double          GetDistVolume()             {return volume;}$/;"	f	class:vcg::Sampling
GetEntry	vcglib/vcg/container/container_allocation_table.h	/^GetEntry(typename STL_CONT::value_type*pt){$/;"	f	class:vcg::CATEntry
GetError	vcglib/wrap/ply/plylib.h	/^	inline int GetError() const { return error; }$/;"	f	class:vcg::ply::PlyFile
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_3ds.h	/^		static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::Exporter3DS
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_ctm.h	/^                static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::ExporterCTM
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_dae.h	/^		static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::ExporterDAE
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_fbx.h	/^	static int GetExportMaskCapability()$/;"	f	class:ExporterFBX
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_gts.h	/^        static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::ExporterGTS
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_idtf.h	/^	static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::ExporterIDTF
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_obj.h	/^  static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::ExporterOBJ
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_off.h	/^        static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::ExporterOFF
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_ply.h	/^  static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::ExporterPLY
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_stl.h	/^static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::ExporterSTL
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_u3d.h	/^	static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::ExporterU3D
GetExportMaskCapability	vcglib/wrap/io_trimesh/export_vrml.h	/^	static int GetExportMaskCapability()$/;"	f	class:vcg::tri::io::ExporterWRL
GetExtension	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^inline char* GetExtension(char* filename)$/;"	f
GetExtrinsicsToWorldMatrix	vcglib/vcg/math/shot.h	/^    Matrix44<S> GetExtrinsicsToWorldMatrix() const$/;"	f	class:vcg::Shot
GetFaceCornerVec	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void GetFaceCornerVec(MeshType &m, PerVertexPointerHandle &sources,$/;"	f	class:vcg::tri::VoronoiProcessing
GetFarPlane	vcglib/wrap/gl/shot.h	/^static ScalarType GetFarPlane(vcg::Shot<ScalarType> & shot, vcg::Box3<ScalarType> bbox)$/;"	f	struct:GlShot
GetFirstVertexIndex	vcglib/wrap/miq/core/poisson_solver.h	/^    int GetFirstVertexIndex(VertexType *v)$/;"	f	class:PoissonSolver
GetFlag	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 inline bool  GetFlag(const typename UniformGrid::CellCoordinate &at)	const			{ return m_Mask[at.X()][at.Y()][at.Z()]; }$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
GetFlag	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 inline bool& GetFlag(const int i, const int j, const int k)const				{ return m_Mask[i][j][k]; }$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
GetFovFromFocal	vcglib/vcg/math/shot.h	/^float Shot<S,RotationType>::GetFovFromFocal()$/;"	f	class:vcg::Shot
GetFrameBuffer	vcglib/wrap/gl/fbo.h	/^	FrameBuffer * GetFrameBuffer(void)$/;"	f	class:RenderTarget
GetFrameBuffer	vcglib/wrap/gl/fbo.h	/^	const FrameBuffer * GetFrameBuffer(void) const$/;"	f	class:RenderTarget
GetFreeEntryList	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			std::list< EntryCoordinate >* GetFreeEntryList() { return &m_FreeEntries; }$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
GetFrustum	vcglib/vcg/math/camera.h	/^void Camera<S>:: GetFrustum( S & sx, S & dx, S & bt, S & tp, S & nr)$/;"	f	class:vcg::Camera
GetFrustum	vcglib/wrap/gl/camera.h	/^static void GetFrustum(vcg::Camera<S> & intrinsics, S & sx,S & dx,S & bt,S & tp,S & f)$/;"	f	struct:GlCamera
GetGeometry	vcglib/wrap/io_trimesh/import_fbx.h	/^	static KFbxXMatrix GetGeometry(KFbxNode* pNode)$/;"	f	class:ImporterFBX
GetHeader	vcglib/wrap/io_trimesh/import_vmi.h	/^        static bool GetHeader(	std::vector<std::string>& fnameV,$/;"	f	class:vcg::tri::io::ImporterVMI
GetHeader	vcglib/wrap/io_trimesh/import_vmi.h	/^        static bool GetHeader(const char * filename,std::vector<std::string>& nameV, std::vector<std::string>& nameF, unsigned int & vertSize, unsigned int &faceSize,vcg::Box3f & bbox,int & mask){$/;"	f	class:vcg::tri::io::ImporterVMI
GetHeader	vcglib/wrap/ply/plylib.h	/^  inline const char * GetHeader() const { return header.c_str(); }$/;"	f	class:vcg::ply::PlyFile
GetHintParamf	vcglib/wrap/gl/trimesh.h	/^    float GetHintParamf(const HintParamf hip) const$/;"	f	class:vcg::GlTrimesh
GetHintParami	vcglib/wrap/gl/trimesh.h	/^    int GetHintParami(const HintParami hip) const$/;"	f	class:vcg::GlTrimesh
GetHist	vcglib/apps/metro/sampling.h	/^    Histogram<double> &GetHist()                  {return hist;}$/;"	f	class:vcg::Sampling
GetInBox	vcglib/vcg/space/index/base.h	/^	unsigned int GetInBox(OBJMARKER & _marker, const BoxType _bbox,OBJPTRCONTAINER & _objectPtrs) {$/;"	f	class:vcg::SpatialIndex
GetInBox	vcglib/vcg/space/index/grid_static_ptr.h	/^			unsigned int GetInBox(OBJMARKER & _marker, $/;"	f	class:vcg::GridStaticPtr
GetInBox	vcglib/vcg/space/index/index2D/base_2d.h	/^	unsigned int GetInBox(OBJMARKER & _marker, const BoxType _bbox,OBJPTRCONTAINER & _objectPtrs) {$/;"	f	class:vcg::SpatialIndex2D
GetInBox	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        unsigned int GetInBox(OBJMARKER & _marker,$/;"	f	class:vcg::SpatialHashTable2D
GetInBox	vcglib/vcg/space/index/octree.h	/^            unsigned int GetInBox$/;"	f	class:vcg::Octree
GetInBox	vcglib/vcg/space/index/spatial_hashing.h	/^			unsigned int GetInBox(OBJMARKER & _marker,$/;"	f	class:vcg::SpatialHashTable
GetInBoxFace	vcglib/vcg/complex/algorithms/closest.h	/^			unsigned int GetInBoxFace(MESH & mesh,$/;"	f	namespace:vcg::tri
GetInBoxVertex	vcglib/vcg/complex/algorithms/closest.h	/^			unsigned int GetInBoxVertex(MESH & mesh,$/;"	f	namespace:vcg::tri
GetInBoxes	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        unsigned int GetInBoxes(OBJMARKER & _marker,$/;"	f	class:vcg::SpatialHashTable2D
GetInSphere	vcglib/vcg/space/index/base.h	/^	unsigned int GetInSphere($/;"	f	class:vcg::SpatialIndex
GetInSphere	vcglib/vcg/space/index/grid_static_ptr.h	/^			unsigned int GetInSphere(OBJPOINTDISTFUNCTOR & _getPointDistance, $/;"	f	class:vcg::GridStaticPtr
GetInSphere	vcglib/vcg/space/index/octree.h	/^        unsigned int GetInSphere$/;"	f	class:vcg::Octree
GetInSphere	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		unsigned int GetInSphere$/;"	f	class:vcg::PerfectSpatialHashing
GetInSphere	vcglib/vcg/space/index/spatial_hashing.h	/^		unsigned int GetInSphere(OBJPOINTDISTFUNCTOR & _getPointDistance,$/;"	f	class:vcg::SpatialHashTable
GetInSphereFaceBase	vcglib/vcg/complex/algorithms/closest.h	/^			unsigned int GetInSphereFaceBase(MESH & mesh,$/;"	f	namespace:vcg::tri
GetInSphereVertex	vcglib/vcg/complex/algorithms/closest.h	/^			unsigned int GetInSphereVertex(MESH & mesh,$/;"	f	namespace:vcg::tri
GetIncenter	vcglib/wrap/qt/Outline2ToQImage.cpp	/^vcg::Point2f Outline2Dumper::GetIncenter(const vector< vector<Point2f> > &polyVec,$/;"	f	class:Outline2Dumper
GetIndexDuplexVertex	vcglib/wrap/io_trimesh/export_3ds.h	/^		inline static int GetIndexDuplexVertex(std::map<Key,int> &m,Key key)$/;"	f	class:vcg::tri::io::Exporter3DS
GetIndexVertex	vcglib/wrap/io_trimesh/export_3ds.h	/^		inline static int GetIndexVertex(SaveMeshType &m, VertexType *p)$/;"	f	class:vcg::tri::io::Exporter3DS
GetIndexVertexNormal	vcglib/wrap/io_trimesh/export_obj.h	/^  inline static int GetIndexVertexNormal(SaveMeshType &\/*m*\/, std::map<CoordType,int> &mapNormToInt, const CoordType &norm )$/;"	f	class:vcg::tri::io::ExporterOBJ
GetIndexVertexTexture	vcglib/wrap/io_trimesh/export_obj.h	/^  inline static int GetIndexVertexTexture(typename std::map<TexCoord2<ScalarType>,int> &mapTexToInt, const vcg::TexCoord2<ScalarType> &wt)$/;"	f	class:vcg::tri::io::ExporterOBJ
GetInfo	vcglib/vcg/complex/algorithms/hole.h	/^    static void GetInfo(MESH &m, bool Selected ,std::vector<Info >& VHI)$/;"	f	class:vcg::tri::Hole
GetIntercept	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  void GetIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointerType &v, const float thr)$/;"	f	class:vcg::SimpleVolume
GetIntercept	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    void GetIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointerType &v, const float thr)$/;"	f	class:vcg::SimpleVolume
GetInterpolatedPlane	vcglib/vcg/complex/algorithms/symmetry.h	/^    vcg::Plane3<ScalarType> GetInterpolatedPlane(int &Index)$/;"	f	class:vcg::tri::ExtrinsicPlaneSymmetry
GetIntersectingSegments	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^MyScalarType GetIntersectingSegments(MySegmentType *S,$/;"	f
GetKClosest	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	inline unsigned int GetKClosest($/;"	f	class:vcg::AABBBinaryTreeIndex
GetKClosest	vcglib/vcg/space/index/base.h	/^	unsigned int GetKClosest($/;"	f	class:vcg::SpatialIndex
GetKClosest	vcglib/vcg/space/index/grid_static_ptr.h	/^			unsigned int GetKClosest(OBJPOINTDISTFUNCTOR & _getPointDistance,OBJMARKER & _marker, $/;"	f	class:vcg::GridStaticPtr
GetKClosest	vcglib/vcg/space/index/octree.h	/^        unsigned int GetKClosest$/;"	f	class:vcg::Octree
GetKClosest	vcglib/vcg/space/index/spatial_hashing.h	/^			unsigned int GetKClosest(OBJPOINTDISTFUNCTOR & _getPointDistance,OBJMARKER & _marker,$/;"	f	class:vcg::SpatialHashTable
GetKClosestFaceBase	vcglib/vcg/complex/algorithms/closest.h	/^      unsigned int GetKClosestFaceBase(MESH & mesh,GRID & gr, const unsigned int _k,$/;"	f	namespace:vcg::tri
GetKClosestFaceEP	vcglib/vcg/complex/algorithms/closest.h	/^      unsigned int GetKClosestFaceEP(MESH & mesh,GRID & gr, const unsigned int _k,$/;"	f	namespace:vcg::tri
GetKClosestVertex	vcglib/vcg/complex/algorithms/closest.h	/^			unsigned int GetKClosestVertex(MESH & mesh,GRID & gr, const unsigned int _k, $/;"	f	namespace:vcg::tri
GetMark	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	inline int GetMark()const$/;"	f	class:vcg::tri::PlanarEdgeFlip
GetMarketLine	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline bool GetMarketLine (std::stringstream& line, int& M, int& N, int& i, int& j, Scalar& value)$/;"	f	namespace:Eigen::internal
GetMarketLine	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline bool GetMarketLine (std::stringstream& line, int& M, int& N, int& i, int& j, std::complex<Scalar>& value)$/;"	f	namespace:Eigen::internal
GetMatrix	vcglib/vcg/math/camera.h	/^template <class S> vcg::Matrix44<S> Camera<S>::GetMatrix(S nearVal, S farVal) {$/;"	f	class:vcg::Camera
GetNAreaSamples	vcglib/apps/metro/sampling.h	/^    unsigned long   GetNAreaSamples()           {return n_total_area_samples;}$/;"	f	class:vcg::Sampling
GetNEdgeSamples	vcglib/apps/metro/sampling.h	/^    unsigned long   GetNEdgeSamples()           {return n_total_edge_samples;}$/;"	f	class:vcg::Sampling
GetNSamples	vcglib/apps/metro/sampling.h	/^    unsigned long   GetNSamples()               {return n_total_samples;}$/;"	f	class:vcg::Sampling
GetNSamplesPerAreaUnit	vcglib/apps/metro/sampling.h	/^    double					GetNSamplesPerAreaUnit()    {return n_samples_per_area_unit;}$/;"	f	class:vcg::Sampling
GetNSamplesTarget	vcglib/apps/metro/sampling.h	/^    unsigned long   GetNSamplesTarget()         {return n_samples_target;}$/;"	f	class:vcg::Sampling
GetNVertexSamples	vcglib/apps/metro/sampling.h	/^    unsigned long   GetNVertexSamples()         {return n_total_vertex_samples;}$/;"	f	class:vcg::Sampling
GetNearFarPlanes	vcglib/wrap/gl/shot.h	/^static void GetNearFarPlanes(vcg::Shot<ScalarType> & shot, vcg::Box3<ScalarType> bbox, ScalarType &nr, ScalarType &fr)$/;"	f	struct:GlShot
GetNeighboringEntryIterator	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			NeighboringEntryIterator GetNeighboringEntryIterator(const CellCoordinate &at) { return NeighboringEntryIterator(at, m_CellPerSide); }$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
GetNeighborintEntryIterator	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			NeighboringEntryIterator GetNeighborintEntryIterator(const EntryCoordinate &at) { return NeighboringEntryIterator(at, m_EntryPerSide); }$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
GetNumberOfFreeEntries	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline int GetNumberOfFreeEntries() $/;"	f	class:vcg::PerfectSpatialHashing::HashTable
GetNumberOfNotEmptyCells	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			int GetNumberOfNotEmptyCells()$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
GetNumberOfNotEmptyEntries	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline int GetNumberOfNotEmptyEntries()$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
GetNumberOfOccupiedCells	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline int GetNumberOfOccupiedCells() const { return m_NumberOfOccupiedEntries;		}$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
GetObjects	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			std::vector< ObjectPointer >* GetObjects(const CellCoordinate &at)							{ return &m_Grid[at.X()][at.Y()][at.Z()];}$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
GetObjects	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			std::vector< ObjectPointer >* GetObjects(const int i, const int j, const int k) { return &m_Grid[i][j][k]; }$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
GetOffset	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline OffsetPointer  GetOffset (const EntryCoordinate &at) const { return m_Table[at.X()][at.Y()][at.Z()]; } $/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
GetOffset	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline OffsetPointer  GetOffset (const int i, const int j, const int k) const { return m_Table[i][j][k]; } $/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
GetOffset	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline OffsetPointer& GetOffset (const EntryCoordinate &at)				{ return m_Table[at.X()][at.Y()][at.Z()]; } $/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
GetOffset	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline OffsetPointer& GetOffset (const int i, const int j, const int k)				{ return m_Table[i][j][k]; } $/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
GetOpt	vcglib/wrap/system/qgetopt.cpp	/^GetOpt::GetOpt(const QStringList &a): args(a) {$/;"	f	class:GetOpt
GetOpt	vcglib/wrap/system/qgetopt.cpp	/^GetOpt::GetOpt(int argc, char *argv[] ) {$/;"	f	class:GetOpt
GetOpt	vcglib/wrap/system/qgetopt.h	/^  GetOpt(): unlimitedArgs(false) {}$/;"	f	class:GetOpt
GetOpt	vcglib/wrap/system/qgetopt.h	/^class GetOpt {$/;"	c
GetPath	vcglib/vcg/space/index/octree_template.h	/^	CenterType GetPath(NodePointer n) const$/;"	f	class:vcg::OctreeTemplate
GetPerEdgeAttribute	vcglib/vcg/complex/allocate.h	/^      GetPerEdgeAttribute( MeshType & m, std::string name = std::string("")){$/;"	f	class:vcg::tri::Allocator
GetPerFaceAttribute	vcglib/vcg/complex/allocate.h	/^      GetPerFaceAttribute( MeshType & m, std::string name = std::string("")){$/;"	f	class:vcg::tri::Allocator
GetPerMeshAttribute	vcglib/vcg/complex/allocate.h	/^      GetPerMeshAttribute( MeshType & m, std::string name = std::string("")){$/;"	f	class:vcg::tri::Allocator
GetPerVertexAttribute	vcglib/vcg/complex/allocate.h	/^      GetPerVertexAttribute( MeshType & m, std::string name = std::string("")){$/;"	f	class:vcg::tri::Allocator
GetPlanes	vcglib/vcg/complex/algorithms/symmetry.h	/^    void GetPlanes(std::vector<vcg::Plane3<ScalarType> > &Planes,int Num)$/;"	f	class:vcg::tri::ExtrinsicPlaneSymmetry
GetPointerFunctor	vcglib/wrap/utils.h	/^class GetPointerFunctor {$/;"	c	namespace:vcg
GetPoints	vcglib/wrap/gui/rubberband.cpp	/^void Rubberband::GetPoints(Point3f &s,Point3f &e)$/;"	f	class:Rubberband
GetPoints	vcglib/wrap/gui/trackmode.cpp	/^void PathMode::GetPoints(float state, Point3f & point, Point3f & prev_point, Point3f & next_point)$/;"	f	class:PathMode
GetPos	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  Pos GetPos(){$/;"	f	class:vcg::tri::BitQuad::Iterator
GetPos	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	inline PosType GetPos() const$/;"	f	class:vcg::tri::PlanarEdgeFlip
GetPoseMatrix	vcglib/wrap/io_trimesh/import_fbx.h	/^	static KFbxXMatrix GetPoseMatrix(KFbxPose* pPose, int pNodeIndex)$/;"	f	class:ImporterFBX
GetPosition	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				CellCoordinate GetPosition() const$/;"	f	struct:vcg::PerfectSpatialHashing::UniformGrid::EntryIterator
GetPosition	vcglib/wrap/gui/coordinateframe.cpp	/^Point3f MovableCoordinateFrame::GetPosition()$/;"	f	class:MovableCoordinateFrame
GetPreImageSortedPerCardinality	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void GetPreImageSortedPerCardinality(std::list< PreImage > &pre_image)$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
GetRandPlane	vcglib/apps/sample/trimesh_edge/trimesh_edge.cpp	/^void GetRandPlane(Box3f &bb, Plane3f &plane)$/;"	f
GetRandomOffset	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void GetRandomOffset( Offset &offset )$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
GetResolution	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 inline int GetResolution() const { return m_Resolution; }$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
GetResolution	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline int GetResolution() const { return m_CellPerSide; }$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
GetRotation	vcglib/wrap/gui/coordinateframe.cpp	/^Quaternionf MovableCoordinateFrame::GetRotation()$/;"	f	class:MovableCoordinateFrame
GetRotationComplex	vcglib/wrap/miq/core/poisson_solver.h	/^    Cmplx GetRotationComplex(int interval)$/;"	f	class:PoissonSolver
GetRoute	vcglib/vcg/space/index/octree_template.h	/^	bool GetRoute(const CoordinateType &p, NodePointer *&route)$/;"	f	class:vcg::OctreeTemplate
GetRow	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED RowXpr GetRow(const unsigned int i) { return row(i); };$/;"	f
GetRow	vcglib/vcg/math/matrix33.h	/^    Point3<S> GetRow(const int n) const {$/;"	f	class:vcg::Matrix33
GetRow	vcglib/vcg/math/old_deprecated_matrix.h	/^			TYPE* GetRow(const unsigned int i)$/;"	f	class:vcg::ndim::Matrix
GetRow3	vcglib/vcg/math/matrix44.h	/^	Point3<T> GetRow3(const int& i)const{$/;"	f	class:vcg::Matrix44
GetRow3	vcglib/vcg/math/old_matrix44.h	/^	Eigen::Block<Base,1,3> GetRow3(const int& i) const { return this->template block<1,3>(i,0); }$/;"	f	class:vcg::Matrix44
GetRow4	vcglib/vcg/math/matrix44.h	/^	Point4<T> GetRow4(const int& i)const{$/;"	f	class:vcg::Matrix44
GetRow4	vcglib/vcg/math/old_matrix44.h	/^	typename Base::RowXpr GetRow4(const int& i) const { return Base::row(i); }$/;"	f	class:vcg::Matrix44
GetSeamInfo	vcglib/wrap/miq/core/vertex_indexing.h	/^    void GetSeamInfo(const FaceType *f0,$/;"	f	class:VertexIndexing
GetSize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline int	GetSize()			const {return m_EntryPerSide;}$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
GetSize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline int GetSize() { return m_EntryPerSide; }$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
GetSliceIndex	vcglib/vcg/complex/algorithms/create/resampler.h	/^		int GetSliceIndex(int x,int z)$/;"	f	class:vcg::tri::Resampler::Walker
GetSpeed	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  ScalarType GetSpeed(){$/;"	f	class:vcg::tri::AreaPreservingTextureOptimizer
GetSubBBox	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^    void GetSubBBox(const ScalarType &step_size,$/;"	f	class:MySegmentType
GetTexCoord	vcglib/wrap/io_trimesh/import_dae.h	/^		static void GetTexCoord(const QDomDocument& doc, QStringList &texturefile)$/;"	f	class:vcg::tri::io::ImporterDAE
GetTexCoords	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  inline int GetTexCoords(vcg::TexCoord2f &tcoord0_1, vcg::TexCoord2f &tcoord1_1,vcg::TexCoord2f &tcoord0_2,vcg::TexCoord2f &tcoord1_2)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
GetTexture	vcglib/wrap/gl/fbo.h	/^	Texture2D * GetTexture(void)$/;"	f	class:TextureRenderTarget
GetTheta	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  int GetTheta(){$/;"	f	class:vcg::tri::AreaPreservingTextureOptimizer
GetTransform	vcglib/wrap/gui/coordinateframe.cpp	/^void MovableCoordinateFrame::GetTransform(Matrix44f & transform)$/;"	f	class:MovableCoordinateFrame
GetUV	vcglib/vcg/space/deprecated_point3.h	/^void GetUV( Point3<P3ScalarType> &n,Point3<P3ScalarType> &u, Point3<P3ScalarType> &v, Point3<P3ScalarType> up=(Point3<P3ScalarType>(0,1,0)) )$/;"	f	namespace:vcg
GetUV	vcglib/vcg/space/point3.h	/^void GetUV( Point3<Scalar> &n,Point3<Scalar> &u, Point3<Scalar> &v, Point3<Scalar> up=(Point3<Scalar>(0,1,0)) )$/;"	f	namespace:vcg
GetUnefectiveOffsetTableSize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		int GetUnefectiveOffsetTableSize(const int hash_table_size, const int offset_table_size)$/;"	f	class:vcg::PerfectSpatialHashing
GetValency	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static int GetValency(const VertexType *v){$/;"	f	class:vcg::tri::BitQuad
GetVectorElt	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void  GetVectorElt (const std::string& line, RealScalar& val)$/;"	f	namespace:Eigen::internal
GetVectorElt	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void GetVectorElt (const std::string& line, std::complex<RealScalar>& val)$/;"	f	namespace:Eigen::internal
GetView	vcglib/wrap/gui/frustum.h	/^template <class T> void Frustum<T>::GetView() {$/;"	f	class:vcg::Frustum
GetView	vcglib/wrap/gui/trackball.cpp	/^void Trackball::GetView() {$/;"	f	class:Trackball
GetView	vcglib/wrap/gui/view.h	/^template <class T> void View<T>::GetView() {$/;"	f	class:vcg::View
GetViewDir	vcglib/vcg/math/shot.h	/^const vcg::Point3<S> Shot<S,RotationType>::GetViewDir() const$/;"	f	class:vcg::Shot
GetViewPlane	vcglib/wrap/gui/trackutils.h	/^Plane3f GetViewPlane (const View < float >&camera, const Point3f & center)$/;"	f	namespace:vcg::trackutils
GetViewPoint	vcglib/vcg/math/shot.h	/^const vcg::Point3<S> Shot<S,RotationType>::GetViewPoint() const$/;"	f	class:vcg::Shot
GetViewSize	vcglib/wrap/gl/camera.h	/^static void GetViewSize(vcg::Camera<S> & camera, S &width, S &height) {$/;"	f	struct:GlCamera
GetWorldToExtrinsicsMatrix	vcglib/vcg/math/shot.h	/^    Matrix44<S> GetWorldToExtrinsicsMatrix() const$/;"	f	class:vcg::Shot
GetXIntercept	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  void GetXIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointerType &v, const float thr)$/;"	f	class:vcg::SimpleVolume
GetXIntercept	vcglib/apps/unsupported/extractors/extractor/Volume.h	/^	void GetXIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:Volume
GetXIntercept	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	void GetXIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v) $/;"	f	class:Walker
GetXIntercept	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    void GetXIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:vcg::tri::TrivialWalker
GetXIntercept	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  void GetXIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointerType &v, const float thr)$/;"	f	class:vcg::SimpleVolume
GetXIntercept	vcglib/vcg/complex/algorithms/create/resampler.h	/^		void GetXIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:vcg::tri::Resampler::Walker
GetYIntercept	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  void GetYIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointerType &v, const float thr)$/;"	f	class:vcg::SimpleVolume
GetYIntercept	vcglib/apps/unsupported/extractors/extractor/Volume.h	/^	void GetYIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:Volume
GetYIntercept	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	void GetYIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v) $/;"	f	class:Walker
GetYIntercept	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    void GetYIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:vcg::tri::TrivialWalker
GetYIntercept	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  void GetYIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointerType &v, const float thr)$/;"	f	class:vcg::SimpleVolume
GetYIntercept	vcglib/vcg/complex/algorithms/create/resampler.h	/^		void GetYIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:vcg::tri::Resampler::Walker
GetZIntercept	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  void GetZIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointerType &v, const float thr)$/;"	f	class:vcg::SimpleVolume
GetZIntercept	vcglib/apps/unsupported/extractors/extractor/Volume.h	/^	void GetZIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:Volume
GetZIntercept	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	void GetZIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v) $/;"	f	class:Walker
GetZIntercept	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    void GetZIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:vcg::tri::TrivialWalker
GetZIntercept	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  void GetZIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointerType &v, const float thr)$/;"	f	class:vcg::SimpleVolume
GetZIntercept	vcglib/vcg/complex/algorithms/create/resampler.h	/^		void GetZIntercept(const vcg::Point3i &p1, const vcg::Point3i &p2, VertexPointer &v)$/;"	f	class:vcg::tri::Resampler::Walker
Getnextvalidmatrix	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    void Getnextvalidmatrix( )$/;"	f	class:Eigen::MatrixMarketIterator
GlCamera	vcglib/wrap/gl/camera.h	/^struct GlCamera{$/;"	s
GlCameraType	vcglib/wrap/gl/shot.h	/^	typedef GlCamera<typename ShotType::CameraType> GlCameraType;$/;"	t	struct:GlShot
GlClip	vcglib/wrap/gl/tetramesh.h	/^			void GlClip()$/;"	f	class:vcg::tetra::GlTetramesh::ClipPlane
GlDraw	vcglib/wrap/gl/tetramesh.h	/^			void GlDraw()$/;"	f	class:vcg::tetra::GlTetramesh::ClipPlane
GlPos	vcglib/wrap/gl/pos.h	/^		struct GlPos{$/;"	s	namespace:vcg
GlShot	vcglib/wrap/gl/shot.h	/^struct GlShot {$/;"	s
GlTetramesh	vcglib/wrap/gl/tetramesh.h	/^	GlTetramesh( )  {}$/;"	f	class:vcg::tetra::GlTetramesh
GlTetramesh	vcglib/wrap/gl/tetramesh.h	/^	GlTetramesh(CONT_TETRA * _t):tetra(_t){}$/;"	f	class:vcg::tetra::GlTetramesh
GlTetramesh	vcglib/wrap/gl/tetramesh.h	/^class GlTetramesh:public GLW{$/;"	c	namespace:vcg::tetra
GlTrimesh	vcglib/wrap/gl/trimesh.h	/^    GlTrimesh()$/;"	f	class:vcg::GlTrimesh
GlTrimesh	vcglib/wrap/gl/trimesh.h	/^class GlTrimesh : public GLW$/;"	c	namespace:vcg
GlVfIterator	vcglib/wrap/gl/pos.h	/^		struct GlVfIterator{$/;"	s	namespace:vcg
GlobalMark	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            static int& GlobalMark()$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
GlobalMark	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	static int& GlobalMark(){ static int im=0; return im;}$/;"	f	class:vcg::tri::TriEdgeCollapse
GlobalMark	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	static int& GlobalMark()$/;"	f	class:vcg::tri::PlanarEdgeFlip
GlobalToLocal	vcglib/vcg/math/eigen_matrix_addons.h	/^inline ParamType GlobalToLocal(PointType \/*p*\/) const { return ParamType(); }$/;"	f
GlobalToLocal	vcglib/vcg/space/box.h	/^	PointType GlobalToLocal(PointType const & p) const{$/;"	f	class:vcg::Box
GlobalToLocal	vcglib/vcg/space/box2.h	/^	PointType GlobalToLocal(PointType const & p) const{$/;"	f	class:vcg::Box2
GlobalToLocal	vcglib/vcg/space/box3.h	/^    Point3<BoxScalarType> GlobalToLocal(Point3<BoxScalarType> const & p) const{$/;"	f	class:vcg::Box3
GlobalToLocal	vcglib/vcg/space/deprecated_point.h	/^  inline ParamType GlobalToLocal(PointType \/*p*\/) const{$/;"	f	class:vcg::ndim::Point
GloballyMirrorX	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			static void GloballyMirrorX(MeshType &m)$/;"	f	class:vcg::tri::UV_Utils
GloballyUnFolded	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static bool GloballyUnFolded(const MeshType &m)$/;"	f	class:vcg::tri::Distortion
Glue	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  bool Glue(std::list<FrontEdge>::iterator a, std::list<FrontEdge>::iterator b) {$/;"	f	class:vcg::tri::AdvancingFront
Glue	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  bool Glue(std::list<FrontEdge>::iterator e) {$/;"	f	class:vcg::tri::AdvancingFront
GoalReached	vcglib/vcg/complex/algorithms/local_optimization.h	/^	bool GoalReached(){$/;"	f	class:vcg::LocalOptimization
GoodObjIndex	vcglib/wrap/io_trimesh/import_obj.h	/^                static bool GoodObjIndex(int &index, const int maxVal)$/;"	f	class:vcg::tri::io::ImporterOBJ
GoogleDenseHashMapTraits	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^template<typename Scalar> struct GoogleDenseHashMapTraits$/;"	s	namespace:Eigen
GoogleSparseHashMapTraits	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^template<typename Scalar> struct GoogleSparseHashMapTraits$/;"	s	namespace:Eigen
GradientToCross	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^            static void GradientToCross(const FaceType &f,$/;"	f	class:vcg::tri::CrossField
Gray	vcglib/vcg/space/color4.h	/^	  Gray    = 0xff808080,$/;"	e	enum:vcg::Color4::ColorConstant
GrayShade	vcglib/vcg/space/color4.h	/^inline static Color4 GrayShade(float f)$/;"	f	class:vcg::Color4
GreatestCommonDivisor	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^	int GreatestCommonDivisor(const int a, const int b)$/;"	f	namespace:vcg
Green	vcglib/vcg/space/color4.h	/^	  Green   = 0xff00ff00,$/;"	e	enum:vcg::Color4::ColorConstant
Grid	vcglib/vcg/complex/algorithms/clustering.h	/^  BasicGrid<ScalarType> Grid;$/;"	m	class:vcg::tri::Clustering
Grid	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Grid(MeshType & in, int w, int h, float wl, float hl, float *data=0)$/;"	f	namespace:vcg::tri
Grid	vcglib/vcg/space/index/grid_static_obj.h	/^	 inline ObjType & Grid( const Point3<FLT> & p )                 {				return grid[GridIndF(p)];		}$/;"	f	class:vcg::GridStaticObj
Grid	vcglib/vcg/space/index/grid_static_obj.h	/^	 inline ObjType & Grid( const int x, const int y, const int z ) {return grid[GridIndI(Point3i(x,y,z))]; }$/;"	f	class:vcg::GridStaticObj
Grid	vcglib/vcg/space/index/grid_static_ptr.h	/^		Cell* Grid(const  int i) {$/;"	f	class:vcg::GridStaticPtr
Grid	vcglib/vcg/space/index/grid_static_ptr.h	/^		inline Cell* Grid( const Point3i &pi)$/;"	f	class:vcg::GridStaticPtr
Grid	vcglib/vcg/space/index/grid_static_ptr.h	/^		inline Cell* Grid( const int x, const int y, const int z )$/;"	f	class:vcg::GridStaticPtr
Grid	vcglib/vcg/space/index/grid_static_ptr.h	/^		inline void Grid( Point3i p, const int axis,$/;"	f	class:vcg::GridStaticPtr
Grid	vcglib/vcg/space/index/grid_static_ptr.h	/^		void Grid( const Cell* g, Cell & first, Cell & last )$/;"	f	class:vcg::GridStaticPtr
Grid	vcglib/vcg/space/index/grid_static_ptr.h	/^		void Grid( const Point3<ScalarType> & p, Cell & first, Cell & last )$/;"	f	class:vcg::GridStaticPtr
Grid	vcglib/vcg/space/index/grid_static_ptr.h	/^		void Grid( const int x, const int y, const int z, Cell & first, Cell & last )$/;"	f	class:vcg::GridStaticPtr
Grid	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void Grid( const Point2i & _c, CellIterator & first, CellIterator & end )$/;"	f	class:vcg::SpatialHashTable2D
Grid	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void Grid( int x,int y, CellIterator & first, CellIterator & last )$/;"	f	class:vcg::SpatialHashTable2D
Grid	vcglib/vcg/space/index/spatial_hashing.h	/^		void Grid( const Point3i & _c, CellIterator & first, CellIterator & end )$/;"	f	class:vcg::SpatialHashTable
Grid	vcglib/vcg/space/index/spatial_hashing.h	/^		void Grid( int x,int y,int z, CellIterator & first, CellIterator & last )$/;"	f	class:vcg::SpatialHashTable
Grid	vcglib/vcg/space/rect_packer.h	/^  #define Grid(/;"	d
Grid	vcglib/vcg/space/rect_packer.h	/^#define Grid(/;"	d
Grid	vcglib/vcg/space/rect_packer.h	/^#undef Grid$/;"	d
GridCell	vcglib/vcg/complex/algorithms/clustering.h	/^  STDEXT::hash_map<HashedPoint3i,CellType> GridCell;$/;"	m	class:vcg::tri::Clustering
GridClosest	vcglib/vcg/space/index/grid_closest.h	/^		typename SPATIAL_INDEX::ObjPtr  GridClosest(SPATIAL_INDEX &Si, $/;"	f	namespace:vcg
GridDoRay	vcglib/vcg/space/index/grid_closest.h	/^		typename SPATIALINDEXING::ObjPtr GridDoRay(SPATIALINDEXING &_Si,$/;"	f	namespace:vcg
GridGetInBox	vcglib/vcg/space/index/grid_closest.h	/^			unsigned int GridGetInBox(SPATIALINDEXING &_Si,$/;"	f	namespace:vcg
GridGetInBox2D	vcglib/vcg/space/index/index2D/grid_closest_2D.h	/^			unsigned int GridGetInBox2D(SPATIALINDEXING &_Si,$/;"	f	namespace:vcg
GridGetInBoxes2D	vcglib/vcg/space/index/index2D/grid_closest_2D.h	/^            unsigned int GridGetInBoxes2D(SPATIALINDEXING &_Si,$/;"	f	namespace:vcg
GridGetInSphere	vcglib/vcg/space/index/grid_closest.h	/^		unsigned int GridGetInSphere(SPATIALINDEXING &_Si,$/;"	f	namespace:vcg
GridGetKClosest	vcglib/vcg/space/index/grid_closest.h	/^		unsigned int GridGetKClosest(SPATIALINDEXING &_Si,$/;"	f	namespace:vcg
GridIndF	vcglib/vcg/space/index/grid_static_obj.h	/^   inline int GridIndF( const Point3<FLT> & p ) const { return GridIndI(this->GridP(p)); 	}$/;"	f	class:vcg::GridStaticObj
GridIndI	vcglib/vcg/space/index/grid_static_obj.h	/^	 inline int GridIndI( const Point3i & pi ) const$/;"	f	class:vcg::GridStaticObj
GridP	vcglib/vcg/space/index/grid_util.h	/^	inline Point3i GridP( const Point3<ScalarType> & p ) const $/;"	f	class:vcg::BasicGrid
GridP	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		inline Point2i GridP( const Point2<ScalarType> & p ) const $/;"	f	class:vcg::BasicGrid2D
GridPtrType	vcglib/vcg/space/index/grid_static_ptr.h	/^		typedef GridStaticPtr<OBJTYPE,FLT> GridPtrType;$/;"	t	class:vcg::GridStaticPtr
GridReal	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void GridReal( const Point2<ScalarType> & p, CellIterator & first, CellIterator & last )$/;"	f	class:vcg::SpatialHashTable2D
GridReal	vcglib/vcg/space/index/spatial_hashing.h	/^		void GridReal( const Point3<ScalarType> & p, CellIterator & first, CellIterator & last )$/;"	f	class:vcg::SpatialHashTable
GridSph	vcglib/vcg/complex/algorithms/symmetry.h	/^    typename vcg::GridStaticPtr<FaceType> GridSph;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
GridStaticObj	vcglib/vcg/space/index/grid_static_obj.h	/^	 inline  GridStaticObj() { grid = 0; }$/;"	f	class:vcg::GridStaticObj
GridStaticObj	vcglib/vcg/space/index/grid_static_obj.h	/^class GridStaticObj : public BasicGrid<FLT>$/;"	c	namespace:vcg
GridStaticPtr	vcglib/vcg/space/index/grid_static_ptr.h	/^	class GridStaticPtr: public BasicGrid<FLT>, SpatialIndex<OBJTYPE,FLT>$/;"	c	namespace:vcg
GridType	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  typedef vcg::GridStaticPtr<typename PMesh::VertexType, ScalarType > GridType;$/;"	t	class:vcg::tri::FourPCS
GridType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef GRID GridType;$/;"	t	class:vcg::tri::ClosestFaceEPIterator
GridType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef GRID GridType;$/;"	t	class:vcg::tri::ClosestVertexIterator
GridType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef GRID GridType;$/;"	t	class:vcg::tri::TriRayIterator
GridType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef BasicGrid<typename MeshType::ScalarType> GridType;$/;"	t	class:vcg::tri::AverageColorCell
GridType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef BasicGrid<typename MeshType::ScalarType> GridType;$/;"	t	class:vcg::tri::NearestToCenter
GridType	vcglib/vcg/complex/algorithms/create/resampler.h	/^		typedef typename vcg::GridStaticPtr<typename Old_Mesh::FaceType> GridType;$/;"	t	class:vcg::tri::Resampler::Walker
GridType	vcglib/vcg/space/index/grid_util.h	/^	typedef BasicGrid<SCALARTYPE> GridType;$/;"	t	class:vcg::BasicGrid
GridType	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		typedef BasicGrid2D<SCALARTYPE> GridType;$/;"	t	class:vcg::BasicGrid2D
GtolTooSmall	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        GtolTooSmall = 8,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
GuessInitialBoundingBox	vcglib/vcg/space/index/octree.h	/^        inline bool GuessInitialBoundingBox(const CoordType &query_point, const ScalarType max_distance, ScalarType &sphere_radius, BoundingBoxType &query_bb)$/;"	f	class:vcg::Octree
H	vcglib/vcg/math/histogram.h	/^  std::vector <ScalarType> H; 	\/\/! Counters for bins.$/;"	m	class:vcg::Histogram
H	vcglib/vcg/simplex/vertex/component_occ.h	/^	ScalarType  &H(){  return CAT< vector_occ<VertType>,CurvatureTypeOcc>::Instance()->Get((VertType*)this)[0];}$/;"	f	class:vcg::vertex::CurvatureOcc
HALFEDGEQUADCLEAN_H	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^#define HALFEDGEQUADCLEAN_H$/;"	d
HALF_MAX_SIZE_T	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define HALF_MAX_SIZE_T /;"	d	file:
HANDLE	vcglib/wrap/gui/trackball.h	/^                HANDLE        = 0x0080, \/\/\/< Application-defined state activated.$/;"	e	enum:vcg::Trackball::Button
HASH_P0	vcglib/vcg/complex/algorithms/clustering.h	/^#define HASH_P0 /;"	d
HASH_P1	vcglib/vcg/complex/algorithms/clustering.h	/^#define HASH_P1 /;"	d
HASH_P2	vcglib/vcg/complex/algorithms/clustering.h	/^#define HASH_P2 /;"	d
HAVE_MMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define HAVE_MMAP /;"	d	file:
HAVE_MORECORE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define HAVE_MORECORE /;"	d	file:
HAVE_MREMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define HAVE_MREMAP /;"	d	file:
HAVE_STRING_H	vcglib/wrap/system/getopt.cpp	/^#define HAVE_STRING_H$/;"	d	file:
HCSmoothInfo	vcglib/vcg/complex/algorithms/smooth.h	/^class HCSmoothInfo$/;"	c	class:vcg::tri::Smooth
HCoeffsType	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::ColPivHouseholderQR
HCoeffsType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::FullPivHouseholderQR
HCoeffsType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
HCoeffsType	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::HouseholderQR
HDim	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^    HDim = _Dim+1   \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon336
HDim	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    HDim = Transform::HDim,$/;"	e	enum:Eigen::internal::transform_traits::__anon372
HDim	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon376
HDim	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
HDim	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    HDim = _Dim+1,  \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon373
HE	vcglib/vcg/connectors/halfedge_pos.h	/^            HEdgePointer HE()$/;"	f	class:vcg::hedge::Pos
HEAdj	vcglib/vcg/connectors/hedge_component.h	/^        HEAdj(){_ep =0;}$/;"	f	class:vcg::hedge::HEAdj
HEAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class HEAdj: public T {$/;"	c	namespace:vcg::hedge
HEdge	vcglib/vcg/connectors/hedge.h	/^							class HEdge: public HEdgeArityMax<UserTypes, A, B, C, D, E, F, G, H, I, J, K>  {$/;"	c	namespace:vcg
HEdgeArityMax	vcglib/vcg/connectors/hedge.h	/^class HEdgeArityMax: public K<Arity10<HEdgeBase<UserTypes>, A, B, C, D, E, F, G, H, I, J> > {$/;"	c	namespace:vcg
HEdgeBase	vcglib/vcg/connectors/hedge.h	/^class HEdgeBase: public$/;"	c	namespace:vcg
HEdgeContainer	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::HEdgeContainer HEdgeContainer;$/;"	t	class:vcg::tri::Allocator
HEdgeContainer	vcglib/vcg/complex/base.h	/^                                typedef CONT HEdgeContainer;$/;"	t	struct:vcg::tri::MeshTypeHolder
HEdgeContainer	vcglib/vcg/complex/base.h	/^                typedef CONTH														HEdgeContainer;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
HEdgeContainer	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::HEdgeContainer				HEdgeContainer;$/;"	t	class:vcg::tri::TriMesh
HEdgeData	vcglib/vcg/connectors/hedge_component.h	/^class HEdgeData : public	HFAdj<			\/\/ pointer to the face$/;"	c	namespace:vcg::hedge
HEdgeIterator	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::HEdgeIterator HEdgeIterator;$/;"	t	class:vcg::tri::HalfedgeQuadClean
HEdgeIterator	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::HEdgeIterator HEdgeIterator;$/;"	t	class:vcg::tri::UpdateHalfEdges
HEdgeIterator	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::HEdgeIterator HEdgeIterator;$/;"	t	struct:vcg::tri::UpdateIndexed
HEdgeIterator	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                typedef typename MeshType::HEdgeIterator HEdgeIterator;$/;"	t	class:vcg::tri::HalfEdgeTopology
HEdgeIterator	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::HEdgeIterator HEdgeIterator;$/;"	t	class:vcg::tri::Allocator
HEdgeIterator	vcglib/vcg/complex/base.h	/^                                typedef typename HEdgeContainer::iterator				HEdgeIterator;$/;"	t	struct:vcg::tri::MeshTypeHolder
HEdgeIterator	vcglib/vcg/complex/base.h	/^                typedef typename CONTH::iterator				HEdgeIterator;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
HEdgeIterator	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::HEdgeIterator					HEdgeIterator;$/;"	t	class:vcg::tri::TriMesh
HEdgeIteratorLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::HEdgeIterator		HEdgeIteratorLeft;$/;"	t	class:vcg::tri::Append
HEdgeIteratorRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::HEdgeIterator  HEdgeIteratorRight;$/;"	t	class:vcg::tri::Append
HEdgeLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::HEdgeType				HEdgeLeft;$/;"	t	class:vcg::tri::Append
HEdgePointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::EdgeFlipPriority
HEdgePointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::HalfedgeQuadClean
HEdgePointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::Homeometry
HEdgePointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::VertReg
HEdgePointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::FeasibilityCheck
HEdgePointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::FitmapsCollapse
HEdgePointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::OperationWeight
HEdgePointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::QuadDiagonalCollapse
HEdgePointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::QuadDiagonalCollapseBase
HEdgePointer	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::UpdateHalfEdges
HEdgePointer	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	struct:vcg::tri::UpdateIndexed
HEdgePointer	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::tri::HalfEdgeTopology
HEdgePointer	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::HEdgePointer  HEdgePointer;$/;"	t	class:vcg::tri::Allocator
HEdgePointer	vcglib/vcg/complex/base.h	/^                                typedef typename HEdgeContainer::value_type *		HEdgePointer;$/;"	t	struct:vcg::tri::MeshTypeHolder
HEdgePointer	vcglib/vcg/complex/base.h	/^                typedef typename TYPESPOOL::HEdgePointer					HEdgePointer;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
HEdgePointer	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::HEdgePointer					HEdgePointer;$/;"	t	class:vcg::tri::TriMesh
HEdgePointer	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsHEdgeType: public T{typedef A HEdgeType;		typedef HEdgeType * HEdgePointer		;};$/;"	t	struct:vcg::Use::AsHEdgeType
HEdgePointer	vcglib/vcg/complex/used_types.h	/^        typedef HEdgeType * HEdgePointer	;$/;"	t	struct:vcg::DummyTypes
HEdgePointer	vcglib/vcg/connectors/halfedge_pos.h	/^            typedef typename MeshType::HEdgePointer HEdgePointer;$/;"	t	class:vcg::hedge::Pos
HEdgePointer	vcglib/vcg/simplex/face/component_polygon.h	/^  typedef typename T::HEdgePointer HEdgePointer;$/;"	t	class:vcg::face::PFHAdj
HEdgeRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::HEdgeType			HEdgeRight;$/;"	t	class:vcg::tri::Append
HEdgeType	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::HEdgeType HEdgeType;$/;"	t	class:vcg::tri::UpdateHalfEdges
HEdgeType	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::HEdgeType HEdgeType;$/;"	t	struct:vcg::tri::UpdateIndexed
HEdgeType	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::HEdgeType     HEdgeType;$/;"	t	class:vcg::tri::Allocator
HEdgeType	vcglib/vcg/complex/base.h	/^                                typedef typename HEdgeContainer::value_type			HEdgeType;$/;"	t	struct:vcg::tri::MeshTypeHolder
HEdgeType	vcglib/vcg/complex/base.h	/^                typedef typename CONTH::value_type			HEdgeType;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
HEdgeType	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::HEdgeType							HEdgeType;$/;"	t	class:vcg::tri::TriMesh
HEdgeType	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsHEdgeType: public T{typedef A HEdgeType;		typedef HEdgeType * HEdgePointer		;};$/;"	t	struct:vcg::Use::AsHEdgeType
HEdgeType	vcglib/vcg/complex/used_types.h	/^        typedef _HEdge HEdgeType; 		\/\/ connector types$/;"	t	struct:vcg::DummyTypes
HEdgeType	vcglib/vcg/simplex/face/component_polygon.h	/^  typedef typename T::HEdgeType HEdgeType;$/;"	t	class:vcg::face::PFHAdj
HEdgeTypeHolder	vcglib/vcg/connectors/hedge.h	/^				class HEdgeTypeHolder: public UserTypes{$/;"	c	namespace:vcg
HEp	vcglib/vcg/connectors/hedge_component.h	/^        typename T::EdgePointer &HEp() { static typename T::EdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHEAdj
HEp	vcglib/vcg/connectors/hedge_component.h	/^        typename T::EdgePointer &HEp() {return _ep ; }$/;"	f	class:vcg::hedge::HEAdj
HFAdj	vcglib/vcg/connectors/hedge_component.h	/^	HFAdj(){_fp=0;}$/;"	f	class:vcg::hedge::HFAdj
HFAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class HFAdj: public T {$/;"	c	namespace:vcg::hedge
HFp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::FacePointer &HFp() { static typename T::FacePointer fp=0;  assert(0); return fp; }$/;"	f	class:vcg::hedge::EmptyHFAdj
HFp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::FacePointer &HFp() {return _fp; }$/;"	f	class:vcg::hedge::HFAdj
HHAdj	vcglib/vcg/connectors/hedge_component.h	/^	HHAdj(){_ep=0;}$/;"	f	class:vcg::hedge::HHAdj
HHAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class HHAdj: public T {$/;"	c	namespace:vcg::hedge
HHi	vcglib/vcg/connectors/hedge_component.h	/^	int &HHi(const int & i) {return _zp[i]; }$/;"	f	class:vcg::hedge::HHAdj
HHi	vcglib/vcg/connectors/hedge_component.h	/^        int &HHi(){static int z=0; return z;}$/;"	f	class:vcg::hedge::EmptyHHAdj
HHp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::EdgePointer &HHp(const int & i) {return _ep[i]; }$/;"	f	class:vcg::hedge::HHAdj
HHp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer &HHp(const int &  ) { static typename T::EdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHHAdj
HIDDEN	vcglib/apps/sample/trimesh_QT/glarea.h	/^  enum DrawMode{SMOOTH=0,POINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:GLArea::DrawMode
HIDDEN	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^enum DrawMode{SMOOTH=0,PERPOINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:DrawMode	file:
HIST	vcglib/apps/metro/sampling.h	/^						HIST														= 0x0001,$/;"	e	enum:vcg::SamplingFlags::__anon1
HN	vcglib/vcg/complex/base.h	/^    inline int HN() const { return hn; }$/;"	f	class:vcg::tri::TriMesh
HNCacheDisplayList	vcglib/wrap/gl/trimesh.h	/^        HNCacheDisplayList	  = 0x0008,		\/\/ Each mode has its dl;$/;"	e	enum:vcg::GLW::Hint
HNHasFFTopology	vcglib/wrap/gl/trimesh.h	/^        HNHasFFTopology       = 0x0080,		\/\/ E' l'utente che si preoccupa di tenere aggiornata la topologia ff$/;"	e	enum:vcg::GLW::Hint
HNHasFaceNormal	vcglib/wrap/gl/trimesh.h	/^        HNHasFaceNormal       = 0x0400,		\/\/ E' l'utente che si preoccupa di tenere aggiornata le normali per vertice$/;"	e	enum:vcg::GLW::Hint
HNHasVFTopology	vcglib/wrap/gl/trimesh.h	/^        HNHasVFTopology       = 0x0100,		\/\/ E' l'utente che si preoccupa di tenere aggiornata la topologia vf$/;"	e	enum:vcg::GLW::Hint
HNHasVertNormal	vcglib/wrap/gl/trimesh.h	/^        HNHasVertNormal       = 0x0200,		\/\/ E' l'utente che si preoccupa di tenere aggiornata le normali per faccia$/;"	e	enum:vcg::GLW::Hint
HNIsPolygonal	vcglib/wrap/gl/trimesh.h	/^        HNIsPolygonal         = 0x4000    \/\/ In wireframe modes, hide faux edges$/;"	e	enum:vcg::GLW::Hint
HNIsTwoManifold	vcglib/wrap/gl/trimesh.h	/^        HNIsTwoManifold		  = 0x0020,			\/\/ There is no need to make DetachComplex before .$/;"	e	enum:vcg::GLW::Hint
HNLazyDisplayList	vcglib/wrap/gl/trimesh.h	/^        HNLazyDisplayList	  = 0x0010,			\/\/ Display list are generated only when requested$/;"	e	enum:vcg::GLW::Hint
HNPCreaseAngle	vcglib/wrap/gl/trimesh.h	/^        HNPCreaseAngle =0,	\/\/ crease angle in radians$/;"	e	enum:vcg::GLW::HintParamf
HNPDisplayListSize	vcglib/wrap/gl/trimesh.h	/^    HNPDisplayListSize =0,$/;"	e	enum:vcg::GLW::HintParami
HNPPointDistanceAttenuation	vcglib/wrap/gl/trimesh.h	/^    HNPPointDistanceAttenuation =1,$/;"	e	enum:vcg::GLW::HintParami
HNPPointSize	vcglib/wrap/gl/trimesh.h	/^        HNPPointSize = 2		\/\/ the point size used in point rendering$/;"	e	enum:vcg::GLW::HintParamf
HNPPointSmooth	vcglib/wrap/gl/trimesh.h	/^    HNPPointSmooth = 2$/;"	e	enum:vcg::GLW::HintParami
HNPZTwist	vcglib/wrap/gl/trimesh.h	/^        HNPZTwist = 1,				\/\/ Z offset used in Flatwire and hiddenline modality$/;"	e	enum:vcg::GLW::HintParamf
HNParamf	vcglib/wrap/gl/trimesh.h	/^    float HNParamf[8];$/;"	m	class:vcg::GlTrimesh
HNParami	vcglib/wrap/gl/trimesh.h	/^    int   HNParami[8];$/;"	m	class:vcg::GlTrimesh
HNUseDisplayList	vcglib/wrap/gl/trimesh.h	/^        HNUseDisplayList	  = 0x0004,$/;"	e	enum:vcg::GLW::Hint
HNUseLazyEdgeStrip	vcglib/wrap/gl/trimesh.h	/^        HNUseLazyEdgeStrip	  = 0x1000,		\/\/ Edge Strip are generated only when requested$/;"	e	enum:vcg::GLW::Hint
HNUsePerWedgeNormal	vcglib/wrap/gl/trimesh.h	/^        HNUsePerWedgeNormal	  = 0x0040,		\/\/$/;"	e	enum:vcg::GLW::Hint
HNUseTriStrip	vcglib/wrap/gl/trimesh.h	/^        HNUseTriStrip		  = 0x0001,				\/\/ ha bisogno che ci sia la fftopology gia calcolata!$/;"	e	enum:vcg::GLW::Hint
HNUseVArray	vcglib/wrap/gl/trimesh.h	/^        HNUseVArray           = 0x0800,$/;"	e	enum:vcg::GLW::Hint
HNUseVBO	vcglib/wrap/gl/trimesh.h	/^        HNUseVBO              = 0x2000,		\/\/ Use Vertex Buffer Object$/;"	e	enum:vcg::GLW::Hint
HNextAdj	vcglib/vcg/connectors/hedge_component.h	/^	HNextAdj(){_nep=0;}$/;"	f	class:vcg::hedge::HNextAdj
HNextAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class HNextAdj: public T {$/;"	c	namespace:vcg::hedge
HNormalizedReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^                const ConstStartMinusOne > HNormalizedReturnType;$/;"	t	class:Eigen::MatrixBase
HNormalizedReturnType	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^            HNormalizedReturnType;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Block	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Block;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Factors	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Factors;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Size	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_Size = Direction==Vertical ? internal::traits<ExpressionType>::RowsAtCompileTime$/;"	e	enum:Eigen::VectorwiseOp::__anon325
HNormalized_SizeMinusOne	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_SizeMinusOne = HNormalized_Size==Dynamic ? Dynamic : HNormalized_Size-1$/;"	e	enum:Eigen::VectorwiseOp::__anon325
HNp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer &HNp( ) { static typename T::HEdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHNextAdj
HNp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer &HNp() {return _nep; }$/;"	f	class:vcg::hedge::HNextAdj
HOp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer &HOp() { static typename T::HEdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHOppAdj
HOp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer &HOp() {return _oep; }$/;"	f	class:vcg::hedge::HOppAdj
HOppAdj	vcglib/vcg/connectors/hedge_component.h	/^	HOppAdj(){_oep=0;}$/;"	f	class:vcg::hedge::HOppAdj
HOppAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class HOppAdj: public T {$/;"	c	namespace:vcg::hedge
HPp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer &HPp() { static typename T::HEdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHPrevAdj
HPp	vcglib/vcg/connectors/hedge_component.h	/^        typename T::HEdgePointer &HPp() {return _pep; }$/;"	f	class:vcg::hedge::HPrevAdj
HPrevAdj	vcglib/vcg/connectors/hedge_component.h	/^	HPrevAdj(){_pep=0;}$/;"	f	class:vcg::hedge::HPrevAdj
HPrevAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class HPrevAdj: public T {$/;"	c	namespace:vcg::hedge
HSLtoRGB	vcglib/vcg/space/colorspace.h	/^	static Color4<T> HSLtoRGB(const Color4<T> & color)$/;"	f	class:vcg::ColorSpace
HSLtoRGB	vcglib/vcg/space/colorspace.h	/^	static void HSLtoRGB(double H, double S, double L, double &R, double &G, double &B)$/;"	f	class:vcg::ColorSpace
HSVtoRGB	vcglib/vcg/space/colorspace.h	/^	static Color4<T> HSVtoRGB(const Color4<T> & color)$/;"	f	class:vcg::ColorSpace
HSVtoRGB	vcglib/vcg/space/colorspace.h	/^	static void HSVtoRGB(double H, double S, double V, double &R, double &G, double &B)$/;"	f	class:vcg::ColorSpace
HShrinkFactor	vcglib/wrap/gl/tetramesh.h	/^	enum Hint {HShrinkFactor};$/;"	e	enum:vcg::tetra::GLW::Hint
HTML_LINES	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^static const int HTML_LINES = 31;$/;"	v	file:
HTML_TABLE	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^static const char * HTML_TABLE[HTML_LINES]=$/;"	v	file:
HVAdj	vcglib/vcg/connectors/hedge_component.h	/^	HVAdj(){_vp =0;}$/;"	f	class:vcg::hedge::HVAdj
HVAdj	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class HVAdj: public T {$/;"	c	namespace:vcg::hedge
HVi	vcglib/vcg/connectors/hedge_component.h	/^        int &HVi(){static int z=0; return z;}$/;"	f	class:vcg::hedge::EmptyHVAdj
HVp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::VertexPointer			&	HVp() {return _vp ; }$/;"	f	class:vcg::hedge::HVAdj
HVp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::VertexPointer &HVp() { static typename T::VertexPointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHVAdj
HWIte	vcglib/wrap/io_trimesh/import_vmi.h	/^        typedef typename std::set<typename MeshType::PointerToAttribute >::iterator HWIte;$/;"	t	struct:vcg::tri::io::Der
HWIte	vcglib/wrap/io_trimesh/import_vmi.h	/^        typedef typename std::set<typename MeshType::PointerToAttribute >::iterator HWIte;$/;"	t	struct:vcg::tri::io::DerK
HalfEdgeTopology	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^        template <class MeshType> class HalfEdgeTopology$/;"	c	namespace:vcg::tri
HalfLength	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon228
HalfLength	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon230
HalfedgeQuadClean	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^        template<class MeshType> class HalfedgeQuadClean$/;"	c	namespace:vcg::tri
HandleS_Index	vcglib/wrap/miq/core/poisson_solver.h	/^    typename MeshType::template PerFaceAttributeHandle<vcg::Point3i> HandleS_Index;$/;"	m	class:PoissonSolver
HandleS_Index	vcglib/wrap/miq/core/vertex_indexing.h	/^    typename  MeshType::template PerFaceAttributeHandle<vcg::Point3i> HandleS_Index;$/;"	m	class:VertexIndexing
HandleV_Integer	vcglib/wrap/miq/core/vertex_indexing.h	/^    typename  MeshType::template PerVertexAttributeHandle<std::vector<int> > HandleV_Integer;$/;"	m	class:VertexIndexing
Handle_Integer	vcglib/wrap/miq/core/vertex_indexing.h	/^    typename MeshType::template PerFaceAttributeHandle<vcg::Point3i> Handle_Integer;$/;"	m	class:VertexIndexing
Handle_MMatch	vcglib/wrap/miq/core/seams_initializer.h	/^    typename  MeshType::template PerFaceAttributeHandle<vcg::Point3i> Handle_MMatch;$/;"	m	class:SeamsInitializer
Handle_MMatch	vcglib/wrap/miq/core/vertex_indexing.h	/^    typename  MeshType::template PerFaceAttributeHandle<vcg::Point3i> Handle_MMatch;$/;"	m	class:VertexIndexing
Handle_Seams	vcglib/wrap/miq/core/seams_initializer.h	/^    typename  MeshType::template PerFaceAttributeHandle<vcg::Point3<bool> > Handle_Seams;$/;"	m	class:SeamsInitializer
Handle_Seams	vcglib/wrap/miq/core/vertex_indexing.h	/^    typename  MeshType::template PerFaceAttributeHandle<vcg::Point3<bool> > Handle_Seams;$/;"	m	class:VertexIndexing
Handle_SeamsIndex	vcglib/wrap/miq/core/seams_initializer.h	/^    typename  MeshType::template PerFaceAttributeHandle<vcg::Point3i > Handle_SeamsIndex;$/;"	m	class:SeamsInitializer
Handle_Singular	vcglib/wrap/miq/core/poisson_solver.h	/^    typename MeshType::template PerVertexAttributeHandle<bool> Handle_Singular;$/;"	m	class:PoissonSolver
Handle_Singular	vcglib/wrap/miq/core/seams_initializer.h	/^    typename  MeshType::template PerVertexAttributeHandle<bool> Handle_Singular;$/;"	m	class:SeamsInitializer
Handle_Singular	vcglib/wrap/miq/core/vertex_indexing.h	/^    typename  MeshType::template PerVertexAttributeHandle<bool> Handle_Singular;$/;"	m	class:VertexIndexing
Handle_SingularDegree	vcglib/wrap/miq/core/seams_initializer.h	/^    typename  MeshType::template PerVertexAttributeHandle<int> Handle_SingularDegree;$/;"	m	class:SeamsInitializer
Handle_SingularDegree	vcglib/wrap/miq/core/vertex_indexing.h	/^    typename  MeshType::template PerVertexAttributeHandle<int> Handle_SingularDegree;$/;"	m	class:VertexIndexing
Handle_Stiffness	vcglib/wrap/miq/MIQ.h	/^  typename MeshType::template PerFaceAttributeHandle<float> Handle_Stiffness;$/;"	m	class:MIQ_parametrization
Handle_Stiffness	vcglib/wrap/miq/core/poisson_solver.h	/^    typename MeshType::template PerFaceAttributeHandle<float> Handle_Stiffness;$/;"	m	class:PoissonSolver
Handle_SystemInfo	vcglib/wrap/miq/core/poisson_solver.h	/^    typename  MeshType::template PerMeshAttributeHandle<MeshSystemInfo> Handle_SystemInfo;$/;"	m	class:PoissonSolver
Handle_SystemInfo	vcglib/wrap/miq/core/vertex_indexing.h	/^    typename  MeshType::template PerMeshAttributeHandle<MeshSystemInfo> Handle_SystemInfo;$/;"	m	class:VertexIndexing
Hard_constraints	vcglib/wrap/miq/core/poisson_solver.h	/^	std::vector<VertexType*> Hard_constraints;$/;"	m	class:PoissonSolver
Harmonic	vcglib/vcg/complex/algorithms/harmonic.h	/^class Harmonic$/;"	c	namespace:vcg::tri
HasACos	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasACos   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasASin	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasASin   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasATan	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasATan   = 0$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasAbs	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon170
HasAbs	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasAbs	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
HasAbs	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
HasAbs	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
HasAbs	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
HasAbs2	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon170
HasAbs2	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasAbs2	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
HasAbs2	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
HasAbs2	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
HasAbs2	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
HasAdd	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon170
HasAdd	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasAdd	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
HasAdd	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
HasAdd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
HasAdd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
HasColor	vcglib/vcg/simplex/edge/component.h	/^	static bool HasColor()   { return false; }$/;"	f	class:vcg::edge::EmptyCore
HasColor	vcglib/vcg/simplex/edge/component.h	/^  static bool HasColor()   { return true; }$/;"	f	class:vcg::edge::Color
HasColor	vcglib/vcg/simplex/face/component.h	/^  static bool HasColor()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasColor	vcglib/vcg/simplex/face/component.h	/^  static bool HasColor()   { return true; }$/;"	f	class:vcg::face::Color
HasColor	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasColor()   { return true; }$/;"	f	class:vcg::face::ColorOcf
HasColor	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasColor()   { return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasColor	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasColor()   { return true; }$/;"	f	class:vcg::vertex::Color
HasColor	vcglib/vcg/simplex/vertex/component_occ.h	/^  static bool HasColor()   { return true; }$/;"	f	class:vcg::vertex::ColorOcc
HasColor	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasColor()   { return true; }$/;"	f	class:vcg::vertex::ColorOcf
HasColor	vcglib/wrap/opensg/vertex_component.h	/^	static bool HasColor() { return false; }$/;"	f	class:vcg::vert::EmptyOSGColor
HasColor	vcglib/wrap/opensg/vertex_component.h	/^	static bool HasColor() { return true; }$/;"	f	class:vcg::vert::OSGColor
HasColorOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasColorOcf()        { return false; }$/;"	f	class:vcg::face::InfoOcf
HasColorOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasColorOcf()   { return true; }$/;"	f	class:vcg::face::ColorOcf
HasColorOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^	static bool HasColorOcf()   { return false; }$/;"	f	class:vcg::vertex::InfoOcf
HasColorOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasColorOcf()   { assert(!T::HasColorOcf()); return true; }$/;"	f	class:vcg::vertex::ColorOcf
HasConj	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon170
HasConj	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasConsistentPerFaceFauxFlag	vcglib/vcg/complex/algorithms/clean.h	/^  static bool HasConsistentPerFaceFauxFlag(const MeshType &m)$/;"	f	class:vcg::tri::Clean
HasConsistentPerWedgeTexCoord	vcglib/vcg/complex/algorithms/clean.h	/^      static bool HasConsistentPerWedgeTexCoord(MeshType &m)$/;"	f	class:vcg::tri::Clean
HasConsistentValencyFlag	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool HasConsistentValencyFlag(MeshType &m) {$/;"	f	class:vcg::tri::BitQuad
HasCoord	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasCoord()   { return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasCoord	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasCoord()   { return true; }$/;"	f	class:vcg::vertex::Coord
HasCoord	vcglib/wrap/opensg/vertex_component.h	/^	static bool HasCoord() { return false; }$/;"	f	class:vcg::vert::EmptyOSGCoord
HasCoord	vcglib/wrap/opensg/vertex_component.h	/^	static bool HasCoord() { return true; }$/;"	f	class:vcg::vert::OSGCoord
HasCos	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasCos    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasCos	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon10
HasCos	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon16
HasCos	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasCos  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon27
HasCurvature	vcglib/vcg/simplex/vertex/component.h	/^    static bool HasCurvature()   { return true; }$/;"	f	class:vcg::vertex::Curvature
HasCurvature	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasCurvature()			{ return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasCurvature	vcglib/vcg/simplex/vertex/component_occ.h	/^	static bool HasCurvature()   { return true; }$/;"	f	class:vcg::vertex::CurvatureOcc
HasCurvature	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasCurvature() { return true; }$/;"	f	class:vcg::vertex::CurvatureOcf
HasCurvatureDir	vcglib/vcg/simplex/face/component.h	/^  static bool HasCurvatureDir()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasCurvatureDir	vcglib/vcg/simplex/face/component.h	/^  static bool HasCurvatureDir()   { return true; }$/;"	f	class:vcg::face::CurvatureDir
HasCurvatureDir	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasCurvatureDir()   { return true; }$/;"	f	class:vcg::face::CurvatureDirOcf
HasCurvatureDir	vcglib/vcg/simplex/vertex/component.h	/^	static bool HasCurvatureDir()   { return true; }$/;"	f	class:vcg::vertex::CurvatureDir
HasCurvatureDir	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasCurvatureDir()			{ return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasCurvatureDir	vcglib/vcg/simplex/vertex/component_occ.h	/^  static bool HasCurvatureDir()   { return true; }$/;"	f	class:vcg::vertex::CurvatureDirOcc
HasCurvatureDir	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasCurvatureDir()  { return true; }$/;"	f	class:vcg::vertex::CurvatureDirOcf
HasCurvatureDirOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^  static bool HasCurvatureDirOcc()   { return true; }$/;"	f	class:vcg::vertex::CurvatureDirOcc
HasCurvatureDirOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasCurvatureDirOcf()   { return true; }$/;"	f	class:vcg::face::CurvatureDirOcf
HasCurvatureDirOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasCurvatureDirOcf() { return false; }$/;"	f	class:vcg::face::InfoOcf
HasCurvatureDirOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^	static bool HasCurvatureDirOcf()   { return false; }$/;"	f	class:vcg::vertex::InfoOcf
HasCurvatureDirOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasCurvatureDirOcf()  { return true; }$/;"	f	class:vcg::vertex::CurvatureDirOcf
HasCurvatureOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^	static bool HasCurvatureOcc()   { return true; }$/;"	f	class:vcg::vertex::CurvatureOcc
HasCurvatureOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^	static bool HasCurvatureOcf()   { return false; }$/;"	f	class:vcg::vertex::InfoOcf
HasCurvatureOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasCurvatureOcf()   { return true; }$/;"	f	class:vcg::vertex::CurvatureOcf
HasDiv	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasDiv    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasDiv	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
HasDiv	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
HasDiv	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon16
HasDiv	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
HasDiv	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
HasDiv	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv    = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon28
HasDiv	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon27
HasEEAdjacency	vcglib/vcg/complex/base.h	/^bool HasEEAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::EdgeType::HasEEAdjacency();}$/;"	f	namespace:vcg::tri
HasEEAdjacency	vcglib/vcg/simplex/edge/component.h	/^    static bool HasEEAdjacency()   {   return false; }$/;"	f	class:vcg::edge::EmptyCore
HasEEAdjacency	vcglib/vcg/simplex/edge/component.h	/^  static bool HasEEAdjacency()   {   return true; }$/;"	f	class:vcg::edge::EEAdj
HasEEAdjacencyOcc	vcglib/vcg/simplex/edge/component.h	/^  static bool HasEEAdjacencyOcc()   {   return true; }$/;"	f	class:vcg::edge::EEAdj
HasEFAdjacency	vcglib/vcg/complex/base.h	/^bool HasEFAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::EdgeType::HasEFAdjacency();}$/;"	f	namespace:vcg::tri
HasEFAdjacency	vcglib/vcg/simplex/edge/component.h	/^    static bool HasEFAdjacency()   {   return false; }$/;"	f	class:vcg::edge::EmptyCore
HasEFAdjacency	vcglib/vcg/simplex/edge/component.h	/^  static bool HasEFAdjacency()   {   return true; }$/;"	f	class:vcg::edge::EFAdj
HasEFAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasEFAdjacency()      {   return true; }$/;"	f	class:vcg::face::EFAdj
HasEFAdjacencyOcc	vcglib/vcg/simplex/edge/component.h	/^  static bool HasEFAdjacencyOcc()   {   return true; }$/;"	f	class:vcg::edge::EFAdj
HasEHAdjacency	vcglib/vcg/complex/base.h	/^bool HasEHAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::EdgeType::HasEHAdjacency();}$/;"	f	namespace:vcg::tri
HasEHAdjacency	vcglib/vcg/simplex/edge/component.h	/^    static bool HasEHAdjacency()   {   return false; }$/;"	f	class:vcg::edge::EmptyCore
HasEHAdjacency	vcglib/vcg/simplex/edge/component.h	/^  static bool HasEHAdjacency()   {   return true; }$/;"	f	class:vcg::edge::EHAdj
HasEHAdjacencyOcc	vcglib/vcg/simplex/edge/component.h	/^  static bool HasEHAdjacencyOcc()   {   return true; }$/;"	f	class:vcg::edge::EHAdj
HasEVAdjacency	vcglib/vcg/complex/base.h	/^bool HasEVAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::EdgeType::HasEVAdjacency();}$/;"	f	namespace:vcg::tri
HasEVAdjacency	vcglib/vcg/simplex/edge/component.h	/^	static bool HasEVAdjacency()   { return false; }$/;"	f	class:vcg::edge::EmptyCore
HasEVAdjacency	vcglib/vcg/simplex/edge/component.h	/^  static bool HasEVAdjacency()   {   return true; }$/;"	f	class:vcg::edge::VertexRef
HasEdgePlane	vcglib/vcg/simplex/face/component_ep.h	/^  static bool HasEdgePlane()   {   return true; }$/;"	f	class:vcg::face::EdgePlane
HasEdgePlane	vcglib/vcg/simplex/face/component_ep.h	/^static bool HasEdgePlane()   {   return false; }$/;"	f	class:vcg::face::EmptyEdgePlane
HasExp	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasExp    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasExp	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon10
HasExp	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon16
HasExp	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon27
HasFEAdjacency	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasFEAdjacency   (const TriMeshType &m) { return tri::FaceVectorHasFEAdjacency   (m.face); }$/;"	f	namespace:vcg::tri
HasFEAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasFEAdjacency()      {   return true; }$/;"	f	class:vcg::face::FEAdj
HasFEAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasFEAdjacency()   {   return false; }$/;"	f	class:vcg::face::EmptyCore
HasFEAdjacency	vcglib/vcg/simplex/face/component_polygon.h	/^  static bool HasFEAdjacency()      {   return true; }$/;"	f	class:vcg::face::PFEAdj
HasFFAdjacency	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasFFAdjacency   (const TriMeshType &m) { return tri::FaceVectorHasFFAdjacency   (m.face); }$/;"	f	namespace:vcg::tri
HasFFAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasFFAdjacency()      {   return true; }$/;"	f	class:vcg::face::FFAdj
HasFFAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasFFAdjacency()   {   return false; }$/;"	f	class:vcg::face::EmptyCore
HasFFAdjacency	vcglib/vcg/simplex/face/component_occ.h	/^  static bool HasFFAdjacency()   {   return true; }$/;"	f	class:vcg::face::FFAdjOccBase
HasFFAdjacency	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasFFAdjacency()   {   return true; }$/;"	f	class:vcg::face::FFAdjOcf
HasFFAdjacency	vcglib/vcg/simplex/face/component_polygon.h	/^  static bool HasFFAdjacency()      {   return true; }$/;"	f	class:vcg::face::PFFAdj
HasFFAdjacencyOcc	vcglib/vcg/simplex/face/component_occ.h	/^  static bool HasFFAdjacencyOcc()   { return true; }$/;"	f	class:vcg::face::FFAdjOccBase
HasFFAdjacencyOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasFFAdjacencyOcf()      { return false; }$/;"	f	class:vcg::face::InfoOcf
HasFFAdjacencyOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasFFAdjacencyOcf()   { return true; }$/;"	f	class:vcg::face::FFAdjOcf
HasFHAdjacency	vcglib/vcg/complex/base.h	/^bool HasFHAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::FaceType::HasFHAdjacency();}$/;"	f	namespace:vcg::tri
HasFHAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasFHAdjacency()      {   return true; }$/;"	f	class:vcg::face::FHAdj
HasFHAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasFHAdjacency()   {   return false; }$/;"	f	class:vcg::face::EmptyCore
HasFHAdjacency	vcglib/vcg/simplex/face/component_polygon.h	/^  static bool HasFHAdjacency()      {   return true; }$/;"	f	class:vcg::face::PFHAdj
HasFVAdjacency	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasFVAdjacency   (const TriMeshType &m) { return tri::FaceVectorHasFVAdjacency   (m.face); }$/;"	f	namespace:vcg::tri
HasFVAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasFVAdjacency()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasFVAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasFVAdjacency()   { return true; }$/;"	f	class:vcg::face::VertexRef
HasFVAdjacency	vcglib/vcg/simplex/face/component_polygon.h	/^  static bool HasFVAdjacency()   { return true; }$/;"	f	class:vcg::face::PFVAdj
HasFaceColor	vcglib/vcg/simplex/face/component_occ.h	/^		static bool HasFaceColor()   { return true; }$/;"	f	class:vcg::face::ColorOcc
HasFaceMark	vcglib/vcg/simplex/face/component_occ.h	/^	  static bool HasFaceMark()   { return true; }$/;"	f	class:vcg::face::MarkOcc
HasFaceMarkOcc	vcglib/vcg/simplex/face/component_occ.h	/^		static bool HasFaceMarkOcc()   { return true; }$/;"	f	class:vcg::face::MarkOcc
HasFaceNormal	vcglib/vcg/simplex/face/component_occ.h	/^	  static bool HasFaceNormal()   { return true; }$/;"	f	class:vcg::face::NormalOcc
HasFaceNormal	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasFaceNormal()   { return false; }$/;"	f	class:vcg::tetra::EmptyFaceNormal
HasFaceNormalOcc	vcglib/vcg/simplex/face/component_occ.h	/^		static bool HasFaceNormalOcc()   { return true; }$/;"	f	class:vcg::face::NormalOcc
HasFaceNormalOcc	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasFaceNormalOcc()   { return false; }$/;"	f	class:vcg::tetra::EmptyFaceNormal
HasFaceNormalOcc	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasFaceNormalOcc()   { return false; }$/;"	f	class:vcg::tetra::FaceNormal
HasFaceNormals	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasFaceNormals()   { return true; }$/;"	f	class:vcg::tetra::FaceNormal
HasFlags	vcglib/vcg/connectors/hedge_component.h	/^  static bool HasFlags()   { return false; }$/;"	f	class:vcg::hedge::EmptyBitFlags
HasFlags	vcglib/vcg/connectors/hedge_component.h	/^  static bool HasFlags()   { return true; }$/;"	f	class:vcg::hedge::BitFlags
HasFlags	vcglib/vcg/simplex/edge/component.h	/^    static bool HasFlags()   { return false; }$/;"	f	class:vcg::edge::EmptyCore
HasFlags	vcglib/vcg/simplex/edge/component.h	/^  static bool HasFlags()   { return true; }$/;"	f	class:vcg::edge::BitFlags
HasFlags	vcglib/vcg/simplex/face/component.h	/^  static bool HasFlags()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasFlags	vcglib/vcg/simplex/face/component.h	/^  static bool HasFlags()   { return true; }$/;"	f	class:vcg::face::BitFlags
HasFlags	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasFlags()   { return false; }$/;"	f	class:vcg::tetra::EmptyBitFlags
HasFlags	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasFlags()   { return true; }$/;"	f	class:vcg::tetra::BitFlags
HasFlags	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasFlags()   { return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasFlags	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasFlags()   { return true; }$/;"	f	class:vcg::vertex::BitFlags
HasFlags	vcglib/vcg/simplex/vertex/component_occ.h	/^	static bool HasFlags() {return true;}	$/;"	f	class:vcg::vertex::FlagOcc
HasFlagsOcc	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasFlagsOcc()   { return false; }$/;"	f	class:vcg::tetra::EmptyBitFlags
HasFlagsOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^	static bool HasFlagsOcc() {return true;}	$/;"	f	class:vcg::vertex::FlagOcc
HasFloatingPoint	vcglib/vcg/math/eigen.h	/^		HasFloatingPoint = 0,$/;"	e	enum:Eigen::NumTraits::__anon488
HasFloatingPoint	vcglib/vcg/math/eigen.h	/^    HasFloatingPoint = 0,$/;"	e	enum:Eigen::NumTraits::__anon486
HasFloatingPoint	vcglib/vcg/math/eigen.h	/^    HasFloatingPoint = 0,$/;"	e	enum:Eigen::NumTraits::__anon487
HasHEAdjacency	vcglib/vcg/complex/base.h	/^bool HasHEAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::HEdgeType::HasHEAdjacency();}$/;"	f	namespace:vcg::tri
HasHEAdjacency	vcglib/vcg/connectors/hedge_component.h	/^        static bool HasHEAdjacency()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHEAdj
HasHEAdjacency	vcglib/vcg/connectors/hedge_component.h	/^        static bool HasHEAdjacency()   {   return true; }$/;"	f	class:vcg::hedge::HEAdj
HasHEAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^        static bool HasHEAdjacencyOcc()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHEAdj
HasHEAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^        static bool HasHEAdjacencyOcc()   {   return true; }$/;"	f	class:vcg::hedge::HEAdj
HasHFAdjacency	vcglib/vcg/complex/base.h	/^bool HasHFAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::HEdgeType::HasHFAdjacency();}$/;"	f	namespace:vcg::tri
HasHFAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHFAdjacency()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHFAdj
HasHFAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHFAdjacency()   {   return true; }$/;"	f	class:vcg::hedge::HFAdj
HasHFAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHFAdjacencyOcc()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHFAdj
HasHFAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHFAdjacencyOcc()   {   return true; }$/;"	f	class:vcg::hedge::HFAdj
HasHHAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHHAdjacency()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHHAdj
HasHHAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHHAdjacency()   {   return true; }$/;"	f	class:vcg::hedge::HHAdj
HasHHAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHHAdjacencyOcc()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHHAdj
HasHHAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHHAdjacencyOcc()   {   return true; }$/;"	f	class:vcg::hedge::HHAdj
HasHNextAdjacency	vcglib/vcg/complex/base.h	/^bool HasHNextAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh< CType0,   CType1,   CType2 ,  CType3>::HEdgeType::HasHNextAdjacency();}$/;"	f	namespace:vcg::tri
HasHNextAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHNextAdjacency()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHNextAdj
HasHNextAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHNextAdjacency()   {   return true; }$/;"	f	class:vcg::hedge::HNextAdj
HasHNextAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHNextAdjacencyOcc()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHNextAdj
HasHOppAdjacency	vcglib/vcg/complex/base.h	/^bool HasHOppAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/)  {return TriMesh< CType0,   CType1,   CType2 ,  CType3>::HEdgeType::HasHOppAdjacency();}$/;"	f	namespace:vcg::tri
HasHOppAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHOppAdjacency()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHOppAdj
HasHOppAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHOppAdjacency()   {   return true; }$/;"	f	class:vcg::hedge::HOppAdj
HasHOpptAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHOpptAdjacencyOcc()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHOppAdj
HasHPrevAdjacency	vcglib/vcg/complex/base.h	/^bool HasHPrevAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh< CType0,   CType1,   CType2 , CType3>::HEdgeType::HasHPrevAdjacency();}$/;"	f	namespace:vcg::tri
HasHPrevAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHPrevAdjacency()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHPrevAdj
HasHPrevAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHPrevAdjacency()   {   return true; }$/;"	f	class:vcg::hedge::HPrevAdj
HasHPrevAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHPrevAdjacencyOcc()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHPrevAdj
HasHVAdjacency	vcglib/vcg/complex/base.h	/^bool HasHVAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::HEdgeType::HasHVAdjacency();}$/;"	f	namespace:vcg::tri
HasHVAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHVAdjacency()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHVAdj
HasHVAdjacency	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHVAdjacency()   {   return true; }$/;"	f	class:vcg::hedge::HVAdj
HasHVAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHVAdjacencyOcc()   {   return false; }$/;"	f	class:vcg::hedge::EmptyHVAdj
HasHVAdjacencyOcc	vcglib/vcg/connectors/hedge_component.h	/^	static bool HasHVAdjacencyOcc()   {   return true; }$/;"	f	class:vcg::hedge::HVAdj
HasIndex	vcglib/wrap/miq/core/vertex_indexing.h	/^    bool HasIndex(VertexType* v0,int indexVar)$/;"	f	class:VertexIndexing
HasIndex	vcglib/wrap/miq/core/vertex_indexing.h	/^    bool HasIndex(int indexVert,int indexVar)$/;"	f	class:VertexIndexing
HasInfo	vcglib/vcg/simplex/face/component_occ.h	/^	  static bool HasInfo()   { return true; }$/;"	f	class:vcg::face::InfoOccBase
HasInfoOcc	vcglib/vcg/simplex/face/component_occ.h	/^		static bool HasInfoOcc()   { return true; }$/;"	f	class:vcg::face::InfoOccBase
HasLog	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasLog    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasLog	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon10
HasLog	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon16
HasLog	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon27
HasMark	vcglib/vcg/connectors/hedge_component.h	/^  static bool HasMark()      { return true; }$/;"	f	class:vcg::hedge::Mark
HasMark	vcglib/vcg/connectors/hedge_component.h	/^  static bool HasMark()   { return false; }$/;"	f	class:vcg::hedge::EmptyMark
HasMark	vcglib/vcg/simplex/edge/component.h	/^    static bool HasMark()      { return true; }$/;"	f	class:vcg::edge::Mark
HasMark	vcglib/vcg/simplex/edge/component.h	/^    static bool HasMark()   { return false; }$/;"	f	class:vcg::edge::EmptyCore
HasMark	vcglib/vcg/simplex/face/component.h	/^  static bool HasMark()      { return true; }$/;"	f	class:vcg::face::Mark
HasMark	vcglib/vcg/simplex/face/component.h	/^  static bool HasMark()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasMark	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasMark()   { return true; }$/;"	f	class:vcg::face::MarkOcf
HasMark	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasMark()      { return true; }$/;"	f	class:vcg::tetra::Mark
HasMark	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasMark()   { return false; }$/;"	f	class:vcg::tetra::EmptyMark
HasMark	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasMark()      { return true; }$/;"	f	class:vcg::vertex::Mark
HasMark	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasMark()   { return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasMark	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasMark()   { return true; }$/;"	f	class:vcg::vertex::MarkOcf
HasMarkOcc	vcglib/vcg/connectors/hedge_component.h	/^  static bool HasMarkOcc()   { return false; }$/;"	f	class:vcg::hedge::EmptyMark
HasMarkOcc	vcglib/vcg/connectors/hedge_component.h	/^  static bool HasMarkOcc()   { return true; }$/;"	f	class:vcg::hedge::Mark
HasMarkOcc	vcglib/vcg/simplex/edge/component.h	/^    static bool HasMarkOcc()   { return true; }$/;"	f	class:vcg::edge::Mark
HasMarkOcc	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasMarkOcc()   { return false; }$/;"	f	class:vcg::tetra::EmptyMark
HasMarkOcc	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasMarkOcc()   { return true; }$/;"	f	class:vcg::tetra::Mark
HasMarkOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasMarkOcf()         { return false; }$/;"	f	class:vcg::face::InfoOcf
HasMarkOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasMarkOcf()   { return true; }$/;"	f	class:vcg::face::MarkOcf
HasMarkOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^	static bool HasMarkOcf()   { return false; }$/;"	f	class:vcg::vertex::InfoOcf
HasMarkOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasMarkOcf()   { return true; }$/;"	f	class:vcg::vertex::MarkOcf
HasMax	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon170
HasMax	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasMax	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
HasMax	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
HasMax	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
HasMax	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
HasMin	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon170
HasMin	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasMin	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
HasMin	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
HasMin	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
HasMin	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
HasMul	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon170
HasMul	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasMul	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
HasMul	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
HasMul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
HasMul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
HasNegate	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon170
HasNegate	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasNegate	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
HasNegate	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
HasNegate	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
HasNegate	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
HasNoInnerStride	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    HasNoInnerStride = InnerStrideAtCompileTime == 1,$/;"	e	enum:Eigen::internal::traits::__anon173
HasNoOuterStride	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,$/;"	e	enum:Eigen::internal::traits::__anon173
HasNoStride	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    HasNoStride = HasNoInnerStride && HasNoOuterStride,$/;"	e	enum:Eigen::internal::traits::__anon173
HasNormal	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  static bool HasNormal() {return false;}$/;"	f	class:vcg::SimpleVoxel
HasNormal	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  static bool HasNormal() {return true;}$/;"	f	class:vcg::SimpleVoxelWithNormal
HasNormal	vcglib/vcg/simplex/face/component.h	/^  static bool HasNormal()    { return false; }$/;"	f	class:vcg::face::EmptyCore
HasNormal	vcglib/vcg/simplex/face/component.h	/^  static bool HasNormal()   { return true; }$/;"	f	class:vcg::face::NormalAbs
HasNormal	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasNormal()   { return true; }$/;"	f	class:vcg::face::NormalOcf
HasNormal	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasNormal()    { return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasNormal	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasNormal()   { return true; }$/;"	f	class:vcg::vertex::Normal
HasNormal	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasNormal()   { return true; }$/;"	f	class:vcg::vertex::NormalOcf
HasNormal	vcglib/wrap/opensg/vertex_component.h	/^	static bool HasNormal()   { return true; }$/;"	f	class:vcg::vert::OSGNormal
HasNormal	vcglib/wrap/opensg/vertex_component.h	/^	static bool HasNormal() { return false; }$/;"	f	class:vcg::vert::EmptyOSGNormal
HasNormalOcc	vcglib/wrap/opensg/vertex_component.h	/^	static bool HasNormalOcc() { return false; }$/;"	f	class:vcg::vert::EmptyOSGNormal
HasNormalOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasNormalOcf()       { return false; }$/;"	f	class:vcg::face::InfoOcf
HasNormalOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasNormalOcf()   { return true; }$/;"	f	class:vcg::face::NormalOcf
HasNormalOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^	static bool HasNormalOcf()   { return false; }$/;"	f	class:vcg::vertex::InfoOcf
HasNormalOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasNormalOcf()   { return true; }$/;"	f	class:vcg::vertex::NormalOcf
HasPerEdgeColor	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerEdgeColor       (const TriMeshType &m) { return tri::EdgeVectorHasPerEdgeColor       (m.edge); }$/;"	f	namespace:vcg::tri
HasPerEdgeFlags	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerEdgeFlags       (const TriMeshType &m) { return tri::EdgeVectorHasPerEdgeFlags       (m.edge); }$/;"	f	namespace:vcg::tri
HasPerEdgeMark	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerEdgeMark        (const TriMeshType &m) { return tri::EdgeVectorHasPerEdgeMark        (m.edge); }$/;"	f	namespace:vcg::tri
HasPerEdgeNormal	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerEdgeNormal      (const TriMeshType &m) { return tri::EdgeVectorHasPerEdgeNormal      (m.edge); }$/;"	f	namespace:vcg::tri
HasPerEdgeQuality	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerEdgeQuality     (const TriMeshType &m) { return tri::EdgeVectorHasPerEdgeQuality     (m.edge); }$/;"	f	namespace:vcg::tri
HasPerEdgeVEAdjacency	vcglib/vcg/complex/base.h	/^bool HasPerEdgeVEAdjacency   (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::EdgeContainer::value_type::HasVEAdjacency();}$/;"	f	namespace:vcg::tri
HasPerFaceAttribute	vcglib/vcg/complex/base.h	/^bool HasPerFaceAttribute(const MeshType &m,   std::string   name){$/;"	f	namespace:vcg::tri
HasPerFaceColor	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerFaceColor       (const TriMeshType &m) { return tri::FaceVectorHasPerFaceColor       (m.face); }$/;"	f	namespace:vcg::tri
HasPerFaceCurvatureDir	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerFaceCurvatureDir(const TriMeshType &m) { return tri::FaceVectorHasPerFaceCurvatureDir(m.face); }$/;"	f	namespace:vcg::tri
HasPerFaceFlags	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerFaceFlags       (const TriMeshType &m) { return tri::FaceVectorHasPerFaceFlags       (m.face); }$/;"	f	namespace:vcg::tri
HasPerFaceMark	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerFaceMark        (const TriMeshType &m) { return tri::FaceVectorHasPerFaceMark        (m.face); }$/;"	f	namespace:vcg::tri
HasPerFaceNormal	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerFaceNormal      (const TriMeshType &m) { return tri::FaceVectorHasPerFaceNormal      (m.face); }$/;"	f	namespace:vcg::tri
HasPerFaceQuality	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerFaceQuality     (const TriMeshType &m) { return tri::FaceVectorHasPerFaceQuality     (m.face); }$/;"	f	namespace:vcg::tri
HasPerFaceVFAdjacency	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool   HasPerFaceVFAdjacency     (const TriMeshType &m) { return tri::FaceVectorHasVFAdjacency  (m.vert); }$/;"	f	namespace:vcg::tri
HasPerMeshAttribute	vcglib/vcg/complex/base.h	/^bool HasPerMeshAttribute(const MeshType &m,   std::string   name){$/;"	f	namespace:vcg::tri
HasPerVertexAttribute	vcglib/vcg/complex/base.h	/^bool HasPerVertexAttribute(const MeshType &m,   std::string   name){$/;"	f	namespace:vcg::tri
HasPerVertexColor	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerVertexColor       (const TriMeshType &m) { return tri::VertexVectorHasPerVertexColor       (m.vert); }$/;"	f	namespace:vcg::tri
HasPerVertexCurvature	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerVertexCurvature   (const TriMeshType &m) { return tri::VertexVectorHasPerVertexCurvature   (m.vert); }$/;"	f	namespace:vcg::tri
HasPerVertexCurvatureDir	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerVertexCurvatureDir(const TriMeshType &m) { return tri::VertexVectorHasPerVertexCurvatureDir(m.vert); }$/;"	f	namespace:vcg::tri
HasPerVertexFlags	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerVertexFlags       (const TriMeshType &m) { return tri::VertexVectorHasPerVertexFlags       (m.vert); }$/;"	f	namespace:vcg::tri
HasPerVertexMark	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerVertexMark        (const TriMeshType &m) { return tri::VertexVectorHasPerVertexMark        (m.vert); }$/;"	f	namespace:vcg::tri
HasPerVertexNormal	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerVertexNormal      (const TriMeshType &m) { return tri::VertexVectorHasPerVertexNormal      (m.vert); }$/;"	f	namespace:vcg::tri
HasPerVertexQuality	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerVertexQuality     (const TriMeshType &m) { return tri::VertexVectorHasPerVertexQuality     (m.vert); }$/;"	f	namespace:vcg::tri
HasPerVertexRadius	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerVertexRadius      (const TriMeshType &m) { return tri::VertexVectorHasPerVertexRadius      (m.vert); }$/;"	f	namespace:vcg::tri
HasPerVertexTexCoord	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerVertexTexCoord    (const TriMeshType &m) { return tri::VertexVectorHasPerVertexTexCoord    (m.vert); }$/;"	f	namespace:vcg::tri
HasPerVertexVEAdjacency	vcglib/vcg/complex/base.h	/^bool HasPerVertexVEAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::VertContainer::value_type::HasVEAdjacency();}$/;"	f	namespace:vcg::tri
HasPerVertexVFAdjacency	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerVertexVFAdjacency     (const TriMeshType &m) { return tri::VertexVectorHasVFAdjacency(m.vert); }$/;"	f	namespace:vcg::tri
HasPerWedgeColor	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerWedgeColor   (const TriMeshType &m) { return tri::FaceVectorHasPerWedgeColor   (m.face); }$/;"	f	namespace:vcg::tri
HasPerWedgeNormal	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerWedgeNormal  (const TriMeshType &m) { return tri::FaceVectorHasPerWedgeNormal  (m.face); }$/;"	f	namespace:vcg::tri
HasPerWedgeTexCoord	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasPerWedgeTexCoord(const TriMeshType &m) { return tri::FaceVectorHasPerWedgeTexCoord(m.face); }$/;"	f	namespace:vcg::tri
HasPolyInfo	vcglib/vcg/complex/base.h	/^bool HasPolyInfo (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::FaceContainer::value_type::HasPolyInfo();}$/;"	f	namespace:vcg::tri
HasPolyInfo	vcglib/vcg/simplex/face/component.h	/^  static bool HasPolyInfo()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasPolyInfo	vcglib/vcg/simplex/face/component_polygon.h	/^  static bool HasPolyInfo()   { return true; }$/;"	f	class:vcg::face::PolyInfo
HasPow	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasPow    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasQuality	vcglib/vcg/simplex/edge/component.h	/^    static bool HasQuality()   { return false; }$/;"	f	class:vcg::edge::EmptyCore
HasQuality	vcglib/vcg/simplex/edge/component.h	/^  static bool HasQuality()   { return true; }$/;"	f	class:vcg::edge::Quality
HasQuality	vcglib/vcg/simplex/face/component.h	/^  static bool HasQuality()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasQuality	vcglib/vcg/simplex/face/component.h	/^  static bool HasQuality()   { return true; }$/;"	f	class:vcg::face::Quality
HasQuality	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasQuality()   { return true; }$/;"	f	class:vcg::face::QualityOcf
HasQuality	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasQuality()   { return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasQuality	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasQuality()   { return true; }$/;"	f	class:vcg::vertex::Quality
HasQuality	vcglib/vcg/simplex/vertex/component_occ.h	/^  static bool HasQuality()   { return true; }$/;"	f	class:vcg::vertex::QualityOcc
HasQuality	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasQuality()   { return true; }$/;"	f	class:vcg::vertex::QualityOcf
HasQuality3	vcglib/vcg/simplex/face/component.h	/^  static bool HasQuality3()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasQuality3	vcglib/vcg/simplex/face/component.h	/^  static bool HasQuality3()   { return true; }$/;"	f	class:vcg::face::Quality3
HasQualityOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasQualityOcf()      { return false; }$/;"	f	class:vcg::face::InfoOcf
HasQualityOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasQualityOcf()   { return true; }$/;"	f	class:vcg::face::QualityOcf
HasQualityOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^	static bool HasQualityOcf()   { return false; }$/;"	f	class:vcg::vertex::InfoOcf
HasQualityOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasQualityOcf()   { assert(!T::HasQualityOcf()); return true; }$/;"	f	class:vcg::vertex::QualityOcf
HasRadius	vcglib/vcg/simplex/vertex/component.h	/^    static bool HasRadius()   { return true; }$/;"	f	class:vcg::vertex::Radius
HasRadius	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasRadius()     { return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasRadius	vcglib/vcg/simplex/vertex/component_occ.h	/^  static bool HasRadius()     { return true; }$/;"	f	class:vcg::vertex::RadiusOcc
HasRadius	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasRadius()     { return true; }$/;"	f	class:vcg::vertex::RadiusOcf
HasRadiusOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^  static bool HasRadiusOcc()  { return true; }$/;"	f	class:vcg::vertex::RadiusOcc
HasRadiusOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^	static bool HasRadiusOcf()   { return false; }$/;"	f	class:vcg::vertex::InfoOcf
HasRadiusOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasRadiusOcf()  { return true; }$/;"	f	class:vcg::vertex::RadiusOcf
HasSH	vcglib/vcg/simplex/vertex/component_sph.h	/^	static bool HasSH()   { return true; }$/;"	f	class:vcg::vertex::Sph
HasSameStorageOrderAsXprType	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    HasSameStorageOrderAsXprType = (IsRowMajor == XprTypeIsRowMajor),$/;"	e	enum:Eigen::internal::traits::__anon50
HasSetLinear	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon170
HasSetLinear	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasSetLinear	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon8
HasSetLinear	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon14
HasSetLinear	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon20
HasSetLinear	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon22
HasSin	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasSin    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasSin	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon10
HasSin	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon16
HasSin	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSin  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon27
HasSqrt	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasSqrt   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasSqrt	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon10
HasSqrt	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon16
HasSqrt	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon27
HasSub	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon170
HasSub	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasSub	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
HasSub	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
HasSub	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
HasSub	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
HasTTAdjacency	vcglib/vcg/simplex/tetrahedron/component.h	/^	static bool HasTTAdjacency() { return false; }$/;"	f	class:vcg::tetra::EmptyAdj
HasTTAdjacency	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasTTAdjacency()      {   return true; }$/;"	f	class:vcg::tetra::TTAdj
HasTTAdjacencyOcc	vcglib/vcg/simplex/tetrahedron/component.h	/^	static bool HasTTAdjacencyOcc() { return false; }$/;"	f	class:vcg::tetra::EmptyAdj
HasTTAdjacencyOcc	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasTTAdjacencyOcc()   {   return false; }$/;"	f	class:vcg::tetra::TTAdj
HasTan	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    HasTan    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon168
HasTexCoord	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasTexCoord()   { return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasTexCoord	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasTexCoord()   { return true; }$/;"	f	class:vcg::vertex::TexCoord
HasTexCoord	vcglib/vcg/simplex/vertex/component_occ.h	/^  static bool HasTexCoord()   { return true; }$/;"	f	class:vcg::vertex::TexCoordOcc
HasTexCoord	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasTexCoord()   { return true; }$/;"	f	class:vcg::vertex::TexCoordOcf
HasTexCoordOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^  static bool HasTexCoordOcc()   { return true; }$/;"	f	class:vcg::vertex::TexCoordOcc
HasTexCoordOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^	static bool HasTexCoordOcf()   { return false; }$/;"	f	class:vcg::vertex::InfoOcf
HasTexCoordOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasTexCoordOcf()   { assert(!TT::HasTexCoordOcf()); return true; }$/;"	f	class:vcg::vertex::TexCoordOcf
HasUnitDiag	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon218
HasUnitDiag	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon219
HasUnitDiag	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^           HasUnitDiag = (Mode&UnitDiag) ? 1 : 0$/;"	e	enum:Eigen::SparseTriangularView::__anon425
HasUsableDirectAccess	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    HasUsableDirectAccess = (    (int(XprType::Flags)&DirectAccessBit)$/;"	e	enum:Eigen::internal::blas_traits::__anon255
HasVEAdjacency	vcglib/vcg/complex/base.h	/^bool HasVEAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::VertContainer::value_type::HasVEAdjacency();}$/;"	f	namespace:vcg::tri
HasVEAdjacency	vcglib/vcg/simplex/edge/component.h	/^	static bool HasVEAdjacency()   {   return true; }$/;"	f	class:vcg::edge::VEAdj
HasVEAdjacency	vcglib/vcg/simplex/edge/component.h	/^    static bool HasVEAdjacency()   {   return false; }$/;"	f	class:vcg::edge::EmptyCore
HasVEAdjacency	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasVEAdjacency()   {   return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasVEAdjacency	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasVEAdjacency()   {   return true; }$/;"	f	class:vcg::vertex::VEAdj
HasVEAdjacencyOcc	vcglib/vcg/simplex/edge/component.h	/^	static bool HasVEAdjacencyOcc()   {   return true; }$/;"	f	class:vcg::edge::VEAdj
HasVFAdjacency	vcglib/vcg/complex/base.h	/^template < class TriMeshType> bool HasVFAdjacency   (const TriMeshType &m) { return tri::FaceVectorHasVFAdjacency   (m.face) && tri::VertexVectorHasVFAdjacency(m.vert);  }$/;"	f	namespace:vcg::tri
HasVFAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasVFAdjacency()      {   return true; }$/;"	f	class:vcg::face::VFAdj
HasVFAdjacency	vcglib/vcg/simplex/face/component.h	/^  static bool HasVFAdjacency()   {   return false; }$/;"	f	class:vcg::face::EmptyCore
HasVFAdjacency	vcglib/vcg/simplex/face/component_occ.h	/^  static bool HasVFAdjacency()   {   return true; }$/;"	f	class:vcg::face::VFAdjOccBase
HasVFAdjacency	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasVFAdjacency()   {   return true; }$/;"	f	class:vcg::face::VFAdjOcf
HasVFAdjacency	vcglib/vcg/simplex/face/component_polygon.h	/^  static bool HasVFAdjacency()      {   return true; }$/;"	f	class:vcg::face::PVFAdj
HasVFAdjacency	vcglib/vcg/simplex/vertex/component.h	/^    static bool HasVFAdjacency()   {   return true; }$/;"	f	class:vcg::vertex::VFAdj
HasVFAdjacency	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasVFAdjacency()   { return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasVFAdjacency	vcglib/vcg/simplex/vertex/component_occ.h	/^  static bool HasVFAdjacency()   {   return true; }$/;"	f	class:vcg::vertex::VFAdjOcc
HasVFAdjacency	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasVFAdjacency()   {   return true; }$/;"	f	class:vcg::vertex::VFAdjOcf
HasVFAdjacencyOcc	vcglib/vcg/simplex/face/component_occ.h	/^  static bool HasVFAdjacencyOcc()   { return true; }$/;"	f	class:vcg::face::VFAdjOccBase
HasVFAdjacencyOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasVFAdjacencyOcf()      { return false; }$/;"	f	class:vcg::face::InfoOcf
HasVFAdjacencyOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasVFAdjacencyOcf()   { return true; }$/;"	f	class:vcg::face::VFAdjOcf
HasVFAdjacencyOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^	static bool HasVFAdjacencyOcf()   { return false; }$/;"	f	class:vcg::vertex::InfoOcf
HasVFAdjacencyOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static bool HasVFAdjacencyOcf()   {   return true; }$/;"	f	class:vcg::vertex::VFAdjOcf
HasVHAdjacency	vcglib/vcg/complex/base.h	/^bool HasVHAdjacency (const TriMesh < CType0, CType1, CType2, CType3> & \/*m*\/) {return TriMesh < CType0 , CType1, CType2, CType3>::VertContainer::value_type::HasVHAdjacency();}$/;"	f	namespace:vcg::tri
HasVHAdjacency	vcglib/vcg/simplex/vertex/component.h	/^	static bool HasVHAdjacency()   {   return true; }$/;"	f	class:vcg::vertex::VHAdj
HasVHAdjacency	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasVHAdjacency()   {   return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasVTAdjacency	vcglib/vcg/simplex/tetrahedron/component.h	/^	static bool HasVTAdjacency() { return false; }$/;"	f	class:vcg::tetra::EmptyAdj
HasVTAdjacency	vcglib/vcg/simplex/tetrahedron/component.h	/^	static bool HasVTAdjacency() { return true; }$/;"	f	class:vcg::tetra::VTAdj
HasVTAdjacency	vcglib/vcg/simplex/vertex/component.h	/^	static bool HasVTAdjacency() { return true; }$/;"	f	class:vcg::vertex::VTAdj
HasVTAdjacency	vcglib/vcg/simplex/vertex/component.h	/^  static bool HasVTAdjacency() { return false; }$/;"	f	class:vcg::vertex::EmptyCore
HasVTAdjacencyOcc	vcglib/vcg/simplex/tetrahedron/component.h	/^	static bool HasVTAdjacencyOcc() { return false; }$/;"	f	class:vcg::tetra::EmptyAdj
HasVTAdjacencyOcc	vcglib/vcg/simplex/tetrahedron/component.h	/^	static bool HasVTAdjacencyOcc() { return false; }$/;"	f	class:vcg::tetra::VTAdj
HasVertexRef	vcglib/vcg/simplex/edge/component.h	/^	static bool HasVertexRef()     { return false; }$/;"	f	class:vcg::edge::EmptyCore
HasVertexRef	vcglib/vcg/simplex/edge/component.h	/^  static bool HasVertexRef()   { return true; }$/;"	f	class:vcg::edge::VertexRef
HasVertexRef	vcglib/vcg/simplex/face/component.h	/^  static bool HasVertexRef()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasVertexRef	vcglib/vcg/simplex/face/component.h	/^  static bool HasVertexRef()   { return true; }$/;"	f	class:vcg::face::VertexRef
HasVertexRef	vcglib/vcg/simplex/face/component_occ.h	/^  static bool HasVertexRef()   { return true; }$/;"	f	class:vcg::face::VertexRefOcc
HasVertexRef	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasVertexRef()   { return false; }$/;"	f	class:vcg::tetra::EmptyVertexRef
HasVertexRef	vcglib/vcg/simplex/tetrahedron/component.h	/^  static bool HasVertexRef()   { return true; }$/;"	f	class:vcg::tetra::VertexRef
HasWedgeColor	vcglib/vcg/simplex/face/component.h	/^  static bool HasWedgeColor()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasWedgeColor	vcglib/vcg/simplex/face/component.h	/^  static bool HasWedgeColor()   { return true; }$/;"	f	class:vcg::face::WedgeColor
HasWedgeColor	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasWedgeColor()   { return true; }$/;"	f	class:vcg::face::WedgeColorOcf
HasWedgeColorOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasWedgeColorOcf()       { return false; }$/;"	f	class:vcg::face::InfoOcf
HasWedgeColorOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasWedgeColorOcf()   { return true; }$/;"	f	class:vcg::face::WedgeColorOcf
HasWedgeNormal	vcglib/vcg/simplex/face/component.h	/^  static bool HasWedgeNormal()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasWedgeNormal	vcglib/vcg/simplex/face/component.h	/^  static bool HasWedgeNormal()   { return true; }$/;"	f	class:vcg::face::WedgeNormal
HasWedgeNormal	vcglib/vcg/simplex/face/component.h	/^  static bool HasWedgeNormal()   { return true; }$/;"	f	class:vcg::face::WedgeRealNormal
HasWedgeNormal	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasWedgeNormal()   { return true; }$/;"	f	class:vcg::face::WedgeNormalOcf
HasWedgeNormalOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasWedgeNormalOcf()      { return false; }$/;"	f	class:vcg::face::InfoOcf
HasWedgeNormalOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasWedgeNormalOcf()   { return true; }$/;"	f	class:vcg::face::WedgeNormalOcf
HasWedgeTexCoord	vcglib/vcg/simplex/face/component.h	/^  static bool HasWedgeTexCoord()   { return false; }$/;"	f	class:vcg::face::EmptyCore
HasWedgeTexCoord	vcglib/vcg/simplex/face/component.h	/^  static bool HasWedgeTexCoord()   { return true; }$/;"	f	class:vcg::face::WedgeTexCoord
HasWedgeTexCoord	vcglib/vcg/simplex/face/component_occ.h	/^	  static bool HasWedgeTexCoord()   { return true; }$/;"	f	class:vcg::face::WedgeTexCoordOcc
HasWedgeTexCoord	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasWedgeTexCoord()   { return true; }$/;"	f	class:vcg::face::WedgeTexCoordOcf
HasWedgeTexCoordOcc	vcglib/vcg/simplex/face/component_occ.h	/^		static bool HasWedgeTexCoordOcc()   { return true; }$/;"	f	class:vcg::face::WedgeTexCoordOcc
HasWedgeTexCoordOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasWedgeTexCoordOcf()    { return false; }$/;"	f	class:vcg::face::InfoOcf
HasWedgeTexCoordOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  static bool HasWedgeTexCoordOcf()   { return true; }$/;"	f	class:vcg::face::WedgeTexCoordOcf
HasZeroDiag	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon218
HasZeroDiag	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon219
HasZeroTexCoordFace	vcglib/vcg/complex/algorithms/clean.h	/^      static bool HasZeroTexCoordFace(MeshType &m)$/;"	f	class:vcg::tri::Clean
HasfaceColorOcc	vcglib/vcg/simplex/face/component_occ.h	/^		static bool HasfaceColorOcc()   { return true; }$/;"	f	class:vcg::face::ColorOcc
Hash	vcglib/vcg/complex/algorithms/clustering.h	/^  size_t Hash() const$/;"	f	class:vcg::tri::HashedPoint3i
Hash2D	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^vcg::SpatialHashTable2D<MySegmentType,MyScalarType> Hash2D;$/;"	v
HashFunctor	vcglib/vcg/space/index/spatial_hashing.h	/^	struct HashFunctor : public std::unary_function<Point3i, size_t>$/;"	s	namespace:vcg
HashFunctor2D	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^	struct HashFunctor2D : public std::unary_function<Point2i, size_t>$/;"	s	namespace:vcg
HashIterator	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^		typedef typename HashType::iterator HashIterator;$/;"	t	class:vcg::SpatialHashTable2D
HashIterator	vcglib/vcg/space/index/spatial_hashing.h	/^	typedef typename HashType::iterator HashIterator;$/;"	t	class:vcg::SpatialHashTable
HashMapType	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    typedef typename MapTraits<ScalarWrapper>::Type HashMapType;$/;"	t	class:Eigen::RandomSetter
HashTable	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			HashTable() {}$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
HashTable	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		class HashTable$/;"	c	class:vcg::PerfectSpatialHashing
HashType	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^		typedef typename STDEXT::hash_multimap<Point2i, ObjType *, HashFunctor2D> HashType;$/;"	t	class:vcg::SpatialHashTable2D
HashType	vcglib/vcg/space/index/spatial_hashing.h	/^	typedef typename STDEXT::hash_multimap<Point3i, ObjType *, HashFunctor> HashType;$/;"	t	class:vcg::SpatialHashTable
HashedPoint3i	vcglib/vcg/complex/algorithms/clustering.h	/^class HashedPoint3i : public Point3i$/;"	c	namespace:vcg::tri
Hausdorff	vcglib/apps/metro/sampling.h	/^void Sampling<MetroMesh>::Hausdorff()$/;"	f	class:vcg::Sampling
HeapElem	vcglib/vcg/complex/algorithms/local_optimization.h	/^		inline HeapElem(){locModPtr = NULL;}$/;"	f	struct:vcg::LocalOptimization::HeapElem
HeapElem	vcglib/vcg/complex/algorithms/local_optimization.h	/^    inline HeapElem( LocModPtrType _locModPtr)$/;"	f	struct:vcg::LocalOptimization::HeapElem
HeapElem	vcglib/vcg/complex/algorithms/local_optimization.h	/^  struct HeapElem$/;"	s	class:vcg::LocalOptimization
HeapElem	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename LocalOptimization<MeshType>::HeapElem HeapElem;$/;"	t	class:vcg::tri::QuadDiagonalCollapse
HeapElem	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename LocalOptimization<MeshType>::HeapElem HeapElem;$/;"	t	class:vcg::tri::QuadDiagonalCollapseBase
HeapElem	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	typedef typename LocalOptimization<TETRA_MESH_TYPE>::HeapElem HeapElem;$/;"	t	class:vcg::tetra::TetraEdgeCollapse
HeapElem	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  typedef typename LocalOptimization<TriMeshType>::HeapElem HeapElem;$/;"	t	class:vcg::tri::TriEdgeCollapse
HeapElem	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^    typedef typename TriEdgeCollapse<TriMeshType, VertexPair, MYTYPE>::HeapElem HeapElem;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadric
HeapElem	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef typename tri::TriEdgeCollapse<TriMeshType, VertexPair, MYTYPE>::HeapElem HeapElem;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadricTex
HeapElem	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename LocalOptimization<TRIMESH_TYPE>::HeapElem HeapElem;$/;"	t	class:vcg::tri::PlanarEdgeFlip
HeapElem	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename LocalOptimization<TRIMESH_TYPE>::HeapElem HeapElem;$/;"	t	class:vcg::tri::TopoEdgeFlip
HeapMaxPriorityQueue	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	HeapMaxPriorityQueue(void)$/;"	f	class:HeapMaxPriorityQueue
HeapMaxPriorityQueue	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^class HeapMaxPriorityQueue$/;"	c
HeapSimplexRatio	vcglib/vcg/complex/algorithms/local_optimization.h	/^  float HeapSimplexRatio; $/;"	m	class:vcg::LocalOptimization
HeapSimplexRatio	vcglib/vcg/complex/algorithms/local_optimization.h	/^  static float HeapSimplexRatio(BaseParameterClass *) {return 6.0f;}$/;"	f	class:vcg::LocalModification
HeapSimplexRatio	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  static float HeapSimplexRatio(BaseParameterClass *_pp) {return IsSymmetric(_pp)?5.0f:9.0f;}$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
HeapType	vcglib/vcg/complex/algorithms/local_optimization.h	/^	typedef typename std::vector<HeapElem> HeapType;	$/;"	t	class:vcg::LocalOptimization
HeapType	vcglib/vcg/complex/algorithms/local_optimization.h	/^        typedef typename LocalOptimization<MeshType>::HeapType HeapType;$/;"	t	class:vcg::LocalModification
HeapType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename LocalOptimization<MeshType>::HeapType HeapType;$/;"	t	class:vcg::tri::QuadDiagonalCollapse
HeapType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename LocalOptimization<MeshType>::HeapType HeapType;$/;"	t	class:vcg::tri::QuadDiagonalCollapseBase
HeapType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	typedef typename LocalOptimization<TriMeshType>::HeapType HeapType;$/;"	t	class:vcg::tri::TriEdgeCollapse
HeapType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^    typedef typename TriEdgeCollapse<TriMeshType, VertexPair, MYTYPE>::HeapType HeapType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadric
HeapType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef typename tri::TriEdgeCollapse<TriMeshType, VertexPair, MYTYPE>::HeapType HeapType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadricTex
HeapType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename LocalOptimization<TRIMESH_TYPE>::HeapType HeapType;$/;"	t	class:vcg::tri::PlanarEdgeFlip
HeapType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename LocalOptimization<TRIMESH_TYPE>::HeapType HeapType;$/;"	t	class:vcg::tri::TopoEdgeFlip
Height	vcglib/wrap/gl/fbo.h	/^	GLsizei Height(void) const$/;"	f	class:BufferRenderTarget
Height	vcglib/wrap/gl/fbo.h	/^	GLsizei Height(void) const$/;"	f	class:Texture2D
Height	vcglib/wrap/gl/fbo.h	/^	GLsizei Height(void) const$/;"	f	class:Texture3D
Height	vcglib/wrap/gl/fbo.h	/^	GLsizei Height(void) const$/;"	f	class:TextureRenderTarget
HereditaryBits	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int HereditaryBits = RowMajorBit$/;"	m	namespace:Eigen
HessenbergDecomposition	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::HessenbergDecomposition
HessenbergDecomposition	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition
HessenbergDecomposition	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename _MatrixType> class HessenbergDecomposition$/;"	c	namespace:Eigen
HessenbergDecompositionMatrixHReturnType	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecompositionMatrixHReturnType(const HessenbergDecomposition<MatrixType>& hess) : m_hess(hess) { }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
HessenbergDecompositionMatrixHReturnType	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename MatrixType> struct HessenbergDecompositionMatrixHReturnType$/;"	s	namespace:Eigen::internal
Hexahedron	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Hexahedron(MeshType &in)$/;"	f	namespace:vcg::tri
HideStill	vcglib/wrap/gui/trackutils.h	/^  bool HideStill;$/;"	m	class:vcg::trackutils::DrawingHint
HierarchicalPoissonDisk	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void HierarchicalPoissonDisk(MetroMesh &origMesh, VertexSampler &ps, MetroMesh &montecarloMesh, ScalarType diskRadius, const struct PoissonDiskParam pp=PoissonDiskParam())$/;"	f	class:vcg::tri::SurfaceSampling
Hinge	vcglib/apps/pivoting/pivot.h	/^      Hinge() {}$/;"	f	struct:vcg::tri::Hinge
Hinge	vcglib/apps/pivoting/pivot.h	/^      Hinge(int _v0, int _v1, int _v2, int _face, Point3f &_center): $/;"	f	struct:vcg::tri::Hinge
Hinge	vcglib/apps/pivoting/pivot.h	/^struct Hinge { $/;"	s	namespace:vcg::tri
Hint	vcglib/wrap/gl/tetramesh.h	/^	enum Hint {HShrinkFactor};$/;"	g	class:vcg::tetra::GLW
Hint	vcglib/wrap/gl/trimesh.h	/^    enum Hint {$/;"	g	class:vcg::GLW
HintParamf	vcglib/wrap/gl/trimesh.h	/^    enum HintParamf {$/;"	g	class:vcg::GLW
HintParami	vcglib/wrap/gl/trimesh.h	/^    enum HintParami {$/;"	g	class:vcg::GLW
Histogram	vcglib/vcg/math/histogram.h	/^class Histogram $/;"	c	namespace:vcg
Histogramd	vcglib/vcg/math/histogram.h	/^typedef Histogram<double> Histogramd ;$/;"	t	namespace:vcg
Histogramf	vcglib/vcg/math/histogram.h	/^typedef Histogram<float> Histogramf ;$/;"	t	namespace:vcg
HistorySize	vcglib/wrap/gui/trackball.cpp	/^void Trackball::HistorySize(int \/* length *\/){}$/;"	f	class:Trackball
HitHyper	vcglib/wrap/gui/trackutils.h	/^bool HitHyper (Point3f center, float radius, Point3f viewpoint, Plane3f vp,$/;"	f	namespace:vcg::trackutils
HitNearestPointOnAxis	vcglib/wrap/gui/trackutils.h	/^std::pair< Point3f,bool > HitNearestPointOnAxis (Trackball * tb,Line3f axis, Point3f point)$/;"	f	namespace:vcg::trackutils
HitPlane	vcglib/wrap/gui/trackutils.h	/^std::pair< Point3f, bool > HitPlane (Trackball * tb, Point3f point, Plane3f plane)$/;"	f	namespace:vcg::trackutils
HitPoint	vcglib/wrap/gui/trackmode.cpp	/^float PathMode::HitPoint(float state, Ray3fN ray, Point3f &hit_point)$/;"	f	class:PathMode
HitSphere	vcglib/wrap/gui/trackutils.h	/^Point3f HitSphere (Trackball * tb, const Point3f & p)$/;"	f	namespace:vcg::trackutils
HitViewPlane	vcglib/wrap/gui/trackutils.h	/^Point3f HitViewPlane (Trackball * tb, const Point3f & p)$/;"	f	namespace:vcg::trackutils
Hits	vcglib/wrap/gui/trackball.h	/^  std::vector<Point3f> Hits;$/;"	m	class:vcg::Trackball
Hole	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^typedef vector<Point3x> Hole;$/;"	t	file:
Hole	vcglib/vcg/complex/algorithms/hole.h	/^class Hole$/;"	c	namespace:vcg::tri
Home	vcglib/wrap/gui/trackball.cpp	/^void Trackball::Home(){}$/;"	f	class:Trackball
Homeometry	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            Homeometry(){}$/;"	f	class:vcg::tri::Homeometry
Homeometry	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^        template <class MeshType> class Homeometry: public EdgeFlipPriority<MeshType>$/;"	c	namespace:vcg::tri
HomoNormalize	vcglib/vcg/math/eigen_matrixbase_addons.h	/^inline Derived& HomoNormalize()$/;"	f
HomoNormalize	vcglib/vcg/math/eigen_matrixbase_addons.h	/^inline const PlainMatrixType HomoNormalize() const$/;"	f
HomoNormalize	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 & HomoNormalize(){$/;"	f	class:vcg::ndim::Point2
HomoNormalize	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & HomoNormalize(){$/;"	f	class:vcg::ndim::Point3
HomoNormalize	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & HomoNormalize(){$/;"	f	class:vcg::ndim::Point4
HomoNormalize	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 & HomoNormalize(){$/;"	f	class:vcg::Point4
Homogeneous	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    inline Homogeneous(const MatrixType& matrix)$/;"	f	class:Eigen::Homogeneous
Homogeneous	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^template<typename MatrixType,int _Direction> class Homogeneous$/;"	c	namespace:Eigen
HomogeneousDimension	vcglib/eigenlib/Eigen/src/Geometry/Umeyama.h	/^    HomogeneousDimension = int(MinRowsAtCompileTime) == Dynamic ? Dynamic : int(MinRowsAtCompileTime)+1$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon380
HomogeneousReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef Homogeneous<Derived, HomogeneousReturnTypeDirection> HomogeneousReturnType;$/;"	t	class:Eigen::MatrixBase
HomogeneousReturnTypeDirection	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    enum { HomogeneousReturnTypeDirection = ColsAtCompileTime==1?Vertical:Horizontal };$/;"	e	enum:Eigen::MatrixBase::__anon183
Horizontal	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Horizontal, $/;"	e	enum:Eigen::DirectionType
HouseholderQR	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR() : m_qr(), m_hCoeffs(), m_temp(), m_isInitialized(false) {}$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^template<typename _MatrixType> class HouseholderQR$/;"	c	namespace:Eigen
HouseholderQRPreconditioner	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  HouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
HouseholderSequence	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const HouseholderSequence& other)$/;"	f	class:Eigen::HouseholderSequence
HouseholderSequence	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	class:Eigen::HouseholderSequence
HouseholderSequence	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^template<typename VectorsType, typename CoeffsType, int Side> class HouseholderSequence$/;"	c	namespace:Eigen
HouseholderSequenceType	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename HouseholderSequence<MatrixType,CoeffVectorType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::HessenbergDecomposition
HouseholderSequenceType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename HouseholderSequence<MatrixType,CoeffVectorType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::Tridiagonalization
HouseholderSequenceType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::HouseholderSequenceType HouseholderSequenceType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
HouseholderSequenceType	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheLeft> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
HouseholderSequenceType	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheRight> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
HouseholderSequenceType	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename HouseholderSequence<MatrixType,HCoeffsType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::ColPivHouseholderQR
HouseholderSequenceType	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename HouseholderSequence<MatrixType,HCoeffsType>::ConjugateReturnType HouseholderSequenceType;$/;"	t	class:Eigen::HouseholderQR
HouseholderUSequenceType	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderUSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
HouseholderVSequenceType	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderVSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Hue2RGB	vcglib/vcg/space/colorspace.h	/^	static double Hue2RGB(double v1, double v2, double vH)$/;"	f	class:vcg::ColorSpace
HybridNonLinearSolver	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    HybridNonLinearSolver(FunctorType &_functor)$/;"	f	class:Eigen::HybridNonLinearSolver
HybridNonLinearSolver	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^class HybridNonLinearSolver$/;"	c	namespace:Eigen
HybridNonLinearSolverSpace	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^namespace HybridNonLinearSolverSpace { $/;"	n	namespace:Eigen
Hyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Hyperplane /;"	d
Hyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Hyperplane$/;"	d
Hyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, Scalar d)$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(int _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
Hyperplane	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  Hyperplane(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, Scalar d)$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(Index _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane
Hyperplane	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
I	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^    I = IsLower ? Index : Size - Index - 1,$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon246
I	vcglib/vcg/simplex/edge/pos.h	/^	int	&					  I() { return z;}$/;"	f	class:vcg::edge::VEIterator
I	vcglib/vcg/simplex/face/pos.h	/^	int	&					  I() { return z;}$/;"	f	class:vcg::face::VFIterator
IAm	vcglib/vcg/complex/base.h	/^struct DummyContainer{struct value_type{ typedef int IAm;}; };$/;"	t	struct:vcg::tri::DummyContainer::value_type
IAm	vcglib/vcg/connectors/hedge.h	/^						public: typedef AllTypes::AHEdgeType IAm; typedef UserTypes TypesPool;};$/;"	t	class:vcg::HEdge
IAm	vcglib/vcg/simplex/edge/base.h	/^						public: typedef AllTypes::AEdgeType IAm; typedef UserTypes TypesPool;};$/;"	t	class:vcg::Edge
IAm	vcglib/vcg/simplex/face/base.h	/^							public: typedef AllTypes::AFaceType IAm; typedef UserTypes TypesPool;};$/;"	t	class:vcg::Face
IAm	vcglib/vcg/simplex/vertex/base.h	/^			 public: typedef AllTypes::AVertexType IAm; typedef UserTypes TypesPool;};$/;"	t	class:vcg::Vertex
IBoxToBox	vcglib/vcg/space/index/grid_util.h	/^	void IBoxToBox( const Box3i & ib, Box3x & b ) const$/;"	f	class:vcg::BasicGrid
IBoxToBox	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		void IBoxToBox( const Box2i & ib, Box2x & b ) const$/;"	f	class:vcg::BasicGrid2D
ID	vcglib/vcg/container/vector_occ.h	/^	static int & ID(){static int id; return id;} $/;"	f	class:vcg::vector_occ
IDI_ICON1	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/resource.h	/^#define IDI_ICON1 /;"	d
IDI_ICON2	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/resource.h	/^#define IDI_ICON2 /;"	d
IDTFConverterParameters	vcglib/wrap/io_trimesh/export_u3d.h	/^		IDTFConverterParameters(const QString& converter_loc,const QString& input_file,const QString& output_file)$/;"	f	struct:vcg::tri::io::u3dparametersclasses::IDTFConverterParameters
IDTFConverterParameters	vcglib/wrap/io_trimesh/export_u3d.h	/^	struct IDTFConverterParameters$/;"	s	namespace:vcg::tri::io::u3dparametersclasses
IDTFError	vcglib/wrap/io_trimesh/export_idtf.h	/^	enum IDTFError $/;"	g	class:vcg::tri::io::ExporterIDTF
IMG_ATTRIBUTES_H_	vcglib/img/img_attributes.h	/^#define IMG_ATTRIBUTES_H_$/;"	d
IMG_BASE_H_	vcglib/img/img_base.h	/^#define IMG_BASE_H_$/;"	d
IMG_CONVERT_H_	vcglib/img/img_convert.h	/^#define IMG_CONVERT_H_$/;"	d
IMG_CS_BASE_H_	vcglib/img/img_cs_base.h	/^#define IMG_CS_BASE_H_$/;"	d
IMG_FILTER_H_	vcglib/img/img_filter.h	/^#define IMG_FILTER_H_$/;"	d
IMG_IMAGE_H_	vcglib/img/img_image.h	/^#define IMG_IMAGE_H_$/;"	d
IMG_INCLUDES_H_	vcglib/img/img.h	/^#define IMG_INCLUDES_H_$/;"	d
IMG_INFO_H_	vcglib/img/img_info.h	/^#define IMG_INFO_H_$/;"	d
IMG_IO_H_	vcglib/img/img_io.h	/^#define IMG_IO_H_$/;"	d
IMG_QT_CONVERT_H_	vcglib/wrap/qt/img_qt_convert.h	/^#define IMG_QT_CONVERT_H_$/;"	d
IMG_QT_INCLUDES_H_	vcglib/wrap/qt/img_qt.h	/^#define IMG_QT_INCLUDES_H_$/;"	d
IMG_QT_IO_H_	vcglib/wrap/qt/img_qt_io.h	/^#define IMG_QT_IO_H_$/;"	d
IMG_SCALAR_H_	vcglib/img/img_scalar.h	/^#define IMG_SCALAR_H_$/;"	d
IMPORT_FBX	vcglib/wrap/io_trimesh/import_fbx.h	/^#define IMPORT_FBX$/;"	d
IMark	vcglib/vcg/complex/base.h	/^template <class MeshType> inline int & IMark(MeshType & m){return m.imark;}$/;"	f	namespace:vcg::tri
IMark	vcglib/vcg/connectors/hedge_component.h	/^  inline const int & IMark() const {return _imark;}$/;"	f	class:vcg::hedge::Mark
IMark	vcglib/vcg/connectors/hedge_component.h	/^  inline int & IMark()       { assert(0); static int tmp=-1; return tmp;}$/;"	f	class:vcg::hedge::EmptyMark
IMark	vcglib/vcg/connectors/hedge_component.h	/^  inline int & IMark()       { return _imark;}$/;"	f	class:vcg::hedge::Mark
IMark	vcglib/vcg/connectors/hedge_component.h	/^  inline int IMark() const {return 0;}$/;"	f	class:vcg::hedge::EmptyMark
IMark	vcglib/vcg/simplex/edge/component.h	/^    inline const int & IMark() const {return _imark;}$/;"	f	class:vcg::edge::Mark
IMark	vcglib/vcg/simplex/edge/component.h	/^    inline int & IMark()       { return _imark;}$/;"	f	class:vcg::edge::Mark
IMark	vcglib/vcg/simplex/edge/component.h	/^    inline int &IMark()       { assert(0); static int tmp=-1; return tmp;}$/;"	f	class:vcg::edge::EmptyCore
IMark	vcglib/vcg/simplex/face/component.h	/^  inline int &IMark()       { assert(0); static int tmp=-1; return tmp;}$/;"	f	class:vcg::face::EmptyCore
IMark	vcglib/vcg/simplex/face/component.h	/^  inline int &IMark()       { return _imark;}$/;"	f	class:vcg::face::Mark
IMark	vcglib/vcg/simplex/face/component_occ.h	/^		int &IMark() {return CAT< vector_occ<FaceType>,MarkType>::Instance()->Get((MarkType*)this);}$/;"	f	class:vcg::face::MarkOcc
IMark	vcglib/vcg/simplex/face/component_ocf.h	/^  inline int &IMark()       {$/;"	f	class:vcg::face::MarkOcf
IMark	vcglib/vcg/simplex/tetrahedron/component.h	/^  inline const int & IMark() const {return _imark;}$/;"	f	class:vcg::tetra::Mark
IMark	vcglib/vcg/simplex/tetrahedron/component.h	/^  inline const int IMark() const {return 0;}$/;"	f	class:vcg::tetra::EmptyMark
IMark	vcglib/vcg/simplex/tetrahedron/component.h	/^  inline int & IMark()       { assert(0); static int tmp=-1; return tmp;}$/;"	f	class:vcg::tetra::EmptyMark
IMark	vcglib/vcg/simplex/tetrahedron/component.h	/^  inline int & IMark()       { return _imark;}$/;"	f	class:vcg::tetra::Mark
IMark	vcglib/vcg/simplex/vertex/component.h	/^  inline       int &IMark()       { return _imark;}$/;"	f	class:vcg::vertex::Mark
IMark	vcglib/vcg/simplex/vertex/component.h	/^  inline const int &IMark() const { return _imark;}$/;"	f	class:vcg::vertex::Mark
IMark	vcglib/vcg/simplex/vertex/component.h	/^  int &IMark()        { assert(0); static int tmp=-1; return tmp;}$/;"	f	class:vcg::vertex::EmptyCore
IMark	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline       int &IMark()       { assert((*this).Base().MarkEnabled);  return (*this).Base().MV[(*this).Index()];   }$/;"	f	class:vcg::vertex::MarkOcf
IMark	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline const int &IMark() const { assert((*this).Base().MarkEnabled);  return (*this).Base().MV[(*this).Index()];   }$/;"	f	class:vcg::vertex::MarkOcf
INCLUDE_UNREFERENCED_VERTICES	vcglib/apps/metro/sampling.h	/^						INCLUDE_UNREFERENCED_VERTICES		= 0x0200,$/;"	e	enum:vcg::SamplingFlags::__anon1
INFLATE_PERCENTAGE	vcglib/apps/metro/metro.cpp	/^#define INFLATE_PERCENTAGE	/;"	d	file:
INFLATE_PERCENTAGE	vcglib/apps/trimeshinfo/defs.h	/^#define INFLATE_PERCENTAGE /;"	d
INFLATE_PERCENTAGE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define INFLATE_PERCENTAGE	/;"	d
INITIAL_LOCK	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define INITIAL_LOCK(/;"	d	file:
INSECURE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define INSECURE /;"	d	file:
INSTANCES_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		INSTANCES_NODE=		9;$/;"	v
INSTANCE_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		INSTANCE_NODE=			10;$/;"	v
INUSE_BITS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define INUSE_BITS /;"	d	file:
INVALID_MATRIXBASE_TEMPLATE_PARAMETERS	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIXBASE_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
INVALID_MATRIX_PRODUCT	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
INVALID_MATRIX_TEMPLATE_PARAMETERS	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
IOFormat	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  IOFormat(int _precision = StreamPrecision, int _flags = 0,$/;"	f	struct:Eigen::IOFormat
IOFormat	vcglib/eigenlib/Eigen/src/Core/IO.h	/^struct IOFormat$/;"	s	namespace:Eigen
IOM_ALL	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_ALL          = 0xFFFFF$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_BITPOLYGONAL	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_BITPOLYGONAL = 0x20000, \/\/ loads explicit polygonal mesh$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_CAMERA	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_CAMERA       = 0x08000,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_EDGEINDEX	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_EDGEINDEX    = 0x80000,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_FACECOLOR	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_FACECOLOR    = 0x00100,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_FACEFLAGS	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_FACEFLAGS    = 0x00080,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_FACEINDEX	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_FACEINDEX    = 0x00040,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_FACENORMAL	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_FACENORMAL   = 0x00400,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_FACEQUALITY	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_FACEQUALITY  = 0x00200,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_FLAGS	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_FLAGS        = IOM_VERTFLAGS + IOM_FACEFLAGS,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_NONE	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_NONE         = 0x00000,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_VERTCOLOR	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_VERTCOLOR    = 0x00004,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_VERTCOORD	vcglib/wrap/io_trimesh/io_mask.h	/^  IOM_VERTCOORD    = 0x00001,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_VERTFLAGS	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_VERTFLAGS    = 0x00002,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_VERTNORMAL	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_VERTNORMAL   = 0x00010,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_VERTQUALITY	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_VERTQUALITY  = 0x00008,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_VERTRADIUS	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_VERTRADIUS   = 0x10000,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_VERTTEXCOORD	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_VERTTEXCOORD = 0x00020,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_WEDGCOLOR	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_WEDGCOLOR    = 0x00800,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_WEDGNORMAL	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_WEDGNORMAL   = 0x04000,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_WEDGTEXCOORD	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_WEDGTEXCOORD = 0x01000,$/;"	e	enum:vcg::tri::io::Mask::__anon524
IOM_WEDGTEXMULTI	vcglib/wrap/io_trimesh/io_mask.h	/^	IOM_WEDGTEXMULTI = 0x02000, \/\/ when textrue index is explicit$/;"	e	enum:vcg::tri::io::Mask::__anon524
IO_FAN_TESSELLATOR_H	vcglib/wrap/io_trimesh/io_fan_tessellator.h	/^#define IO_FAN_TESSELLATOR_H$/;"	d
IPfToPf	vcglib/vcg/space/index/grid_util.h	/^	inline void IPfToPf(const CoordType & pi, CoordType &p ) const$/;"	f	class:vcg::BasicGrid
IPfToPf	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		inline void IPfToPf(const CoordType & pi, CoordType &p ) const$/;"	f	class:vcg::BasicGrid2D
IPiToBox	vcglib/vcg/space/index/grid_util.h	/^	inline void IPiToBox(const Point3i & pi, Box3x & b ) const$/;"	f	class:vcg::BasicGrid
IPiToBox	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		inline void IPiToBox(const Point2i & pi, Box2x & b ) const$/;"	f	class:vcg::BasicGrid2D
IPiToBoxCenter	vcglib/vcg/space/index/grid_util.h	/^	 *\/inline void IPiToBoxCenter(const Point3i & pi, CoordType & c ) const$/;"	f	class:vcg::BasicGrid
IPiToBoxCenter	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		*\/inline void IPiToBoxCenter(const Point2i & pi, CoordType & c ) const$/;"	f	class:vcg::BasicGrid2D
IPiToPf	vcglib/vcg/space/index/grid_util.h	/^	inline void IPiToPf(const Point3i & pi, CoordType &p ) const$/;"	f	class:vcg::BasicGrid
IPiToPf	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		inline void IPiToPf(const Point2i & pi, CoordType &p ) const$/;"	f	class:vcg::BasicGrid2D
ISOMETRIC	vcglib/vcg/math/camera.h	/^        ISOMETRIC	=   2,$/;"	e	enum:vcg::Camera::__anon485
ISize	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  const Point3i &ISize() {return sz;};   \/\/\/ Dimensioni griglia come numero di celle per lato$/;"	f	class:vcg::SimpleVolume
ISize	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  const Point3i &ISize() {return sz;}   \/\/\/ Dimensioni griglia come numero di celle per lato$/;"	f	class:vcg::SimpleVolume
ITERATIVE	vcglib/wrap/miq/MIQ.h	/^  enum StiffMode{NO_STIFF = 0,GAUSSIAN = 1,ITERATIVE = 2};$/;"	e	enum:MIQ_parametrization::StiffMode
I_K_PI	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^            static int I_K_PI(const CoordType &a, const CoordType &b, const CoordType &n)$/;"	f	class:vcg::tri::CrossField
Icosahedron	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Icosahedron(IcoMeshType &in)$/;"	f	namespace:vcg::tri
Id	vcglib/vcg/container/container_allocation_table.h	/^static int & Id(){															\/\/ unique identifier of the istance$/;"	f	class:vcg::CATEntry
Id	vcglib/vcg/container/container_allocation_table.h	/^static int & Id(){$/;"	f	class:vcg::CATBase
IdentifyAndCollapseSmallestDiag	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static bool IdentifyAndCollapseSmallestDiag(MeshType &m){$/;"	f	class:vcg::tri::BitQuadOptimization
Identity	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity()$/;"	f	class:Eigen::MatrixBase
Identity	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity(Index rows, Index cols)$/;"	f	class:Eigen::MatrixBase
Identity	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline Quaternion Identity() { return Quaternion(1, 0, 0, 0); }$/;"	f	class:Eigen::Quaternion
Identity	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  static const typename MatrixType::IdentityReturnType Identity()$/;"	f	class:Eigen::Transform
Identity	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  static inline const AngleAxis Identity() { return AngleAxis(0, Vector3::UnitX()); }$/;"	f	class:Eigen::AngleAxis
Identity	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  static inline Quaternion<Scalar> Identity() { return Quaternion<Scalar>(1, 0, 0, 0); }$/;"	f	class:Eigen::QuaternionBase
Identity	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  static inline Rotation2D Identity() { return Rotation2D(0); }$/;"	f	class:Eigen::Rotation2D
Identity	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static const Transform Identity()$/;"	f	class:Eigen::Transform
Identity	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  static const Translation Identity() { return Translation(VectorType::Zero()); }$/;"	f	class:Eigen::Translation
Identity	vcglib/vcg/math/matrix44.h	/^	static inline const Matrix44 &Identity( )$/;"	f	class:vcg::Matrix44
IdentityPreconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner() {}$/;"	f	class:Eigen::IdentityPreconditioner
IdentityPreconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner(const MatrixType& ) {}$/;"	f	class:Eigen::IdentityPreconditioner
IdentityPreconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class IdentityPreconditioner$/;"	c	namespace:Eigen
IdentityReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_identity_op<Scalar>,Derived> IdentityReturnType;$/;"	t	class:Eigen::MatrixBase
Illuminant	vcglib/vcg/space/colorspace.h	/^	enum Illuminant$/;"	g	class:vcg::ColorSpace
ImagReturnType	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_imag_op<Scalar>, const Derived> ImagReturnType;$/;"	t
Image	vcglib/img/img_image.h	/^  Image() \/\/ creates a 0 x 0 image$/;"	f	class:img::Image
Image	vcglib/img/img_image.h	/^  Image(const Image<Channels,OtherScalarType,OtherSafe> &image) \/\/ templated copy constructor (deep copy)$/;"	f	class:img::Image
Image	vcglib/img/img_image.h	/^  Image(const Image<Channels,ScalarType,Safe> &image) \/\/ copy constructor (deep copy)$/;"	f	class:img::Image
Image	vcglib/img/img_image.h	/^  Image(int arg_width,int arg_height)$/;"	f	class:img::Image
Image	vcglib/img/img_image.h	/^class Image \/\/TODO: Safe=false prima di mettere in vcg$/;"	c	namespace:img
ImageException	vcglib/img/img_base.h	/^  ImageException():exception(),message("no message"){}$/;"	f	class:img::ImageException
ImageException	vcglib/img/img_base.h	/^  ImageException(const char *arg_message):exception(),message(arg_message){}$/;"	f	class:img::ImageException
ImageException	vcglib/img/img_base.h	/^class ImageException: public std::exception$/;"	c	namespace:img
ImageResultType	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    > ImageResultType;$/;"	t	class:Eigen::LU
ImageTag	vcglib/wrap/dae/colladaformat.h	/^		ImageTag(const QString& id,const QString& name)$/;"	f	class:Collada::Tags::ImageTag
ImageTag	vcglib/wrap/dae/colladaformat.h	/^	class ImageTag : public XMLTag$/;"	c	namespace:Collada::Tags
ImgAttributes	vcglib/img/img_attributes.h	/^  ImgAttributes()$/;"	f	class:img::ImgAttributes
ImgAttributes	vcglib/img/img_attributes.h	/^  ImgAttributes(const ImgAttributes<OtherScalarType>  &attributes)$/;"	f	class:img::ImgAttributes
ImgAttributes	vcglib/img/img_attributes.h	/^  ImgAttributes(const ImgAttributes<ScalarType>  &attributes)$/;"	f	class:img::ImgAttributes
ImgAttributes	vcglib/img/img_attributes.h	/^class ImgAttributes$/;"	c	namespace:img
Implicit	vcglib/apps/unsupported/extractors/extractor/Implicit.h	/^	Implicit() {};$/;"	f	class:Implicit
Implicit	vcglib/apps/unsupported/extractors/extractor/Implicit.h	/^class Implicit$/;"	c
ImplicitSphere	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	ImplicitSphere()$/;"	f	class:ImplicitSphere
ImplicitSphere	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	ImplicitSphere(const ImplicitSphere &sphere)$/;"	f	class:ImplicitSphere
ImplicitSphere	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	ImplicitSphere(vcg::Point3f &center, float radius)$/;"	f	class:ImplicitSphere
ImplicitSphere	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^class ImplicitSphere$/;"	c
Import	vcglib/vcg/math/eigen_matrix_addons.h	/^inline void Import(const MatrixBase<OtherDerived>& b)$/;"	f
Import	vcglib/vcg/math/matrix44.h	/^	template <class Q> void Import(const Matrix44<Q> &m) {$/;"	f	class:vcg::Matrix44
Import	vcglib/vcg/space/box.h	/^	inline void Import( const Box<N0,S0> & b )$/;"	f	class:vcg::Box
Import	vcglib/vcg/space/box3.h	/^    inline void Import( const Box3<Q> & b )$/;"	f	class:vcg::Box3
Import	vcglib/vcg/space/color4.h	/^	inline void Import(const Color4<Q> & b )$/;"	f	class:vcg::Color4
Import	vcglib/vcg/space/color4.h	/^	inline void Import(const Point4<Q> & b )$/;"	f	class:vcg::Color4
Import	vcglib/vcg/space/color4.h	/^inline void Color4<float>::Import(const Color4<unsigned char> &b)$/;"	f	class:vcg::Color4
Import	vcglib/vcg/space/color4.h	/^inline void Color4<unsigned char>::Import(const Color4<float> &b)$/;"	f	class:vcg::Color4
Import	vcglib/vcg/space/color4.h	/^inline void Color4<unsigned char>::Import(const Point4<float> &b)$/;"	f	class:vcg::Color4
Import	vcglib/vcg/space/deprecated_point.h	/^	inline void Import( const Point<N2,S2> & b )$/;"	f	class:vcg::ndim::Point
Import	vcglib/vcg/space/deprecated_point2.h	/^	inline void Import( const Point2<T> & b )$/;"	f	class:vcg::Point2
Import	vcglib/vcg/space/deprecated_point3.h	/^    inline void Import( const Point3<Q> & b )$/;"	f	class:vcg::Point3
Import	vcglib/vcg/space/deprecated_point4.h	/^	inline void Import( const Point4<Q> & b )$/;"	f	class:vcg::Point4
Import	vcglib/vcg/space/line2.h	/^	inline void Import( const Line2<Q,K> & b )$/;"	f	class:vcg::Line2
Import	vcglib/vcg/space/line3.h	/^	inline void Import( const Line3<Q,K> & b )$/;"	f	class:vcg::Line3
Import	vcglib/vcg/space/plane3.h	/^	inline void Import( const Plane3<Q,false> & b )$/;"	f	class:vcg::Plane3
Import	vcglib/vcg/space/ray2.h	/^	inline void Import( const Ray2<Q,K> & b )$/;"	f	class:vcg::Ray2
Import	vcglib/vcg/space/ray3.h	/^	inline void Import( const Ray3<Q,K> & b )$/;"	f	class:vcg::Ray3
Import	vcglib/vcg/space/segment2.h	/^	inline void Import( const Segment2<Q> & b )$/;"	f	class:vcg::Segment2
Import	vcglib/vcg/space/segment3.h	/^	inline void Import( const Segment3<Q> & b )$/;"	f	class:vcg::Segment3
ImportData	vcglib/vcg/complex/used_types.h	/^        void ImportData(const LeftV  & \/*left*\/ ) {}$/;"	f	struct:vcg::DummyTypes
ImportData	vcglib/vcg/connectors/hedge.h	/^	void ImportData(const LeftV  & \/* left *\/ ) { }$/;"	f	class:vcg::HEdgeTypeHolder
ImportData	vcglib/vcg/connectors/hedge_component.h	/^								void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::hedge::EmptyHEAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^				void ImportData(const LeftV  & left ) { this->V() = NULL; T::ImportData( left); }$/;"	f	class:vcg::hedge::HEAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^		void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::hedge::EmptyHHAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^		void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::hedge::EmptyHNextAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^		void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::hedge::EmptyHOppAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^		void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::hedge::EmptyHPrevAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^		void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::hedge::EmptyHVAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { Flags() = left.Flags(); T::ImportData( left); }$/;"	f	class:vcg::hedge::BitFlags
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { HHp() = NULL; T::ImportData( left); }$/;"	f	class:vcg::hedge::HHAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { IMark() = left.IMark(); T::ImportData( left); }$/;"	f	class:vcg::hedge::Mark
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::hedge::EmptyBitFlags
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::hedge::EmptyHFAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::hedge::EmptyMark
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { this->EEp() = NULL; T::ImportData( left); }$/;"	f	class:vcg::hedge::HNextAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { this->EEp() = NULL; T::ImportData( left); }$/;"	f	class:vcg::hedge::HPrevAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { this->EFp() = NULL; T::ImportData( left); }$/;"	f	class:vcg::hedge::HFAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { this->HOp() = NULL; T::ImportData( left); }$/;"	f	class:vcg::hedge::HOppAdj
ImportData	vcglib/vcg/connectors/hedge_component.h	/^	void ImportData(const LeftV  & left ) { this->V() = NULL; T::ImportData( left); }$/;"	f	class:vcg::hedge::HVAdj
ImportData	vcglib/vcg/simplex/edge/base.h	/^	void ImportData(const LeftV  & \/* left *\/ ) { }$/;"	f	class:vcg::EdgeTypeHolder
ImportData	vcglib/vcg/simplex/edge/component.h	/^	void ImportData(const LeftF & leftF){ T::ImportData(leftF);}$/;"	f	class:vcg::edge::VertexRef
ImportData	vcglib/vcg/simplex/edge/component.h	/^	void ImportData(const LeftV  & left ) {  T::ImportData( left); }$/;"	f	class:vcg::edge::EEAdj
ImportData	vcglib/vcg/simplex/edge/component.h	/^	void ImportData(const LeftV  & left ) {  T::ImportData( left); }$/;"	f	class:vcg::edge::VEAdj
ImportData	vcglib/vcg/simplex/edge/component.h	/^	void ImportData(const LeftV  & left ) { C() = left.cC(); T::ImportData( left); }$/;"	f	class:vcg::edge::Color
ImportData	vcglib/vcg/simplex/edge/component.h	/^	void ImportData(const LeftV  & left ) { Flags() = left.Flags(); T::ImportData( left); }$/;"	f	class:vcg::edge::BitFlags
ImportData	vcglib/vcg/simplex/edge/component.h	/^	void ImportData(const LeftV  & left ) { Q() = left.cQ(); TT::ImportData( left); }$/;"	f	class:vcg::edge::Quality
ImportData	vcglib/vcg/simplex/edge/component.h	/^	void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::edge::EHAdj
ImportData	vcglib/vcg/simplex/edge/component.h	/^    void ImportData(const LeftF & leftF) {T::ImportData(leftF);}$/;"	f	class:vcg::edge::EmptyCore
ImportData	vcglib/vcg/simplex/edge/component.h	/^    void ImportData(const LeftV  & left ) { IMark() = left.IMark(); T::ImportData( left); }$/;"	f	class:vcg::edge::Mark
ImportData	vcglib/vcg/simplex/edge/component.h	/^  void ImportData(const LeftV  & left ) {  T::ImportData( left); }$/;"	f	class:vcg::edge::EFAdj
ImportData	vcglib/vcg/simplex/face/base.h	/^	void ImportData(const LeftF & ){}$/;"	f	class:vcg::FaceTypeHolder
ImportData	vcglib/vcg/simplex/face/component.h	/^    void ImportData(const RightValueType & rightF){$/;"	f	class:vcg::face::Quality
ImportData	vcglib/vcg/simplex/face/component.h	/^    void ImportData(const RightValueType & rightF){T::ImportData(rightF);}$/;"	f	class:vcg::face::VFAdj
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType  & rightF ) {$/;"	f	class:vcg::face::CurvatureDir
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF) {T::ImportData(rightF);}$/;"	f	class:vcg::face::EmptyCore
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF)$/;"	f	class:vcg::face::NormalAbs
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){  T::ImportData(rightF);}$/;"	f	class:vcg::face::VertexRef
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){ if(RightValueType::HasWedgeNormal()) for (int i=0; i<3; ++i) { WN(i) = rightF.cWN(i); } T::ImportData(rightF);}$/;"	f	class:vcg::face::WedgeRealNormal
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){ if(rightF.IsWedgeNormalEnabled()) for (int i=0; i<3; ++i) { WN(i) = rightF.cWN(i); } T::ImportData(rightF);}$/;"	f	class:vcg::face::WedgeNormal
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){$/;"	f	class:vcg::face::BitFlags
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){$/;"	f	class:vcg::face::Color
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){$/;"	f	class:vcg::face::Mark
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){$/;"	f	class:vcg::face::Quality3
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){$/;"	f	class:vcg::face::WedgeColor
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){$/;"	f	class:vcg::face::WedgeTexCoord
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){T::ImportData(rightF);}$/;"	f	class:vcg::face::EFAdj
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){T::ImportData(rightF);}$/;"	f	class:vcg::face::FEAdj
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){T::ImportData(rightF);}$/;"	f	class:vcg::face::FFAdj
ImportData	vcglib/vcg/simplex/face/component.h	/^  void ImportData(const RightValueType & rightF){T::ImportData(rightF);}$/;"	f	class:vcg::face::FHAdj
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^	void ImportData(const RightFaceType & rightF){$/;"	f	class:vcg::face::VFAdjOcf
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^  void ImportData(const RightFaceType & rightF){$/;"	f	class:vcg::face::ColorOcf
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^  void ImportData(const RightFaceType & rightF){$/;"	f	class:vcg::face::CurvatureDirOcf
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^  void ImportData(const RightFaceType & rightF){$/;"	f	class:vcg::face::FFAdjOcf
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^  void ImportData(const RightFaceType & rightF){$/;"	f	class:vcg::face::MarkOcf
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^  void ImportData(const RightFaceType & rightF){$/;"	f	class:vcg::face::NormalOcf
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^  void ImportData(const RightFaceType & rightF){$/;"	f	class:vcg::face::QualityOcf
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^  void ImportData(const RightFaceType & rightF){$/;"	f	class:vcg::face::WedgeColorOcf
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^  void ImportData(const RightFaceType & rightF){$/;"	f	class:vcg::face::WedgeNormalOcf
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^  void ImportData(const RightFaceType & rightF){$/;"	f	class:vcg::face::WedgeTexCoordOcf
ImportData	vcglib/vcg/simplex/face/component_ocf.h	/^  void ImportData(const RightFaceType & rightF){T::ImportData(rightF);}$/;"	f	class:vcg::face::InfoOcf
ImportData	vcglib/vcg/simplex/face/component_polygon.h	/^  void ImportData(const LeftF & leftF){  T::ImportData(leftF);}$/;"	f	class:vcg::face::PFVAdj
ImportData	vcglib/vcg/simplex/face/component_polygon.h	/^  void ImportData(const LeftF & leftF){T::ImportData(leftF);}$/;"	f	class:vcg::face::PFEAdj
ImportData	vcglib/vcg/simplex/face/component_polygon.h	/^  void ImportData(const LeftF & leftF){T::ImportData(leftF);}$/;"	f	class:vcg::face::PFFAdj
ImportData	vcglib/vcg/simplex/face/component_polygon.h	/^  void ImportData(const LeftF & leftF){T::ImportData(leftF);}$/;"	f	class:vcg::face::PFHAdj
ImportData	vcglib/vcg/simplex/face/component_polygon.h	/^  void ImportData(const LeftF & leftF){T::ImportData(leftF);}$/;"	f	class:vcg::face::PVFAdj
ImportData	vcglib/vcg/simplex/vertex/component.h	/^	void ImportData(const RightValueType  & rVert ) {  T::ImportData( rVert); }$/;"	f	class:vcg::vertex::VHAdj
ImportData	vcglib/vcg/simplex/vertex/component.h	/^	void ImportData(const RightValueType  & rVert ) {$/;"	f	class:vcg::vertex::CurvatureDir
ImportData	vcglib/vcg/simplex/vertex/component.h	/^          void ImportData(const RightValueType  & rVert ) {$/;"	f	class:vcg::vertex::Curvature
ImportData	vcglib/vcg/simplex/vertex/component.h	/^    void ImportData(const RightValueType  & rVert ) { T::ImportData( rVert); }$/;"	f	class:vcg::vertex::VFAdj
ImportData	vcglib/vcg/simplex/vertex/component.h	/^    void ImportData(const RightValueType  & rVert ) { if(rVert.IsRadiusEnabled()) R() = rVert.cR(); TT::ImportData( rVert); }$/;"	f	class:vcg::vertex::Radius
ImportData	vcglib/vcg/simplex/vertex/component.h	/^    void ImportData(const RightValueType  & rVert ) { if(rVert.IsTexCoordEnabled())  T() = rVert.cT(); TT::ImportData( rVert); }$/;"	f	class:vcg::vertex::TexCoord
ImportData	vcglib/vcg/simplex/vertex/component.h	/^  void ImportData(const RightValueType  & \/*rVert*\/ ) {$/;"	f	class:vcg::vertex::EmptyCore
ImportData	vcglib/vcg/simplex/vertex/component.h	/^  void ImportData(const RightValueType  & rVert ) {  T::ImportData( rVert); }$/;"	f	class:vcg::vertex::VEAdj
ImportData	vcglib/vcg/simplex/vertex/component.h	/^  void ImportData(const RightValueType  & rVert ) { if(RightValueType::HasFlags()) Flags() = rVert.cFlags(); T::ImportData( rVert); }$/;"	f	class:vcg::vertex::BitFlags
ImportData	vcglib/vcg/simplex/vertex/component.h	/^  void ImportData(const RightValueType  & rVert ) { if(rVert.IsColorEnabled()) C() = rVert.cC();  T::ImportData( rVert); }$/;"	f	class:vcg::vertex::Color
ImportData	vcglib/vcg/simplex/vertex/component.h	/^  void ImportData(const RightValueType  & rVert ) { if(rVert.IsCoordEnabled()) P().Import(rVert.cP()); T::ImportData( rVert); }$/;"	f	class:vcg::vertex::Coord
ImportData	vcglib/vcg/simplex/vertex/component.h	/^  void ImportData(const RightValueType  & rVert ) { if(rVert.IsMarkEnabled())  IMark() = rVert.cIMark(); T::ImportData( rVert); }$/;"	f	class:vcg::vertex::Mark
ImportData	vcglib/vcg/simplex/vertex/component.h	/^  void ImportData(const RightValueType  & rVert ) { if(rVert.IsQualityEnabled()) Q() = rVert.cQ(); TT::ImportData( rVert); }$/;"	f	class:vcg::vertex::Quality
ImportData	vcglib/vcg/simplex/vertex/component.h	/^  void ImportData(const RightValueType  & rVert ){$/;"	f	class:vcg::vertex::Normal
ImportData	vcglib/vcg/simplex/vertex/component_occ.h	/^	void ImportData(const LeftV & leftV){$/;"	f	class:vcg::vertex::CurvatureOcc
ImportData	vcglib/vcg/simplex/vertex/component_occ.h	/^	void ImportData(const LeftV & leftV){$/;"	f	class:vcg::vertex::RadiusOcc
ImportData	vcglib/vcg/simplex/vertex/component_ocf.h	/^    void ImportData(const RightVertexType & rightV)$/;"	f	class:vcg::vertex::VFAdjOcf
ImportData	vcglib/vcg/simplex/vertex/component_ocf.h	/^  void ImportData(const RightVertexType & rightV)$/;"	f	class:vcg::vertex::ColorOcf
ImportData	vcglib/vcg/simplex/vertex/component_ocf.h	/^  void ImportData(const RightVertexType & rightV)$/;"	f	class:vcg::vertex::MarkOcf
ImportData	vcglib/vcg/simplex/vertex/component_ocf.h	/^  void ImportData(const RightVertexType & rightV)$/;"	f	class:vcg::vertex::QualityOcf
ImportData	vcglib/vcg/simplex/vertex/component_ocf.h	/^  void ImportData(const RightVertexType & rightV)$/;"	f	class:vcg::vertex::RadiusOcf
ImportData	vcglib/vcg/simplex/vertex/component_ocf.h	/^  void ImportData(const RightVertexType & rightV)$/;"	f	class:vcg::vertex::TexCoordOcf
ImportData	vcglib/vcg/simplex/vertex/component_ocf.h	/^  void ImportData(const RightVertexType & rightV){$/;"	f	class:vcg::vertex::CurvatureDirOcf
ImportData	vcglib/vcg/simplex/vertex/component_ocf.h	/^  void ImportData(const RightVertexType & rightV){$/;"	f	class:vcg::vertex::CurvatureOcf
ImportData	vcglib/vcg/simplex/vertex/component_ocf.h	/^  void ImportData(const RightVertexType & rightV){$/;"	f	class:vcg::vertex::NormalOcf
ImportData	vcglib/vcg/simplex/vertex/component_sph.h	/^	void ImportData(const LeftV  & left ) { T::ImportData( left); }$/;"	f	class:vcg::vertex::Sph
ImportEdgeAdj	vcglib/vcg/complex/append.h	/^ static void ImportEdgeAdj(MeshLeft &ml, ConstMeshRight &mr, EdgeLeft &el, const EdgeRight &er, Remap &remap)$/;"	f	class:vcg::tri::Append
ImportFaceAdj	vcglib/vcg/complex/append.h	/^ static void ImportFaceAdj(MeshLeft &ml, ConstMeshRight &mr, FaceLeft &fl, const FaceRight &fr, Remap &remap )$/;"	f	class:vcg::tri::Append
ImportFromPolyMesh	vcglib/vcg/complex/algorithms/polygon_support.h	/^	static void ImportFromPolyMesh(TriMeshType & tm,  PolyMeshType & pm){$/;"	f	struct:vcg::tri::PolygonSupport
ImportFromTriMesh	vcglib/vcg/complex/algorithms/polygon_support.h	/^	static void ImportFromTriMesh( PolyMeshType & pm,  TriMeshType & tm){$/;"	f	struct:vcg::tri::PolygonSupport
ImportHEdgeAdj	vcglib/vcg/complex/append.h	/^ static void ImportHEdgeAdj(MeshLeft &ml, ConstMeshRight &mr, HEdgeLeft &hl, const HEdgeRight &hr, Remap &remap, bool \/*sel*\/ ){$/;"	f	class:vcg::tri::Append
ImportHomo	vcglib/vcg/math/eigen_matrix_addons.h	/^inline void ImportHomo(const MatrixBase<OtherDerived>& b)$/;"	f
ImportHomo	vcglib/vcg/space/deprecated_point.h	/^	inline void ImportHomo( const Point<N-1,S2> & b )$/;"	f	class:vcg::ndim::Point
ImportMesh	vcglib/wrap/io_trimesh/import_fbx.h	/^	static int ImportMesh(OpenMeshType& m,KFbxNode* node,const KFbxXMatrix& mat,Info& oi)$/;"	f	class:ImporterFBX
ImportNode	vcglib/wrap/io_trimesh/import_fbx.h	/^	static int ImportNode(OpenMeshType& m,KFbxNode* node,KFbxPose* pose,KFbxXMatrix* globPosMat,Info &oi)$/;"	f	class:ImporterFBX
ImportScene	vcglib/wrap/io_trimesh/import_fbx.h	/^	static int ImportScene(OpenMeshType& m,KFbxScene* scene,Info &oi)$/;"	f	class:ImporterFBX
ImportVertexAdj	vcglib/vcg/complex/append.h	/^ static void ImportVertexAdj(MeshLeft &ml, ConstMeshRight &mr, VertexLeft &vl,   VertexRight &vr, Remap &remap ){$/;"	f	class:vcg::tri::Append
Importance	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static ScalarType Importance(const CoordType  &p){$/;"	f	class:vcg::tri::BitQuadOptimization
Importer	vcglib/wrap/io_trimesh/import.h	/^class Importer$/;"	c	namespace:vcg::tri::io
ImporterASC	vcglib/wrap/io_trimesh/import_asc.h	/^class ImporterASC$/;"	c	namespace:vcg::tri::io
ImporterCTM	vcglib/wrap/io_trimesh/import_ctm.h	/^class ImporterCTM$/;"	c	namespace:vcg::tri::io
ImporterDAE	vcglib/wrap/io_trimesh/import_dae.h	/^	class ImporterDAE : public UtilDAE$/;"	c	namespace:vcg::tri::io
ImporterFBX	vcglib/wrap/io_trimesh/import_fbx.h	/^class ImporterFBX$/;"	c
ImporterFIELD	vcglib/wrap/io_trimesh/import_field.h	/^class ImporterFIELD$/;"	c	namespace:vcg::tri::io
ImporterGTS	vcglib/wrap/io_trimesh/import_gts.h	/^			class ImporterGTS$/;"	c	namespace:vcg::tri::io
ImporterNVM	vcglib/wrap/io_trimesh/import_nvm.h	/^class ImporterNVM$/;"	c	namespace:vcg::tri::io
ImporterOBJ	vcglib/wrap/io_trimesh/import_obj.h	/^            class ImporterOBJ$/;"	c	namespace:vcg::tri::io
ImporterOFF	vcglib/wrap/io_trimesh/import_off.h	/^class ImporterOFF$/;"	c	namespace:vcg::tri::io
ImporterOUT	vcglib/wrap/io_trimesh/import_out.h	/^class ImporterOUT$/;"	c	namespace:vcg::tri::io
ImporterPLY	vcglib/wrap/io_tetramesh/import_ply.h	/^class ImporterPLY$/;"	c	namespace:vcg::tetra::io
ImporterPLY	vcglib/wrap/io_trimesh/import_ply.h	/^class ImporterPLY$/;"	c	namespace:vcg::tri::io
ImporterPTX	vcglib/wrap/io_trimesh/import_ptx.h	/^	class ImporterPTX$/;"	c	namespace:vcg::tri::io
ImporterRAW	vcglib/wrap/io_trimesh/import_raw.h	/^class ImporterRAW$/;"	c	namespace:vcg::tri::io
ImporterSMF	vcglib/wrap/io_trimesh/import_smf.h	/^	class ImporterSMF$/;"	c	namespace:vcg::tri::io
ImporterSTL	vcglib/wrap/io_trimesh/import_stl.h	/^class ImporterSTL$/;"	c	namespace:vcg::tri::io
ImporterTS	vcglib/wrap/io_tetramesh/import_ts.h	/^class ImporterTS{$/;"	c	namespace:vcg::tetra::io
ImporterVMI	vcglib/wrap/io_trimesh/import_vmi.h	/^    class ImporterVMI: public AttrAll<OpenMeshType,A0,A1,A2,A3,A4>$/;"	c	namespace:vcg::tri::io
ImproperInputParameters	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        ImproperInputParameters = 0,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
ImproperInputParameters	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        ImproperInputParameters = 0,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
InRegion	vcglib/vcg/complex/algorithms/clip.h	/^	static inline unsigned int InRegion(int mode, const ScalarType & value, const CoordType & p_in)$/;"	f	class:vcg::tri::TriMeshClipper
In_mem	vcglib/wrap/io_trimesh/import_vmi.h	/^        static const char * & In_mem(){static const char *    in_mem; return in_mem;}$/;"	f	class:vcg::tri::io::ImporterVMI
In_mode	vcglib/wrap/io_trimesh/import_vmi.h	/^        static unsigned int & In_mode(){static unsigned int  in_mode = 0; return in_mode;}$/;"	f	class:vcg::tri::io::ImporterVMI
InactiveMode	vcglib/wrap/gui/trackmode.h	/^class InactiveMode:public TrackMode {$/;"	c	namespace:vcg
IncompleteLU	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    IncompleteLU() : m_isInitialized(false) {}$/;"	f	class:Eigen::IncompleteLU
IncompleteLU	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    IncompleteLU(const MatrixType& mat) : m_isInitialized(false)$/;"	f	class:Eigen::IncompleteLU
IncompleteLU	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^class IncompleteLU$/;"	c	namespace:Eigen
IncompleteLUT	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT()$/;"	f	class:Eigen::IncompleteLUT
IncompleteLUT	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT(const MatrixType& mat, RealScalar droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)$/;"	f	class:Eigen::IncompleteLUT
IncompleteLUT	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^class IncompleteLUT : internal::noncopyable$/;"	c	namespace:Eigen
IncreaseValency	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void IncreaseValency(VertexType *v, int dv=1){$/;"	f	class:vcg::tri::BitQuad
IncrementMark	vcglib/vcg/space/index/octree.h	/^        inline void IncrementMark()$/;"	f	class:vcg::Octree
IndToVertex	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    std::map<int, VertexType*> IndToVertex;$/;"	m	class:vcg::tri::PoissonSolver
Index	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LDLT
Index	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LLT
Index	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::CholmodBase
Index	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::ArrayBase
Index	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::assign_impl
Index	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::vml_assign_impl
Index	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::internal::TridiagonalMatrix
Index	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef typename DenseMatrixType::Index Index;$/;"	t	class:Eigen::internal::BandMatrixBase
Index	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Index Index;$/;"	t	class:Eigen::internal::BandMatrix
Index	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Index Index;$/;"	t	class:Eigen::internal::BandMatrixWrapper
Index	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::CommaInitializer
Index	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::setIdentity_impl
Index	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Index Index; $/;"	t	class:Eigen::DenseBase
Index	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DenseCoeffsBase
Index	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DiagonalBase
Index	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::Index Index;$/;"	t	class:Eigen::DiagonalMatrix
Index	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::Index Index;$/;"	t	struct:Eigen::EigenBase
Index	vcglib/eigenlib/Eigen/src/Core/Map.h	/^  typedef typename PlainObjectType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::MapBase
Index	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MapBase
Index	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MatrixBase
Index	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map
Index	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PermutationBase
Index	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::PlainObjectBase
Index	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::conservative_resize_like_impl
Index	vcglib/eigenlib/Eigen/src/Core/Product.h	/^                                      typename traits<RhsCleaned>::Index>::type Index;$/;"	t	struct:internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::redux_impl
Index	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointView
Index	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector
Index	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::triangular_solve_retval
Index	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Index Index;$/;"	t	struct:Eigen::internal::triangular_solver_selector
Index	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::InnerStride
Index	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::OuterStride
Index	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::Stride
Index	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map
Index	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Transpositions
Index	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsBase
Index	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsWrapper
Index	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename TranspositionType::Index Index;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval
Index	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::TriangularBase
Index	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Index Index;$/;"	t	class:Eigen::TriangularView
Index	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector
Index	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Index Index;$/;"	t	class:Eigen::VectorwiseOp
Index	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::coeff_visitor
Index	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::max_coeff_visitor
Index	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::min_coeff_visitor
Index	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::visitor_impl
Index	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_impl
Index	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_dyn_selector
Index	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_unroller
Index	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_packet_impl
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexEigenSolver
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexSchur
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::EigenSolver
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HessenbergDecomposition
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::RealSchur
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::Tridiagonalization
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
Index	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
Index	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  typedef DenseIndex                                Index;$/;"	t	class:Eigen::AlignedBox
Index	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
Index	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl
Index	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Hyperplane
Index	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
Index	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::ParametrizedLine
Index	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl
Index	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Transform
Index	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename VectorsType::Index Index;$/;"	t	class:Eigen::HouseholderSequence
Index	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
Index	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef typename Vector::Index Index;$/;"	t	class:Eigen::DiagonalPreconditioner
Index	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::BiCGSTAB
Index	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ConjugateGradient
Index	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename FactorType::Index Index;$/;"	t	class:Eigen::IncompleteLUT
Index	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::IterativeSolverBase
Index	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivLU
Index	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::inverse_impl
Index	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PartialPivLU
Index	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::partial_lu_impl
Index	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixBase
Index	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixLU
Index	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pastix_traits
Index	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef long long int Index;$/;"	t	struct:Eigen::internal::pardiso_run_selector
Index	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLDLT
Index	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLLT
Index	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PardisoImpl
Index	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;    $/;"	t	struct:Eigen::internal::pardiso_traits
Index	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pardiso_traits
Index	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ColPivHouseholderQR
Index	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivHouseholderQR
Index	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
Index	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HouseholderQR
Index	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::JacobiSVD
Index	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
Index	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename SVD::Index Index;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
Index	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Index	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholesky
Index	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholeskyBase
Index	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLDLT
Index	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLLT
Index	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                              Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                          Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::AmbiVector
Index	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::CompressedStorage
Index	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::DenseBase::InnerIterator
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef typename traits<MatrixType>::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::SparseMatrixBase
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSelfAdjointView
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  typedef int Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
Index	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperILU
Index	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperLU
Index	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SuperLUBase
Index	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::UmfPackLU
Index	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::image_retval_base
Index	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::kernel_retval_base
Index	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_base
Index	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base
Index	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  typedef typename DecompositionType::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_with_guess
Index	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef typename JacobianType::Index Index;$/;"	t	class:Eigen::AutoDiffJacobian
Index	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    typedef typename JacobianType::Index Index;$/;"	t	class:Eigen::AutoDiffVector
Index	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef int Index;$/;"	t	class:Eigen::KdBVH
Index	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::GMRES
Index	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef typename Vector::Index Index;$/;"	t	class:Eigen::IncompleteLU
Index	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Scaling
Index	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    typedef typename Derived::Index Index;$/;"	t	struct:Eigen::MatrixExponentialReturnValue
Index	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::MatrixFunctionReturnValue
Index	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::MatrixFunction
Index	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::MatrixFunctionAtomic
Index	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  typedef typename Derived::Index Index;$/;"	t	class:Eigen::MatrixLogarithmReturnValue
Index	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::MatrixSquareRootReturnValue
Index	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::MatrixSquareRootQuasiTriangular
Index	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::HybridNonLinearSolver
Index	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::LevenbergMarquardt
Index	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::internal::companion
Index	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::PolynomialSolverBase
Index	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SkylineInplaceLU
Index	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    typedef typename internal::index<StorageKind>::type Index;$/;"	t	class:Eigen::SkylineMatrixBase
Index	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    typedef SparseIndex Index;$/;"	t	class:Eigen::SkylineStorage
Index	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits
Index	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    typedef typename SparseMatrixType::Index Index;$/;"	t	class:Eigen::RandomSetter
Index	vcglib/vcg/complex/allocate.h	/^size_t Index(MeshType &m, const typename MeshType::EdgeType &e) {return &e-&*m.edge.begin();}$/;"	f	namespace:vcg::tri
Index	vcglib/vcg/complex/allocate.h	/^size_t Index(MeshType &m, const typename MeshType::EdgeType*  e) {return e-&*m.edge.begin();}$/;"	f	namespace:vcg::tri
Index	vcglib/vcg/complex/allocate.h	/^size_t Index(MeshType &m, const typename MeshType::FaceType &f) {return &f-&*m.face.begin();}$/;"	f	namespace:vcg::tri
Index	vcglib/vcg/complex/allocate.h	/^size_t Index(MeshType &m, const typename MeshType::FaceType * fp) {return fp-&*m.face.begin();}$/;"	f	namespace:vcg::tri
Index	vcglib/vcg/complex/allocate.h	/^size_t Index(MeshType &m, const typename MeshType::HEdgeType &h) {return &h-&*m.hedge.begin();}$/;"	f	namespace:vcg::tri
Index	vcglib/vcg/complex/allocate.h	/^size_t Index(MeshType &m, const typename MeshType::HEdgeType*  h) {return h-&*m.hedge.begin();}$/;"	f	namespace:vcg::tri
Index	vcglib/vcg/complex/allocate.h	/^size_t Index(MeshType &m, const typename MeshType::VertexType &v) {return &v-&*m.vert.begin();}$/;"	f	namespace:vcg::tri
Index	vcglib/vcg/complex/allocate.h	/^size_t Index(MeshType &m, const typename MeshType::VertexType *vp) {return vp-&*m.vert.begin();}$/;"	f	namespace:vcg::tri
Index	vcglib/vcg/simplex/face/component_ocf.h	/^  inline int Index() const {$/;"	f	class:vcg::face::InfoOcf
Index	vcglib/vcg/simplex/vertex/component_ocf.h	/^	inline int Index() const {$/;"	f	class:vcg::vertex::InfoOcf
Index	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline int & Index() {$/;"	f	class:vcg::GridStaticPtr::Link
Index	vcglib/wrap/opensg/vertex_component.h	/^	int & Index() { return _vertexi; }$/;"	f	class:vcg::vert::OSGInfo
IndexBufferBindingParams	vcglib/wrap/glw/buffer.h	/^		IndexBufferBindingParams(void)$/;"	f	class:glw::IndexBufferBindingParams
IndexBufferBindingParams	vcglib/wrap/glw/buffer.h	/^class IndexBufferBindingParams : public BufferBindingParams$/;"	c	namespace:glw
IndexInnerNodes	vcglib/vcg/space/index/octree.h	/^        void IndexInnerNodes(NodePointer n)$/;"	f	class:vcg::Octree
IndexOfRefractionTag	vcglib/wrap/dae/colladaformat.h	/^		IndexOfRefractionTag()$/;"	f	class:Collada::Tags::IndexOfRefractionTag
IndexOfRefractionTag	vcglib/wrap/dae/colladaformat.h	/^	class IndexOfRefractionTag : public XMLTag$/;"	c	namespace:Collada::Tags
IndexToVert	vcglib/wrap/miq/core/vertex_indexing.h	/^    std::vector<VertexType*> IndexToVert;$/;"	m	class:VertexIndexing
IndexType	vcglib/wrap/math/sparse_matrix.h	/^	typedef typename std::pair<int,int> IndexType;$/;"	t	class:SparseMatrix
IndexVertex	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    VertexType* IndexVertex(int index)$/;"	f	class:vcg::tri::PoissonSolver
IndexingBoxType	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename Spatial_Idexing::Box3x IndexingBoxType;$/;"	t	class:vcg::RayIterator
IndicesType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose
IndicesType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map
IndicesType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationBase
IndicesType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationMatrix
IndicesType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationWrapper
IndicesType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^  typedef Map<const Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^  typedef Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map
IndicesType	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Transpositions
IndicesType	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsBase
IndicesType	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsWrapper
IndicesType	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename TranspositionType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose
IndicesType	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^  typedef Map<const Matrix<Index,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^  typedef Matrix<Index, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits
Inertia	vcglib/vcg/complex/algorithms/inertia.h	/^ Inertia(MeshType &m) {Compute(m);}$/;"	f	class:vcg::tri::Inertia
Inertia	vcglib/vcg/complex/algorithms/inertia.h	/^class Inertia$/;"	c	namespace:vcg::tri
InertiaTensor	vcglib/vcg/complex/algorithms/inertia.h	/^void InertiaTensor(Eigen::Matrix3d &J )$/;"	f	class:vcg::tri::Inertia
InertiaTensor	vcglib/vcg/complex/algorithms/inertia.h	/^void InertiaTensor(Matrix33<ScalarType> &J ){$/;"	f	class:vcg::tri::Inertia
InertiaTensorEigen	vcglib/vcg/complex/algorithms/inertia.h	/^void InertiaTensorEigen(Matrix33<ScalarType> &EV, Point3<ScalarType> &ev )$/;"	f	class:vcg::tri::Inertia
Infinity	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const int Infinity = -1;$/;"	m	namespace:Eigen
Inflate	vcglib/vcg/space/box.h	/^	void Inflate( const PointType & delta )$/;"	f	class:vcg::Box
Inflate	vcglib/vcg/space/box.h	/^	void Inflate( const S s )$/;"	f	class:vcg::Box
InflateFix	vcglib/vcg/space/box.h	/^	void InflateFix( const S s )$/;"	f	class:vcg::Box
Info	vcglib/vcg/complex/algorithms/hole.h	/^            Info(){}$/;"	f	class:vcg::tri::Hole::Info
Info	vcglib/vcg/complex/algorithms/hole.h	/^            Info(PosType const &pHole, int  const pHoleSize, Box3<ScalarType> &pHoleBB)$/;"	f	class:vcg::tri::Hole::Info
Info	vcglib/vcg/complex/algorithms/hole.h	/^        class Info$/;"	c	class:vcg::tri::Hole
Info	vcglib/vcg/complex/algorithms/local_optimization.h	/^  virtual const char *Info(MeshType &) {return 0;}$/;"	f	class:vcg::LocalModification
Info	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            virtual const char *Info(MeshType &m)$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
Info	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  virtual const char *Info(TETRA_MESH_TYPE &m) {$/;"	f	class:vcg::tetra::TetraEdgeCollapse
Info	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  virtual const char *Info(TriMeshType &m) {$/;"	f	class:vcg::tri::TriEdgeCollapse
Info	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	const char* Info(TRIMESH_TYPE &m)$/;"	f	class:vcg::tri::PlanarEdgeFlip
Info	vcglib/wrap/io_trimesh/import_fbx.h	/^		Info()$/;"	f	class:ImporterFBX::Info
Info	vcglib/wrap/io_trimesh/import_fbx.h	/^	class Info$/;"	c	class:ImporterFBX
Info	vcglib/wrap/io_trimesh/import_obj.h	/^                    Info()$/;"	f	class:vcg::tri::io::ImporterOBJ::Info
Info	vcglib/wrap/io_trimesh/import_obj.h	/^                class Info$/;"	c	class:vcg::tri::io::ImporterOBJ
Info	vcglib/wrap/io_trimesh/import_ptx.h	/^			Info()$/;"	f	class:vcg::tri::io::ImporterPTX::Info
Info	vcglib/wrap/io_trimesh/import_ptx.h	/^		class Info		\/\/ptx file info$/;"	c	class:vcg::tri::io::ImporterPTX
InfoDAE	vcglib/wrap/dae/util_dae.h	/^		InfoDAE() :AdditionalInfo(){$/;"	f	class:vcg::tri::io::InfoDAE
InfoDAE	vcglib/wrap/dae/util_dae.h	/^	class InfoDAE  : public AdditionalInfo$/;"	c	namespace:vcg::tri::io
InfoLog	vcglib/wrap/gl/shaders.h	/^	std::string InfoLog(void)$/;"	f	class:Program
InfoLog	vcglib/wrap/gl/shaders.h	/^	std::string InfoLog(void)$/;"	f	class:Shader
InfoOcc	vcglib/vcg/simplex/face/component_occ.h	/^	template <class T> class InfoOcc: public InfoOccBase<int, T> {};$/;"	c	namespace:vcg::face
InfoOccBase	vcglib/vcg/simplex/face/component_occ.h	/^	template <class A, class T> class InfoOccBase: public T {$/;"	c	namespace:vcg::face
InfoOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template < class T> class InfoOcf: public T {$/;"	c	namespace:vcg::face
InfoOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template < class T> class InfoOcf: public T {$/;"	c	namespace:vcg::vertex
InfoType	vcglib/vcg/simplex/face/component_occ.h	/^		typedef A InfoType;$/;"	t	class:vcg::face::InfoOccBase
Init	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  void Init(Point3i _sz)$/;"	f	class:vcg::SimpleVolume
Init	vcglib/apps/unsupported/shadevis/visshader.h	/^	void Init()  {		VV.resize(m.vert.size()); }$/;"	f	class:vcg::VertexVisShader
Init	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^void FourPCS<MeshType>:: Init(MeshType &_P,MeshType &_Q)$/;"	f	class:vcg::tri::FourPCS
Init	vcglib/vcg/complex/algorithms/clustering.h	/^  void Init(Box3<ScalarType> _mbb, int _size, ScalarType _cellsize=0)$/;"	f	class:vcg::tri::Clustering
Init	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  void Init(Point3i _sz)$/;"	f	class:vcg::SimpleVolume
Init	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  void Init(VolumeType &volume)$/;"	f	class:vcg::tri::TrivialWalker
Init	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    void Init() { newPtMap.clear(); }$/;"	f	class:vcg::tri::CylinderClipping::CylPred
Init	vcglib/vcg/complex/algorithms/local_optimization.h	/^  template <class LocalModificationType> void Init()$/;"	f	class:vcg::LocalOptimization
Init	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            static void Init(MeshType &m,HeapType &h_ret)$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
Init	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	static void Init(TETRA_MESH_TYPE &m,typename LocalOptimization<TETRA_MESH_TYPE>::HeapType& h_ret){$/;"	f	class:vcg::tetra::TetraEdgeCollapse
Init	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  static void Init() $/;"	f	class:vcg::tri::TriEdgeCollapse::FailStat
Init	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  static void Init(TriMeshType &m, HeapType &h_ret, BaseParameterClass *pp)$/;"	f	class:vcg::tri::TriEdgeCollapse
Init	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^      static void Init(){}$/;"	f	class:vcg::tri::QInfoStandard
Init	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  static void Init(TriMeshType &m, HeapType &h_ret, BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
Init	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^        static void Init(){}$/;"	f	class:vcg::tri::QuadricTexHelper
Init	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    static void Init(TriMeshType &m,HeapType&h_ret,BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
Init	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  static void Init(TRIMESH_TYPE &m, HeapType &heap,BaseParameterClass *pp)$/;"	f	class:vcg::tri::TopoEdgeFlip
Init	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  static void Init(TRIMESH_TYPE &mesh, HeapType &heap, BaseParameterClass *pp)$/;"	f	class:vcg::tri::PlanarEdgeFlip
Init	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    bool Init(Parameters& param){$/;"	f	class:OverlapEstimation
Init	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void Init(bool _use_direction_field=false,$/;"	f	class:vcg::tri::PoissonSolver
Init	vcglib/vcg/complex/algorithms/symmetry.h	/^    void Init(bool OnlyBorder=false,$/;"	f	class:vcg::tri::ExtrinsicPlaneSymmetry
Init	vcglib/vcg/container/simple_temporary_data.h	/^    void Init(const ATTR_TYPE &val)$/;"	f	class:vcg::SimpleTempData
Init	vcglib/vcg/math/gen_normal.h	/^    void Init(int lev)$/;"	f	class:vcg::GenNormal::OctaLevel
Init	vcglib/vcg/space/index/grid_static_obj.h	/^	 inline void Init(const ObjType &val)$/;"	f	class:vcg::GridStaticObj
Init	vcglib/vcg/space/index/space_iterators.h	/^		void Init(CoordType _p,const ScalarType &_max_dist)$/;"	f	class:vcg::ClosestIterator
Init	vcglib/vcg/space/index/space_iterators.h	/^		void Init(const RayType _r)$/;"	f	class:vcg::RayIterator
Init	vcglib/vcg/space/plane3.h	/^  inline void Init(const PointType &p0, const PointType &norm) {$/;"	f	class:vcg::Plane3
Init	vcglib/vcg/space/plane3.h	/^  void Init(const PointType &p0, const PointType &p1, const PointType &p2) {$/;"	f	class:vcg::Plane3
Init	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>::Init(QGLWidget *gla)$/;"	f	class:SplatRenderer
Init	vcglib/wrap/gui/trackmode.cpp	/^void AreaMode::Init(const std::vector < Point3f > &pts)$/;"	f	class:AreaMode
Init	vcglib/wrap/gui/trackmode.cpp	/^void PathMode::Init(const std::vector < Point3f > &pts)$/;"	f	class:PathMode
Init	vcglib/wrap/miq/core/seams_initializer.h	/^    void Init(MeshType *_mesh,$/;"	f	class:SeamsInitializer
Init	vcglib/wrap/miq/core/vertex_indexing.h	/^    void Init(MeshType *_mesh){mesh=_mesh;AddAttributesIfNeeded();}$/;"	f	class:VertexIndexing
InitControl	vcglib/wrap/minpack/minpack.h	/^void InitControl(){lm_initialize_control();}$/;"	f	class:LMDiff
InitDebug	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    void InitDebug(const char * name1, const char * name2){$/;"	f	class:vcg::tri::FourPCS
InitDefaultStiffening	vcglib/wrap/miq/core/stiffening.h	/^    static void InitDefaultStiffening(MeshType & mesh)$/;"	f	class:StiffeningInitializer
InitEmpty	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void InitEmpty(const Box2x &_bbox, vcg::Point2i grid_size)$/;"	f	class:vcg::SpatialHashTable2D
InitEmpty	vcglib/vcg/space/index/spatial_hashing.h	/^		void InitEmpty(const Box3x &_bbox, vcg::Point3i grid_size)$/;"	f	class:vcg::SpatialHashTable
InitFaceIMark	vcglib/vcg/complex/base.h	/^template <class MeshType> inline  void InitFaceIMark(MeshType & m)$/;"	f	namespace:vcg::tri
InitFaceIntegerVal	vcglib/wrap/miq/core/vertex_indexing.h	/^    void InitFaceIntegerVal()$/;"	f	class:VertexIndexing
InitFromTag	vcglib/wrap/dae/colladaformat.h	/^		InitFromTag(const QString& txtpathname)$/;"	f	class:Collada::Tags::InitFromTag
InitFromTag	vcglib/wrap/dae/colladaformat.h	/^	class InitFromTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
InitGL	vcglib/apps/unsupported/shadevis/visshader.h	/^	void InitGL() $/;"	f	class:vcg::VisShader
InitIMark	vcglib/vcg/connectors/hedge_component.h	/^  inline void InitIMark()    {  }$/;"	f	class:vcg::hedge::EmptyMark
InitIMark	vcglib/vcg/connectors/hedge_component.h	/^  inline void InitIMark()    { _imark = 0; }$/;"	f	class:vcg::hedge::Mark
InitIMark	vcglib/vcg/simplex/edge/component.h	/^    inline void InitIMark()    {  }$/;"	f	class:vcg::edge::EmptyCore
InitIMark	vcglib/vcg/simplex/edge/component.h	/^    inline void InitIMark()    { _imark = 0; }$/;"	f	class:vcg::edge::Mark
InitIMark	vcglib/vcg/simplex/face/component.h	/^  inline void InitIMark()    {  }$/;"	f	class:vcg::face::EmptyCore
InitIMark	vcglib/vcg/simplex/face/component.h	/^  inline void InitIMark()    { _imark = 0; }$/;"	f	class:vcg::face::Mark
InitIMark	vcglib/vcg/simplex/face/component_occ.h	/^	  inline void InitIMark()    { IMark() = 0; }$/;"	f	class:vcg::face::MarkOcc
InitIMark	vcglib/vcg/simplex/face/component_ocf.h	/^  inline void InitIMark()    { IMark() = 0; }$/;"	f	class:vcg::face::MarkOcf
InitIMark	vcglib/vcg/simplex/tetrahedron/component.h	/^  inline void InitIMark()    {  }$/;"	f	class:vcg::tetra::EmptyMark
InitIMark	vcglib/vcg/simplex/tetrahedron/component.h	/^  inline void InitIMark()    { _imark = 0; }$/;"	f	class:vcg::tetra::Mark
InitIMark	vcglib/vcg/simplex/vertex/component.h	/^  inline void InitIMark()    { _imark = 0; }$/;"	f	class:vcg::vertex::Mark
InitIMark	vcglib/vcg/simplex/vertex/component.h	/^  void InitIMark()    {  }$/;"	f	class:vcg::vertex::EmptyCore
InitIMark	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline void InitIMark()    { IMark() = 0; }$/;"	f	class:vcg::vertex::MarkOcf
InitIndex	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void InitIndex()$/;"	f	class:vcg::tri::PoissonSolver
InitIntegerEdgesVert	vcglib/wrap/miq/quadrangulator.h	/^    void InitIntegerEdgesVert(TriMesh &Tmesh,$/;"	f	class:Quadrangulator
InitIntegerVectors	vcglib/wrap/miq/quadrangulator.h	/^    void InitIntegerVectors()$/;"	f	class:Quadrangulator
InitMMatch	vcglib/wrap/miq/core/seams_initializer.h	/^    void InitMMatch()$/;"	f	class:SeamsInitializer
InitMapping	vcglib/wrap/miq/core/vertex_indexing.h	/^    void InitMapping()$/;"	f	class:VertexIndexing
InitMappingSeam	vcglib/wrap/miq/core/vertex_indexing.h	/^    void InitMappingSeam()$/;"	f	class:VertexIndexing
InitMappingSeam	vcglib/wrap/miq/core/vertex_indexing.h	/^    void InitMappingSeam(VertexType *vert)$/;"	f	class:VertexIndexing
InitMatrix	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void InitMatrix()$/;"	f	class:vcg::tri::PoissonSolver
InitMatrix	vcglib/wrap/miq/core/poisson_solver.h	/^	void InitMatrix()$/;"	f	class:PoissonSolver
InitQuadric	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  static void InitQuadric(TriMeshType &m,BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
InitQuadric	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  static void InitQuadric(TriMeshType &m,BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
InitRandom	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^void InitRandom(int num,$/;"	f
InitSBuffer	vcglib/wrap/ply/plylib.cpp	/^static void InitSBuffer()$/;"	f	namespace:vcg::ply
InitSeamIndexes	vcglib/wrap/miq/core/seams_initializer.h	/^    void InitSeamIndexes()$/;"	f	class:SeamsInitializer
InitSeamInfo	vcglib/wrap/miq/core/vertex_indexing.h	/^    void InitSeamInfo()$/;"	f	class:VertexIndexing
InitSeamsSing	vcglib/wrap/miq/MIQ.h	/^  static void InitSeamsSing(MeshType &mesh,$/;"	f	class:MIQ_parametrization
InitSpatialHashTable	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void InitSpatialHashTable(MetroMesh &montecarloMesh, MontecarloSHT &montecarloSHT, ScalarType diskRadius,$/;"	f	class:vcg::tri::SurfaceSampling
InitSymmetricPlanes	vcglib/vcg/complex/algorithms/symmetry.h	/^    void InitSymmetricPlanes(const int SubN=4)$/;"	f	class:vcg::tri::ExtrinsicPlaneSymmetry
InitTopologycalCuts	vcglib/wrap/miq/core/seams_initializer.h	/^    int InitTopologycalCuts(){$/;"	f	class:SeamsInitializer
InitVertexIMark	vcglib/vcg/complex/base.h	/^template <class MeshType> inline  void InitVertexIMark(MeshType & m)$/;"	f	namespace:vcg::tri
InitVertexQuadMesh	vcglib/wrap/miq/quadrangulator.h	/^    void InitVertexQuadMesh(TriMesh &Tmesh)$/;"	f	class:Quadrangulator
Initalize	vcglib/wrap/math/sparse_matrix.h	/^virtual void Initalize(int dimension)$/;"	f	class:SparseMatrix
Initalize	vcglib/wrap/math/system_interface_ldl.h	/^void Initalize(int dimension)$/;"	f	class:SystemLDL
Initialize	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            void Initialize()$/;"	f	class:vcg::tri::ExtendedMarchingCubes
Initialize	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            void Initialize()$/;"	f	class:vcg::tri::MarchingCubes
Initialize	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	static inline void Initialize(TreeType & tree) {$/;"	f	class:vcg::AABBBinaryTreeFrustumCull
Initialize	vcglib/vcg/space/index/octree_template.h	/^	void Initialize(int maximumDepth)$/;"	f	class:vcg::OctreeTemplate
InitializeFrustumCull	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	inline void InitializeFrustumCull(void) {$/;"	f	class:vcg::AABBBinaryTreeIndex
InitializeNodeFlagsRec	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	static inline void InitializeNodeFlagsRec(NodeType * node) {$/;"	f	class:vcg::AABBBinaryTreeFrustumCull
InnerIterator	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    typedef typename ExpressionType::InnerIterator InnerIterator;$/;"	t	class:Eigen::Flagged
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator(const Derived& expr, Index outer)$/;"	f	class:Eigen::DenseBase::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^template<typename Derived> class DenseBase<Derived>::InnerIterator$/;"	c	class:Eigen::DenseBase
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    InnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::InnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^        inline InnerIterator(const SparseInnerVectorSet& xpr, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    class InnerIterator: public MatrixType::InnerIterator$/;"	c	class:Eigen::SparseInnerVectorSet
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseBinaryOpImpl& binOp, typename CwiseBinaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseBinaryOpImpl::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp,Lhs,Rhs,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseBinaryOpImpl
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseDenseOuterProduct& prod, Index outer)$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct<Lhs,Rhs,Transpose>::InnerIterator : public _LhsNested::InnerIterator$/;"	c	class:Eigen::SparseDenseOuterProduct
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^                <_LhsNested,_RhsNested,SparseDiagonalProduct,LhsMode,RhsMode> InnerIterator;$/;"	t	class:Eigen::SparseDiagonalProduct
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    InnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseMatrix
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE InnerIterator(const TransposeImpl& trans, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::TransposeImpl
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::InnerIterator : public MatrixTypeNestedCleaned::InnerIterator$/;"	c	class:Eigen::SparseTriangularView
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    InnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    InnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseVector
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  InnerIterator(const SparseView& view, Index outer) :$/;"	f	class:Eigen::SparseView::InnerIterator
InnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^class SparseView<MatrixType>::InnerIterator : public _MatrixTypeNested::InnerIterator$/;"	c	class:Eigen::SparseView
InnerIterator	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^        inline InnerIterator(const SparseInnerVectorSet& xpr, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator
InnerIterator	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    class InnerIterator: public MatrixType::InnerIterator$/;"	c	class:Eigen::SparseInnerVectorSet
InnerIterator	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    InnerIterator(const DynamicSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::DynamicSparseMatrix::InnerIterator
InnerIterator	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^class DynamicSparseMatrix<Scalar,_Options,_Index>::InnerIterator : public SparseVector<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::DynamicSparseMatrix
InnerLowerIterator	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    InnerLowerIterator(const SkylineMatrix& mat, Index outer)$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
InnerLowerIterator	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^class SkylineMatrix<Scalar, _Options>::InnerLowerIterator {$/;"	c	class:Eigen::SkylineMatrix
InnerMaxSize	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    InnerMaxSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon35
InnerMaxSize	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      InnerMaxSize  = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
InnerMaxSize	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    InnerMaxSize = int(Derived::IsRowMajor)$/;"	e	enum:Eigen::internal::redux_traits::__anon223
InnerNode	vcglib/vcg/space/index/octree_template.h	/^		InnerNode() : Node() {};$/;"	f	struct:vcg::OctreeTemplate::InnerNode
InnerNode	vcglib/vcg/space/index/octree_template.h	/^		InnerNode(NodePointer parent, int level) : Node(parent, level)$/;"	f	struct:vcg::OctreeTemplate::InnerNode
InnerNode	vcglib/vcg/space/index/octree_template.h	/^	struct InnerNode : public Node$/;"	s	class:vcg::OctreeTemplate
InnerNodePointer	vcglib/vcg/space/index/octree.h	/^        typedef typename	Octree::InnerNode									* InnerNodePointer;$/;"	t	class:vcg::Octree
InnerProduct	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon266
InnerRandomAccessPattern	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^const int InnerRandomAccessPattern  = 0x2 | CoherentAccessPattern;$/;"	m	namespace:Eigen
InnerSize	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    InnerSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon35
InnerSize	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
InnerSize	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon50
InnerSize	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      InnerSize  = internal::traits<CoeffBasedProduct>::InnerSize,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon195
InnerSize	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon194
InnerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon424
InnerSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon452
InnerSizeAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::DenseBase::__anon58
InnerStride	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    InnerStride() : Base() {}$/;"	f	class:Eigen::InnerStride
InnerStride	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    InnerStride(Index v) : Base(0, v) {}$/;"	f	class:Eigen::InnerStride
InnerStride	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^class InnerStride : public Stride<0, Value>$/;"	c	namespace:Eigen
InnerStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    InnerStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon50
InnerStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    InnerStrideAtCompileTime = MatrixTypeInnerStride == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon57
InnerStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,$/;"	e	enum:Eigen::DenseBase::__anon58
InnerStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    InnerStrideAtCompileTime = MatrixTypeOuterStride == Dynamic ? Dynamic : MatrixTypeOuterStride+1,$/;"	e	enum:Eigen::internal::traits::__anon64
InnerStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon173
InnerStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    InnerStrideAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon181
InnerStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    InnerStrideAtCompileTime = Lhs::InnerStrideAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon243
InnerStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^      InnerStrideAtCompileTime = _InnerStrideAtCompileTime,$/;"	e	enum:Eigen::Stride::__anon247
InnerStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    InnerStrideAtCompileTime = inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon248
InnerUnrolling	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  InnerUnrolling,$/;"	e	enum:Eigen::__anon261
InnerUpperIterator	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    InnerUpperIterator(const SkylineMatrix& mat, Index outer)$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
InnerUpperIterator	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^class SkylineMatrix<Scalar, _Options>::InnerUpperIterator {$/;"	c	class:Eigen::SkylineMatrix
InnerVectorizedTraversal	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  InnerVectorizedTraversal,$/;"	e	enum:Eigen::__anon260
InputScalar	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MatrixType::Scalar InputScalar;$/;"	t	struct:Eigen::internal::traits
InputTag	vcglib/wrap/dae/colladaformat.h	/^		InputTag(const QString& semantic,const QString& source)$/;"	f	class:Collada::Tags::InputTag
InputTag	vcglib/wrap/dae/colladaformat.h	/^		InputTag(const int offset,const QString& semantic,const QString& source)$/;"	f	class:Collada::Tags::InputTag
InputTag	vcglib/wrap/dae/colladaformat.h	/^	class InputTag : public XMLTag$/;"	c	namespace:Collada::Tags
InputType	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef typename Functor::InputType InputType;$/;"	t	class:Eigen::AutoDiffJacobian
InputType	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    typedef typename Functor::InputType InputType;$/;"	t	class:Eigen::NumericalDiff
InputType	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^  typedef Matrix<Scalar,InputsAtCompileTime,1> InputType;$/;"	t	struct:Functor	file:
InputType	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^  typedef Matrix<Scalar,InputsAtCompileTime,1> InputType;$/;"	t	struct:Functor	file:
InputType	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  typedef Matrix<Scalar,InputsAtCompileTime,1> InputType;$/;"	t	struct:TestFunc1	file:
InputType	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  typedef Matrix<Scalar,InputsAtCompileTime,1> InputType;$/;"	t	struct:TestFunc1	file:
InputsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^    InputsAtCompileTime = Functor::InputsAtCompileTime,$/;"	e	enum:Eigen::AutoDiffJacobian::__anon444
InputsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^        InputsAtCompileTime = Functor::InputsAtCompileTime,$/;"	e	enum:Eigen::NumericalDiff::__anon447
InputsAtCompileTime	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    InputsAtCompileTime = NX,$/;"	e	enum:Functor::__anon475	file:
InputsAtCompileTime	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^    InputsAtCompileTime = NX,$/;"	e	enum:Functor::__anon476	file:
InputsAtCompileTime	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^    InputsAtCompileTime = NX,$/;"	e	enum:TestFunc1::__anon472	file:
InputsAtCompileTime	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^    InputsAtCompileTime = NX,$/;"	e	enum:TestFunc1::__anon474	file:
Insert	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  static void Insert(HeapType& heap, PosType& p, int mark, BaseParameterClass *pp)$/;"	f	class:vcg::tri::PlanarEdgeFlip
Insert	vcglib/vcg/container/container_allocation_table.h	/^Insert( STL_CONT & c,bool cond )$/;"	f	class:vcg::CATEntry
InsertElements	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void InsertElements(const OBJECT_ITERATOR &begin, const OBJECT_ITERATOR &end)$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
InsertObject	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void InsertObject(ObjType* s, const Point2i &cell)$/;"	f	class:vcg::SpatialHashTable2D
InsertObject	vcglib/vcg/space/index/spatial_hashing.h	/^	void InsertObject(ObjType* s, const Point3i &cell)$/;"	f	class:vcg::SpatialHashTable
Inside	vcglib/vcg/complex/algorithms/inside.h	/^		class Inside$/;"	c	namespace:vcg::tri
Inside	vcglib/wrap/gui/trackmode.cpp	/^bool AreaMode::Inside(Point3f point)$/;"	f	class:AreaMode
Instance	vcglib/vcg/container/container_allocation_table.h	/^static CAT<STL_CONT,ATTR_TYPE> *& Instance(){ static CAT<STL_CONT,ATTR_TYPE> *  instance=NULL; return instance;}$/;"	f	class:vcg::CAT
InstanceEffectTag	vcglib/wrap/dae/colladaformat.h	/^		InstanceEffectTag(const QString& url)$/;"	f	class:Collada::Tags::InstanceEffectTag
InstanceEffectTag	vcglib/wrap/dae/colladaformat.h	/^	class InstanceEffectTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
InstanceGeometryTag	vcglib/wrap/dae/colladaformat.h	/^		InstanceGeometryTag(const QString& url)$/;"	f	class:Collada::Tags::InstanceGeometryTag
InstanceGeometryTag	vcglib/wrap/dae/colladaformat.h	/^	class InstanceGeometryTag : public XMLTag$/;"	c	namespace:Collada::Tags
InstanceMaterialTag	vcglib/wrap/dae/colladaformat.h	/^		InstanceMaterialTag(const QString& symbol,const QString& target)$/;"	f	class:Collada::Tags::InstanceMaterialTag
InstanceMaterialTag	vcglib/wrap/dae/colladaformat.h	/^	class InstanceMaterialTag : public XMLTag$/;"	c	namespace:Collada::Tags
InstanceNode	vcglib/apps/trimeshinfo/InstancesNode.h	/^	InstanceNode(void){node_type = INSTANCE_NODE; id = "empty"; type= "empty";};$/;"	f	class:InstanceNode
InstanceNode	vcglib/apps/trimeshinfo/InstancesNode.h	/^class InstanceNode: public Node$/;"	c
InstanceVisualSceneTag	vcglib/wrap/dae/colladaformat.h	/^		InstanceVisualSceneTag(const QString& url)$/;"	f	class:Collada::Tags::InstanceVisualSceneTag
InstanceVisualSceneTag	vcglib/wrap/dae/colladaformat.h	/^	class InstanceVisualSceneTag : public XMLTag$/;"	c	namespace:Collada::Tags
InstancesNode	vcglib/apps/trimeshinfo/InstancesNode.h	/^	InstancesNode(void){node_type = INSTANCES_NODE;};$/;"	f	class:InstancesNode
InstancesNode	vcglib/apps/trimeshinfo/InstancesNode.h	/^class InstancesNode: public Node$/;"	c
IntColVectorType	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::LU
IntColVectorType	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	class:Eigen::FullPivLU
IntColVectorType	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::PardisoImpl
IntColVectorType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
IntColVectorType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
IntColVectorType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;    $/;"	t	class:Eigen::SuperLUBase
IntColVectorType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntColVectorType IntColVectorType;    $/;"	t	class:Eigen::SuperLU
IntColVectorType	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::UmfPackLU
IntPoint	vcglib/vcg/space/index/space_iterators.h	/^		CoordType IntPoint()$/;"	f	class:vcg::RayIterator
IntRowVectorType	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::LU
IntRowVectorType	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::FullPivLU
IntRowVectorType	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::PardisoImpl
IntRowVectorType	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
IntRowVectorType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef Matrix<Index, 1, ColsAtCompileTime, RowMajor, 1, MaxColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
IntRowVectorType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::SuperLUBase
IntRowVectorType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntRowVectorType IntRowVectorType;$/;"	t	class:Eigen::SuperLU
IntRowVectorType	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::UmfPackLU
IntValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^const int & AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::IntValue(void) const {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
IntValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^int & AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::IntValue(void) {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
IntVectorType	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef Matrix<Index, Traits::RowsAtCompileTime, 1> IntVectorType;$/;"	t	class:Eigen::MatrixFunction
IntegerEdges	vcglib/wrap/miq/quadrangulator.h	/^    std::set<std::pair<TriFaceType*,int> > IntegerEdges;$/;"	m	class:Quadrangulator
IntegerLineAdj	vcglib/wrap/miq/quadrangulator.h	/^    std::map<TriVertexType*,std::vector<TriVertexType*> > IntegerLineAdj;$/;"	m	class:Quadrangulator
IntegerLines	vcglib/wrap/miq/quadrangulator.h	/^    std::vector<std::pair<TriFaceType*,int> > IntegerLines;$/;"	m	class:Quadrangulator
IntegerValues	vcglib/wrap/miq/core/vertex_indexing.h	/^    std::vector<int> IntegerValues;$/;"	m	struct:MeshSystemInfo
IntegerVertex	vcglib/wrap/miq/quadrangulator.h	/^    std::vector<TriVertexType*> IntegerVertex;$/;"	m	class:Quadrangulator
IntegerVertices	vcglib/wrap/miq/quadrangulator.h	/^    std::set<TriVertexType*> IntegerVertices;$/;"	m	class:Quadrangulator
InterPoint	vcglib/vcg/simplex/face/distance.h	/^        static ScalarType & InterPoint(){static ScalarType interpoint= 1.0; return interpoint;}$/;"	f	class:vcg::face::PointNormalDistanceFunctor
InterPoint	vcglib/vcg/simplex/vertex/distance.h	/^		static ScalarType & InterPoint (){static ScalarType interpoint= 1.0; return interpoint;} $/;"	f	class:vcg::vertex::PointNormalDistanceFunctor
Interize	vcglib/vcg/space/index/octree_template.h	/^	CenterType Interize(const CoordinateType &pf) const$/;"	f	class:vcg::OctreeTemplate
Interize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline CellCoordinate Interize(const CoordinateType &query) const$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
Interize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline vcg::Box3i Interize(const BoundingBoxType &bounding_box) const$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
Interpolate	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFitting.h	/^  SplineType SplineFitting<SplineType>::Interpolate(const PointArrayType& pts, DenseIndex degree)$/;"	f	class:Eigen::SplineFitting
Interpolate	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFitting.h	/^  SplineType SplineFitting<SplineType>::Interpolate(const PointArrayType& pts, DenseIndex degree, const KnotVectorType& knot_parameters)$/;"	f	class:Eigen::SplineFitting
Interpolate	vcglib/vcg/complex/algorithms/create/resampler.h	/^		NewCoordType Interpolate(const vcg::Point3i &p1, const vcg::Point3i &p2,int dir)$/;"	f	class:vcg::tri::Resampler::Walker
Interpolate	vcglib/vcg/math/quaternion.h	/^template <class S> Quaternion<S> Interpolate(   Quaternion<S>   a ,    Quaternion<S>   b , double t) {$/;"	f	namespace:vcg
Interpolate	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Similarity<S,RotationType> Interpolate(const Similarity<S,RotationType> &a, const Similarity<S,RotationType> &b, const S t) {$/;"	f	namespace:vcg
InterpolateCrossField	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static CoordType InterpolateCrossField(const CoordType &t0,$/;"	f	class:vcg::tri::CrossField
InterpolateCrossField	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^            static  CoordType InterpolateCrossField(const std::vector<CoordType> &TangVect,$/;"	f	class:vcg::tri::CrossField
InterpolateCrossFieldLine	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static typename FaceType::CoordType InterpolateCrossFieldLine(const typename FaceType::CoordType &t0,$/;"	f	class:vcg::tri::CrossField
InterpolateNRosy2D	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^        vcg::Point2<ScalarType> InterpolateNRosy2D(const std::vector<vcg::Point2<ScalarType> > &V,$/;"	f	namespace:vcg::tri
InterpolateNRosy3D	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^        vcg::Point3<ScalarType> InterpolateNRosy3D(const std::vector<vcg::Point3<ScalarType> > &V,$/;"	f	namespace:vcg::tri
InterpolationParameters	vcglib/vcg/space/tetra3.h	/^	void InterpolationParameters(const CoordType & bq, ScalarType &a, ScalarType &b, ScalarType &c ,ScalarType &d)$/;"	f	class:vcg::Tetra3
InterpolationParameters	vcglib/vcg/space/triangle2.h	/^bool InterpolationParameters(const CoordType & bq, ScalarType &L1, $/;"	f	class:vcg::Triangle2
InterpolationParameters	vcglib/vcg/space/triangle3.h	/^bool InterpolationParameters(const TriangleType t, const Point3<ScalarType> & N, const Point3<ScalarType> & P,  Point3<ScalarType> & L)$/;"	f	namespace:vcg
InterpolationParameters	vcglib/vcg/space/triangle3.h	/^bool InterpolationParameters(const TriangleType t, const Point3<ScalarType> & P,  Point3<ScalarType> & L)$/;"	f	namespace:vcg
InterpolationParameters	vcglib/vcg/space/triangle3.h	/^bool InterpolationParameters(const TriangleType t, const int Axis, const Point3<ScalarType> & P,  Point3<ScalarType> & L)$/;"	f	namespace:vcg
InterpolationParameters2	vcglib/vcg/space/triangle3.h	/^bool InterpolationParameters2(const Point2<ScalarType> &V1,$/;"	f	namespace:vcg
Intersect	vcglib/vcg/space/box.h	/^	void Intersect( const Box & b )$/;"	f	class:vcg::Box
Intersect	vcglib/vcg/space/box2.h	/^	void Intersect( const Box2 & b )$/;"	f	class:vcg::Box2
Intersect	vcglib/vcg/space/box3.h	/^    void Intersect( const Box3<BoxScalarType> & b )$/;"	f	class:vcg::Box3
Intersect	vcglib/vcg/space/planar_polygon_tessellation.h	/^	bool Intersect(size_t cur , int v2, std::vector<int> & next, std::vector<Point2<S> > & points2){$/;"	f	namespace:vcg
Intersect	vcglib/vcg/space/sphere3.h	/^template <class T> void Sphere3<T>::Intersect(const Sphere3<T> &s) {$/;"	f	class:vcg::Sphere3
Intersection	vcglib/vcg/complex/algorithms/intersection.h	/^bool Intersection(Plane3<ScalarType>  pl,$/;"	f	namespace:vcg
IntersectionBallMesh	vcglib/vcg/complex/algorithms/intersection.h	/^void IntersectionBallMesh(	 TriMeshType & m, const vcg::Sphere3<ScalarType> &ball, TriMeshType & res,$/;"	f	namespace:vcg
IntersectionBallMesh	vcglib/vcg/complex/algorithms/intersection.h	/^void IntersectionBallMesh( IndexingType * grid,	 TriMeshType & m, const vcg::Sphere3<ScalarType> &ball, TriMeshType & res,$/;"	f	namespace:vcg
IntersectionBoxRay	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^	static inline bool IntersectionBoxRay(const CoordType & boxCenter, const CoordType & boxHalfDims, const Ray3Ex & ray, ScalarType & t0) {$/;"	f	class:vcg::AABBBinaryTreeRay
IntersectionLineBox	vcglib/vcg/space/intersection3.h	/^bool IntersectionLineBox( const Box3<T> & box, const Line3<T> & r, Point3<T> & coord )$/;"	f	namespace:vcg
IntersectionLineCylinder	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^static bool IntersectionLineCylinder(const Segment3<T> & cylSeg, T radius, const Line3<T> & line, Point3<T> & p0, Point3<T> & p1, T & t0, T &t1)$/;"	f	namespace:vcg
IntersectionLineLine	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  void IntersectionLineLine(const CoordType & x1,const CoordType & x2,const CoordType & x3,const CoordType & x4, CoordType&x)$/;"	f	class:vcg::tri::FourPCS
IntersectionLinePlane	vcglib/vcg/space/intersection3.h	/^    inline bool IntersectionLinePlane(const Line3<T> & li, const Plane3<T> & pl, Point3<T> & po){$/;"	f	namespace:vcg
IntersectionLineSphere	vcglib/vcg/space/intersection3.h	/^    inline bool IntersectionLineSphere( const Sphere3<T> & sp, const Line3<T> & li, Point3<T> & p0,Point3<T> & p1 ){$/;"	f	namespace:vcg
IntersectionLineTriangle	vcglib/vcg/space/intersection3.h	/^bool IntersectionLineTriangle( const Line3<T> & line, const Point3<T> & vert0, $/;"	f	namespace:vcg
IntersectionPlaneBox	vcglib/vcg/space/intersection3.h	/^bool IntersectionPlaneBox(const vcg::Plane3<ScalarType> &pl,$/;"	f	namespace:vcg
IntersectionPlaneGrid	vcglib/vcg/complex/algorithms/intersection.h	/^bool IntersectionPlaneGrid( GridType & grid, Plane3<ScalarType> plane, std::vector<typename GridType::Cell *> &cells)$/;"	f	namespace:vcg
IntersectionPlaneLine	vcglib/vcg/space/intersection3.h	/^    inline bool IntersectionPlaneLine( const Plane3<T> & pl, const Line3<T> & li, Point3<T> & po){$/;"	f	namespace:vcg
IntersectionPlaneMesh	vcglib/vcg/complex/algorithms/intersection.h	/^bool IntersectionPlaneMesh(TriMeshType & m,$/;"	f	namespace:vcg
IntersectionPlaneMeshOld	vcglib/vcg/complex/algorithms/intersection.h	/^bool IntersectionPlaneMeshOld(TriMeshType & m,$/;"	f	namespace:vcg
IntersectionPlanePlane	vcglib/vcg/space/intersection3.h	/^bool IntersectionPlanePlane (const Plane3<T> & plane0, const Plane3<T> & plane1,$/;"	f	namespace:vcg
IntersectionPlaneSegment	vcglib/vcg/space/intersection3.h	/^    inline bool IntersectionPlaneSegment( const Plane3<T> & pl, const Segment3<T> & s, Point3<T> & p0){$/;"	f	namespace:vcg
IntersectionPlaneSegmentEpsilon	vcglib/vcg/space/intersection3.h	/^    inline bool IntersectionPlaneSegmentEpsilon(const Plane3<ScalarType> & pl,$/;"	f	namespace:vcg
IntersectionPlaneTriangle	vcglib/vcg/space/intersection3.h	/^    inline bool IntersectionPlaneTriangle( const Plane3<typename TRIANGLETYPE::ScalarType> & pl, $/;"	f	namespace:vcg
IntersectionRayBox	vcglib/vcg/space/intersection3.h	/^bool IntersectionRayBox( const Box3<T> & box, const Ray3<T> & r, Point3<T> & coord )$/;"	f	namespace:vcg
IntersectionRayMesh	vcglib/vcg/complex/algorithms/intersection.h	/^bool IntersectionRayMesh(	$/;"	f	namespace:vcg
IntersectionRayPlane	vcglib/wrap/gui/trackutils.h	/^  inline bool IntersectionRayPlane( const Plane3<T> & pl, const Ray3<T> & ray, Point3<T> &po){$/;"	f	namespace:vcg::trackutils
IntersectionRayTriangle	vcglib/vcg/space/intersection3.h	/^bool IntersectionRayTriangle( const Ray3<T> & ray, const Point3<T> & vert0, $/;"	f	namespace:vcg
IntersectionSegmentBox	vcglib/vcg/space/intersection3.h	/^bool IntersectionSegmentBox( const Box3<ScalarType> & box,$/;"	f	namespace:vcg
IntersectionSegmentBox	vcglib/vcg/space/intersection3.h	/^int IntersectionSegmentBox( const Box3<ScalarType> & box,$/;"	f	namespace:vcg
IntersectionSegmentCylinder	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^static bool IntersectionSegmentCylinder(const Segment3<T> & cylSeg , T radius,  const Segment3<T> & seg, Point3<T> & p0, Point3<T> & p1)$/;"	f	namespace:vcg
IntersectionSegmentSphere	vcglib/vcg/space/intersection3.h	/^	inline int IntersectionSegmentSphere(const Sphere3<SCALAR_TYPE>& sphere, const Segment3<SCALAR_TYPE>& segment, Point3<SCALAR_TYPE> & t0, Point3<SCALAR_TYPE> & t1)$/;"	f	namespace:vcg
IntersectionSegmentTriangle	vcglib/vcg/space/intersection3.h	/^bool IntersectionSegmentTriangle( const vcg::Segment3<ScalarType> & seg,$/;"	f	namespace:vcg
IntersectionSegmentTriangle	vcglib/vcg/space/intersection3.h	/^bool IntersectionSegmentTriangle( const vcg::Segment3<typename TriangleType::ScalarType> & seg,$/;"	f	namespace:vcg
IntersectionSphereSphere	vcglib/vcg/space/intersection3.h	/^bool IntersectionSphereSphere( const SphereType & s0,const SphereType & s1){$/;"	f	namespace:vcg
IntersectionSphereTriangle	vcglib/vcg/space/intersection3.h	/^	bool IntersectionSphereTriangle(const vcg::Sphere3	< SCALAR_TYPE >		& sphere  ,$/;"	f	namespace:vcg
IntersectionTriangleBox	vcglib/vcg/space/intersection3.h	/^bool IntersectionTriangleBox(const vcg::Box3<ScalarType>   &bbox,$/;"	f	namespace:vcg
IntersectionTriangleTriangle	vcglib/vcg/space/intersection3.h	/^    inline bool IntersectionTriangleTriangle(Point3<T> V0,Point3<T> V1,Point3<T> V2,$/;"	f	namespace:vcg
IntersectionTriangleTriangle	vcglib/vcg/space/intersection3.h	/^    inline bool IntersectionTriangleTriangle(const TRIANGLETYPE & t0,const TRIANGLETYPE & t1){$/;"	f	namespace:vcg
Intrinsics	vcglib/vcg/math/shot.h	/^  Camera<S>												Intrinsics;		\/\/ the camera that made the shot$/;"	m	class:vcg::Shot
InvalidFile	vcglib/wrap/io_trimesh/import_gts.h	/^				enum GTSCodes {NoError=0, CantOpen, InvalidFile,$/;"	e	enum:vcg::tri::io::ImporterGTS::GTSCodes
InvalidFile	vcglib/wrap/io_trimesh/import_off.h	/^  enum OFFCodes {NoError=0, CantOpen, InvalidFile,$/;"	e	enum:vcg::tri::io::ImporterOFF::OFFCodes
InvalidFile_MissingOFF	vcglib/wrap/io_trimesh/import_off.h	/^                 InvalidFile_MissingOFF,$/;"	e	enum:vcg::tri::io::ImporterOFF::OFFCodes
InvalidInput	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  InvalidInput = 3$/;"	e	enum:Eigen::ComputationInfo
InvalidTraversal	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  InvalidTraversal$/;"	e	enum:Eigen::__anon260
InvalidType	vcglib/wrap/glw/type.h	/^	InvalidType = 0,$/;"	e	enum:glw::Type
Inverse	vcglib/vcg/math/matrix33.h	/^Matrix33<S> Inverse(const Matrix33<S>&m)$/;"	f	namespace:vcg
Inverse	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> Inverse(const Matrix44<T> &m) {$/;"	f	namespace:vcg
Inverse	vcglib/vcg/math/old_matrix33.h	/^Matrix33<S> Inverse(const Matrix33<S>&m) { return m.lu().inverse(); }$/;"	f	namespace:vcg
Inverse	vcglib/vcg/math/old_matrix44.h	/^template <class T> Matrix44<T> Inverse(const Matrix44<T> &m) {$/;"	f	namespace:vcg
Inverse	vcglib/vcg/math/quaternion.h	/^template <class S> Quaternion<S> Inverse(const Quaternion<S> &m) {$/;"	f	namespace:vcg
Inverse	vcglib/vcg/math/quaternion.h	/^template <class S> Quaternion<S> Quaternion<S>::Inverse() const{$/;"	f	class:vcg::Quaternion
Inverse	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Similarity<S,RotationType> Inverse(const Similarity<S,RotationType> &m) {$/;"	f	namespace:vcg
InverseMatrix	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Matrix44<S> Similarity<S,RotationType>::InverseMatrix() const {$/;"	f	class:vcg::Similarity
InverseMatrix	vcglib/wrap/gui/trackball.cpp	/^Matrix44f Trackball::InverseMatrix() const{$/;"	f	class:Trackball
Invert	vcglib/vcg/math/old_matrix.h	/^void Invert(MatrixType & m)$/;"	f	namespace:vcg::ndim
Invert	vcglib/vcg/math/old_matrix33.h	/^void Invert(Matrix33<S> &m) { m = m.lu().inverse(); }$/;"	f	namespace:vcg
Invert	vcglib/vcg/math/old_matrix44.h	/^template <class T> Matrix44<T> & Invert(Matrix44<T> &m) {$/;"	f	namespace:vcg
Invert	vcglib/vcg/math/quaternion.h	/^template <class S> Quaternion<S> &Invert(Quaternion<S> &m) {$/;"	f	namespace:vcg
Invert	vcglib/vcg/math/quaternion.h	/^template <class S> void Quaternion<S>::Invert() {$/;"	f	class:vcg::Quaternion
Invert	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Similarity<S,RotationType> &Invert(Similarity<S,RotationType> &a) {  $/;"	f	namespace:vcg
InvokeConverter	vcglib/wrap/io_trimesh/export_u3d.h	/^	static int InvokeConverter(const u3dparametersclasses::IDTFConverterParameters& par)$/;"	f	class:vcg::tri::io::ExporterU3D
Invr	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  PMesh     Invr;										\/\/ invariants$/;"	m	class:vcg::tri::FourPCS
IsAValidOffset	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		bool IsAValidOffset(const std::vector< typename UniformGrid::CellCoordinate > *pre_image, const typename OffsetTable::Offset &offset)$/;"	f	class:vcg::PerfectSpatialHashing
IsAligned	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    IsAligned = bool(EIGEN_ALIGN) && ((int(MapOptions)&Aligned)==Aligned),$/;"	e	enum:Eigen::internal::traits::__anon173
IsAligned	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^      IsAligned = TraitsBase::IsAligned,$/;"	e	enum:Eigen::internal::traits::__anon366
IsAligned	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^      IsAligned = TraitsBase::IsAligned,$/;"	e	enum:Eigen::internal::traits::__anon367
IsAligned	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    IsAligned = internal::traits<Coefficients>::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::traits::__anon364
IsAligned	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  enum { IsAligned = internal::traits<Quaternion>::IsAligned };$/;"	e	enum:Eigen::Quaternion::__anon365
IsAnimating	vcglib/wrap/gui/trackball.cpp	/^bool Trackball::IsAnimating(unsigned int msec){$/;"	f	class:Trackball
IsAnimating	vcglib/wrap/gui/trackmode.cpp	/^bool NavigatorWasdMode::IsAnimating(const Trackball * tb){$/;"	f	class:NavigatorWasdMode
IsAnimating	vcglib/wrap/gui/trackmode.cpp	/^bool TrackMode::IsAnimating(const Trackball *){ $/;"	f	class:TrackMode
IsAnyF	vcglib/vcg/simplex/face/base.h	/^	bool IsAnyF() const {return (this->cFlags() & (FAUX0|FAUX1|FAUX2)) != 0;}$/;"	f	class:vcg::FaceArityMax
IsB	vcglib/vcg/connectors/hedge.h	/^	bool IsB() const {return (this->Flags() & BORDER) != 0;}\/\/\/  checks if the vertex is a border one$/;"	f	class:vcg::HEdgeArityMax
IsB	vcglib/vcg/simplex/edge/base.h	/^	bool IsB() const {return (this->Flags() & BORDER) != 0;}\/\/\/  checks if the vertex is a border one$/;"	f	class:vcg::EdgeArityMax
IsB	vcglib/vcg/simplex/face/base.h	/^	bool IsB(int i) const {return (this->cFlags() & (BORDER0<<i)) != 0;}$/;"	f	class:vcg::FaceArityMax
IsB	vcglib/vcg/simplex/tetrahedron/base.h	/^	bool IsB(int i) const {return (this->Flags() & (BORDER0<<i)) != 0;}$/;"	f	class:vcg::TetraArityMax
IsB	vcglib/vcg/simplex/vertex/base.h	/^    bool IsB() const {return (this->cFlags() & BORDER) != 0;}\/\/\/  checks if the vertex is a border one$/;"	f	class:vcg::VertexArityMax
IsBitPolygonal	vcglib/vcg/complex/algorithms/clean.h	/^  static bool IsBitPolygonal(const MeshType &m){$/;"	f	class:vcg::tri::Clean
IsBitQuadOnly	vcglib/vcg/complex/algorithms/clean.h	/^            static bool IsBitQuadOnly(const MeshType &m)$/;"	f	class:vcg::tri::Clean
IsBitTriOnly	vcglib/vcg/complex/algorithms/clean.h	/^  static bool IsBitTriOnly(const MeshType &m)$/;"	f	class:vcg::tri::Clean
IsBitTriQuadConventional	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static bool IsBitTriQuadConventional(const MeshType &m){$/;"	f	class:vcg::tri::BitQuadCreation
IsBitTriQuadOnly	vcglib/vcg/complex/algorithms/clean.h	/^  static bool IsBitTriQuadOnly(const MeshType &m)$/;"	f	class:vcg::tri::Clean
IsBorder	vcglib/vcg/simplex/edge/pos.h	/^  bool IsBorder()$/;"	f	class:vcg::edge::Pos
IsBorder	vcglib/vcg/simplex/face/pos.h	/^	bool IsBorder()$/;"	f	class:vcg::face::Pos
IsBorder	vcglib/vcg/simplex/face/topology.h	/^inline bool IsBorder(FaceType const & f,  const int j )$/;"	f	namespace:vcg::face
IsBorderF	vcglib/vcg/simplex/tetrahedron/component.h	/^	bool IsBorderF(const int & i)  const { assert( (i>=0) && (i < 4)); { return TTp(i) == this;}}$/;"	f	class:vcg::tetra::TTAdj
IsBound	vcglib/wrap/gl/gl_object.h	/^	bool IsBound(void) const$/;"	f	class:Bindable
IsCCW	vcglib/vcg/space/triangle2.h	/^bool IsCCW()$/;"	f	class:vcg::Triangle2
IsClosedFlag	vcglib/apps/unsupported/shadevis/visshader.h	/^	 bool IsClosedFlag;$/;"	m	class:vcg::VisShader
IsCoherentlyOrientedMesh	vcglib/vcg/complex/algorithms/clean.h	/^  static bool IsCoherentlyOrientedMesh(MeshType &m)$/;"	f	class:vcg::tri::Clean
IsColMajor	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^      IsColMajor = !IsRowMajor,$/;"	e	enum:Eigen::Reverse::__anon237
IsColVector	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^      IsColVector = !(internal::traits<VectorType>::Flags & RowMajorBit)$/;"	e	enum:Eigen::VectorBlock::__anon320
IsColVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    IsColVector = (_Options & RowMajorBit) ? 0 : 1,$/;"	e	enum:Eigen::internal::traits::__anon430
IsColVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    enum { IsColVector = internal::traits<SparseVector>::IsColVector };$/;"	e	enum:Eigen::SparseVector::__anon431
IsColorEnabled	vcglib/vcg/simplex/face/component.h	/^  inline bool IsColorEnabled( )        const { return T::FaceType::HasColor(); }$/;"	f	class:vcg::face::EmptyCore
IsColorEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  inline bool IsColorEnabled()          const  { return this->Base().IsColorEnabled();}$/;"	f	class:vcg::face::ColorOcf
IsColorEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^bool IsColorEnabled() const {return _ColorEnabled;}$/;"	f	class:vcg::face::vector_ocf
IsColorEnabled	vcglib/vcg/simplex/vertex/component.h	/^  inline bool IsColorEnabled() const { return TT::VertexType::HasColor();}$/;"	f	class:vcg::vertex::EmptyCore
IsColorEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline bool IsColorEnabled()         const  { return this->Base().IsColorEnabled();}$/;"	f	class:vcg::vertex::ColorOcf
IsColorEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool IsColorEnabled() const {return ColorEnabled;}$/;"	f	class:vcg::vertex::vector_ocf
IsCompiled	vcglib/wrap/gl/shaders.h	/^	bool IsCompiled(void)$/;"	f	class:Shader
IsComplex	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::GenericNumTraits::__anon185
IsComplex	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon255
IsComplex	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon256
IsComplex	vcglib/vcg/math/eigen.h	/^		IsComplex = 0,$/;"	e	enum:Eigen::NumTraits::__anon488
IsComplex	vcglib/vcg/math/eigen.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::NumTraits::__anon486
IsComplex	vcglib/vcg/math/eigen.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::NumTraits::__anon487
IsConcave	vcglib/vcg/complex/algorithms/hole.h	/^  bool IsConcave() const {return(angleRad > (float)M_PI);}$/;"	f	class:vcg::tri::TrivialEar
IsCoordEnabled	vcglib/vcg/simplex/vertex/component.h	/^  inline bool IsCoordEnabled() const { return TT::VertexType::HasCoord();}$/;"	f	class:vcg::vertex::EmptyCore
IsCrease	vcglib/vcg/simplex/face/base.h	/^	bool IsCrease(int i) const {return (this->cFlags() & (CREASE0<<i)) != 0;}$/;"	f	class:vcg::FaceArityMax
IsCurvatureDirEnabled	vcglib/vcg/simplex/face/component.h	/^  inline bool IsCurvatureDirEnabled( ) const { return T::FaceType::HasCurvatureDir(); }$/;"	f	class:vcg::face::EmptyCore
IsCurvatureDirEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  inline bool IsCurvatureDirEnabled( )  const  { return this->Base().IsCurvatureDirEnabled(); }$/;"	f	class:vcg::face::CurvatureDirOcf
IsCurvatureDirEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^bool IsCurvatureDirEnabled() const {return CurvatureDirEnabled;}$/;"	f	class:vcg::face::vector_ocf
IsCurvatureDirEnabled	vcglib/vcg/simplex/vertex/component.h	/^  inline bool IsCurvatureDirEnabled() const { return TT::VertexType::HasCurvatureDir();}$/;"	f	class:vcg::vertex::EmptyCore
IsCurvatureDirEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline bool IsCurvatureDirEnabled( ) const  { return this->Base().IsCurvatureDirEnabled(); }$/;"	f	class:vcg::vertex::CurvatureDirOcf
IsCurvatureDirEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool IsCurvatureDirEnabled() const {return CurvatureDirEnabled;}$/;"	f	class:vcg::vertex::vector_ocf
IsCurvatureEnabled	vcglib/vcg/simplex/vertex/component.h	/^  inline bool IsCurvatureEnabled() const { return TT::VertexType::HasCurvature();}$/;"	f	class:vcg::vertex::EmptyCore
IsCurvatureEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline bool IsCurvatureEnabled( )    const  { return this->Base().IsCurvatureDirEnabled(); }$/;"	f	class:vcg::vertex::CurvatureOcf
IsCurvatureEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool IsCurvatureEnabled() const {return CurvatureEnabled;}$/;"	f	class:vcg::vertex::vector_ocf
IsD	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^	bool IsD(){return deleted;}$/;"	f	class:MySegmentType
IsD	vcglib/vcg/connectors/hedge.h	/^	bool IsD() const {return (this->Flags() & DELETED) != 0;} \/\/\/  checks if the vertex is deleted$/;"	f	class:vcg::HEdgeArityMax
IsD	vcglib/vcg/simplex/edge/base.h	/^	bool IsD() const {return (this->Flags() & DELETED) != 0;} \/\/\/  checks if the vertex is deleted$/;"	f	class:vcg::EdgeArityMax
IsD	vcglib/vcg/simplex/face/base.h	/^    bool IsD() const {return (this->cFlags() & DELETED) != 0;}$/;"	f	class:vcg::FaceArityMax
IsD	vcglib/vcg/simplex/tetrahedron/base.h	/^	bool IsD() const {return (this->Flags() & DELETED) != 0;}$/;"	f	class:vcg::TetraArityMax
IsD	vcglib/vcg/simplex/vertex/base.h	/^    bool IsD() const {return (this->cFlags() & DELETED) != 0;} \/\/\/  checks if the vertex is deleted$/;"	f	class:vcg::VertexArityMax
IsDegen	vcglib/vcg/complex/algorithms/hole.h	/^  bool IsDegen(const int nonManifoldBit)$/;"	f	class:vcg::tri::TrivialEar
IsDense	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  IsDense         = 0,$/;"	e	enum:Eigen::__anon265
IsDoublet	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool IsDoublet(const FaceType& f, int wedge){$/;"	f	class:vcg::tri::BitQuad
IsDoubletFF	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool IsDoubletFF(const FaceType& f, int wedge){$/;"	f	class:vcg::tri::BitQuad
IsDoubletOrSinglet	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool IsDoubletOrSinglet(const FaceType& f, int wedge){$/;"	f	class:vcg::tri::BitQuad
IsDynamicSize	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon173
IsEdgeBorder	vcglib/vcg/simplex/edge/topology.h	/^inline bool IsEdgeBorder(EdgeType const & e,  const int j )$/;"	f	namespace:vcg::edge
IsEdgeManifold	vcglib/vcg/simplex/edge/topology.h	/^inline bool IsEdgeManifold( EdgeType const & e, const int j )$/;"	f	namespace:vcg::edge
IsEmpty	vcglib/vcg/complex/base.h	/^bool IsEmpty()$/;"	f	class:vcg::tri::TriMesh
IsEmpty	vcglib/vcg/space/box.h	/^	bool IsEmpty() const { return _min==_max; }$/;"	f	class:vcg::Box
IsEmpty	vcglib/vcg/space/box2.h	/^	inline bool IsEmpty() const { return min==max; }$/;"	f	class:vcg::Box2
IsEmpty	vcglib/vcg/space/box3.h	/^    bool IsEmpty() const { return min==max; }$/;"	f	class:vcg::Box3
IsEmpty	vcglib/vcg/space/sphere3.h	/^	bool IsEmpty() const { return _radius < 0; }$/;"	f	class:vcg::Sphere3
IsEnabled	vcglib/vcg/container/vector_occ.h	/^		bool IsEnabled() const{$/;"	f	class:vcg::vector_occ
IsF	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  bool IsF(){return f->IsF(e);}$/;"	f	class:vcg::tri::BitQuad::Pos
IsF	vcglib/vcg/simplex/face/base.h	/^	bool IsF(int i) const {return (this->cFlags() & (FAUX0<<i) ) != 0;}$/;"	f	class:vcg::FaceArityMax
IsFFAdjacencyConsistent	vcglib/vcg/complex/algorithms/clean.h	/^      static bool IsFFAdjacencyConsistent(MeshType &m)$/;"	f	class:vcg::tri::Clean
IsFFAdjacencyEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^bool IsFFAdjacencyEnabled() const {return FFAdjacencyEnabled;}$/;"	f	class:vcg::face::vector_ocf
IsFeaseable	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    bool IsFeaseable()$/;"	f	class:vcg::tri::PoissonSolver
IsFeasible	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            bool IsFeasible()$/;"	f	class:vcg::tri::QuadDiagonalCollapse
IsFeasible	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            inline bool IsFeasible()$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
IsFeasible	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  bool IsFeasible(){$/;"	f	class:vcg::tetra::TetraEdgeCollapse
IsFeasible	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  inline bool IsFeasible(BaseParameterClass *){$/;"	f	class:vcg::tri::TriEdgeCollapse
IsFeasible	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^    inline bool IsFeasible(BaseParameterClass *_pp){$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
IsFeasible	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  virtual bool IsFeasible(BaseParameterClass *_pp)$/;"	f	class:vcg::tri::PlanarEdgeFlip
IsFlipped	vcglib/wrap/miq/core/param_stats.h	/^inline bool IsFlipped( FaceType &f)$/;"	f
IsFlipped	vcglib/wrap/miq/core/param_stats.h	/^inline bool IsFlipped(const CoordType2D &uv0,$/;"	f
IsFoldFree	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^bool IsFoldFree(MESH_TYPE &m){$/;"	f	namespace:vcg::tri
IsFree	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline bool IsFree(const EntryCoordinate &at) const { return GetOffset(at)==NULL;	} $/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
IsFree	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline bool IsFree(const EntryCoordinate &at) const$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
IsFullyVisible	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	static inline bool IsFullyVisible(const NodeType * node) {$/;"	f	class:vcg::AABBBinaryTreeFrustumCull
IsHorizontal	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^      IsHorizontal = (Direction==Horizontal) ? 1 : 0$/;"	e	enum:Eigen::VectorwiseOp::__anon324
IsIn	vcglib/vcg/space/box.h	/^	bool IsIn( PointType const & p ) const$/;"	f	class:vcg::Box
IsIn	vcglib/vcg/space/box2.h	/^	bool IsIn( PointType const & p ) const$/;"	f	class:vcg::Box2
IsIn	vcglib/vcg/space/box3.h	/^    bool IsIn( Point3<BoxScalarType> const & p ) const$/;"	f	class:vcg::Box3
IsIn	vcglib/vcg/space/obox3.h	/^		bool IsIn( Point3<T> const &p) const{$/;"	f	class:vcg::Obox3
IsIn	vcglib/vcg/space/sphere3.h	/^template <class T> bool Sphere3<T>::IsIn(const Point3<T> &p) const {$/;"	f	class:vcg::Sphere3
IsIn	vcglib/vcg/space/sphere3.h	/^template <class T> bool Sphere3<T>::IsIn(const Sphere3<T> &p) const {$/;"	f	class:vcg::Sphere3
IsInEx	vcglib/vcg/space/box.h	/^	bool IsInEx( PointType const & p ) const$/;"	f	class:vcg::Box
IsInEx	vcglib/vcg/space/box2.h	/^	bool IsInEx( PointType const & p ) const$/;"	f	class:vcg::Box2
IsInEx	vcglib/vcg/space/box3.h	/^    bool IsInEx( Point3<BoxScalarType> const & p ) const$/;"	f	class:vcg::Box3
IsInf	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	#define IsInf(/;"	d
IsInside	vcglib/vcg/space/tetra3.h	/^	bool IsInside(const CoordType &p)$/;"	f	class:vcg::Tetra3
IsInsideTrianglePoint	vcglib/vcg/space/intersection2.h	/^	inline bool IsInsideTrianglePoint( const Triangle2<SCALAR_TYPE> & t,const Point2<SCALAR_TYPE> & p)$/;"	f	namespace:vcg
IsInteger	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^    IsInteger = std::numeric_limits<T>::is_integer,$/;"	e	enum:Eigen::GenericNumTraits::__anon185
IsLeaf	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^bool AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::IsLeaf(void) const {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
IsLeaf	vcglib/vcg/space/index/octree_template.h	/^		inline bool IsLeaf()$/;"	f	struct:vcg::OctreeTemplate::InnerNode
IsLeaf	vcglib/vcg/space/index/octree_template.h	/^		inline bool IsLeaf()$/;"	f	struct:vcg::OctreeTemplate::Leaf
IsLinked	vcglib/wrap/gl/shaders.h	/^	bool IsLinked(void) const$/;"	f	class:Program
IsLower	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon246
IsLower	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon216
IsLower	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon217
IsLower	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon218
IsLower	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon219
IsLower	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon220
IsLower	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon221
IsManifold	vcglib/vcg/simplex/edge/pos.h	/^  bool IsManifold()$/;"	f	class:vcg::edge::Pos
IsManifold	vcglib/vcg/simplex/face/pos.h	/^  bool IsManifold()$/;"	f	class:vcg::face::Pos
IsManifold	vcglib/vcg/simplex/face/topology.h	/^inline bool IsManifold( FaceType const & f, const int j )$/;"	f	namespace:vcg::face
IsMarkEnabled	vcglib/vcg/simplex/face/component.h	/^  inline bool IsMarkEnabled( )         const { return T::FaceType::HasMark(); }$/;"	f	class:vcg::face::EmptyCore
IsMarkEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  inline bool IsMarkEnabled( )          const  { return this->Base().IsMarkEnabled(); }$/;"	f	class:vcg::face::MarkOcf
IsMarkEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^bool IsMarkEnabled() const {return MarkEnabled;}$/;"	f	class:vcg::face::vector_ocf
IsMarkEnabled	vcglib/vcg/simplex/vertex/component.h	/^  inline bool IsMarkEnabled() const { return TT::VertexType::HasMark();}$/;"	f	class:vcg::vertex::EmptyCore
IsMarkEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline bool IsMarkEnabled( )         const  { return this->Base().IsMarkEnabled(); }$/;"	f	class:vcg::vertex::MarkOcf
IsMarkEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool IsMarkEnabled() const {return MarkEnabled;}$/;"	f	class:vcg::vertex::vector_ocf
IsMarked	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^	bool IsMarked(MySegmentType* obj)$/;"	f	class:MyMarker
IsMarked	vcglib/vcg/complex/algorithms/closest.h	/^			bool IsMarked(OBJ_TYPE* obj){return (vcg::tri::IsMarked(*m,obj));}$/;"	f	class:vcg::tri::Tmark
IsMarked	vcglib/vcg/complex/algorithms/closest.h	/^			inline bool IsMarked(VertexType*) const { return false; }$/;"	f	class:vcg::tri::VertTmark
IsMarked	vcglib/vcg/complex/base.h	/^template <class MeshType> inline bool IsMarked( MeshType & m,typename MeshType::ConstFacePointer f )  { return f->cIMark() == m.imark; }$/;"	f	namespace:vcg::tri
IsMarked	vcglib/vcg/complex/base.h	/^template <class MeshType> inline bool IsMarked(MeshType & m, typename MeshType::ConstVertexPointer  v )  { return v->cIMark() == m.imark; }$/;"	f	namespace:vcg::tri
IsMarked	vcglib/vcg/space/index/octree.h	/^        inline bool IsMarked(const ObjectReference *ref) const$/;"	f	class:vcg::Octree
IsNAN	vcglib/vcg/math/base.h	/^template<class T> int IsNAN(T t) {    return _isnan(t) || (!_finite(t)); }$/;"	f	namespace:vcg::math
IsNAN	vcglib/vcg/math/base.h	/^template<class T> int IsNAN(T t) {    return isnan(t) || isinf(t); }$/;"	f	namespace:vcg::math
IsNAN	vcglib/vcg/math/base.h	/^template<class T> int IsNAN(T t)$/;"	f	namespace:vcg::math
IsNormalEnabled	vcglib/vcg/simplex/face/component.h	/^  inline bool IsNormalEnabled( )       const { return T::FaceType::HasNormal(); }$/;"	f	class:vcg::face::EmptyCore
IsNormalEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  inline bool IsNormalEnabled( )        const  { return this->Base().IsNormalEnabled(); }$/;"	f	class:vcg::face::NormalOcf
IsNormalEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^bool IsNormalEnabled() const {return NormalEnabled;}$/;"	f	class:vcg::face::vector_ocf
IsNormalEnabled	vcglib/vcg/simplex/vertex/component.h	/^  inline bool IsNormalEnabled() const { return TT::VertexType::HasNormal();}$/;"	f	class:vcg::vertex::EmptyCore
IsNormalEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline bool IsNormalEnabled( )       const  { return this->Base().IsNormalEnabled(); }$/;"	f	class:vcg::vertex::NormalOcf
IsNormalEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool IsNormalEnabled() const {return NormalEnabled;}$/;"	f	class:vcg::vertex::vector_ocf
IsNormalized	vcglib/vcg/space/line2.h	/^	static bool IsNormalized() {return NORM;};$/;"	f	class:vcg::Line2
IsNormalized	vcglib/vcg/space/line3.h	/^	static bool IsNormalized() {return NORM;};$/;"	f	class:vcg::Line3
IsNormalized	vcglib/vcg/space/ray2.h	/^	static bool IsNormalized() {return NORM;};$/;"	f	class:vcg::Ray2
IsNormalized	vcglib/vcg/space/ray3.h	/^	static bool IsNormalized() {return NORM;};$/;"	f	class:vcg::Ray3
IsNull	vcglib/vcg/complex/algorithms/hole.h	/^  bool IsNull(){return e0.IsNull() || e1.IsNull();}$/;"	f	class:vcg::tri::TrivialEar
IsNull	vcglib/vcg/simplex/edge/pos.h	/^	bool IsNull() const {$/;"	f	class:vcg::edge::Pos
IsNull	vcglib/vcg/simplex/face/pos.h	/^	bool IsNull() const {$/;"	f	class:vcg::face::Pos
IsNull	vcglib/vcg/simplex/tetrahedron/pos.h	/^	bool IsNull() const {$/;"	f	class:vcg::tetra::Pos
IsNull	vcglib/vcg/space/box.h	/^	bool IsNull() const { return _min.X()>_max.X() || _min.Y()>_max.Y() || _min.Z()>_max.Z(); }$/;"	f	class:vcg::Box
IsNull	vcglib/vcg/space/box2.h	/^	inline bool IsNull() const { return min.X()>max.X() || min.Y()>max.Y(); }$/;"	f	class:vcg::Box2
IsNull	vcglib/vcg/space/box3.h	/^    bool IsNull() const { return min.X()>max.X() || min.Y()>max.Y() || min.Z()>max.Z(); }$/;"	f	class:vcg::Box3
IsOfType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            ModifierType IsOfType()$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
IsOfType	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  ModifierType IsOfType(){ return TetraEdgeCollapseOp;}$/;"	f	class:vcg::tetra::TetraEdgeCollapse
IsOfType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  ModifierType IsOfType(){ return TriEdgeCollapseOp;}$/;"	f	class:vcg::tri::TriEdgeCollapse
IsOfType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	ModifierType IsOfType()$/;"	f	class:vcg::tri::PlanarEdgeFlip
IsOnIntegerLine	vcglib/wrap/miq/quadrangulator.h	/^    bool IsOnIntegerLine(vcg::Point2<ScalarType> uv0,$/;"	f	class:Quadrangulator
IsOnIntegerVertex	vcglib/wrap/miq/quadrangulator.h	/^    bool IsOnIntegerVertex(vcg::Point2<ScalarType> uv,$/;"	f	class:Quadrangulator
IsOrtho	vcglib/vcg/math/camera.h	/^    bool IsOrtho() const$/;"	f	class:vcg::Camera
IsOutside	vcglib/wrap/gui/frustum.h	/^template <class T> T Frustum<T>::IsOutside(Point3<T> &point, T radius) {$/;"	f	class:vcg::Frustum
IsOutside	vcglib/wrap/gui/frustum.h	/^template <class T> bool Frustum<T>::IsOutside(Point3<T> &point) {$/;"	f	class:vcg::Frustum
IsPartiallyVisible	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	static inline bool IsPartiallyVisible(const NodeType * node) {$/;"	f	class:vcg::AABBBinaryTreeFrustumCull
IsPolychordSelfIntersecting	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  static bool IsPolychordSelfIntersecting (const PolyMeshType &mesh,$/;"	f	class:vcg::tri::PolychordCollapse
IsProjective	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    IsProjective = (int(Mode)==int(Projective))$/;"	e	enum:Eigen::internal::transform_traits::__anon372
IsQuadOnly	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static bool IsQuadOnly(const MeshType &m){$/;"	f	class:vcg::tri::BitQuadCreation
IsQuality3Enabled	vcglib/vcg/simplex/face/component.h	/^  inline bool IsQuality3Enabled( )     const { return T::FaceType::HasQuality3(); }$/;"	f	class:vcg::face::EmptyCore
IsQualityEnabled	vcglib/vcg/simplex/face/component.h	/^  inline bool IsQualityEnabled( )      const { return T::FaceType::HasQuality(); }$/;"	f	class:vcg::face::EmptyCore
IsQualityEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  inline bool IsQualityEnabled( )       const  { return this->Base().IsQualityEnabled(); }$/;"	f	class:vcg::face::QualityOcf
IsQualityEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^bool IsQualityEnabled() const {return QualityEnabled;}$/;"	f	class:vcg::face::vector_ocf
IsQualityEnabled	vcglib/vcg/simplex/vertex/component.h	/^  inline bool IsQualityEnabled() const { return TT::VertexType::HasQuality();}$/;"	f	class:vcg::vertex::EmptyCore
IsQualityEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline bool IsQualityEnabled( )      const  { return this->Base().IsQualityEnabled(); }$/;"	f	class:vcg::vertex::QualityOcf
IsQualityEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool IsQualityEnabled() const {return QualityEnabled;}$/;"	f	class:vcg::vertex::vector_ocf
IsR	vcglib/vcg/connectors/hedge.h	/^	bool IsR() const {return (this->Flags() & NOTREAD) == 0;} \/\/\/  checks if the vertex is readable$/;"	f	class:vcg::HEdgeArityMax
IsR	vcglib/vcg/simplex/edge/base.h	/^	bool IsR() const {return (this->Flags() & NOTREAD) == 0;} \/\/\/  checks if the vertex is readable$/;"	f	class:vcg::EdgeArityMax
IsR	vcglib/vcg/simplex/face/base.h	/^	bool IsR() const {return (this->cFlags() & NOTREAD) == 0;}$/;"	f	class:vcg::FaceArityMax
IsR	vcglib/vcg/simplex/tetrahedron/base.h	/^	bool IsR() const {return (this->Flags() & NOTREAD) == 0;}$/;"	f	class:vcg::TetraArityMax
IsR	vcglib/vcg/simplex/vertex/base.h	/^    bool IsR() const {return (this->cFlags() & NOTREAD) == 0;} \/\/\/  checks if the vertex is readable$/;"	f	class:vcg::VertexArityMax
IsRW	vcglib/vcg/connectors/hedge.h	/^	bool IsRW() const {return (this->Flags() & (NOTREAD | NOTWRITE)) == 0;}\/\/\/ This funcion checks whether the vertex is both readable and modifiable$/;"	f	class:vcg::HEdgeArityMax
IsRW	vcglib/vcg/simplex/edge/base.h	/^	bool IsRW() const {return (this->Flags() & (NOTREAD | NOTWRITE)) == 0;}\/\/\/ This funcion checks whether the vertex is both readable and modifiable$/;"	f	class:vcg::EdgeArityMax
IsRW	vcglib/vcg/simplex/face/base.h	/^	bool IsRW() const {return (this->cFlags() & (NOTREAD | NOTWRITE)) == 0;}$/;"	f	class:vcg::FaceArityMax
IsRW	vcglib/vcg/simplex/tetrahedron/base.h	/^	bool IsRW() const {return (this->Flags() & (NOTREAD | NOTWRITE)) == 0;}$/;"	f	class:vcg::TetraArityMax
IsRW	vcglib/vcg/simplex/vertex/base.h	/^    bool IsRW() const {return (this->cFlags() & (NOTREAD | NOTWRITE)) == 0;}\/\/\/ This funcion checks whether the vertex is both readable and modifiable$/;"	f	class:vcg::VertexArityMax
IsRadiusEnabled	vcglib/vcg/simplex/vertex/component.h	/^  inline bool IsRadiusEnabled() const { return TT::VertexType::HasRadius();}$/;"	f	class:vcg::vertex::EmptyCore
IsRadiusEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline bool IsRadiusEnabled( )       const  { return this->Base().IsRadiusEnabled(); }$/;"	f	class:vcg::vertex::RadiusOcf
IsRadiusEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool IsRadiusEnabled() const {return RadiusEnabled;}$/;"	f	class:vcg::vertex::vector_ocf
IsReady	vcglib/wrap/gui/rubberband.cpp	/^bool Rubberband::IsReady()$/;"	f	class:Rubberband
IsRegularMesh	vcglib/vcg/complex/algorithms/clean.h	/^            static void IsRegularMesh(MeshType &m, bool &Regular, bool &Semiregular)$/;"	f	class:vcg::tri::Clean
IsRepeatable	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon99
IsRepeatable	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon97
IsRepeatable	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon98
IsRepeatable	vcglib/eigenlib/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon222
IsRotSeam	vcglib/wrap/miq/core/seams_initializer.h	/^    bool IsRotSeam(const FaceType *f0,const int edge)$/;"	f	class:SeamsInitializer
IsRowMajor	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    IsRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon50
IsRowMajor	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      IsRowMajor = int(Flags) & RowMajorBit, \/**< True if this expression has row-major storage order. *\/$/;"	e	enum:Eigen::DenseBase::__anon58
IsRowMajor	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    IsRowMajor = MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1 ? 1$/;"	e	enum:Eigen::internal::traits::__anon234
IsRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    enum { IsRowMajor = (Derived::Flags&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::DenseBase::InnerIterator::__anon406
IsRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::MappedSparseMatrix::__anon407
IsRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    IsRowMajor = (int(MatrixType::Flags)&RowMajorBit)==RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon408
IsRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<SparseInnerVectorSet>::IsRowMajor };$/;"	e	enum:Eigen::SparseInnerVectorSet::__anon409
IsRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<SparseInnerVectorSet>::IsRowMajor };$/;"	e	enum:Eigen::SparseInnerVectorSet::__anon410
IsRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Lhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon411
IsRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Rhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon412
IsRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsRowMajor = Flags&RowMajorBit ? 1 : 0,$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
IsRowMajor	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        IsRowMajor = Flags & RowMajorBit ? 1 : 0$/;"	e	enum:Eigen::SkylineMatrixBase::__anon451
IsRowMajor	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    enum { IsRowMajor = internal::traits<SparseInnerVectorSet>::IsRowMajor };$/;"	e	enum:Eigen::SparseInnerVectorSet::__anon455
IsS	vcglib/vcg/connectors/hedge.h	/^	bool IsS() const {return (this->Flags() & SELECTED) != 0;}\/\/\/  checks if the vertex is Selected$/;"	f	class:vcg::HEdgeArityMax
IsS	vcglib/vcg/simplex/edge/base.h	/^	bool IsS() const {return (this->Flags() & SELECTED) != 0;}\/\/\/  checks if the vertex is Selected$/;"	f	class:vcg::EdgeArityMax
IsS	vcglib/vcg/simplex/face/base.h	/^	bool IsS() const {return (this->cFlags() & SELECTED) != 0;}$/;"	f	class:vcg::FaceArityMax
IsS	vcglib/vcg/simplex/tetrahedron/base.h	/^	bool IsS() const {return (this->Flags() & SELECTED) != 0;}$/;"	f	class:vcg::TetraArityMax
IsS	vcglib/vcg/simplex/vertex/base.h	/^    bool IsS() const {return (this->cFlags() & SELECTED) != 0;}\/\/\/  checks if the vertex is Selected$/;"	f	class:vcg::VertexArityMax
IsSTLBinary	vcglib/wrap/io_trimesh/import_stl.h	/^static bool IsSTLBinary(const char * filename)$/;"	f	class:vcg::tri::io::ImporterSTL
IsSTLColored	vcglib/wrap/io_trimesh/import_stl.h	/^static bool IsSTLColored(const char * filename, bool &magicsMode)$/;"	f	class:vcg::tri::io::ImporterSTL
IsSeam	vcglib/wrap/miq/core/vertex_indexing.h	/^    bool IsSeam(FaceType *f0,FaceType *f1)$/;"	f	class:VertexIndexing
IsSigned	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^    IsSigned = std::numeric_limits<T>::is_signed,$/;"	e	enum:Eigen::GenericNumTraits::__anon185
IsSinglet	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool IsSinglet(const FaceType& f, int wedge){$/;"	f	class:vcg::tri::BitQuad
IsSingletFF	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool IsSingletFF(const FaceType& f, int wedge){$/;"	f	class:vcg::tri::BitQuad
IsSingularByCross	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static bool IsSingularByCross(const VertexType &v,int &missmatch)$/;"	f	class:vcg::tri::CrossField
IsSingularByMMatch	vcglib/wrap/miq/core/seams_initializer.h	/^    bool IsSingularByMMatch(const VertexType &v,int &missmatch)$/;"	f	class:SeamsInitializer
IsSizeConsistent	vcglib/vcg/complex/algorithms/clean.h	/^      static bool IsSizeConsistent(MeshType &m)$/;"	f	class:vcg::tri::Clean
IsSkyline	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^enum {IsSkyline = SkylineBit};$/;"	e	enum:Eigen::__anon453
IsSorted	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    IsSorted = 0$/;"	e	enum:Eigen::GoogleDenseHashMapTraits::__anon461
IsSorted	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    IsSorted = 0$/;"	e	enum:Eigen::GoogleSparseHashMapTraits::__anon462
IsSorted	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    IsSorted = 0$/;"	e	enum:Eigen::StdUnorderedMapTraits::__anon460
IsSorted	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    IsSorted = 1$/;"	e	enum:Eigen::StdMapTraits::__anon459
IsSparse	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  IsSparse$/;"	e	enum:Eigen::__anon265
IsSpinnable	vcglib/wrap/gui/trackball.cpp	/^bool Trackball::IsSpinnable() {$/;"	f	class:Trackball
IsSpinning	vcglib/wrap/gui/trackball.cpp	/^bool Trackball::IsSpinning() {$/;"	f	class:Trackball
IsSupported	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^{ enum { IsSupported = 0 }; };$/;"	e	enum:Eigen::internal::vml_call::__anon42
IsSymmetric	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  static bool IsSymmetric(BaseParameterClass *) { return true;}$/;"	f	class:vcg::tri::TriEdgeCollapse
IsSymmetric	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  static bool IsSymmetric(BaseParameterClass *_pp) {return ((QParameter *)_pp)->OptimalPlacement;}$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
IsSymmetric	vcglib/wrap/math/sparse_matrix.h	/^virtual bool IsSymmetric()$/;"	f	class:SparseMatrix
IsSymmetric	vcglib/wrap/math/system_interface_ldl.h	/^bool IsSymmetric()$/;"	f	class:SystemLDL
IsTerminationFlag	vcglib/vcg/complex/algorithms/local_optimization.h	/^	bool IsTerminationFlag		(int v){return ((tf & v)!=0);}$/;"	f	class:vcg::LocalOptimization
IsTexCoordEnabled	vcglib/vcg/simplex/vertex/component.h	/^  inline bool IsTexCoordEnabled() const { return TT::VertexType::HasTexCoord();}$/;"	f	class:vcg::vertex::EmptyCore
IsTexCoordEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline bool IsTexCoordEnabled( )     const  { return this->Base().IsTexCoordEnabled(); }$/;"	f	class:vcg::vertex::TexCoordOcf
IsTexCoordEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool IsTexCoordEnabled() const {return TexCoordEnabled;}$/;"	f	class:vcg::vertex::vector_ocf
IsTheSameAsLast	vcglib/vcg/container/container_allocation_table.h	/^IsTheSameAsLast(const ValueType * pt)$/;"	f	class:vcg::CATEntry
IsTransfCongruent	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^bool FourPCS<MeshType>::IsTransfCongruent(FourPoints fp, vcg::Matrix44<ScalarType> & mat, float &  trerr){$/;"	f	class:vcg::tri::FourPCS
IsTransposed	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = Base::IsTransposed ? 0 : 1$/;"	e	enum:Eigen::internal::blas_traits::__anon257
IsTransposed	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon255
IsTriOnly	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static bool IsTriOnly(const MeshType &m){$/;"	f	class:vcg::tri::BitQuadCreation
IsTriQuadOnly	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static bool IsTriQuadOnly(const MeshType &m){$/;"	f	class:vcg::tri::BitQuadCreation
IsUpToDate	vcglib/vcg/complex/algorithms/hole.h	/^  bool IsUpToDate()	{return ( e0.IsBorder() && e1.IsBorder());}$/;"	f	class:vcg::tri::TrivialEar
IsUpToDate	vcglib/vcg/complex/algorithms/local_optimization.h	/^    bool IsUpToDate() const$/;"	f	struct:vcg::LocalOptimization::HeapElem
IsUpToDate	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            inline bool IsUpToDate()$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
IsUpToDate	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  bool IsUpToDate(){$/;"	f	class:vcg::tetra::TetraEdgeCollapse
IsUpToDate	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  inline bool IsUpToDate() const$/;"	f	class:vcg::tri::TriEdgeCollapse
IsUpToDate	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  bool IsUpToDate() const$/;"	f	class:vcg::tri::PlanarEdgeFlip
IsUserBit	vcglib/vcg/connectors/hedge.h	/^	bool IsUserBit(int userBit){return (this->Flags() & userBit) != 0;}$/;"	f	class:vcg::HEdgeArityMax
IsUserBit	vcglib/vcg/simplex/edge/base.h	/^	bool IsUserBit(int userBit){return (this->Flags() & userBit) != 0;}$/;"	f	class:vcg::EdgeArityMax
IsUserBit	vcglib/vcg/simplex/face/base.h	/^	bool IsUserBit(int userBit){return (this->Flags() & userBit) != 0;}$/;"	f	class:vcg::FaceArityMax
IsUserBit	vcglib/vcg/simplex/tetrahedron/base.h	/^	bool IsUserBit(int userBit){return (this->Flags() & userBit) != 0;}$/;"	f	class:vcg::TetraArityMax
IsUserBit	vcglib/vcg/simplex/vertex/base.h	/^	bool IsUserBit(int userBit){return (this->Flags() & userBit) != 0;}$/;"	f	class:vcg::VertexArityMax
IsV	vcglib/vcg/connectors/hedge.h	/^	bool IsV() const {return (this->Flags() & VISITED) != 0;}\/\/\/  checks if the vertex Has been visited$/;"	f	class:vcg::HEdgeArityMax
IsV	vcglib/vcg/simplex/edge/base.h	/^	bool IsV() const {return (this->Flags() & VISITED) != 0;}\/\/\/  checks if the vertex Has been visited$/;"	f	class:vcg::EdgeArityMax
IsV	vcglib/vcg/simplex/face/base.h	/^	bool IsV() const {return (this->cFlags() & VISITED) != 0;}$/;"	f	class:vcg::FaceArityMax
IsV	vcglib/vcg/simplex/tetrahedron/base.h	/^	bool IsV() const {return (this->Flags() & VISITED) != 0;}$/;"	f	class:vcg::TetraArityMax
IsV	vcglib/vcg/simplex/vertex/base.h	/^    bool IsV() const {return (this->cFlags() & VISITED) != 0;}\/\/\/  checks if the vertex Has been visited$/;"	f	class:vcg::VertexArityMax
IsVFAdjacencyEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^bool IsVFAdjacencyEnabled() const {return VFAdjacencyEnabled;}$/;"	f	class:vcg::face::vector_ocf
IsVFAdjacencyEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  bool IsVFAdjacencyEnabled(const typename T::VertexType *vp)   {return vp->Base().VFAdjacencyEnabled;}$/;"	f	class:vcg::vertex::VFAdjOcf
IsVFAdjacencyEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool IsVFAdjacencyEnabled() const {return VFAdjacencyEnabled;}$/;"	f	class:vcg::vertex::vector_ocf
IsVFInitialized	vcglib/vcg/simplex/face/component.h	/^  bool IsVFInitialized(const int j) const {return  static_cast<const typename T::FaceType *>(this)->cVFi(j)!=-1;}$/;"	f	class:vcg::face::EmptyCore
IsVFInitialized	vcglib/vcg/simplex/vertex/component.h	/^  bool IsVFInitialized() const {return static_cast<const typename TT::VertexType *>(this)->cVFi()!=-1;}$/;"	f	class:vcg::vertex::EmptyCore
IsValid	vcglib/vcg/math/quadric.h	/^	bool IsValid() const { return c>=0; }$/;"	f	class:vcg::math::Quadric
IsValid	vcglib/vcg/math/quadric5.h	/^	bool IsValid() const { return (c>=0); }$/;"	f	class:vcg::Quadric5
IsValid	vcglib/vcg/math/shot.h	/^  bool IsValid() const$/;"	f	class:vcg::Shot
IsValid	vcglib/vcg/space/box2.h	/^	inline bool IsValid() const { return min.X()<max.X() && min.Y()<max.Y(); }$/;"	f	class:vcg::Box2
IsValid	vcglib/wrap/gl/fbo.h	/^	bool IsValid(void) const$/;"	f	class:FrameBuffer
IsValid	vcglib/wrap/miq/MIQ.h	/^  static bool IsValid(MeshType &mesh)$/;"	f	class:MIQ_parametrization
IsValidHandle	vcglib/vcg/complex/allocate.h	/^    bool IsValidHandle( MeshType & m,  const typename MeshType::template PerEdgeAttributeHandle<ATTR_TYPE> & a){$/;"	f	class:vcg::tri::Allocator
IsValidHandle	vcglib/vcg/complex/allocate.h	/^    bool IsValidHandle( MeshType & m,  const typename MeshType::template PerFaceAttributeHandle<ATTR_TYPE> & a){$/;"	f	class:vcg::tri::Allocator
IsValidHandle	vcglib/vcg/complex/allocate.h	/^    bool IsValidHandle( MeshType & m,  const typename MeshType::template PerMeshAttributeHandle<ATTR_TYPE> & a){$/;"	f	class:vcg::tri::Allocator
IsValidHandle	vcglib/vcg/complex/allocate.h	/^    bool IsValidHandle( MeshType & m,  const typename MeshType::template PerVertexAttributeHandle<ATTR_TYPE> & a){$/;"	f	class:vcg::tri::Allocator
IsVectorAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1$/;"	e	enum:Eigen::DenseBase::__anon58
IsVectorAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^      IsVectorAtCompileTime = 0,$/;"	e	enum:Eigen::DiagonalBase::__anon65
IsVectorAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
IsVectorAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon451
IsVertexAdjacentToAnyNonManifoldEdge	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  static bool IsVertexAdjacentToAnyNonManifoldEdge (const vcg::face::Pos<FaceType> &pos) {$/;"	f	class:vcg::tri::PolychordCollapse
IsVertexStable	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  static bool IsVertexStable(BaseParameterClass *_pp) {return !((QParameter *)_pp)->OptimalPlacement;}$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
IsVertical	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^      IsVertical   = (Direction==Vertical) ? 1 : 0,$/;"	e	enum:Eigen::VectorwiseOp::__anon324
IsVisible	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	static inline bool IsVisible(const NodeType * node) {$/;"	f	class:vcg::AABBBinaryTreeFrustumCull
IsW	vcglib/vcg/connectors/hedge.h	/^	bool IsW() const {return (this->Flags() & NOTWRITE)== 0;}\/\/\/  checks if the vertex is modifiable$/;"	f	class:vcg::HEdgeArityMax
IsW	vcglib/vcg/simplex/edge/base.h	/^	bool IsW() const {return (this->Flags() & NOTWRITE)== 0;}\/\/\/  checks if the vertex is modifiable$/;"	f	class:vcg::EdgeArityMax
IsW	vcglib/vcg/simplex/face/base.h	/^	bool IsW() const {return (this->cFlags() & NOTWRITE)== 0;}$/;"	f	class:vcg::FaceArityMax
IsW	vcglib/vcg/simplex/tetrahedron/base.h	/^	bool IsW() const {return (this->Flags() & NOTWRITE)== 0;}$/;"	f	class:vcg::TetraArityMax
IsW	vcglib/vcg/simplex/vertex/base.h	/^    bool IsW() const {return (this->cFlags() & NOTWRITE)== 0;}\/\/\/  checks if the vertex is modifiable$/;"	f	class:vcg::VertexArityMax
IsWedgeColorEnabled	vcglib/vcg/simplex/face/component.h	/^  inline bool IsWedgeColorEnabled( )    const { return T::FaceType::HasWedgeColor(); }$/;"	f	class:vcg::face::EmptyCore
IsWedgeColorEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  inline bool IsWedgeColorEnabled( )    const { return this->Base().IsWedgeColorEnabled(); }$/;"	f	class:vcg::face::WedgeColorOcf
IsWedgeColorEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^bool IsWedgeColorEnabled() const {return WedgeColorEnabled;}$/;"	f	class:vcg::face::vector_ocf
IsWedgeNormalEnabled	vcglib/vcg/simplex/face/component.h	/^  inline bool IsWedgeNormalEnabled( )   const { return T::FaceType::HasWedgeNormal(); }$/;"	f	class:vcg::face::EmptyCore
IsWedgeNormalEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  inline bool IsWedgeNormalEnabled( )   const { return this->Base().IsWedgeNormalEnabled(); }$/;"	f	class:vcg::face::WedgeNormalOcf
IsWedgeNormalEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^bool IsWedgeNormalEnabled() const {return WedgeNormalEnabled;}$/;"	f	class:vcg::face::vector_ocf
IsWedgeTexCoordEnabled	vcglib/vcg/simplex/face/component.h	/^  inline bool IsWedgeTexCoordEnabled( ) const { return T::FaceType::HasWedgeTexCoord(); }$/;"	f	class:vcg::face::EmptyCore
IsWedgeTexCoordEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  inline bool IsWedgeTexCoordEnabled( ) const { return this->Base().IsWedgeTexCoordEnabled(); }$/;"	f	class:vcg::face::WedgeTexCoordOcf
IsWedgeTexCoordEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^bool IsWedgeTexCoordEnabled() const {return WedgeTexEnabled;}$/;"	f	class:vcg::face::vector_ocf
Is_Inside	vcglib/vcg/complex/algorithms/inside.h	/^			static bool Is_Inside( TriMeshType & m, FaceSpatialIndexing & _g_mesh, const CoordType & test )$/;"	f	class:vcg::tri::Inside
Isometry	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Isometry      = 0x1,$/;"	e	enum:Eigen::TransformTraits
Isometry2d	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Isometry> Isometry2d;$/;"	t	namespace:Eigen
Isometry2f	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Isometry> Isometry2f;$/;"	t	namespace:Eigen
Isometry3d	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Isometry> Isometry3d;$/;"	t	namespace:Eigen
Isometry3f	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Isometry> Isometry3f;$/;"	t	namespace:Eigen
IsometryTransformType	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Isometry> IsometryTransformType;$/;"	t	class:Eigen::Translation
IsotropicDistance	vcglib/vcg/complex/algorithms/geodesic.h	/^  IsotropicDistance(MeshType &m, float variance)$/;"	f	class:vcg::tri::IsotropicDistance
IsotropicDistance	vcglib/vcg/complex/algorithms/geodesic.h	/^class IsotropicDistance{$/;"	c	namespace:vcg::tri
Item	vcglib/wrap/gcache/dheap.h	/^    Item(T *val): value(val) {}$/;"	f	class:PtrDHeap::Item
Item	vcglib/wrap/gcache/dheap.h	/^  class Item {$/;"	c	class:PtrDHeap
IterBase	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  typedef typename _MatrixTypeNested::InnerIterator IterBase;$/;"	t	class:Eigen::SparseView::InnerIterator
Iterate	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  ScalarType Iterate(){$/;"	f	class:vcg::tri::AreaPreservingTextureOptimizer
IterateBlind	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  void IterateBlind(){$/;"	f	class:vcg::tri::AreaPreservingTextureOptimizer
IterateN	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  virtual ScalarType IterateN(int step){$/;"	f	class:vcg::tri::TextureOptimizer
IterateUntilConvergence	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  bool IterateUntilConvergence(ScalarType threshold=0.0001, int maxite=5000){$/;"	f	class:vcg::tri::TextureOptimizer
IterationController	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    IterationController(double r = 1.0E-8, int noi = 0, size_t mit = size_t(-1))$/;"	f	class:Eigen::IterationController
IterationController	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^class IterationController$/;"	c	namespace:Eigen
IterativeSolverBase	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase()$/;"	f	class:Eigen::IterativeSolverBase
IterativeSolverBase	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase
IterativeSolverBase	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^class IterativeSolverBase : internal::noncopyable$/;"	c	namespace:Eigen
Iterator	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Iterator(const AmbiVector& vec, RealScalar epsilon = 0)$/;"	f	class:Eigen::internal::AmbiVector::Iterator
Iterator	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector<_Scalar,_Index>::Iterator$/;"	c	class:Eigen::internal::AmbiVector
Iterator	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  Iterator(Pos& pos){$/;"	f	class:vcg::tri::BitQuad::Iterator
Iterator	vcglib/vcg/complex/algorithms/bitquad_support.h	/^class Iterator{$/;"	c	class:vcg::tri::BitQuad
Iterator	vcglib/wrap/glw/framebuffer.h	/^		typedef Map::iterator                  Iterator;$/;"	t	class:glw::RenderTargetMapping
Iterator	vcglib/wrap/glw/framebuffer.h	/^		typedef Map::iterator            Iterator;$/;"	t	class:glw::RenderTargetBinding
Iterator	vcglib/wrap/glw/program.h	/^		typedef Map::iterator                 Iterator;$/;"	t	class:glw::FragmentOutputBinding
Iterator	vcglib/wrap/glw/program.h	/^		typedef Map::iterator                 Iterator;$/;"	t	class:glw::VertexAttributeBinding
Jacobi	vcglib/vcg/math/old_lin_algebra.h	/^	static void Jacobi(MATRIX_TYPE &w, POINT_TYPE &d, MATRIX_TYPE &v, int &nrot)$/;"	f	namespace:vcg
JacobiRotate	vcglib/vcg/math/old_lin_algebra.h	/^	static void JacobiRotate(MATRIX_TYPE &A, typename MATRIX_TYPE::ScalarType s, typename MATRIX_TYPE::ScalarType tau, int i,int j,int k,int l)$/;"	f	namespace:vcg
JacobiRotation	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation() {}$/;"	f	class:Eigen::JacobiRotation
JacobiRotation	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}$/;"	f	class:Eigen::JacobiRotation
JacobiRotation	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^template<typename Scalar> class JacobiRotation$/;"	c	namespace:Eigen
JacobiSVD	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD()$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD(Index rows, Index cols, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD(const MatrixType& matrix, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^template<typename _MatrixType, int QRPreconditioner> class JacobiSVD$/;"	c	namespace:Eigen
JacobiSVDType	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<_MatrixType, QRPreconditioner> JacobiSVDType;$/;"	t	struct:Eigen::internal::solve_retval
JacobianType	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef typename Functor::JacobianType JacobianType;$/;"	t	class:Eigen::AutoDiffJacobian
JacobianType	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    typedef Matrix< Scalar, Dynamic, Dynamic > JacobianType;$/;"	t	class:Eigen::HybridNonLinearSolver
JacobianType	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    typedef Matrix< Scalar, Dynamic, Dynamic > JacobianType;$/;"	t	class:Eigen::LevenbergMarquardt
JacobianType	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    typedef typename Functor::JacobianType JacobianType;$/;"	t	class:Eigen::NumericalDiff
JacobianType	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;$/;"	t	struct:Functor	file:
JacobianType	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;$/;"	t	struct:Functor	file:
JacobianType	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;$/;"	t	struct:TestFunc1	file:
JacobianType	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,InputsAtCompileTime> JacobianType;$/;"	t	struct:TestFunc1	file:
JointAlignment	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    JointAlignment = assign_traits<Derived1,Derived2>::JointAlignment$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon41
JointAlignment	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    JointAlignment = bool(DstIsAligned) && bool(SrcIsAligned) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::assign_traits::__anon34
Jump	vcglib/vcg/simplex/tetrahedron/pos.h	/^  bool Jump()$/;"	f	class:vcg::tetra::PosLoop
JumpingPos	vcglib/vcg/simplex/face/jumping_pos.h	/^			JumpingPos()																																: Pos<FACE_TYPE>()   								{ }$/;"	f	class:vcg::face::JumpingPos
JumpingPos	vcglib/vcg/simplex/face/jumping_pos.h	/^			JumpingPos(FaceType * const pFace, VertexType * const pVertex)							: Pos<FACE_TYPE>(pFace, pVertex)			{  }$/;"	f	class:vcg::face::JumpingPos
JumpingPos	vcglib/vcg/simplex/face/jumping_pos.h	/^			JumpingPos(FaceType * const pFace, int const z)															: Pos<FACE_TYPE>(pFace, z)						{  }$/;"	f	class:vcg::face::JumpingPos
JumpingPos	vcglib/vcg/simplex/face/jumping_pos.h	/^			JumpingPos(FaceType * const pFace, int const z, VertexType * const pVertex) : Pos<FACE_TYPE>(pFace, z, pVertex)	{   }$/;"	f	class:vcg::face::JumpingPos
JumpingPos	vcglib/vcg/simplex/face/jumping_pos.h	/^		class JumpingPos : public Pos< FACE_TYPE >$/;"	c	namespace:vcg::face
JumpingPosType	vcglib/vcg/simplex/face/jumping_pos.h	/^			typedef						JumpingPos<FaceType>		JumpingPosType;$/;"	t	class:vcg::face::JumpingPos
K	vcglib/vcg/math/spherical_harmonics.h	/^	static ScalarType K(unsigned l, unsigned m)$/;"	f	class:vcg::math::ScalingFactor
K	vcglib/vcg/simplex/vertex/component_occ.h	/^	ScalarType  &K(){  return CAT< vector_occ<VertType>,CurvatureTypeOcc>::Instance()->Get((VertType*)this)[1];}$/;"	f	class:vcg::vertex::CurvatureOcc
K	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType>	struct K	{$/;"	s	namespace:vcg::tri::io
K0	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0 >																												struct K0	: public DerK<  MeshType, B0,	K<MeshType> > {};$/;"	s	namespace:vcg::tri::io
K1	vcglib/vcg/simplex/face/component.h	/^  ScalarType &K1()       { return _curv.k1;}$/;"	f	class:vcg::face::CurvatureDir
K1	vcglib/vcg/simplex/face/component.h	/^  float &K1()      { static float dummy(0); assert(0); return dummy;}$/;"	f	class:vcg::face::EmptyCore
K1	vcglib/vcg/simplex/face/component_ocf.h	/^  ScalarType &K1()       {$/;"	f	class:vcg::face::CurvatureDirOcf
K1	vcglib/vcg/simplex/vertex/component.h	/^	ScalarType &K1(){ return _curv.k1;}$/;"	f	class:vcg::vertex::CurvatureDir
K1	vcglib/vcg/simplex/vertex/component.h	/^  ScalarType &K1()       { static ScalarType v = 0.0;assert(0);return v;}$/;"	f	class:vcg::vertex::EmptyCore
K1	vcglib/vcg/simplex/vertex/component_occ.h	/^	ScalarType &K1(){ return CAT< vector_occ<VertType>,CurvatureDirTypeOcc>::Instance()->Get((VertType*)this).k1;}$/;"	f	class:vcg::vertex::CurvatureDirOcc
K1	vcglib/vcg/simplex/vertex/component_ocf.h	/^  ScalarType &K1()       { assert((*this).Base().CurvatureDirEnabled); return (*this).Base().CuDV[(*this).Index()].k1;}$/;"	f	class:vcg::vertex::CurvatureDirOcf
K1	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1 >																										struct K1	: public DerK<  MeshType, B1,	K0<MeshType, B0> > {};$/;"	s	namespace:vcg::tri::io
K10	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2,class B3,class B4,class B5,class B6,class B7,class B8,class B9,class B10>					struct K10	: public DerK<  MeshType, B10,	K9<MeshType, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9> > {};$/;"	s	namespace:vcg::tri::io
K11	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2,class B3,class B4,class B5,class B6,class B7,class B8,class B9,class B10,class B11>			struct K11	: public DerK<  MeshType, B11,	K10<MeshType, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B11 > > {};$/;"	s	namespace:vcg::tri::io
K12	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2,class B3,class B4,class B5,class B6,class B7,class B8,class B9,class B10,class B11,class B12>struct K12	: public DerK<  MeshType, B12,	K11<MeshType, B0, B1, B2, B3, B4, B5, B6, B7, B8, B9, B11, B12 > > {};$/;"	s	namespace:vcg::tri::io
K2	vcglib/vcg/simplex/face/component.h	/^  ScalarType &K2()       { return _curv.k2;}$/;"	f	class:vcg::face::CurvatureDir
K2	vcglib/vcg/simplex/face/component.h	/^  float &K2()      { static float dummy(0); assert(0); return dummy;}$/;"	f	class:vcg::face::EmptyCore
K2	vcglib/vcg/simplex/face/component_ocf.h	/^  ScalarType &K2()       {$/;"	f	class:vcg::face::CurvatureDirOcf
K2	vcglib/vcg/simplex/vertex/component.h	/^	ScalarType &K2(){ return _curv.k2;}$/;"	f	class:vcg::vertex::CurvatureDir
K2	vcglib/vcg/simplex/vertex/component.h	/^  ScalarType &K2()       { static ScalarType v = 0.0;assert(0);return v;}$/;"	f	class:vcg::vertex::EmptyCore
K2	vcglib/vcg/simplex/vertex/component_occ.h	/^	ScalarType &K2(){ return CAT< vector_occ<VertType>,CurvatureDirTypeOcc>::Instance()->Get((VertType*)this).k2;}$/;"	f	class:vcg::vertex::CurvatureDirOcc
K2	vcglib/vcg/simplex/vertex/component_ocf.h	/^  ScalarType &K2()       { assert((*this).Base().CurvatureDirEnabled); return (*this).Base().CuDV[(*this).Index()].k2;}$/;"	f	class:vcg::vertex::CurvatureDirOcf
K2	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2 >																							struct K2	: public DerK<  MeshType, B2,	K1<MeshType, B0, B1> > {};$/;"	s	namespace:vcg::tri::io
K3	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2,class B3>																					struct K3	: public DerK<  MeshType, B3,	K2<MeshType, B0, B1, B2> > {};$/;"	s	namespace:vcg::tri::io
K4	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2,class B3,class B4>																			struct K4	: public DerK<  MeshType, B4,	K3<MeshType, B0, B1, B2, B3> > {};$/;"	s	namespace:vcg::tri::io
K5	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2,class B3,class B4,class B5>																	struct K5	: public DerK<  MeshType, B5,	K4<MeshType, B0, B1, B2, B3, B4> > {};$/;"	s	namespace:vcg::tri::io
K6	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2,class B3,class B4,class B5,class B6>															struct K6	: public DerK<  MeshType, B6,	K5<MeshType, B0, B1, B2, B3, B4, B5> > {};$/;"	s	namespace:vcg::tri::io
K7	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2,class B3,class B4,class B5,class B6,class B7>												struct K7	: public DerK<  MeshType, B7,	K6<MeshType, B0, B1, B2, B3, B4, B5, B6> > {};$/;"	s	namespace:vcg::tri::io
K8	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2,class B3,class B4,class B5,class B6,class B7,class B8>										struct K8	: public DerK<  MeshType, B8,	K7<MeshType, B0, B1, B2, B3, B4, B5, B6, B7> > {};$/;"	s	namespace:vcg::tri::io
K9	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <class MeshType, class B0, class B1, class B2,class B3,class B4,class B5,class B6,class B7,class B8,class B9>								struct K9	: public DerK<  MeshType, B9,	K8<MeshType, B0, B1, B2, B3, B4, B5, B6, B7, B8> > {};$/;"	s	namespace:vcg::tri::io
KClosest	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^	static inline unsigned int KClosest(TreeType & tree, OBJPOINTDISTANCEFUNCT & getPointDistance, const unsigned int k, const CoordType & p, const ScalarType & maxDist, OBJPTRCONTAINERTYPE & objects, DISTCONTAINERTYPE & distances, POINTCONTAINERTYPE & points) {$/;"	f	class:vcg::AABBBinaryTreeKClosest
KDBVH_H_INCLUDED	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^#define KDBVH_H_INCLUDED$/;"	d
KDTREE_H	vcglib/vcg/space/index/kdtree/kdtree.h	/^#define KDTREE_H$/;"	d
KEY_ALT	vcglib/wrap/gui/trackball.h	/^                KEY_ALT       = 0x0040, \/\/\/< Alt key pressed.$/;"	e	enum:vcg::Trackball::Button
KEY_CTRL	vcglib/wrap/gui/trackball.h	/^                KEY_CTRL      = 0x0020, \/\/\/< Ctrl key pressed.$/;"	e	enum:vcg::Trackball::Button
KEY_DOWN	vcglib/wrap/gui/trackball.h	/^								KEY_DOWN      = 0x0200, \/\/\/< Down directional key$/;"	e	enum:vcg::Trackball::Button
KEY_LEFT	vcglib/wrap/gui/trackball.h	/^								KEY_LEFT      = 0x0400, \/\/\/< Left directional key$/;"	e	enum:vcg::Trackball::Button
KEY_PGDOWN	vcglib/wrap/gui/trackball.h	/^								KEY_PGDOWN    = 0x2000, \/\/\/< PageDown directional key$/;"	e	enum:vcg::Trackball::Button
KEY_PGUP	vcglib/wrap/gui/trackball.h	/^								KEY_PGUP      = 0x1000, \/\/\/< PageUp directional key$/;"	e	enum:vcg::Trackball::Button
KEY_RIGHT	vcglib/wrap/gui/trackball.h	/^								KEY_RIGHT     = 0x0800, \/\/\/< Right directional key$/;"	e	enum:vcg::Trackball::Button
KEY_SHIFT	vcglib/wrap/gui/trackball.h	/^                KEY_SHIFT     = 0x0010, \/\/\/< Shift key pressed.$/;"	e	enum:vcg::Trackball::Button
KEY_UP	vcglib/wrap/gui/trackball.h	/^								KEY_UP        = 0x0100, \/\/\/< Up directional key$/;"	e	enum:vcg::Trackball::Button
KRONECKER_TENSOR_PRODUCT_H	vcglib/eigenlib/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^#define KRONECKER_TENSOR_PRODUCT_H$/;"	d
KT_DXF	vcglib/wrap/io_trimesh/export.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_DXF, KT_OFF, KT_OBJ};$/;"	e	enum:vcg::tri::io::Exporter::KnownTypes
KT_OBJ	vcglib/wrap/io_trimesh/export.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_DXF, KT_OFF, KT_OBJ};$/;"	e	enum:vcg::tri::io::Exporter::KnownTypes
KT_OBJ	vcglib/wrap/io_trimesh/import.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_OFF, KT_OBJ, KT_VMI };$/;"	e	enum:vcg::tri::io::Importer::KnownTypes
KT_OFF	vcglib/wrap/io_trimesh/export.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_DXF, KT_OFF, KT_OBJ};$/;"	e	enum:vcg::tri::io::Exporter::KnownTypes
KT_OFF	vcglib/wrap/io_trimesh/import.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_OFF, KT_OBJ, KT_VMI };$/;"	e	enum:vcg::tri::io::Importer::KnownTypes
KT_PLY	vcglib/wrap/io_trimesh/export.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_DXF, KT_OFF, KT_OBJ};$/;"	e	enum:vcg::tri::io::Exporter::KnownTypes
KT_PLY	vcglib/wrap/io_trimesh/import.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_OFF, KT_OBJ, KT_VMI };$/;"	e	enum:vcg::tri::io::Importer::KnownTypes
KT_STL	vcglib/wrap/io_trimesh/export.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_DXF, KT_OFF, KT_OBJ};$/;"	e	enum:vcg::tri::io::Exporter::KnownTypes
KT_STL	vcglib/wrap/io_trimesh/import.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_OFF, KT_OBJ, KT_VMI };$/;"	e	enum:vcg::tri::io::Importer::KnownTypes
KT_UNKNOWN	vcglib/wrap/io_trimesh/export.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_DXF, KT_OFF, KT_OBJ};$/;"	e	enum:vcg::tri::io::Exporter::KnownTypes
KT_UNKNOWN	vcglib/wrap/io_trimesh/import.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_OFF, KT_OBJ, KT_VMI };$/;"	e	enum:vcg::tri::io::Importer::KnownTypes
KT_VMI	vcglib/wrap/io_trimesh/import.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_OFF, KT_OBJ, KT_VMI };$/;"	e	enum:vcg::tri::io::Importer::KnownTypes
K_PI	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static CoordType K_PI(const CoordType &a, const CoordType &b, const CoordType &n)$/;"	f	class:vcg::tri::CrossField
Ka	vcglib/wrap/io_trimesh/io_material.h	/^		Point3f Ka;\/\/ambient$/;"	m	struct:vcg::tri::io::Material
Kd	vcglib/wrap/io_trimesh/io_material.h	/^		Point3f Kd;\/\/diffuse$/;"	m	struct:vcg::tri::io::Material
KdBVH	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  KdBVH() {}$/;"	f	class:Eigen::KdBVH
KdBVH	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  template<typename Iter> KdBVH(Iter begin, Iter end) { init(begin, end, 0, 0); } \/\/int is recognized by init as not being an iterator type$/;"	f	class:Eigen::KdBVH
KdBVH	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  template<typename OIter, typename BIter> KdBVH(OIter begin, OIter end, BIter boxBegin, BIter boxEnd) { init(begin, end, boxBegin, boxEnd); }$/;"	f	class:Eigen::KdBVH
KdBVH	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^template<typename _Scalar, int _Dim, typename _Object> class KdBVH$/;"	c	namespace:Eigen
KdTree	vcglib/vcg/space/index/kdtree/kdtree.h	/^KdTree<Scalar>::KdTree(const ConstDataWrapper<VectorType>& points, unsigned int nofPointsPerCell, unsigned int maxDepth)$/;"	f	class:KdTree
KdTree	vcglib/vcg/space/index/kdtree/kdtree.h	/^class KdTree$/;"	c
KeepsPacketAccess	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    KeepsPacketAccess = bool(HasNoInnerStride)$/;"	e	enum:Eigen::internal::traits::__anon173
KernelResultType	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    > KernelResultType;$/;"	t	class:Eigen::LU
Key	vcglib/wrap/io_trimesh/export_3ds.h	/^		typedef std::pair<int,vcg::TexCoord2<float> > Key;$/;"	t	class:vcg::tri::io::Exporter3DS
KeyType	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    typedef typename MapTraits<ScalarWrapper>::KeyType KeyType;$/;"	t	class:Eigen::RandomSetter
KeyType	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef int KeyType;$/;"	t	struct:Eigen::GoogleDenseHashMapTraits
KeyType	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef int KeyType;$/;"	t	struct:Eigen::GoogleSparseHashMapTraits
KeyType	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef int KeyType;$/;"	t	struct:Eigen::StdMapTraits
KeyType	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef int KeyType;$/;"	t	struct:Eigen::StdUnorderedMapTraits
Kg	vcglib/vcg/simplex/vertex/component.h	/^          ScalarType &Kg()       { return _hk[1];}$/;"	f	class:vcg::vertex::Curvature
Kg	vcglib/vcg/simplex/vertex/component.h	/^    const ScalarType &Kg() const { return _hk[1];}$/;"	f	class:vcg::vertex::Curvature
Kg	vcglib/vcg/simplex/vertex/component.h	/^  float &Kg()       { static float dummy = 0.f; assert(0);return dummy;}$/;"	f	class:vcg::vertex::EmptyCore
Kg	vcglib/vcg/simplex/vertex/component_ocf.h	/^  ScalarType &Kg(){  assert((*this).Base().CurvatureEnabled); return (*this).Base().CuV[(*this).Index()][1];}$/;"	f	class:vcg::vertex::CurvatureOcf
Kh	vcglib/vcg/simplex/vertex/component.h	/^          ScalarType &Kh()       { return _hk[0];}$/;"	f	class:vcg::vertex::Curvature
Kh	vcglib/vcg/simplex/vertex/component.h	/^    const ScalarType &Kh() const { return _hk[0];}$/;"	f	class:vcg::vertex::Curvature
Kh	vcglib/vcg/simplex/vertex/component.h	/^  float &Kh()       { static float dummy = 0.f; assert(0);return dummy;}$/;"	f	class:vcg::vertex::EmptyCore
Kh	vcglib/vcg/simplex/vertex/component_ocf.h	/^  ScalarType &Kh(){  assert((*this).Base().CurvatureEnabled); return (*this).Base().CuV[(*this).Index()][0];}$/;"	f	class:vcg::vertex::CurvatureOcf
KillEdge	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  void KillEdge(std::list<FrontEdge>::iterator e)$/;"	f	class:vcg::tri::AdvancingFront
KnotAveraging	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFitting.h	/^  void KnotAveraging(const KnotVectorType& parameters, DenseIndex degree, KnotVectorType& knots)$/;"	f	namespace:Eigen
KnotVectorType	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    typedef typename SplineTraits<Spline>::KnotVectorType KnotVectorType;$/;"	t	class:Eigen::Spline
KnotVectorType	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFitting.h	/^    typedef typename SplineType::KnotVectorType KnotVectorType;$/;"	t	struct:Eigen::SplineFitting
KnotVectorType	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,1,Dynamic> KnotVectorType;$/;"	t	struct:Eigen::SplineTraits
KnownTypes	vcglib/wrap/io_trimesh/export.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_DXF, KT_OFF, KT_OBJ};$/;"	g	class:vcg::tri::io::Exporter
KnownTypes	vcglib/wrap/io_trimesh/import.h	/^  enum KnownTypes { KT_UNKNOWN, KT_PLY, KT_STL, KT_OFF, KT_OBJ, KT_VMI };$/;"	g	class:vcg::tri::io::Importer
Ks	vcglib/wrap/io_trimesh/io_material.h	/^		Point3f Ks;\/\/specular$/;"	m	struct:vcg::tri::io::Material
LACKS_ERRNO_H	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define LACKS_ERRNO_H$/;"	d	file:
LACKS_FCNTL_H	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define LACKS_FCNTL_H$/;"	d	file:
LACKS_STRINGS_H	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define LACKS_STRINGS_H$/;"	d	file:
LACKS_STRING_H	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define LACKS_STRING_H$/;"	d	file:
LACKS_SYS_MMAN_H	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define LACKS_SYS_MMAN_H$/;"	d	file:
LACKS_SYS_PARAM_H	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define LACKS_SYS_PARAM_H$/;"	d	file:
LACKS_SYS_TYPES_H	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define LACKS_SYS_TYPES_H$/;"	d	file:
LACKS_UNISTD_H	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define LACKS_UNISTD_H$/;"	d	file:
LCEdge	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^      LCEdge() {v1 = v2 = NULL;}  \/\/ default contructor$/;"	f	struct:vcg::tri::PolychordCollapse::LinkConditions::LCEdge
LCEdge	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    struct LCEdge {$/;"	s	class:vcg::tri::PolychordCollapse::LinkConditions
LCEdgeStar	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    typedef std::set<LCEdge *> LCEdgeStar;      \/\/ define the set of edges whose star involves a vertex$/;"	t	class:vcg::tri::PolychordCollapse::LinkConditions
LCVertex	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    struct LCVertex {$/;"	s	class:vcg::tri::PolychordCollapse::LinkConditions
LCVertexStar	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    typedef std::set<LCVertex *> LCVertexStar;  \/\/ define the star of a vertex$/;"	t	class:vcg::tri::PolychordCollapse::LinkConditions
LC_ResetStars	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    void LC_ResetStars (const PolyMeshType &mesh, const vcg::face::Pos<FaceType> &startPos) {$/;"	f	class:vcg::tri::PolychordCollapse::LinkConditions
LC_SimulateEdgeCollapse	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    void LC_SimulateEdgeCollapse (LCEdge &edge) {$/;"	f	class:vcg::tri::PolychordCollapse::LinkConditions
LC_computeStars	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    void LC_computeStars (const PolyMeshType &mesh, const vcg::face::Pos<FaceType> &startPos, std::list<LCEdge> &lcEdges)$/;"	f	class:vcg::tri::PolychordCollapse::LinkConditions
LDFLAGS	Makefile	/^LDFLAGS    = ${LDFLAGS_COMMON}$/;"	m
LDLT	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    LDLT() : m_matrix(), m_transpositions(), m_isInitialized(false) {}$/;"	f	class:Eigen::LDLT
LDLT	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    LDLT(Index size)$/;"	f	class:Eigen::LDLT
LDLT	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    LDLT(const MatrixType& matrix)$/;"	f	class:Eigen::LDLT
LDLT	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^template<typename _MatrixType, int _UpLo> class LDLT$/;"	c	namespace:Eigen
LDLTTraits	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT<MatrixType,UpLo> > LDLTTraits;$/;"	t	class:Eigen::SimplicialCholesky
LDLTType	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  typedef LDLT<_MatrixType,_UpLo> LDLTType;$/;"	t	struct:Eigen::internal::solve_retval
LDLT_Traits	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LDLT_Traits	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LENGTH	vcglib/apps/plyrefine/main.cpp	/^#define LENGTH /;"	d	file:
LENGTH_CRITERION	vcglib/vcg/complex/algorithms/bitquad_support.h	/^#define LENGTH_CRITERION /;"	d
LITTLE_MACHINE	vcglib/wrap/ply/plylib.cpp	/^#define LITTLE_MACHINE$/;"	d	file:
LKE	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	static int LKE(){static int lke=0; return lke++;}$/;"	f	struct:FAIL
LKF	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	static int LKF(){static int lkf=0; return lkf++;}$/;"	f	struct:FAIL
LKV	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	static int LKV(){static int lkv=0; return lkv++;}$/;"	f	struct:FAIL
LLT	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    LLT() : m_matrix(), m_isInitialized(false) {}$/;"	f	class:Eigen::LLT
LLT	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    LLT(Index size) : m_matrix(size, size),$/;"	f	class:Eigen::LLT
LLT	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    LLT(const MatrixType& matrix)$/;"	f	class:Eigen::LLT
LLT	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^template<typename _MatrixType, int _UpLo> class LLT$/;"	c	namespace:Eigen
LLTTraits	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT<MatrixType,UpLo>  > LLTTraits;$/;"	t	class:Eigen::SimplicialCholesky
LLTType	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  typedef LLT<_MatrixType,UpLo> LLTType;$/;"	t	struct:Eigen::internal::solve_retval
LLT_Traits	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LLT_Traits	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LMDiff	vcglib/wrap/minpack/minpack.h	/^class LMDiff{$/;"	c
LM_DIFF	vcglib/wrap/minpack/minpack.h	/^#define LM_DIFF$/;"	d
LMatrixType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType, Lower|UnitDiag>  LMatrixType;$/;"	t	class:Eigen::SuperLU
LOCKED	vcglib/wrap/gcache/token.h	/^    enum Status { LOCKED = 1, READY = 0, CACHE = -1, REMOVE = -2, OUTSIDE = -3 };$/;"	e	enum:vcg::Token::Status
LOMetric	vcglib/vcg/complex/algorithms/local_optimization.h	/^			LOMetric		= 0x08, \/\/ test Metric (error, quality...instance dependent)$/;"	e	enum:vcg::LocalOptimization::LOTermination
LOOP	vcglib/apps/sample/trimesh_refine/trimesh_refine.cpp	/^#define LOOP	/;"	d	file:
LOTermination	vcglib/vcg/complex/algorithms/local_optimization.h	/^	 enum LOTermination {	$/;"	g	class:vcg::LocalOptimization
LOTime	vcglib/vcg/complex/algorithms/local_optimization.h	/^			LOTime			= 0x10  \/\/ test how much time is passed since the start$/;"	e	enum:vcg::LocalOptimization::LOTermination
LOWER_MASK	vcglib/vcg/math/random_generator.h	/^	static const unsigned int LOWER_MASK = 0x7fffffffu; \/\/ least significant r bits$/;"	m	class:vcg::math::MarsenneTwisterRNG
LOnOps	vcglib/vcg/complex/algorithms/local_optimization.h	/^			LOnOps			= 0x04, \/\/ test number of operations$/;"	e	enum:vcg::LocalOptimization::LOTermination
LOnSimplices	vcglib/vcg/complex/algorithms/local_optimization.h	/^      LOnSimplices	= 0x01,	\/\/ test number of simplicies	$/;"	e	enum:vcg::LocalOptimization::LOTermination
LOnVertices	vcglib/vcg/complex/algorithms/local_optimization.h	/^			LOnVertices		= 0x02, \/\/ test number of verticies$/;"	e	enum:vcg::LocalOptimization::LOTermination
LS3Projection	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline LS3Projection(Scalar beta = 1.0) : beta(beta) { reset(); }$/;"	f	struct:vcg::tri::LS3Projection
LS3Projection	vcglib/vcg/complex/algorithms/refine_loop.h	/^struct LS3Projection {$/;"	s	namespace:vcg::tri
LScalar	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef LSCALAR_TYPE LScalar;$/;"	t	struct:vcg::tri::Centroid
LScalar	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef LSCALAR_TYPE LScalar;$/;"	t	struct:vcg::tri::LS3Projection
LU	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    explicit LU(const T& t) : Base(t), m_originalMatrix(t) {}$/;"	f	class:Eigen::LU
LU	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^class LU : public FullPivLU<MatrixType>$/;"	c	namespace:Eigen
LUMatrixType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::SuperLUBase
LUMatrixType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::LUMatrixType LUMatrixType;$/;"	t	class:Eigen::SuperLU
LUMatrixType	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::UmfPackLU
LVector	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef vcg::Point3<LScalar> LVector;$/;"	t	struct:vcg::tri::Centroid
LVector	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef vcg::Point3<LScalar> LVector;$/;"	t	struct:vcg::tri::LS3Projection
LabelPosition	vcglib/wrap/qt/gl_label.h	/^    enum LabelPosition { TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT} ;$/;"	g	class:vcg::glLabel
LaplaceDistortion	vcglib/wrap/miq/core/param_stats.h	/^typename FaceType::ScalarType LaplaceDistortion(FaceType &f ,typename FaceType::ScalarType h)$/;"	f
LaplacianFilter	vcglib/img/img_filter.h	/^inline void LaplacianFilter(const Image<Channels,SrcScalarType,SrcSafe> &source,Image<Channels,DestScalarType,DestSafe> &destination)$/;"	f	namespace:img
LaplacianInfo	vcglib/vcg/complex/algorithms/smooth.h	/^    LaplacianInfo() {}$/;"	f	class:vcg::tri::Smooth::LaplacianInfo
LaplacianInfo	vcglib/vcg/complex/algorithms/smooth.h	/^    LaplacianInfo(const CoordType &_p, const int _n):sum(_p),cnt(_n) {}$/;"	f	class:vcg::tri::Smooth::LaplacianInfo
LaplacianInfo	vcglib/vcg/complex/algorithms/smooth.h	/^class LaplacianInfo$/;"	c	class:vcg::tri::Smooth
LaplacianUVVert	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			static void LaplacianUVVert(MeshType &m,bool fix_borders=false,int steps=3)$/;"	f	class:vcg::tri::UV_Utils
Large	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  Large = 2,$/;"	e	enum:Eigen::__anon140
LargeEnough	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      LargeEnough = VmlSize==Dynamic || VmlSize>=EIGEN_MKL_VML_THRESHOLD,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
LargeThreshold	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    LargeThreshold = EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD$/;"	e	enum:Eigen::internal::product_type::__anon142
LargestOutline2	vcglib/vcg/complex/algorithms/outline_support.h	/^  static int LargestOutline2(const std::vector< std::vector< Point2f > > &outline2Vec)$/;"	f	class:vcg::tri::OutlineUtil
LastType	vcglib/wrap/io_trimesh/export.h	/^static int &LastType()$/;"	f	class:vcg::tri::io::Exporter
LastType	vcglib/wrap/io_trimesh/import.h	/^static int &LastType()$/;"	f	class:vcg::tri::io::Importer
LazyCoeffBasedProductMode	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon266
LazyCoeffBasedProductType	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef CoeffBasedProduct<LhsNested,RhsNested,NestByRefBit> LazyCoeffBasedProductType;$/;"	t	class:Eigen::CoeffBasedProduct
LazyProductReturnType	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct LazyProductReturnType : public ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen
Leaf	vcglib/vcg/space/index/octree_template.h	/^		Leaf() : Node() {};$/;"	f	struct:vcg::OctreeTemplate::Leaf
Leaf	vcglib/vcg/space/index/octree_template.h	/^		Leaf(NodePointer parent, int level) : Node(parent, level) {}$/;"	f	struct:vcg::OctreeTemplate::Leaf
Leaf	vcglib/vcg/space/index/octree_template.h	/^	struct Leaf : public Node$/;"	s	class:vcg::OctreeTemplate
LeafPointer	vcglib/vcg/space/index/octree.h	/^            typedef LEAF_TYPE* LeafPointer;$/;"	t	struct:vcg::Octree::ObjectPlaceholder
LeafPointer	vcglib/vcg/space/index/octree.h	/^        typedef typename	Octree::Leaf											* LeafPointer;$/;"	t	class:vcg::Octree
LeaveUnsorted	vcglib/vcg/math/old_lin_algebra.h	/^	enum SortingStrategy {LeaveUnsorted=0, SortAscending=1, SortDescending=2};$/;"	e	enum:vcg::SortingStrategy
LeftBlock	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix< Scalar, _Deg, Deg_1 >          LeftBlock;$/;"	t	class:Eigen::internal::companion
LeftBlockFirstRow	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix< Scalar, 1, Deg_1 >             LeftBlockFirstRow;$/;"	t	class:Eigen::internal::companion
LeftScaling	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    VectorXd& LeftScaling()$/;"	f	class:Scaling
Legendre	vcglib/vcg/math/legendre.h	/^class Legendre {$/;"	c	namespace:vcg::math
Len	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  float Len() const { return Distance(vcg::Barycenter(*f0), vcg::Barycenter(*f1)); }$/;"	f	class:vcg::tri::VoronoiProcessing::VoronoiEdge
LenSum	vcglib/vcg/complex/algorithms/smooth.h	/^    ScalarType LenSum;$/;"	m	class:vcg::tri::Smooth::ScaleLaplacianInfo
Length	vcglib/vcg/space/segment2.h	/^	ScalarType Length() const$/;"	f	class:vcg::Segment2
Length	vcglib/vcg/space/segment2.h	/^    ScalarType Length()$/;"	f	class:vcg::Segment2
Length	vcglib/vcg/space/segment3.h	/^	ScalarType Length() const$/;"	f	class:vcg::Segment3
Lerp	vcglib/vcg/space/segment2.h	/^    inline PointType Lerp( const ScalarType t ) const$/;"	f	class:vcg::Segment2
Lerp	vcglib/vcg/space/segment3.h	/^	inline PointType Lerp( const ScalarType t ) const$/;"	f	class:vcg::Segment3
Level	vcglib/vcg/space/index/octree_template.h	/^	inline char					Level(const NodePointer n)	const	{ return n->level;					}$/;"	f	class:vcg::OctreeTemplate
LevenbergMarquardt	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    LevenbergMarquardt(FunctorType &_functor)$/;"	f	class:Eigen::LevenbergMarquardt
LevenbergMarquardt	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^class LevenbergMarquardt$/;"	c	namespace:Eigen
LevenbergMarquardtSpace	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^namespace LevenbergMarquardtSpace {$/;"	n	namespace:Eigen
Lhs	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^  typedef typename remove_all<_Lhs>::type Lhs;$/;"	t	struct:Eigen::internal::traits
Lhs	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,LhsMode,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<SparseLhsType>::type Lhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
LhsBlasTraits	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef internal::blas_traits<_LhsNested> LhsBlasTraits;$/;"	t	class:Eigen::ProductBase
LhsCleaned	vcglib/eigenlib/Eigen/src/Core/Product.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:internal::traits
LhsCleaned	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
LhsCoeffReadCost	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon54
LhsCoeffReadCost	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon194
LhsCoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    LhsCoeffReadCost = traits<_LhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon413
LhsCoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon424
LhsCoeffReadCost	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon452
LhsFlags	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon54
LhsFlags	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon194
LhsFlags	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon424
LhsFlags	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon452
LhsInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::InnerIterator LhsInnerIterator;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
LhsIsSelfAdjoint	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsSelfAdjoint = (LhsMode&SelfAdjoint)==SelfAdjoint,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon213
LhsIsUpper	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsUpper = (LhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon213
LhsIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _LhsNested::InnerIterator LhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
LhsMatrixType	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename take_matrix_for_product<Lhs>::type LhsMatrixType;$/;"	t	struct:Eigen::internal::traits
LhsMatrixType	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<homogeneous_left_product_impl>::LhsMatrixType LhsMatrixType;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsMatrixTypeCleaned	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsMatrixTypeCleaned	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits
LhsMatrixTypeNested	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename LhsMatrixTypeCleaned::Nested>::type LhsMatrixTypeNested;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsMode	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      LhsMode = internal::is_diagonal<_LhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon416
LhsNested	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Lhs>::type LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
LhsNested	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Lhs, Rhs::ColsAtCompileTime, typename internal::plain_matrix_type<Lhs>::type >::type LhsNested;$/;"	t	struct:Eigen::ProductReturnType
LhsNested	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Product
LhsNested	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::ProductBase
LhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::LhsNested LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct
LhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct
LhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    typename internal::nested<Lhs,Rhs::RowsAtCompileTime>::type>::type LhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType
LhsNested	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef const typename internal::nested<Lhs, Rhs::RowsAtCompileTime>::type LhsNested;$/;"	t	struct:Eigen::SkylineProductReturnType
LhsNestedCleaned	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;$/;"	t	class:Product
LhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::LhsPacket LhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
LhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,RealPacket,  Scalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
LhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
LhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
LhsPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
LhsPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
LhsPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
LhsPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon210
LhsPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon211
LhsProductTraits	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef blas_traits<Lhs> LhsProductTraits;$/;"	t	struct:Eigen::internal::triangular_solver_selector
LhsProgress	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress   = Traits::LhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon202
LhsProgress	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
LhsProgress	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
LhsProgress	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon200
LhsProgress	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
LhsRowMajor	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsRowMajor = LhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon194
LhsRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    LhsRowMajor = internal::traits<Lhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon423
LhsScalar	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    typedef typename Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct
LhsScalar	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::traits<Lhs>::Scalar LhsScalar;$/;"	t	class:Eigen::ProductBase
LhsScalar	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Lhs::Scalar LhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
LhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar> LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::level3_blocking
LhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct
LhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_RhsScalar,_LhsScalar>::type LhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space
LhsUpLo	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^    LhsUpLo = LhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon214
Li	vcglib/wrap/math/system_interface_ldl.h	/^    std::vector<int> Li,Lp,Parent,Lnz,Flag,Pattern;$/;"	m	class:SystemLDL
LibraryEffectsTag	vcglib/wrap/dae/colladaformat.h	/^		LibraryEffectsTag()$/;"	f	class:Collada::Tags::LibraryEffectsTag
LibraryEffectsTag	vcglib/wrap/dae/colladaformat.h	/^	class LibraryEffectsTag : public XMLTag$/;"	c	namespace:Collada::Tags
LibraryGeometriesTag	vcglib/wrap/dae/colladaformat.h	/^		LibraryGeometriesTag()$/;"	f	class:Collada::Tags::LibraryGeometriesTag
LibraryGeometriesTag	vcglib/wrap/dae/colladaformat.h	/^	class LibraryGeometriesTag : public XMLTag$/;"	c	namespace:Collada::Tags
LibraryImagesTag	vcglib/wrap/dae/colladaformat.h	/^		LibraryImagesTag()$/;"	f	class:Collada::Tags::LibraryImagesTag
LibraryImagesTag	vcglib/wrap/dae/colladaformat.h	/^	class LibraryImagesTag : public XMLTag$/;"	c	namespace:Collada::Tags
LibraryMaterialsTag	vcglib/wrap/dae/colladaformat.h	/^		LibraryMaterialsTag()$/;"	f	class:Collada::Tags::LibraryMaterialsTag
LibraryMaterialsTag	vcglib/wrap/dae/colladaformat.h	/^	class LibraryMaterialsTag : public XMLTag$/;"	c	namespace:Collada::Tags
LibraryVisualScenesTag	vcglib/wrap/dae/colladaformat.h	/^		LibraryVisualScenesTag()$/;"	f	class:Collada::Tags::LibraryVisualScenesTag
LibraryVisualScenesTag	vcglib/wrap/dae/colladaformat.h	/^	class LibraryVisualScenesTag : public XMLTag$/;"	c	namespace:Collada::Tags
LightBlue	vcglib/vcg/space/color4.h	/^	  LightBlue   =0xffff8080,$/;"	e	enum:vcg::Color4::ColorConstant
LightEdge	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^        LightEdge(size_t _face, size_t _edge):face(_face), edge(_edge) { }$/;"	f	struct:vcg::tri::ExtendedMarchingCubes::LightEdge
LightEdge	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^      struct LightEdge$/;"	s	class:vcg::tri::ExtendedMarchingCubes
LightFlag	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^bool LightFlag=true;$/;"	v
LightGray	vcglib/vcg/space/color4.h	/^	  LightGray   =0xffc0c0c0,$/;"	e	enum:vcg::Color4::ColorConstant
LightGreen	vcglib/vcg/space/color4.h	/^	  LightGreen  =0xff80ff80,$/;"	e	enum:vcg::Color4::ColorConstant
LightRed	vcglib/vcg/space/color4.h	/^	  LightRed    =0xff8080ff,$/;"	e	enum:vcg::Color4::ColorConstant
LinSpaced	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
Line2	vcglib/vcg/space/line2.h	/^	Line2 (const Line2<ScalarType,!NORM > &r) $/;"	f	class:vcg::Line2
Line2	vcglib/vcg/space/line2.h	/^	Line2() {};$/;"	f	class:vcg::Line2
Line2	vcglib/vcg/space/line2.h	/^	Line2(const PointType &ori, const PointType &dir) {SetOrigin(ori); SetDirection(dir);};$/;"	f	class:vcg::Line2
Line2	vcglib/vcg/space/line2.h	/^class Line2$/;"	c	namespace:vcg
Line2d	vcglib/vcg/space/line2.h	/^typedef Line2<double> Line2d;$/;"	t	namespace:vcg
Line2dN	vcglib/vcg/space/line2.h	/^typedef Line2<double,true> Line2dN;$/;"	t	namespace:vcg
Line2f	vcglib/vcg/space/line2.h	/^typedef Line2<float>  Line2f;$/;"	t	namespace:vcg
Line2fN	vcglib/vcg/space/line2.h	/^typedef Line2<float ,true> Line2fN;$/;"	t	namespace:vcg
Line2i	vcglib/vcg/space/line2.h	/^typedef Line2<int>	  Line2i;$/;"	t	namespace:vcg
Line2iN	vcglib/vcg/space/line2.h	/^typedef Line2<int   ,true> Line2iN;$/;"	t	namespace:vcg
Line2s	vcglib/vcg/space/line2.h	/^typedef Line2<short>  Line2s;$/;"	t	namespace:vcg
Line2sN	vcglib/vcg/space/line2.h	/^typedef Line2<short ,true> Line2sN;$/;"	t	namespace:vcg
Line3	vcglib/vcg/space/line3.h	/^	Line3 (const Line3<ScalarType,!NORM > &r) $/;"	f	class:vcg::Line3
Line3	vcglib/vcg/space/line3.h	/^	Line3() {};$/;"	f	class:vcg::Line3
Line3	vcglib/vcg/space/line3.h	/^	Line3(const PointType &ori, const PointType &dir) {SetOrigin(ori); SetDirection(dir);};$/;"	f	class:vcg::Line3
Line3	vcglib/vcg/space/line3.h	/^class Line3$/;"	c	namespace:vcg
Line3d	vcglib/vcg/space/line3.h	/^typedef Line3<double> Line3d;$/;"	t	namespace:vcg
Line3dN	vcglib/vcg/space/line3.h	/^typedef Line3<double,true> Line3dN;$/;"	t	namespace:vcg
Line3f	vcglib/vcg/space/line3.h	/^typedef Line3<float>  Line3f;$/;"	t	namespace:vcg
Line3fN	vcglib/vcg/space/line3.h	/^typedef Line3<float ,true> Line3fN;$/;"	t	namespace:vcg
Line3i	vcglib/vcg/space/line3.h	/^typedef Line3<int>	  Line3i;$/;"	t	namespace:vcg
Line3iN	vcglib/vcg/space/line3.h	/^typedef Line3<int   ,true> Line3iN;$/;"	t	namespace:vcg
Line3s	vcglib/vcg/space/line3.h	/^typedef Line3<short>  Line3s;$/;"	t	namespace:vcg
Line3sN	vcglib/vcg/space/line3.h	/^typedef Line3<short ,true> Line3sN;$/;"	t	namespace:vcg
Line3x	vcglib/vcg/space/index/grid_static_ptr.h	/^		typedef Line3<ScalarType> Line3x;$/;"	t	class:vcg::GridStaticPtr
LineLineDistance	vcglib/vcg/space/distance3.h	/^void LineLineDistance(const vcg::Line3<ScalarType> &mLine0,$/;"	f	namespace:vcg
LineLineDistance	vcglib/wrap/gui/trackutils.h	/^std::pair< float, bool > LineLineDistance(const Line3f & P,const Line3f & Q,Point3f & P_s, Point3f & Q_t){$/;"	f	namespace:vcg::trackutils
LineLineIntersection	vcglib/vcg/space/intersection2.h	/^	inline bool LineLineIntersection(const vcg::Line2<SCALAR_TYPE> & l0,$/;"	f	namespace:vcg
LinePointDistance	vcglib/vcg/space/distance3.h	/^void  LinePointDistance(const Line3<ScalarType> &l,const Point3<ScalarType> &p,$/;"	f	namespace:vcg
LinePointSquaredDistance	vcglib/vcg/space/distance3.h	/^void  LinePointSquaredDistance(const Line3<ScalarType> &l,const Point3<ScalarType> &p,$/;"	f	namespace:vcg
LineSegmentIntersection	vcglib/vcg/space/intersection2.h	/^	inline bool LineSegmentIntersection(const vcg::Line2<SCALAR_TYPE> & line,$/;"	f	namespace:vcg
LineType	vcglib/vcg/space/line2.h	/^	typedef Line2<LineScalarType,NORM> LineType;$/;"	t	class:vcg::Line2
LineType	vcglib/vcg/space/line3.h	/^	typedef Line3<LineScalarType,NORM> LineType;$/;"	t	class:vcg::Line3
LineWidthMoving	vcglib/wrap/gui/trackutils.h	/^  float LineWidthMoving;$/;"	m	class:vcg::trackutils::DrawingHint
LineWidthStill	vcglib/wrap/gui/trackutils.h	/^  float LineWidthStill;$/;"	m	class:vcg::trackutils::DrawingHint
Linear	vcglib/vcg/math/linear.h	/^	class Linear{$/;"	c	namespace:vcg
LinearAccess	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    LinearAccess = ( (Direction==BothDirections) && (int(_MatrixTypeNested::Flags)&PacketAccessBit) )$/;"	e	enum:Eigen::internal::traits::__anon236
LinearAccessBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int LinearAccessBit = 0x10;$/;"	m	namespace:Eigen
LinearMatrixType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Scaling
LinearMatrixType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Transform
LinearMatrixType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation
LinearMatrixType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim,Options> LinearMatrixType;$/;"	t	class:Eigen::Transform
LinearMatrixType	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation
LinearPart	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim> LinearPart;$/;"	t	class:Eigen::Transform
LinearPart	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim,int(Mode)==(AffineCompact)> LinearPart;$/;"	t	class:Eigen::Transform
LinearSolve	vcglib/vcg/math/matrix44.h	/^template <class T> class LinearSolve: public Matrix44<T> {$/;"	c	namespace:vcg
LinearTraversal	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  LinearTraversal,$/;"	e	enum:Eigen::__anon260
LinearVectorizedTraversal	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  LinearVectorizedTraversal,$/;"	e	enum:Eigen::__anon260
Link	vcglib/vcg/math/disjoint_set.h	/^		void Link(OBJECT_TYPE *x, OBJECT_TYPE *y)$/;"	f	class:vcg::DisjointSet
Link	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline Link(){};$/;"	f	class:vcg::GridStaticPtr::Link
Link	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline Link(ObjPtr nt, const int ni ){$/;"	f	class:vcg::GridStaticPtr::Link
Link	vcglib/vcg/space/index/grid_static_ptr.h	/^		class Link$/;"	c	class:vcg::GridStaticPtr
Link	vcglib/wrap/gl/shaders.h	/^	bool Link(void)$/;"	f	class:Program
LinkConditionEdge	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	static int &LinkConditionEdge(){static int lke=0; return lke;}$/;"	f	class:vcg::tri::TriEdgeCollapse::FailStat
LinkConditionFace	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	static int &LinkConditionFace(){static int lkf=0; return lkf;}$/;"	f	class:vcg::tri::TriEdgeCollapse::FailStat
LinkConditionVert	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	static int &LinkConditionVert(){static int lkv=0; return lkv;}$/;"	f	class:vcg::tri::TriEdgeCollapse::FailStat
LinkConditions	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  static bool LinkConditions(VertexPair &pos)$/;"	f	class:vcg::tri::EdgeCollapser
LinkConditions	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    LinkConditions (const size_t size) : _lcVertices(size) { }$/;"	f	class:vcg::tri::PolychordCollapse::LinkConditions
LinkConditions	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  class LinkConditions {$/;"	c	class:vcg::tri::PolychordCollapse
ListEl	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    struct ListEl$/;"	s	class:Eigen::internal::AmbiVector
ListID	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  enum ListID {FRONT,DEADS};$/;"	g	class:vcg::tri::AdvancingFront
ListOfClusters	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef std::list<Cluster> ListOfClusters;$/;"	t	class:Eigen::MatrixFunction
LnFac	vcglib/vcg/complex/algorithms/point_sampling.h	/^static double LnFac(int n) {$/;"	f	class:vcg::tri::SurfaceSampling
Lnz	vcglib/wrap/math/system_interface_ldl.h	/^    std::vector<int> Li,Lp,Parent,Lnz,Flag,Pattern;$/;"	m	class:SystemLDL
LoGFilter	vcglib/img/img_filter.h	/^inline void LoGFilter(const Image<Channels,SrcScalarType,SrcSafe> &source,Image<Channels,DestScalarType,DestSafe> &destination,int radius)$/;"	f	namespace:img
Load	vcglib/wrap/bmt/bmt.cpp	/^bool Bmt::Load(const std::string &filename) {$/;"	f	class:Bmt
Load	vcglib/wrap/mt/mt.h	/^  void Load(std::vector<Update> &updates) {    $/;"	f	class:vcg::MT
Load4ROSY	vcglib/wrap/io_trimesh/import_field.h	/^    static void Load4ROSY(MeshType &mesh,$/;"	f	class:vcg::tri::io::ImporterFIELD
LoadCamera	vcglib/wrap/io_tetramesh/import_ply.h	/^int LoadCamera(const char * filename)$/;"	f	class:vcg::tetra::io::ImporterPLY
LoadCamera	vcglib/wrap/io_trimesh/import_ply.h	/^int LoadCamera(const char * filename)$/;"	f	class:vcg::tri::io::ImporterPLY
LoadControllerMesh	vcglib/wrap/io_trimesh/import_dae.h	/^        static int LoadControllerMesh(ColladaMesh& m, InfoDAE& info, const QDomElement& geo,QMap<QString, QString> materialBindingMap, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ImporterDAE
LoadFFIELD	vcglib/wrap/io_trimesh/import_field.h	/^    static bool LoadFFIELD(MeshType &mesh,$/;"	f	class:vcg::tri::io::ImporterFIELD
LoadFaceOcf	vcglib/wrap/io_trimesh/import_vmi.h	/^                                                                struct LoadFaceOcf< MeshType, face::vector_ocf<typename OpenMeshType::FaceType> >{$/;"	s	class:vcg::tri::io::ImporterVMI
LoadFaceOcf	vcglib/wrap/io_trimesh/import_vmi.h	/^                        LoadFaceOcf( face::vector_ocf<FaceType> & face){$/;"	f	struct:vcg::tri::io::ImporterVMI::LoadFaceOcf
LoadFaceOcf	vcglib/wrap/io_trimesh/import_vmi.h	/^                        LoadFaceOcf(const CONT & \/* face *\/){$/;"	f	struct:vcg::tri::io::ImporterVMI::LoadFaceOcf
LoadFaceOcf	vcglib/wrap/io_trimesh/import_vmi.h	/^                struct LoadFaceOcf{$/;"	s	class:vcg::tri::io::ImporterVMI
LoadFaceOcfMask	vcglib/wrap/io_trimesh/import_vmi.h	/^                 static int  LoadFaceOcfMask( ){$/;"	f	class:vcg::tri::io::ImporterVMI
LoadGeometry	vcglib/wrap/io_trimesh/import_dae.h	/^        static int LoadGeometry(ColladaMesh& m, InfoDAE& info, const QDomElement& geo, QMap<QString,QString> &materialBinding, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ImporterDAE
LoadGrad	vcglib/wrap/io_trimesh/import_field.h	/^    static bool LoadGrad(MeshType &mesh,$/;"	f	class:vcg::tri::io::ImporterFIELD
LoadMask	vcglib/wrap/io_tetramesh/import_ply.h	/^bool LoadMask(const char * filename, int &mask)$/;"	f	class:vcg::tetra::io::ImporterPLY
LoadMask	vcglib/wrap/io_trimesh/import.h	/^static bool LoadMask(const char * filename, int &mask)$/;"	f	class:vcg::tri::io::Importer
LoadMask	vcglib/wrap/io_trimesh/import_dae.h	/^        static bool LoadMask(const char * filename, InfoDAE& info)$/;"	f	class:vcg::tri::io::ImporterDAE
LoadMask	vcglib/wrap/io_trimesh/import_fbx.h	/^	static int LoadMask(const char * filename, Info &oi)$/;"	f	class:ImporterFBX
LoadMask	vcglib/wrap/io_trimesh/import_gts.h	/^				static bool LoadMask(const char *filename, int &loadmask)$/;"	f	class:vcg::tri::io::ImporterGTS
LoadMask	vcglib/wrap/io_trimesh/import_obj.h	/^                static bool LoadMask(const char * filename, Info &oi)$/;"	f	class:vcg::tri::io::ImporterOBJ
LoadMask	vcglib/wrap/io_trimesh/import_obj.h	/^                static bool LoadMask(const char * filename, int &mask)$/;"	f	class:vcg::tri::io::ImporterOBJ
LoadMask	vcglib/wrap/io_trimesh/import_off.h	/^  static bool LoadMask(const char *filename, int &loadmask)$/;"	f	class:vcg::tri::io::ImporterOFF
LoadMask	vcglib/wrap/io_trimesh/import_ply.h	/^static bool LoadMask(const char * filename, int &mask)$/;"	f	class:vcg::tri::io::ImporterPLY
LoadMask	vcglib/wrap/io_trimesh/import_ply.h	/^static bool LoadMask(const char * filename, int &mask, PlyInfo &pi)$/;"	f	class:vcg::tri::io::ImporterPLY
LoadMask	vcglib/wrap/io_trimesh/import_stl.h	/^static bool LoadMask(const char * filename, int &mask)$/;"	f	class:vcg::tri::io::ImporterSTL
LoadMask	vcglib/wrap/io_trimesh/import_vmi.h	/^        static bool LoadMask(const char * f, int & mask){$/;"	f	class:vcg::tri::io::ImporterVMI
LoadMaskFromMem	vcglib/wrap/io_trimesh/import_vmi.h	/^        static bool LoadMaskFromMem(  const char * ptr, int & mask){$/;"	f	class:vcg::tri::io::ImporterVMI
LoadMaskNode	vcglib/wrap/io_trimesh/import_fbx.h	/^	static void LoadMaskNode(KFbxNode* node, Info &oi)$/;"	f	class:ImporterFBX
LoadMaterials	vcglib/wrap/io_trimesh/import_obj.h	/^                static bool LoadMaterials(const char * filename, std::vector<Material> &materials, std::vector<std::string> &textures)$/;"	f	class:vcg::tri::io::ImporterOBJ
LoadPly_Camera	vcglib/wrap/io_trimesh/import_ply.h	/^struct LoadPly_Camera$/;"	s	class:vcg::tri::io::ImporterPLY
LoadPly_EdgeAux	vcglib/wrap/io_trimesh/import_ply.h	/^struct LoadPly_EdgeAux$/;"	s	class:vcg::tri::io::ImporterPLY
LoadPly_FaceAux	vcglib/wrap/io_trimesh/import_ply.h	/^struct LoadPly_FaceAux$/;"	s	class:vcg::tri::io::ImporterPLY
LoadPly_RangeGridAux	vcglib/wrap/io_trimesh/import_ply.h	/^struct LoadPly_RangeGridAux {$/;"	s	class:vcg::tri::io::ImporterPLY
LoadPly_TetraAux	vcglib/wrap/io_tetramesh/import_ply.h	/^struct LoadPly_TetraAux$/;"	s	class:vcg::tetra::io::ImporterPLY
LoadPly_TristripAux	vcglib/wrap/io_trimesh/import_ply.h	/^struct LoadPly_TristripAux$/;"	s	class:vcg::tri::io::ImporterPLY
LoadPly_VertAux	vcglib/wrap/io_tetramesh/import_ply.h	/^struct LoadPly_VertAux$/;"	s	class:vcg::tetra::io::ImporterPLY
LoadPly_VertAux	vcglib/wrap/io_trimesh/import_ply.h	/^struct LoadPly_VertAux$/;"	s	class:vcg::tri::io::ImporterPLY
LoadPolygonalListMesh	vcglib/wrap/io_trimesh/import_dae.h	/^        static DAEError	LoadPolygonalListMesh(QDomNodeList& polylist,ColladaMesh& m,const size_t offset,InfoDAE& info,QMap<QString,QString> &materialBinding)$/;"	f	class:vcg::tri::io::ImporterDAE
LoadPolygonalMesh	vcglib/wrap/io_trimesh/import_dae.h	/^        static DAEError LoadPolygonalMesh(QDomNodeList& polypatch,ColladaMesh& m,const size_t offset,InfoDAE & info)$/;"	f	class:vcg::tri::io::ImporterDAE
LoadSeamsMMFromOBJ	vcglib/wrap/io_trimesh/import_field.h	/^    static bool LoadSeamsMMFromOBJ(MeshType &mesh,std::string PathOBJ)$/;"	f	class:vcg::tri::io::ImporterFIELD
LoadSource	vcglib/wrap/gl/shaders.h	/^	bool LoadSource(const char * fileName)$/;"	f	class:Shader
LoadSources	vcglib/wrap/gl/shaders.h	/^	void LoadSources(const char * vfile, const char * ffile)$/;"	f	class:ProgramVF
LoadTriMesh	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::LoadTriMesh(QString &namefile)$/;"	f	class:GLWidget
LoadTriangularMesh	vcglib/wrap/io_trimesh/import_dae.h	/^        static DAEError LoadTriangularMesh(QDomNodeList& triNodeList, ColladaMesh& m, const size_t offset, InfoDAE& info,QMap<QString,QString> &materialBinding)$/;"	f	class:vcg::tri::io::ImporterDAE
LoadVertexOcf	vcglib/wrap/io_trimesh/import_vmi.h	/^                        LoadVertexOcf(FILE* \/*f*\/,const CONT & \/*vert*\/){$/;"	f	struct:vcg::tri::io::ImporterVMI::LoadVertexOcf
LoadVertexOcf	vcglib/wrap/io_trimesh/import_vmi.h	/^                struct LoadVertexOcf{$/;"	s	class:vcg::tri::io::ImporterVMI
LoadVertexOcf	vcglib/wrap/io_trimesh/import_vmi.h	/^            LoadVertexOcf( FILE * \/*f*\/, vertex::vector_ocf<typename OpenMeshType::VertexType> & vert){$/;"	f	struct:vcg::tri::io::ImporterVMI::LoadVertexOcf
LoadVertexOcf	vcglib/wrap/io_trimesh/import_vmi.h	/^        LoadVertexOcf<MeshType,vertex::vector_ocf<typename OpenMeshType::VertexType> >{$/;"	s	class:vcg::tri::io::ImporterVMI
LoadVertexOcfMask	vcglib/wrap/io_trimesh/import_vmi.h	/^         static int   LoadVertexOcfMask( ){$/;"	f	class:vcg::tri::io::ImporterVMI
LocModPtrType	vcglib/vcg/complex/algorithms/local_optimization.h	/^  typedef  LocalModification <MeshType> * LocModPtrType;$/;"	t	class:vcg::LocalOptimization
LocModType	vcglib/vcg/complex/algorithms/local_optimization.h	/^  typedef  LocalModification <MeshType>  LocModType;$/;"	t	class:vcg::LocalOptimization
LocRnd	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    static int LocRnd(int n){$/;"	f	class:OverlapEstimation
LocRnd	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    static math::SubtractiveRingRNG &LocRnd(){$/;"	f	class:OverlapEstimation
LocalModification	vcglib/vcg/complex/algorithms/local_optimization.h	/^  inline LocalModification(){}$/;"	f	class:vcg::LocalModification
LocalModification	vcglib/vcg/complex/algorithms/local_optimization.h	/^class LocalModification$/;"	c	namespace:vcg
LocalOptimization	vcglib/vcg/complex/algorithms/local_optimization.h	/^  LocalOptimization(MeshType &mm, BaseParameterClass *_pp): m(mm){ ClearTermination();e=0.0;HeapSimplexRatio=5; pp=_pp;}$/;"	f	class:vcg::LocalOptimization
LocalOptimization	vcglib/vcg/complex/algorithms/local_optimization.h	/^class LocalOptimization$/;"	c	namespace:vcg
LocalToGlobal	vcglib/vcg/math/eigen_matrix_addons.h	/^inline Matrix LocalToGlobal(ParamType p) const { return *this; }$/;"	f
LocalToGlobal	vcglib/vcg/space/box.h	/^	PointType LocalToGlobal(PointType const & p) const{$/;"	f	class:vcg::Box
LocalToGlobal	vcglib/vcg/space/box2.h	/^	PointType LocalToGlobal(PointType const & p) const{$/;"	f	class:vcg::Box2
LocalToGlobal	vcglib/vcg/space/box3.h	/^    Point3<BoxScalarType> LocalToGlobal(Point3<BoxScalarType> const & p) const{$/;"	f	class:vcg::Box3
LocalToGlobal	vcglib/vcg/space/deprecated_point.h	/^	inline PointType LocalToGlobal(ParamType p) const{$/;"	f	class:vcg::ndim::Point
LocalToViewportPx	vcglib/vcg/math/camera.h	/^vcg::Point2<S> Camera<S>::LocalToViewportPx(const vcg::Point2<S> & p) const$/;"	f	class:vcg::Camera
LocalTo_0_1	vcglib/vcg/math/camera.h	/^vcg::Point2<S> Camera<S>::LocalTo_0_1(const vcg::Point2<S> & p) const$/;"	f	class:vcg::Camera
LocalTo_neg1_1	vcglib/vcg/math/camera.h	/^vcg::Point2<S> Camera<S>::LocalTo_neg1_1(const vcg::Point2<S> & p) const$/;"	f	class:vcg::Camera
LookAt	vcglib/vcg/math/shot.h	/^void Shot<S,RotationType>::LookAt(const S & eye_x, const S & eye_y, const S & eye_z,$/;"	f	class:vcg::Shot
LookAt	vcglib/vcg/math/shot.h	/^void Shot<S,RotationType>::LookAt(const vcg::Point3<S> & z_dir,const vcg::Point3<S> & up)$/;"	f	class:vcg::Shot
LookTowards	vcglib/vcg/math/shot.h	/^void Shot<S,RotationType>::LookTowards(const vcg::Point3<S> & z_dir,const vcg::Point3<S> & up)$/;"	f	class:vcg::Shot
LoopEnd	vcglib/vcg/simplex/tetrahedron/pos.h	/^  bool LoopEnd()$/;"	f	class:vcg::tetra::PosLoop
LoopWeight	vcglib/vcg/complex/algorithms/refine_loop.h	/^struct LoopWeight {$/;"	s	namespace:vcg::tri
LowClampToZero	vcglib/vcg/math/eigen.h	/^LowClampToZero(const Eigen::MatrixBase<Derived>& p)$/;"	f	namespace:vcg
LowClampToZero	vcglib/vcg/space/deprecated_point3.h	/^inline Point3<SCALARTYPE> LowClampToZero(const Point3<SCALARTYPE> & p) {$/;"	f	namespace:vcg
Lower	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Lower=0x1,                      $/;"	e	enum:Eigen::__anon258
Lower	vcglib/vcg/container/container_allocation_table.h	/^static ValueType *& Lower() {$/;"	f	class:vcg::CATEntry
LowerTriangular	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangular = Lower;$/;"	m	namespace:Eigen
LowerTriangularBit	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangularBit = Lower;$/;"	m	namespace:Eigen
LowestHorizon	vcglib/vcg/space/rasterized_outline2_packer.h	/^          LowestHorizon,$/;"	e	enum:vcg::RasterizedOutline2Packer::Parameters::costFuncEnum
Lp	vcglib/wrap/math/system_interface_ldl.h	/^    std::vector<int> Li,Lp,Parent,Lnz,Flag,Pattern;$/;"	m	class:SystemLDL
LvalueBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int LvalueBit = 0x20;$/;"	m	namespace:Eigen
Lx	vcglib/wrap/math/system_interface_ldl.h	/^	std::vector<double> Lx,D,Y ;$/;"	m	class:SystemLDL
M	vcglib/vcg/math/quaternion.h	/^#define M(/;"	d
M	vcglib/vcg/math/quaternion.h	/^#undef M$/;"	d
M	vcglib/vcg/math/random_generator.h	/^	static const int M = 397;$/;"	m	class:vcg::math::MarsenneTwisterRNG
MADD	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  #define MADD(/;"	d
MAINWINDOW_H_	vcglib/apps/sample/trimesh_QT/mainwindow.h	/^#define MAINWINDOW_H_$/;"	d
MAIN_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		MAIN_NODE=					0;$/;"	v
MALLINFO_FIELD_TYPE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MALLINFO_FIELD_TYPE /;"	d	file:
MALLINFO_FIELD_TYPE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define MALLINFO_FIELD_TYPE /;"	d
MALLOC_280_H	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define MALLOC_280_H$/;"	d
MALLOC_ALIGNMENT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MALLOC_ALIGNMENT /;"	d	file:
MALLOC_FAILURE_ACTION	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MALLOC_FAILURE_ACTION /;"	d	file:
MALLOC_FAILURE_ACTION	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MALLOC_FAILURE_ACTION$/;"	d	file:
MAP_ANONYMOUS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MAP_ANONYMOUS /;"	d	file:
MATRIX_A	vcglib/vcg/math/random_generator.h	/^	static const unsigned int MATRIX_A = 0x9908b0dfu;   \/\/ constant vector a$/;"	m	class:vcg::math::MarsenneTwisterRNG
MATRIX_VCGLIB	vcglib/vcg/math/old_deprecated_matrix.h	/^#define MATRIX_VCGLIB$/;"	d
MATRIX_VCGLIB	vcglib/vcg/math/old_matrix.h	/^#define MATRIX_VCGLIB$/;"	d
MAXBPATH	vcglib/wrap/ply/plystuff.h	/^const int MAXBPATH = 256;$/;"	m	namespace:vcg::ply
MAXLEVELS	vcglib/vcg/complex/algorithms/point_sampling.h	/^  int MAXLEVELS;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
MAX_FACTORIAL	vcglib/vcg/math/factorial.h	/^struct MAX_FACTORIAL$/;"	s	namespace:vcg::math
MAX_FACTORIAL	vcglib/vcg/math/factorial.h	/^template <> struct MAX_FACTORIAL<double> 		{enum {value = 170};};$/;"	s	namespace:vcg::math
MAX_FACTORIAL	vcglib/vcg/math/factorial.h	/^template <> struct MAX_FACTORIAL<float> 		{enum {value = 34};};$/;"	s	namespace:vcg::math
MAX_FACTORIAL	vcglib/vcg/math/factorial.h	/^template <> struct MAX_FACTORIAL<int> 			{enum {value = 34};};$/;"	s	namespace:vcg::math
MAX_FACTORIAL	vcglib/vcg/math/factorial.h	/^template <> struct MAX_FACTORIAL<long double> 	{enum {value = 170};};$/;"	s	namespace:vcg::math
MAX_FACTORIAL	vcglib/vcg/math/factorial.h	/^template <> struct MAX_FACTORIAL<short> 		{enum {value = 7};};$/;"	s	namespace:vcg::math
MAX_POLYGONS	vcglib/wrap/io_trimesh/export_3ds.h	/^#define MAX_POLYGONS /;"	d
MAX_RELEASE_CHECK_RATE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MAX_RELEASE_CHECK_RATE /;"	d	file:
MAX_REQUEST	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MAX_REQUEST /;"	d	file:
MAX_SIZE_T	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MAX_SIZE_T /;"	d	file:
MAX_SMALL_REQUEST	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MAX_SMALL_REQUEST /;"	d	file:
MAX_SMALL_SIZE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MAX_SMALL_SIZE /;"	d	file:
MAX_USER_DATA	vcglib/wrap/io_tetramesh/import_ply.h	/^#define MAX_USER_DATA /;"	d
MAX_USER_DATA	vcglib/wrap/io_trimesh/import_ply.h	/^#define MAX_USER_DATA /;"	d
MArity1	vcglib/vcg/container/derivation_chain.h	/^					class MArity1: public A<  Base, TA  > {$/;"	c	namespace:vcg
MArity2	vcglib/vcg/container/derivation_chain.h	/^					class MArity2: public B< MArity1<Base, TA, A>,TB > {};$/;"	c	namespace:vcg
MArity3	vcglib/vcg/container/derivation_chain.h	/^					class MArity3: public C<MArity2<Base, TA,A,TB, B>,TC > {};$/;"	c	namespace:vcg
MArity4	vcglib/vcg/container/derivation_chain.h	/^					class MArity4: public D<MArity3<Base, TA,A,TB, B, TC,C>,TD > {};$/;"	c	namespace:vcg
MCHUNK_SIZE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MCHUNK_SIZE /;"	d	file:
MCLookUpTable	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^		class MCLookUpTable$/;"	c	namespace:vcg::tri
METHOD_2	vcglib/wrap/gcache/door.h	/^#define METHOD_2$/;"	d
MFAIL	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MFAIL /;"	d	file:
MGH09_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    MGH09_functor(void) : Functor<double>(4,11) {}$/;"	f	struct:MGH09_functor
MGH09_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct MGH09_functor : Functor<double>$/;"	s	file:
MGH10_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    MGH10_functor(void) : Functor<double>(3,16) {}$/;"	f	struct:MGH10_functor
MGH10_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct MGH10_functor : Functor<double>$/;"	s	file:
MGH17_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    MGH17_functor(void) : Functor<double>(5,33) {}$/;"	f	struct:MGH17_functor
MGH17_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct MGH17_functor : Functor<double>$/;"	s	file:
MIN_CHUNK_SIZE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MIN_CHUNK_SIZE\\/;"	d	file:
MIN_LARGE_SIZE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MIN_LARGE_SIZE /;"	d	file:
MIN_POINTS_FOR_CALIBRATE	vcglib/wrap/tsai/tsaimethods.h	/^static const int MIN_POINTS_FOR_CALIBRATE = 13;$/;"	v
MIN_REQUEST	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MIN_REQUEST /;"	d	file:
MIN_SIZE	vcglib/apps/metro/metro.cpp	/^#define MIN_SIZE	/;"	d	file:
MIN_SIZE	vcglib/apps/trimeshinfo/defs.h	/^#define MIN_SIZE /;"	d
MIN_SIZE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define MIN_SIZE	/;"	d
MIN_SMALL_INDEX	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MIN_SMALL_INDEX /;"	d	file:
MIQ_GL_UTILS	vcglib/wrap/miq/core/glUtils.h	/^#define MIQ_GL_UTILS$/;"	d
MIQ_POISSON_SOLVER	vcglib/wrap/miq/core/poisson_solver.h	/^#define MIQ_POISSON_SOLVER$/;"	d
MIQ_QUADRANGULATOR_H	vcglib/wrap/miq/quadrangulator.h	/^#define MIQ_QUADRANGULATOR_H$/;"	d
MIQ_SEAMS_INTIALIZER	vcglib/wrap/miq/core/seams_initializer.h	/^#define MIQ_SEAMS_INTIALIZER$/;"	d
MIQ_STIFFENING	vcglib/wrap/miq/core/stiffening.h	/^#define MIQ_STIFFENING$/;"	d
MIQ_VERTEX_INDEXING	vcglib/wrap/miq/core/vertex_indexing.h	/^#define MIQ_VERTEX_INDEXING$/;"	d
MIQ_parametrization	vcglib/wrap/miq/MIQ.h	/^class MIQ_parametrization{$/;"	c
MLOCK_T	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MLOCK_T /;"	d	file:
MLS_ADVANCE_H	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^#define MLS_ADVANCE_H$/;"	d
MM2PT	vcglib/wrap/qt/Outline2ToQImage.h	/^  static float MM2PT(const float valueMM, float dpi)$/;"	f	class:Outline2Dumper
MMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define MMAP(/;"	d	file:
MMAP_CHUNK_OVERHEAD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MMAP_CHUNK_OVERHEAD /;"	d	file:
MMAP_CLEARS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MMAP_CLEARS /;"	d	file:
MMAP_DEFAULT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MMAP_DEFAULT(/;"	d	file:
MMAP_FLAGS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MMAP_FLAGS /;"	d	file:
MMAP_FOOT_PAD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MMAP_FOOT_PAD /;"	d	file:
MMAP_PROT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MMAP_PROT /;"	d	file:
MMatch	vcglib/wrap/miq/core/vertex_indexing.h	/^    unsigned char MMatch;$/;"	m	struct:SeamInfo
MODE_READ	vcglib/wrap/ply/plylib.h	/^		MODE_READ,$/;"	e	enum:vcg::ply::PlyFile::__anon527
MODE_WRITE	vcglib/wrap/ply/plylib.h	/^		MODE_WRITE$/;"	e	enum:vcg::ply::PlyFile::__anon527
MODIFIED	vcglib/vcg/connectors/hedge.h	/^		MODIFIED   = 0x0008,		\/\/ This bit indicate that the edge is modified$/;"	e	enum:vcg::HEdgeArityMax::__anon484
MODIFIED	vcglib/vcg/simplex/edge/base.h	/^		MODIFIED   = 0x0008,		\/\/ This bit indicate that the edge is modified$/;"	e	enum:vcg::EdgeArityMax::__anon496
MODIFIED	vcglib/vcg/simplex/vertex/base.h	/^		MODIFIED   = 0x0008,		\/\/ This bit indicate that the vertex is modified$/;"	e	enum:vcg::VertexArityMax::__anon499
MODIFIER_MASK	vcglib/wrap/gui/trackball.h	/^								MODIFIER_MASK = 0x00FF, \/\/\/< (mask to get modifiers only)$/;"	e	enum:vcg::Trackball::Button
MONTECARLO_SAMPLING	vcglib/apps/metro/sampling.h	/^						MONTECARLO_SAMPLING							= 0x0010,$/;"	e	enum:vcg::SamplingFlags::__anon1
MORECORE_CONTIGUOUS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MORECORE_CONTIGUOUS /;"	d	file:
MORECORE_DEFAULT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MORECORE_DEFAULT /;"	d	file:
MPFR_USE_INTMAX_T	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^			#undef MPFR_USE_INTMAX_T	/;"	d
MPFR_USE_INTMAX_T	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	#define MPFR_USE_INTMAX_T	/;"	d
MPREAL_HAVE_INT64_SUPPORT	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^			#undef MPREAL_HAVE_INT64_SUPPORT	/;"	d
MPREAL_HAVE_INT64_SUPPORT	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^#define MPREAL_HAVE_INT64_SUPPORT	/;"	d
MPREAL_HAVE_MSVC_DEBUGVIEW	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^#define MPREAL_HAVE_MSVC_DEBUGVIEW	/;"	d
MPREAL_MSVC_DEBUGVIEW_CODE	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	#define MPREAL_MSVC_DEBUGVIEW_CODE /;"	d
MPREAL_MSVC_DEBUGVIEW_CODE	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^#define MPREAL_MSVC_DEBUGVIEW_CODE /;"	d
MPREAL_MSVC_DEBUGVIEW_DATA	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	#define MPREAL_MSVC_DEBUGVIEW_DATA /;"	d
MREMAP_DEFAULT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MREMAP_DEFAULT(/;"	d	file:
MRGBLineCount	vcglib/wrap/io_trimesh/import_obj.h	/^                static int &MRGBLineCount(){static int _MRGBLineCount=0; return _MRGBLineCount;}$/;"	f	class:vcg::tri::io::ImporterOBJ
MSG_ERR_FILE_OPEN	vcglib/apps/metro/metro.cpp	/^#define MSG_ERR_FILE_OPEN /;"	d	file:
MSG_ERR_FILE_OPEN	vcglib/apps/trimeshinfo/defs.h	/^#define MSG_ERR_FILE_OPEN /;"	d
MSG_ERR_FILE_OPEN	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define MSG_ERR_FILE_OPEN /;"	d
MSG_ERR_INVALID_OPTION	vcglib/apps/metro/metro.cpp	/^#define MSG_ERR_INVALID_OPTION /;"	d	file:
MSG_ERR_INVALID_OPTION	vcglib/apps/trimeshinfo/defs.h	/^#define MSG_ERR_INVALID_OPTION /;"	d
MSG_ERR_INVALID_OPTION	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define MSG_ERR_INVALID_OPTION /;"	d
MSG_ERR_MESH_LOAD	vcglib/apps/metro/metro.cpp	/^#define MSG_ERR_MESH_LOAD /;"	d	file:
MSG_ERR_MESH_LOAD	vcglib/apps/trimeshinfo/defs.h	/^#define MSG_ERR_MESH_LOAD /;"	d
MSG_ERR_MESH_LOAD	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define MSG_ERR_MESH_LOAD /;"	d
MSG_ERR_N_ARGS	vcglib/apps/trimeshinfo/defs.h	/^#define MSG_ERR_N_ARGS /;"	d
MSG_ERR_N_ARGS	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define MSG_ERR_N_ARGS /;"	d
MSG_ERR_UNKNOWN_FORMAT	vcglib/apps/metro/metro.cpp	/^#define MSG_ERR_UNKNOWN_FORMAT /;"	d	file:
MSG_ERR_UNKNOWN_FORMAT	vcglib/apps/trimeshinfo/defs.h	/^#define MSG_ERR_UNKNOWN_FORMAT /;"	d
MSG_ERR_UNKNOWN_FORMAT	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define MSG_ERR_UNKNOWN_FORMAT /;"	d
MSPACES	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MSPACES /;"	d	file:
MT	vcglib/wrap/mt/mt.h	/^template <class C> class MT {$/;"	c	namespace:vcg
MT_ASSERT	vcglib/wrap/system/multithreading/base.h	/^#define MT_ASSERT /;"	d
MT_BASE_H	vcglib/wrap/system/multithreading/base.h	/^#define MT_BASE_H$/;"	d
MT_CONDITION_H	vcglib/wrap/system/multithreading/condition.h	/^#define MT_CONDITION_H$/;"	d
MT_MT_H	vcglib/wrap/system/multithreading/mt.h	/^#define MT_MT_H$/;"	d
MT_MUTEX_H	vcglib/wrap/system/multithreading/mutex.h	/^#define MT_MUTEX_H$/;"	d
MT_PREVENT_COPY	vcglib/wrap/system/multithreading/base.h	/^#define MT_PREVENT_COPY(/;"	d
MT_RW_LOCK_H	vcglib/wrap/system/multithreading/rw_lock.h	/^#define MT_RW_LOCK_H$/;"	d
MT_SCOPED_MUTEX_LOCK_H	vcglib/wrap/system/multithreading/scoped_mutex_lock.h	/^#define MT_SCOPED_MUTEX_LOCK_H$/;"	d
MT_SCOPED_READ_LOCK_H	vcglib/wrap/system/multithreading/scoped_read_lock.h	/^#define MT_SCOPED_READ_LOCK_H$/;"	d
MT_SCOPED_WRITE_LOCK_H	vcglib/wrap/system/multithreading/scoped_write_lock.h	/^#define MT_SCOPED_WRITE_LOCK_H$/;"	d
MT_SEMAPHORE_H	vcglib/wrap/system/multithreading/semaphore.h	/^#define MT_SEMAPHORE_H$/;"	d
MT_THREAD_H	vcglib/wrap/system/multithreading/thread.h	/^#define MT_THREAD_H$/;"	d
MT_UTIL_H	vcglib/wrap/system/multithreading/util.h	/^#define MT_UTIL_H$/;"	d
MULT	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define MULT(/;"	d
MULT	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef MULT$/;"	d
MULTICOLOR	vcglib/wrap/dae/poly_triangulator.h	/^		enum PERWEDGEATTRIBUTETYPE {NONE = 0,NORMAL = 1,MULTITEXTURECOORD = 2,MULTICOLOR = 4};$/;"	e	enum:vcg::tri::io::PolygonalMesh::PERWEDGEATTRIBUTETYPE
MULTITEXTURECOORD	vcglib/wrap/dae/poly_triangulator.h	/^		enum PERWEDGEATTRIBUTETYPE {NONE = 0,NORMAL = 1,MULTITEXTURECOORD = 2,MULTICOLOR = 4};$/;"	e	enum:vcg::tri::io::PolygonalMesh::PERWEDGEATTRIBUTETYPE
MUNMAP	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define MUNMAP(/;"	d	file:
MUNMAP_DEFAULT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define MUNMAP_DEFAULT(/;"	d	file:
MV	vcglib/vcg/simplex/face/component_ocf.h	/^  std::vector<int> MV;$/;"	m	class:vcg::face::vector_ocf
MV	vcglib/vcg/simplex/vertex/component_ocf.h	/^  std::vector<int> MV;$/;"	m	class:vcg::vertex::vector_ocf
M_AVERAGE	vcglib/vcg/complex/algorithms/update/color.h	/^enum DesaturationMethods {M_LIGHTNESS = 0, M_LUMINOSITY = 1, M_AVERAGE = 2};$/;"	e	enum:vcg::tri::UpdateColor::DesaturationMethods
M_GRANULARITY	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define M_GRANULARITY /;"	d	file:
M_GRANULARITY	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define M_GRANULARITY /;"	d
M_LIGHTNESS	vcglib/vcg/complex/algorithms/update/color.h	/^enum DesaturationMethods {M_LIGHTNESS = 0, M_LUMINOSITY = 1, M_AVERAGE = 2};$/;"	e	enum:vcg::tri::UpdateColor::DesaturationMethods
M_LUMINOSITY	vcglib/vcg/complex/algorithms/update/color.h	/^enum DesaturationMethods {M_LIGHTNESS = 0, M_LUMINOSITY = 1, M_AVERAGE = 2};$/;"	e	enum:vcg::tri::UpdateColor::DesaturationMethods
M_MMAP_THRESHOLD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define M_MMAP_THRESHOLD /;"	d	file:
M_MMAP_THRESHOLD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define M_MMAP_THRESHOLD /;"	d
M_PI	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define M_PI /;"	d
M_PI	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^#define M_PI /;"	d
M_PI	vcglib/vcg/math/base.h	/^#define M_PI /;"	d
M_TRIM_THRESHOLD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define M_TRIM_THRESHOLD /;"	d	file:
M_TRIM_THRESHOLD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define M_TRIM_THRESHOLD /;"	d
MagFilterTag	vcglib/wrap/dae/colladaformat.h	/^		MagFilterTag(const QString& filter)$/;"	f	class:Collada::Tags::MagFilterTag
MagFilterTag	vcglib/wrap/dae/colladaformat.h	/^	class MagFilterTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
Magenta	vcglib/vcg/space/color4.h	/^	  Magenta = 0xffff00ff,$/;"	e	enum:vcg::Color4::ColorConstant
MagnitudoComparer	vcglib/vcg/math/base.h	/^ class MagnitudoComparer$/;"	c	namespace:vcg::math
MainNode	vcglib/apps/trimeshinfo/XMLTree.h	/^	MainNode(void){node_type = MAIN_NODE;};$/;"	f	class:MainNode
MainNode	vcglib/apps/trimeshinfo/XMLTree.h	/^class MainNode: public Node$/;"	c
MainWindow	vcglib/apps/sample/trimesh_QT/mainwindow.cpp	/^MainWindow::MainWindow (QWidget * parent):QMainWindow (parent)$/;"	f	class:MainWindow
MainWindow	vcglib/apps/sample/trimesh_QT/mainwindow.h	/^class MainWindow:public QMainWindow$/;"	c
MakeBitTriOnly	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static void MakeBitTriOnly(MeshType &m){$/;"	f	class:vcg::tri::BitQuadCreation
MakeBitTriQuadConventional	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static bool MakeBitTriQuadConventional(MeshType &\/*m*\/){$/;"	f	class:vcg::tri::BitQuadCreation
MakeDirectionFaceCoherent	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^            static void MakeDirectionFaceCoherent(MeshType &mesh)$/;"	f	class:vcg::tri::CrossField
MakeDominant	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static void MakeDominant(MeshType &m, int level){$/;"	f	class:vcg::tri::BitQuadCreation
MakeDominantPass	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static void MakeDominantPass(MeshType &m){$/;"	f	class:vcg::tri::BitQuadCreation
MakePureByCatmullClark	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static void MakePureByCatmullClark(MeshType &m){$/;"	f	class:vcg::tri::BitQuadCreation
MakePureByFlip	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static bool MakePureByFlip(MeshType &m, int maxdist=10000)$/;"	f	class:vcg::tri::BitQuadCreation
MakePureByFlipStepByStep	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static int MakePureByFlipStepByStep(MeshType &m, int maxdist=10000, int restart=false){$/;"	f	class:vcg::tri::BitQuadCreation
MakePureByRefine	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static void MakePureByRefine(MeshType &m){$/;"	f	class:vcg::tri::BitQuadCreation
MakeSet	vcglib/vcg/math/disjoint_set.h	/^		void MakeSet(OBJECT_TYPE *x)$/;"	f	class:vcg::DisjointSet
MakeSquare	vcglib/vcg/space/box2.h	/^	void MakeSquare(){$/;"	f	class:vcg::Box2
MakeTriEvenByDelete	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static bool MakeTriEvenByDelete(MeshType& m)$/;"	f	class:vcg::tri::BitQuadCreation
MakeTriEvenBySplit	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static bool MakeTriEvenBySplit(MeshType& m){$/;"	f	class:vcg::tri::BitQuadCreation
Malloc	vcglib/wrap/io_trimesh/import_vmi.h	/^        static void * Malloc(unsigned int n){ return (n)?malloc(n):0;}$/;"	f	class:vcg::tri::io::ImporterVMI
Map	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType data, Index rows, Index cols, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map
Map	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType data, Index size, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map
Map	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    inline Map(PointerArgType data, const StrideType& stride = StrideType())$/;"	f	class:Eigen::Map
Map	vcglib/eigenlib/Eigen/src/Core/Map.h	/^template<typename PlainObjectType, int MapOptions, typename StrideType> class Map$/;"	c	namespace:Eigen
Map	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const Index* indices)$/;"	f	class:Eigen::Map
Map	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const Index* indices, Index size)$/;"	f	class:Eigen::Map
Map	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^class Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess>$/;"	c	namespace:Eigen
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Map(const Index* indices)$/;"	f	class:Eigen::Map
Map	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Map(const Index* indices, Index size)$/;"	f	class:Eigen::Map
Map	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^class Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,PacketAccess>$/;"	c	namespace:Eigen
Map	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map
Map	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(const Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map
Map	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^class Map<Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen
Map	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^class Map<const Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen
Map	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    static CompressedStorage Map(Index* indices, Scalar* values, size_t size)$/;"	f	class:Eigen::internal::CompressedStorage
Map	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef MappedSparseMatrix<Scalar,Flags> Map;$/;"	t	class:Eigen::SparseMatrix
Map	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(MatrixBase<MatrixType>& _mat)$/;"	f	struct:Eigen::SluMatrix
Map	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(SparseMatrixBase<MatrixType>& mat)$/;"	f	struct:Eigen::SluMatrix
Map	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    static SkylineStorage Map(Index* upperProfile, Index* lowerProfile, Scalar* diag, Scalar* upper, Scalar* lower, Index size, Index upperSize, Index lowerSize) {$/;"	f	class:Eigen::SkylineStorage
Map	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    typedef MappedSparseMatrix<Scalar,Flags> Map;$/;"	t	class:Eigen::DynamicSparseMatrix
Map	vcglib/wrap/glw/framebuffer.h	/^		typedef std::map<GLuint, GLuint> Map;$/;"	t	class:glw::RenderTargetBinding
Map	vcglib/wrap/glw/framebuffer.h	/^		typedef std::map<GLuint, RenderTarget> Map;$/;"	t	class:glw::RenderTargetMapping
Map	vcglib/wrap/glw/program.h	/^		typedef std::map<std::string, GLuint> Map;$/;"	t	class:glw::FragmentOutputBinding
Map	vcglib/wrap/glw/program.h	/^		typedef std::map<std::string, GLuint> Map;$/;"	t	class:glw::VertexAttributeBinding
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapBase	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    explicit inline MapBase(PointerType data) : Base(data) {}$/;"	f	class:Eigen::MapBase
MapBase	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data) : m_data(data), m_rows(RowsAtCompileTime), m_cols(ColsAtCompileTime)$/;"	f	class:Eigen::MapBase
MapBase	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index rows, Index cols) : Base(data, rows, cols) {}$/;"	f	class:Eigen::MapBase
MapBase	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index rows, Index cols)$/;"	f	class:Eigen::MapBase
MapBase	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index size) : Base(data, size) {}$/;"	f	class:Eigen::MapBase
MapBase	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType data, Index size)$/;"	f	class:Eigen::MapBase
MapBase	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
MapBase	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, WriteAccessors>$/;"	c	namespace:Eigen
MapCoords	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void MapCoords(bool normalize=false,$/;"	f	class:vcg::tri::PoissonSolver
MapCoords	vcglib/wrap/miq/core/poisson_solver.h	/^	void MapCoords()$/;"	f	class:PoissonSolver
MapFalseColor	vcglib/apps/unsupported/shadevis/visshader.h	/^void MapFalseColor()$/;"	f	class:vcg::VertexVisShader
MapFalseColor	vcglib/apps/unsupported/shadevis/visshader.h	/^void MapFalseColor(float minv, float maxv)$/;"	f	class:vcg::VertexVisShader
MapIndexes	vcglib/wrap/miq/core/vertex_indexing.h	/^    void MapIndexes(VertexType * vert,$/;"	f	class:VertexIndexing
MapLU	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^  typedef Map<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > MapLU;$/;"	t	struct:Eigen::internal::partial_lu_impl
MapType	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Unaligned>  MapType;$/;"	t	class:Eigen::PlainObjectBase
MapVisibility	vcglib/apps/unsupported/shadevis/visshader.h	/^void MapVisibility(float Gamma=1, float LowPass=0, float HighPass=1, float Scale= 1.0)$/;"	f	class:vcg::VertexVisShader
MappedRhs	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;$/;"	t	struct:Eigen::internal::triangular_solver_selector
MappedSparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline MappedSparseMatrix(Index rows, Index cols, Index nnz, Index* outerIndexPtr, Index* innerIndexPtr, Scalar* valuePtr)$/;"	f	class:Eigen::MappedSparseMatrix
MappedSparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix$/;"	c	namespace:Eigen
MarchingCubes	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            MarchingCubes(TRIMESH_TYPE &mesh, WALKER_TYPE &walker)$/;"	f	class:vcg::tri::MarchingCubes
MarchingCubes	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^        class MarchingCubes$/;"	c	namespace:vcg::tri
Mark	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^	void Mark(MySegmentType* obj)$/;"	f	class:MyMarker
Mark	vcglib/vcg/complex/algorithms/closest.h	/^			inline void Mark(VertexType*) const {}$/;"	f	class:vcg::tri::VertTmark
Mark	vcglib/vcg/complex/algorithms/closest.h	/^			void Mark(OBJ_TYPE* obj){ vcg::tri::Mark(*m,obj);}$/;"	f	class:vcg::tri::Tmark
Mark	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  void Mark(VertexType *v) {$/;"	f	class:vcg::tri::BallPivoting
Mark	vcglib/vcg/complex/base.h	/^template <class MeshType> inline void Mark(MeshType & m, typename MeshType::FacePointer f )  { f->IMark() = m.imark; }$/;"	f	namespace:vcg::tri
Mark	vcglib/vcg/complex/base.h	/^template <class MeshType> inline void Mark(MeshType & m, typename MeshType::VertexPointer v )  { v->IMark() = m.imark; }$/;"	f	namespace:vcg::tri
Mark	vcglib/vcg/connectors/hedge_component.h	/^template <class T> class Mark: public T {$/;"	c	namespace:vcg::hedge
Mark	vcglib/vcg/simplex/edge/component.h	/^    Mark():_imark(0){}$/;"	f	class:vcg::edge::Mark
Mark	vcglib/vcg/simplex/edge/component.h	/^template <class T> class Mark: public T {$/;"	c	namespace:vcg::edge
Mark	vcglib/vcg/simplex/face/component.h	/^  Mark():_imark(0){}$/;"	f	class:vcg::face::Mark
Mark	vcglib/vcg/simplex/face/component.h	/^template <class T> class Mark: public T {$/;"	c	namespace:vcg::face
Mark	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class Mark: public T {$/;"	c	namespace:vcg::tetra
Mark	vcglib/vcg/simplex/vertex/component.h	/^    Mark():_imark(0){}$/;"	f	class:vcg::vertex::Mark
Mark	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class Mark: public T {$/;"	c	namespace:vcg::vertex
Mark	vcglib/vcg/space/index/octree.h	/^        inline void Mark(const ObjectReference *ref)$/;"	f	class:vcg::Octree
MarkDoublets	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static int MarkDoublets(MeshType &m)$/;"	f	class:vcg::tri::BitQuadOptimization
MarkEdgeDistance	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static FaceType * MarkEdgeDistance(MeshType &m, FaceType *startF, int maxDist){$/;"	f	class:vcg::tri::BitQuadCreation
MarkEdgeRotations	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static int MarkEdgeRotations(MeshType &m, Pos *p=NULL)$/;"	f	class:vcg::tri::BitQuadOptimization
MarkEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  bool MarkEnabled;$/;"	m	class:vcg::face::vector_ocf
MarkEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  bool MarkEnabled;$/;"	m	class:vcg::vertex::vector_ocf
MarkFace	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static void MarkFace(FaceType* f, MeshType &m){$/;"	f	class:vcg::tri::BitQuadOptimization
MarkFaceF	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void MarkFaceF(FaceType *f){$/;"	f	class:vcg::tri::BitQuad
MarkFolds	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^int MarkFolds(MESH_TYPE &m){$/;"	f	namespace:vcg::tri
MarkOcc	vcglib/vcg/simplex/face/component_occ.h	/^	template <class T> class MarkOcc: public T {$/;"	c	namespace:vcg::face
MarkOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class MarkOcf: public T {$/;"	c	namespace:vcg::face
MarkOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class MarkOcf: public T {$/;"	c	namespace:vcg::vertex
MarkSinglets	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static int MarkSinglets(MeshType &m)$/;"	f	class:vcg::tri::BitQuadOptimization
MarkSmallestDiag	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static void MarkSmallestDiag(MeshType &m)$/;"	f	class:vcg::tri::BitQuadOptimization
MarkSmallestEdge	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static bool MarkSmallestEdge(MeshType &m, bool perform)$/;"	f	class:vcg::tri::BitQuadOptimization
MarkSmallestEdgeOrDiag	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static int MarkSmallestEdgeOrDiag(MeshType &m, ScalarType edgeMult, bool perform, Pos* affected=NULL)$/;"	f	class:vcg::tri::BitQuadOptimization
MarkType	vcglib/vcg/simplex/edge/component.h	/^    typedef int  MarkType;$/;"	t	class:vcg::edge::EmptyCore
MarkType	vcglib/vcg/simplex/face/component.h	/^  typedef int MarkType;$/;"	t	class:vcg::face::EmptyCore
MarkType	vcglib/vcg/simplex/face/component_occ.h	/^		typedef int MarkType;$/;"	t	class:vcg::face::MarkOcc
MarkType	vcglib/vcg/simplex/tetrahedron/component.h	/^	typedef int MarkType;$/;"	t	class:vcg::tetra::EmptyMark
MarkType	vcglib/vcg/simplex/vertex/component.h	/^  typedef int  MarkType;$/;"	t	class:vcg::vertex::EmptyCore
MarkType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef int MarkType;$/;"	t	class:vcg::vertex::MarkOcf
MarkVertex	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static void MarkVertex(FaceType* f, int wedge, MeshType &m){$/;"	f	class:vcg::tri::BitQuadOptimization
MarkVertexRotations	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static int MarkVertexRotations(MeshType &m, Pos *affected=NULL)$/;"	f	class:vcg::tri::BitQuadOptimization
MarkerFace	vcglib/vcg/complex/algorithms/closest.h	/^			typedef FaceTmark<MESH> MarkerFace;$/;"	t	class:vcg::tri::ClosestFaceEPIterator
MarkerFace	vcglib/vcg/complex/algorithms/closest.h	/^			typedef FaceTmark<MESH> MarkerFace;$/;"	t	class:vcg::tri::TriRayIterator
MarkerFace	vcglib/vcg/complex/algorithms/create/resampler.h	/^		typedef tri::FaceTmark<Old_Mesh> MarkerFace;$/;"	t	class:vcg::tri::Resampler::Walker
MarkerVert	vcglib/vcg/complex/algorithms/closest.h	/^			typedef VertTmark<MESH> MarkerVert;$/;"	t	class:vcg::tri::ClosestVertexIterator
MarkerVertex	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    typedef tri::VertTmark<MeshType> MarkerVertex;$/;"	t	class:OverlapEstimation
MarsenneTwisterRNG	vcglib/vcg/math/random_generator.h	/^	MarsenneTwisterRNG()$/;"	f	class:vcg::math::MarsenneTwisterRNG
MarsenneTwisterRNG	vcglib/vcg/math/random_generator.h	/^	MarsenneTwisterRNG(unsigned int seed)$/;"	f	class:vcg::math::MarsenneTwisterRNG
MarsenneTwisterRNG	vcglib/vcg/math/random_generator.h	/^class MarsenneTwisterRNG : public RandomGenerator$/;"	c	namespace:vcg::math
Mask	vcglib/wrap/io_trimesh/io_mask.h	/^class Mask$/;"	c	namespace:vcg::tri::io
MaskAlignedBit	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    MaskAlignedBit = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic) && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % 16) == 0)) ? AlignedBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon50
MaskLvalueBit	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    MaskLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon64
MaskPacketAccessBit	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    MaskPacketAccessBit = (InnerSize == Dynamic || (InnerSize % packet_traits<Scalar>::size) == 0)$/;"	e	enum:Eigen::internal::traits::__anon50
Mass	vcglib/vcg/complex/algorithms/inertia.h	/^ScalarType Mass()$/;"	f	class:vcg::tri::Inertia
Material	vcglib/wrap/io_trimesh/io_material.h	/^	struct Material$/;"	s	namespace:vcg::tri::io
MaterialInfo	vcglib/wrap/io_trimesh/import_fbx.h	/^			MaterialInfo():hascolor(false),textindex(-1),surfMat(NULL){}$/;"	f	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
MaterialInfo	vcglib/wrap/io_trimesh/import_fbx.h	/^		class MaterialInfo$/;"	c	class:ImporterFBX::VCGMaterialBridge
MaterialTag	vcglib/wrap/dae/colladaformat.h	/^		MaterialTag(const QString& id,const QString& name)$/;"	f	class:Collada::Tags::MaterialTag
MaterialTag	vcglib/wrap/dae/colladaformat.h	/^	class MaterialTag : public XMLTag$/;"	c	namespace:Collada::Tags
Materials	vcglib/wrap/io_trimesh/io_material.h	/^	class Materials$/;"	c	namespace:vcg::tri::io
MaterialsCompare	vcglib/wrap/io_trimesh/io_material.h	/^		inline static int MaterialsCompare(std::vector<Material> &materials, Material mtl)$/;"	f	class:vcg::tri::io::Materials
Matrix	vcglib/eigenlib/Eigen/src/Core/Map.h	/^  ::Matrix(const Scalar *data)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Matrix& other)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const T0& x, const T1& y)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix() : Base()$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix(Index dim)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    Matrix(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^class Matrix$/;"	c	namespace:Eigen
Matrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
Matrix	vcglib/vcg/complex/algorithms/update/position.h	/^static void Matrix(ComputeMeshType &m, const Matrix44<ScalarType> &M, bool update_also_normals = true)$/;"	f	class:vcg::tri::UpdatePosition
Matrix	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix()$/;"	f	class:vcg::ndim::Matrix
Matrix	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix(const Matrix<TYPE> &m)$/;"	f	class:vcg::ndim::Matrix
Matrix	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix(unsigned int m, unsigned int n)$/;"	f	class:vcg::ndim::Matrix
Matrix	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix(unsigned int m, unsigned int n, TYPE *values)$/;"	f	class:vcg::ndim::Matrix
Matrix	vcglib/vcg/math/old_deprecated_matrix.h	/^	class Matrix$/;"	c	namespace:vcg::ndim
Matrix	vcglib/vcg/math/old_matrix.h	/^	Matrix() : Base() {}$/;"	f	class:vcg::ndim::Matrix
Matrix	vcglib/vcg/math/old_matrix.h	/^	Matrix(const Eigen::MatrixBase<OtherDerived> &m) : Base(m) {}$/;"	f	class:vcg::ndim::Matrix
Matrix	vcglib/vcg/math/old_matrix.h	/^	Matrix(const Matrix<Scalar> &m) : Base(m) {}$/;"	f	class:vcg::ndim::Matrix
Matrix	vcglib/vcg/math/old_matrix.h	/^	Matrix(int m, int n)$/;"	f	class:vcg::ndim::Matrix
Matrix	vcglib/vcg/math/old_matrix.h	/^	Matrix(int m, int n, Scalar *values)$/;"	f	class:vcg::ndim::Matrix
Matrix	vcglib/vcg/math/old_matrix.h	/^class Matrix : public Eigen::Matrix<_Scalar,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor> \/\/ FIXME col or row major ?$/;"	c	namespace:vcg::ndim
Matrix	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Matrix44<S> Similarity<S,RotationType>::Matrix() const {$/;"	f	class:vcg::Similarity
Matrix	vcglib/wrap/gui/trackball.cpp	/^Matrix44f Trackball::Matrix() const{$/;"	f	class:Trackball
Matrix2	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D
Matrix2	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D
Matrix3	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis
Matrix3	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::Quaternion
Matrix3	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis
Matrix3	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::QuaternionBase
Matrix33	vcglib/vcg/math/matrix33.h	/^    Matrix33 (const Matrix44<S> & m, const int & k)$/;"	f	class:vcg::Matrix33
Matrix33	vcglib/vcg/math/matrix33.h	/^    Matrix33( const Matrix33 & m )$/;"	f	class:vcg::Matrix33
Matrix33	vcglib/vcg/math/matrix33.h	/^    Matrix33( const S * v )$/;"	f	class:vcg::Matrix33
Matrix33	vcglib/vcg/math/matrix33.h	/^    inline Matrix33() {}$/;"	f	class:vcg::Matrix33
Matrix33	vcglib/vcg/math/matrix33.h	/^class Matrix33$/;"	c	namespace:vcg
Matrix33	vcglib/vcg/math/old_matrix33.h	/^	Matrix33(const Eigen::MatrixBase<OtherDerived>& other) : Base(other) {}$/;"	f	class:vcg::Matrix33
Matrix33	vcglib/vcg/math/old_matrix33.h	/^	Matrix33(const Matrix33& m ) : Base(m) {}$/;"	f	class:vcg::Matrix33
Matrix33	vcglib/vcg/math/old_matrix33.h	/^	Matrix33(const Matrix44<Scalar> & m, const int & k) : Base(m.minor(k,k)) {}$/;"	f	class:vcg::Matrix33
Matrix33	vcglib/vcg/math/old_matrix33.h	/^	Matrix33(const Scalar * v ) : Base(Eigen::Map<Eigen::Matrix<Scalar,3,3,Eigen::RowMajor> >(v)) {}$/;"	f	class:vcg::Matrix33
Matrix33	vcglib/vcg/math/old_matrix33.h	/^	inline Matrix33() : Base() {}$/;"	f	class:vcg::Matrix33
Matrix33	vcglib/vcg/math/old_matrix33.h	/^class Matrix33 : public Eigen::Matrix<_Scalar,3,3,Eigen::RowMajor> \/\/ FIXME col or row major ?$/;"	c	namespace:vcg
Matrix33d	vcglib/vcg/math/matrix33.h	/^typedef Matrix33<double> Matrix33d;$/;"	t	namespace:vcg
Matrix33d	vcglib/vcg/math/old_matrix33.h	/^typedef Matrix33<double> Matrix33d;$/;"	t	namespace:vcg
Matrix33f	vcglib/vcg/math/matrix33.h	/^typedef Matrix33<float>  Matrix33f;$/;"	t	namespace:vcg
Matrix33f	vcglib/vcg/math/old_matrix33.h	/^typedef Matrix33<float>  Matrix33f;$/;"	t	namespace:vcg
Matrix33i	vcglib/vcg/math/matrix33.h	/^typedef Matrix33<int>	 Matrix33i;$/;"	t	namespace:vcg
Matrix33i	vcglib/vcg/math/old_matrix33.h	/^typedef Matrix33<int>    Matrix33i;$/;"	t	namespace:vcg
Matrix33s	vcglib/vcg/math/matrix33.h	/^typedef Matrix33<short>  Matrix33s;$/;"	t	namespace:vcg
Matrix33s	vcglib/vcg/math/old_matrix33.h	/^typedef Matrix33<short>  Matrix33s;$/;"	t	namespace:vcg
Matrix44	vcglib/vcg/math/matrix44.h	/^	Matrix44() {}$/;"	f	class:vcg::Matrix44
Matrix44	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T>::Matrix44(const Matrix44<T> &m) {$/;"	f	class:vcg::Matrix44
Matrix44	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T>::Matrix44(const T v[]) {$/;"	f	class:vcg::Matrix44
Matrix44	vcglib/vcg/math/matrix44.h	/^template <class T> class Matrix44 {$/;"	c	namespace:vcg
Matrix44	vcglib/vcg/math/old_matrix44.h	/^	Matrix44() : Base() {}$/;"	f	class:vcg::Matrix44
Matrix44	vcglib/vcg/math/old_matrix44.h	/^	Matrix44(const Eigen::MatrixBase<OtherDerived>& other) : Base(other) {}$/;"	f	class:vcg::Matrix44
Matrix44	vcglib/vcg/math/old_matrix44.h	/^	Matrix44(const Matrix44 &m) : Base(m) {}$/;"	f	class:vcg::Matrix44
Matrix44	vcglib/vcg/math/old_matrix44.h	/^	Matrix44(const Scalar * v ) : Base(Eigen::Map<Eigen::Matrix<Scalar,4,4,Eigen::RowMajor> >(v)) {}$/;"	f	class:vcg::Matrix44
Matrix44	vcglib/vcg/math/old_matrix44.h	/^class Matrix44 : public Eigen::Matrix<_Scalar,4,4,Eigen::RowMajor> \/\/ FIXME col or row major !$/;"	c	namespace:vcg
Matrix44d	vcglib/vcg/math/matrix44.h	/^typedef Matrix44<double> Matrix44d;$/;"	t	namespace:vcg
Matrix44d	vcglib/vcg/math/old_matrix44.h	/^typedef Matrix44<double> Matrix44d;$/;"	t	namespace:vcg
Matrix44f	vcglib/vcg/math/matrix44.h	/^typedef Matrix44<float>  Matrix44f;$/;"	t	namespace:vcg
Matrix44f	vcglib/vcg/math/old_matrix44.h	/^typedef Matrix44<float>  Matrix44f;$/;"	t	namespace:vcg
Matrix44i	vcglib/vcg/math/matrix44.h	/^typedef Matrix44<int>    Matrix44i;$/;"	t	namespace:vcg
Matrix44i	vcglib/vcg/math/old_matrix44.h	/^typedef Matrix44<int>    Matrix44i;$/;"	t	namespace:vcg
Matrix44s	vcglib/vcg/math/matrix44.h	/^typedef Matrix44<short>  Matrix44s;$/;"	t	namespace:vcg
Matrix44s	vcglib/vcg/math/old_matrix44.h	/^typedef Matrix44<short>  Matrix44s;$/;"	t	namespace:vcg
Matrix44x	vcglib/apps/unsupported/shadevis/visshader.h	/^	typedef Matrix44<ScalarType> Matrix44x;$/;"	t	class:vcg::VisShader
MatrixAlignment	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment     = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon385
MatrixAlignment	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon386
MatrixBase	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    MatrixBase() : Base() {}$/;"	f	class:Eigen::MatrixBase
MatrixBase	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^template<typename Derived> class MatrixBase$/;"	c	namespace:Eigen
MatrixCols	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    MatrixCols = traits<XprType>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon50
MatrixConjugateReturnType	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;$/;"	t	class:Eigen::TriangularView
MatrixDiag	vcglib/vcg/math/old_deprecated_matrix.h	/^		MatrixDiag(const Point<N,S>&p):Point<N,S>(p){}$/;"	f	class:vcg::ndim::MatrixDiag
MatrixDiag	vcglib/vcg/math/old_deprecated_matrix.h	/^	class MatrixDiag: public Point<N,S>, public MatrixDiagBase{$/;"	c	namespace:vcg::ndim
MatrixDiagBase	vcglib/vcg/math/old_deprecated_matrix.h	/^	class MatrixDiagBase{public: $/;"	c	namespace:vcg::ndim
MatrixExponential	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^MatrixExponential<MatrixType>::MatrixExponential(const MatrixType &M) :$/;"	f	class:Eigen::MatrixExponential
MatrixExponential	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^class MatrixExponential {$/;"	c	namespace:Eigen
MatrixExponentialReturnValue	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    MatrixExponentialReturnValue(const Derived& src) : m_src(src) { }$/;"	f	struct:Eigen::MatrixExponentialReturnValue
MatrixExponentialReturnValue	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^template<typename Derived> struct MatrixExponentialReturnValue$/;"	s	namespace:Eigen
MatrixFunction	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    MatrixFunction(const MatrixType& A, AtomicType& atomic) : m_A(A), m_atomic(atomic) { }$/;"	f	class:Eigen::MatrixFunction
MatrixFunction	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^MatrixFunction<MatrixType,AtomicType,1>::MatrixFunction(const MatrixType& A, AtomicType& atomic)$/;"	f	class:Eigen::MatrixFunction
MatrixFunction	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^class MatrixFunction$/;"	c	namespace:Eigen
MatrixFunction	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^class MatrixFunction<MatrixType, AtomicType, 0>$/;"	c	namespace:Eigen
MatrixFunction	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^class MatrixFunction<MatrixType, AtomicType, 1>$/;"	c	namespace:Eigen
MatrixFunctionAtomic	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    MatrixFunctionAtomic(StemFunction f) : m_f(f) { }$/;"	f	class:Eigen::MatrixFunctionAtomic
MatrixFunctionAtomic	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^class MatrixFunctionAtomic$/;"	c	namespace:Eigen
MatrixFunctionReturnValue	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    MatrixFunctionReturnValue(const Derived& A, StemFunction f) : m_A(A), m_f(f) { }$/;"	f	class:Eigen::MatrixFunctionReturnValue
MatrixFunctionReturnValue	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^template<typename Derived> class MatrixFunctionReturnValue$/;"	c	namespace:Eigen
MatrixGL	vcglib/wrap/gl/camera.h	/^MatrixGL(vcg::Camera<S> & cam, vcg::Matrix44<S> &m)$/;"	f	struct:GlCamera
MatrixGL	vcglib/wrap/gl/shot.h	/^static void MatrixGL(ShotType & shot,vcg::Matrix44<ScalarType> & m) $/;"	f	struct:GlShot
MatrixHReturnType	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef internal::HessenbergDecompositionMatrixHReturnType<MatrixType> MatrixHReturnType;$/;"	t	class:Eigen::HessenbergDecomposition
MatrixL	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixL	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixL	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixL	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixL	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLDLT
MatrixL	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLLT
MatrixL	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::Lower>  MatrixL;$/;"	t	struct:Eigen::internal::traits
MatrixL	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::UnitLower>  MatrixL;$/;"	t	struct:Eigen::internal::traits
MatrixLogarithmAtomic	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  MatrixLogarithmAtomic() { }$/;"	f	class:Eigen::MatrixLogarithmAtomic
MatrixLogarithmAtomic	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^class MatrixLogarithmAtomic$/;"	c	namespace:Eigen
MatrixLogarithmReturnValue	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  MatrixLogarithmReturnValue(const Derived& A) : m_A(A) { }$/;"	f	class:Eigen::MatrixLogarithmReturnValue
MatrixLogarithmReturnValue	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^template<typename Derived> class MatrixLogarithmReturnValue$/;"	c	namespace:Eigen
MatrixMNd	vcglib/vcg/math/old_deprecated_matrix.h	/^		typedef vcg::ndim::Matrix<double> MatrixMNd;$/;"	t	namespace:vcg::ndim
MatrixMNd	vcglib/vcg/math/old_matrix.h	/^typedef vcg::ndim::Matrix<double> MatrixMNd;$/;"	t	namespace:vcg::ndim
MatrixMNf	vcglib/vcg/math/old_deprecated_matrix.h	/^		typedef vcg::ndim::Matrix<float>  MatrixMNf;$/;"	t	namespace:vcg::ndim
MatrixMNf	vcglib/vcg/math/old_matrix.h	/^typedef vcg::ndim::Matrix<float>  MatrixMNf;$/;"	t	namespace:vcg::ndim
MatrixMarketIterator	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    MatrixMarketIterator(const std::string folder):m_sym(0),m_isvalid(false),m_matIsLoaded(false),m_hasRhs(false),m_hasrefX(false),m_folder(folder)$/;"	f	class:Eigen::MatrixMarketIterator
MatrixMarketIterator	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^class MatrixMarketIterator $/;"	c	namespace:Eigen
MatrixOptions	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^      MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::JacobiSVD::__anon442
MatrixQReturnType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef internal::FullPivHouseholderQRMatrixQReturnType<MatrixType> MatrixQReturnType;$/;"	t	class:Eigen::FullPivHouseholderQR
MatrixQType	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, Options, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::ColPivHouseholderQR
MatrixQType	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, (MatrixType::Flags&RowMajorBit) ? RowMajor : ColMajor, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::HouseholderQR
MatrixRBlockType	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^    typedef Block<const MatrixType, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixRBlockType;$/;"	t	class:Eigen::QR
MatrixRows	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    MatrixRows = traits<XprType>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon50
MatrixSquareRoot	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    MatrixSquareRoot(const MatrixType& A) $/;"	f	class:Eigen::MatrixSquareRoot
MatrixSquareRoot	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^class MatrixSquareRoot$/;"	c	namespace:Eigen
MatrixSquareRoot	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^class MatrixSquareRoot<MatrixType, 0>$/;"	c	namespace:Eigen
MatrixSquareRoot	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^class MatrixSquareRoot<MatrixType, 1>$/;"	c	namespace:Eigen
MatrixSquareRootQuasiTriangular	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    MatrixSquareRootQuasiTriangular(const MatrixType& A) $/;"	f	class:Eigen::MatrixSquareRootQuasiTriangular
MatrixSquareRootQuasiTriangular	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^class MatrixSquareRootQuasiTriangular$/;"	c	namespace:Eigen
MatrixSquareRootReturnValue	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    MatrixSquareRootReturnValue(const Derived& src) : m_src(src) { }$/;"	f	class:Eigen::MatrixSquareRootReturnValue
MatrixSquareRootReturnValue	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^template<typename Derived> class MatrixSquareRootReturnValue$/;"	c	namespace:Eigen
MatrixSquareRootTriangular	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    MatrixSquareRootTriangular(const MatrixType& A) $/;"	f	class:Eigen::MatrixSquareRootTriangular
MatrixSquareRootTriangular	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^class MatrixSquareRootTriangular$/;"	c	namespace:Eigen
MatrixTReturnType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef internal::TridiagonalizationMatrixTReturnType<MatrixTypeRealView> MatrixTReturnType;$/;"	t	class:Eigen::Tridiagonalization
MatrixToQuaternion	vcglib/vcg/math/quaternion.h	/^template<class S, class M> void MatrixToQuaternion(const M &m, Quaternion<S> &q) {$/;"	f	namespace:vcg
MatrixType	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LDLT
MatrixType	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LLT
MatrixType	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodBase
MatrixType	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodDecomposition
MatrixType	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLDLT
MatrixType	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLLT
MatrixType	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSupernodalLLT
MatrixType	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    typedef typename internal::conditional<int(Side)==OnTheRight,_LhsNested,_RhsNested>::type MatrixType;$/;"	t	class:Eigen::GeneralProduct
MatrixType	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::TriangularView
MatrixType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,HDim,HDim> MatrixType;$/;"	t	class:Eigen::Transform
MatrixType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::ei_transform_product_impl
MatrixType	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexEigenSolver
MatrixType	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexSchur
MatrixType	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::EigenSolver
MatrixType	vcglib/eigenlib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver
MatrixType	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HessenbergDecomposition
MatrixType	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealSchur
MatrixType	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
MatrixType	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
MatrixType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::Tridiagonalization
MatrixType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef typename Transform<Scalar,Dim,AffineCompact,Options>::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part
MatrixType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
MatrixType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part
MatrixType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef typename internal::make_proper_matrix_type<Scalar,Rows,HDim,Options>::type MatrixType;$/;"	t	class:Eigen::Transform
MatrixType	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::DiagonalPreconditioner
MatrixType	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::BiCGSTAB
MatrixType	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ConjugateGradient
MatrixType	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::IncompleteLUT
MatrixType	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::IterativeSolverBase
MatrixType	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivLU
MatrixType	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PartialPivLU
MatrixType	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MapLU, Dynamic, Dynamic> MatrixType;$/;"	t	struct:Eigen::internal::partial_lu_impl
MatrixType	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixBase
MatrixType	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLDLT
MatrixType	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLLT
MatrixType	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLU
MatrixType	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pastix_traits
MatrixType	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pardiso_traits
MatrixType	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::MatrixType MatrixType;$/;"	t	class:Eigen::PardisoImpl
MatrixType	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ColPivHouseholderQR
MatrixType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivHouseholderQR
MatrixType	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HouseholderQR
MatrixType	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::JacobiSVD
MatrixType	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
MatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholesky
MatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLDLT
MatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLLT
MatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase
MatrixType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> MatrixType;$/;"	t	class:Eigen::SparseInnerVectorSet
MatrixType	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef SparseMatrix<_Scalar, _Options, _Index> MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperILU
MatrixType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLU
MatrixType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLUBase
MatrixType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Derived MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper
MatrixType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Matrix<Scalar,Rows,Cols,Options,MRows,MCols> MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper
MatrixType	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::UmfPackLU
MatrixType	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::image_retval_base
MatrixType	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GMRES
MatrixType	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::IncompleteLU
MatrixType	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    typedef _MatrixType MatrixType; $/;"	t	class:Scaling
MatrixType	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    typedef DynamicSparseMatrix<_Scalar, _Options, _Index> MatrixType;$/;"	t	class:Eigen::SparseInnerVectorSet
MatrixType	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    typedef SparseMatrix<Scalar,ColMajor> MatrixType; $/;"	t	class:Eigen::MatrixMarketIterator
MatrixTypeCleaned	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeInnerStride	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    MatrixTypeInnerStride =  inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon57
MatrixTypeIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl
MatrixTypeIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::Replicate
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^  typedef typename nested<MatrixType,Factor>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::SelfAdjointView
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::TriangularView
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  typedef typename internal::eval<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::inverse_impl
MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView
MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseTriangularView
MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseView
MatrixTypeNestedCleaned	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_matrix_product_retval
MatrixTypeNestedCleaned	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SelfAdjointView
MatrixTypeNestedCleaned	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedCleaned	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval
MatrixTypeNestedCleaned	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::TriangularView
MatrixTypeNestedCleaned	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedCleaned	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::inverse_impl
MatrixTypeNestedCleaned	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval
MatrixTypeNestedCleaned	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedCleaned	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SparseTriangularView
MatrixTypeNestedNonRef	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;$/;"	t	class:Eigen::TriangularView
MatrixTypeNestedNonRef	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedNonRef	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	class:Eigen::SparseTriangularView
MatrixTypeNestedPlain	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;$/;"	t	struct:Eigen::internal::traits
MatrixTypeOuterStride	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    MatrixTypeOuterStride = outer_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon64
MatrixTypeRealView	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::remove_all<typename MatrixType::RealReturnType>::type MatrixTypeRealView;$/;"	t	class:Eigen::Tridiagonalization
MatrixTypeReverseIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl
MatrixTypeReverseIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl
MatrixU	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixU	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixU	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixU	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixU	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLDLT
MatrixU	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLLT
MatrixU	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::traits
MatrixU	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::Upper>   MatrixU;$/;"	t	struct:Eigen::internal::traits
MatrixUType	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, MinSize> MatrixUType;$/;"	t	class:Eigen::SVD
MatrixUType	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^            MatrixUType;$/;"	t	class:Eigen::JacobiSVD
MatrixVType	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixVType;$/;"	t	class:Eigen::SVD
MatrixVType	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^            MatrixVType;$/;"	t	class:Eigen::JacobiSVD
MatrixWrapper	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline MatrixWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::MatrixWrapper
MatrixWrapper	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^class MatrixWrapper : public MatrixBase<MatrixWrapper<ExpressionType> >$/;"	c	namespace:Eigen
MatrixXpr	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^struct MatrixXpr {};$/;"	s	namespace:Eigen
Max	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Max	vcglib/vcg/math/base.h	/^  template<class T> inline const T & Max(const T &a, const T &b, const T &c){$/;"	f	namespace:vcg::math
Max	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar Max() const { return maxCoeff(); }$/;"	f
Max	vcglib/vcg/math/histogram.h	/^	 ScalarType Max() { return max_v; }$/;"	f	class:vcg::Distribution
Max	vcglib/vcg/space/box.h	/^  inline PointType &Max() { return _max; } $/;"	f	class:vcg::Box
Max	vcglib/vcg/space/box.h	/^  inline const PointType &Max() const { return _max; } $/;"	f	class:vcg::Box
Max	vcglib/vcg/space/deprecated_point.h	/^	inline S Max() const {$/;"	f	class:vcg::ndim::Point2
Max	vcglib/vcg/space/deprecated_point.h	/^	inline S Max() const {$/;"	f	class:vcg::ndim::Point3
Max	vcglib/vcg/space/deprecated_point.h	/^	inline S Max() const {$/;"	f	class:vcg::ndim::Point4
MaxCoeff	vcglib/vcg/space/index/kdtree/mlsutils.h	/^inline Scalar MaxCoeff(Point3<Scalar> const & p)$/;"	f	namespace:vcg
MaxCoeffId	vcglib/vcg/space/index/kdtree/mlsutils.h	/^inline int MaxCoeffId(Point3<Scalar> const & p)$/;"	f	namespace:vcg
MaxCols	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    MaxCols  = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon142
MaxCols	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    static const int MaxCols = Traits::MaxColsAtCompileTime;$/;"	m	class:Eigen::MatrixFunction
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon4
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::LLT::__anon5
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon45
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon48
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon49
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    MaxColsAtCompileTime = BlockCols==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon50
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon53
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon58
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon64
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^      MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon65
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    MaxColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon67
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    MaxColsAtCompileTime = _MaxCols,$/;"	e	enum:Eigen::internal::traits::__anon181
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::PermutationBase::__anon186
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::Transpose::__anon188
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    MaxColsAtCompileTime = IndicesType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon187
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    MaxColsAtCompileTime = RhsCleaned::MaxColsAtCompileTime,$/;"	e	enum:internal::traits::__anon192
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    MaxColsAtCompileTime = traits<Rhs>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon193
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon234
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon236
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    MaxColsAtCompileTime = ConditionMatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon238
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon248
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime$/;"	e	enum:Eigen::TriangularBase::__anon251
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    MaxColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon321
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon194
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    MaxColsAtCompileTime = (MatrixType::MaxColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon348
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexEigenSolver::__anon350
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexSchur::__anon351
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::EigenSolver::__anon352
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealSchur::__anon354
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon355
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon359
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^      MaxColsAtCompileTime = internal::traits<HouseholderSequence>::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderSequence::__anon383
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    MaxColsAtCompileTime = MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon382
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivLU::__anon387
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::PartialPivLU::__anon390
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon396
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon397
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderQR::__anon398
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon442
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon439
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon440
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon441
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon408
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    MaxColsAtCompileTime = Tr ? int(traits<Lhs>::MaxColsAtCompileTime)  : int(traits<Rhs>::MaxColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon413
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    MaxColsAtCompileTime = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon414
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon418
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon417
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon424
MaxColsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon430
MaxColsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon450
MaxColsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon451
MaxColsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
MaxColsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon456
MaxCount	vcglib/vcg/math/histogram.h	/^ScalarType Histogram<ScalarType>::MaxCount() const$/;"	f	class:vcg::Histogram
MaxDepth	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    MaxDepth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon142
MaxDepthAtCompileTime	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      MaxDepthAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(Lhs::MaxColsAtCompileTime,Rhs::MaxRowsAtCompileTime)$/;"	e	enum:Eigen::GeneralProduct::__anon208
MaxDiagSizeAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^      MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon442
MaxDim	vcglib/vcg/space/box3.h	/^    inline unsigned char MaxDim() const {$/;"	f	class:vcg::Box3
MaxElem	vcglib/vcg/math/histogram.h	/^  ScalarType MaxElem() {return maxElem;}; 	\/\/! Maximum element added to the histogram. It could be < or > than MinV;..$/;"	f	class:vcg::Histogram
MaxI	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline int MaxI() const { EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived); int i; maxCoeff(&i,0); return i; }$/;"	f
MaxI	vcglib/vcg/space/deprecated_point.h	/^	inline int MaxI() const {$/;"	f	class:vcg::ndim::Point2
MaxI	vcglib/vcg/space/deprecated_point.h	/^	inline int MaxI() const {$/;"	f	class:vcg::ndim::Point3
MaxI	vcglib/vcg/space/deprecated_point.h	/^	inline int MaxI() const {$/;"	f	class:vcg::ndim::Point4
MaxRadius	vcglib/vcg/complex/algorithms/symmetry.h	/^    ScalarType MaxRadius;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
MaxRows	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    MaxRows  = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon142
MaxRows	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    static const int MaxRows = Traits::MaxRowsAtCompileTime;$/;"	m	class:Eigen::MatrixFunction
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon4
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon45
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon48
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon49
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    MaxRowsAtCompileTime = BlockRows==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon50
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon53
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon58
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    MaxRowsAtCompileTime = int(MatrixType::MaxSizeAtCompileTime) == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon64
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^      MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon65
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    MaxRowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon67
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    MaxRowsAtCompileTime = _MaxRows,$/;"	e	enum:Eigen::internal::traits::__anon181
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon186
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon188
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    MaxRowsAtCompileTime = IndicesType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon187
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    MaxRowsAtCompileTime = LhsCleaned::MaxRowsAtCompileTime,$/;"	e	enum:internal::traits::__anon192
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    MaxRowsAtCompileTime = traits<Lhs>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon193
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon234
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon236
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    MaxRowsAtCompileTime = ConditionMatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon238
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon248
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon251
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    MaxRowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon321
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon194
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    MaxRowsAtCompileTime = (MatrixType::MaxRowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon348
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon350
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon351
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon352
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon354
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon359
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^      MaxRowsAtCompileTime = internal::traits<HouseholderSequence>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon383
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    MaxRowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon382
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon387
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon390
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon396
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon397
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon398
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon442
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon438
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon439
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon440
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon441
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon408
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    MaxRowsAtCompileTime = Tr ? int(traits<Rhs>::MaxRowsAtCompileTime)  : int(traits<Lhs>::MaxRowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon413
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    MaxRowsAtCompileTime = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon414
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon417
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon418
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon424
MaxRowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon430
MaxRowsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon450
MaxRowsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon451
MaxRowsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
MaxRowsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon456
MaxSize	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon353
MaxSize	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon356
MaxSizeAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    MaxSizeAtCompileTime = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_traits::__anon35
MaxSizeAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      MaxSizeAtCompileTime = Dst::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
MaxSizeAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon58
MaxSizeAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
MaxSizeAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        MaxSizeAtCompileTime = (internal::size_at_compile_time<MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon451
MaxSizeMinusOne	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : MaxSize - 1$/;"	e	enum:Eigen::HessenbergDecomposition::__anon353
MaxSizeMinusOne	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : (MaxSize > 1 ? MaxSize - 1 : 1)$/;"	e	enum:Eigen::Tridiagonalization::__anon356
MaxSmallDimAtCompileTime	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::image_retval::__anon389
MaxSmallDimAtCompileTime	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::kernel_retval::__anon388
MaxV	vcglib/vcg/math/histogram.h	/^  ScalarType MaxV() {return maxv;}; 	\/\/! Maximum value.$/;"	f	class:vcg::Histogram
MayEnableVml	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      MayEnableVml = MightEnableVml && LargeEnough,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
MayInnerVectorize	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    MayInnerVectorize  = MightVectorize && int(InnerSize)!=Dynamic && int(InnerSize)%int(PacketSize)==0$/;"	e	enum:Eigen::internal::assign_traits::__anon36
MayLinearVectorize	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    MayLinearVectorize = MightVectorize && MayLinearize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon36
MayLinearVectorize	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    MayLinearVectorize = MightVectorize && (int(Derived::Flags)&LinearAccessBit),$/;"	e	enum:Eigen::internal::redux_traits::__anon224
MayLinearize	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    MayLinearize = StorageOrdersAgree && (int(Derived::Flags) & int(OtherDerived::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::assign_traits::__anon36
MayLinearize	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      MayLinearize = MayEnableVml && MightLinearize$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
MaySliceVectorize	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    MaySliceVectorize  = MightVectorize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon36
MaySliceVectorize	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    MaySliceVectorize  = MightVectorize && int(InnerMaxSize)>=3*PacketSize$/;"	e	enum:Eigen::internal::redux_traits::__anon224
MayUnrollCompletely	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    MayUnrollCompletely = int(Derived::SizeAtCompileTime) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon38
MayUnrollInner	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    MayUnrollInner      = int(InnerSize) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon38
MeanAndGaussian	vcglib/vcg/complex/algorithms/update/curvature.h	/^static void MeanAndGaussian(MeshType & m)$/;"	f	class:vcg::tri::UpdateCurvature
MeasureQuality	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static ScalarType MeasureQuality(MeshType &m)$/;"	f	class:vcg::tri::BitQuadOptimization
Mem	vcglib/vcg/complex/base.h	/^     int Mem(const int & nv, const int & nf) const  {$/;"	f	class:vcg::tri::TriMesh
MemNeeded	vcglib/vcg/complex/base.h	/^    inline int MemNeeded() const {return Mem(vn,fn);}$/;"	f	class:vcg::tri::TriMesh
MemUsed	vcglib/vcg/complex/base.h	/^    int MemUsed() const  {return Mem(vert.size(),face.size());}$/;"	f	class:vcg::tri::TriMesh
MemUsed	vcglib/vcg/space/index/grid_static_ptr.h	/^		int MemUsed()$/;"	f	class:vcg::GridStaticPtr
Merge	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^      static void Merge(VERTEX_TYPE & \/*v_dest*\/, VERTEX_TYPE const & \/*v_del*\/){}$/;"	f	class:vcg::tri::QInfoStandard
Merge	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^      static void Merge(VertexType & \/*v_dest*\/, VertexType const & \/*v_del*\/){}$/;"	f	class:vcg::tri::QuadricTexHelper
MergeCloseVertex	vcglib/vcg/complex/algorithms/clean.h	/^  static int MergeCloseVertex(MeshType &m, const ScalarType radius)$/;"	f	class:vcg::tri::Clean
MergeFaces	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            static void MergeFaces(FaceType *, FaceType *){}$/;"	f	class:vcg::tri::UpdateHalfEdges
MergeFlatFaces	vcglib/vcg/complex/algorithms/polygon_support.h	/^	static void MergeFlatFaces(TriMeshType & tm, double tolerance = 0.1E-4){$/;"	f	struct:vcg::tri::PolygonSupport
Mesh	vcglib/apps/unsupported/extractors/extractor/Definitions.h	/^class Mesh		: public vcg::tri::TriMesh< std::vector< Vertex>, std::vector< Face > > {};$/;"	c
Mesh	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  MeshType & Mesh() {return m;}$/;"	f	class:vcg::tri::TextureOptimizer
Mesh	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  const MeshType & Mesh() const {return m;}$/;"	f	class:vcg::tri::TextureOptimizer
Mesh	vcglib/vcg/complex/append.h	/^static void Mesh(MeshLeft& ml, ConstMeshRight& mr, const bool selected = false, const bool adjFlag = false)$/;"	f	class:vcg::tri::Append
MeshAngleDistortion	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			static ScalarType MeshAngleDistortion(const MeshType &m)$/;"	f	class:vcg::tri::Distortion
MeshCopy	vcglib/vcg/complex/append.h	/^static void MeshCopy(MeshLeft& ml, ConstMeshRight& mr, bool selected=false)$/;"	f	class:vcg::tri::Append
MeshGenus	vcglib/vcg/complex/algorithms/clean.h	/^            static int MeshGenus(MeshType &m)$/;"	f	class:vcg::tri::Clean
MeshGenus	vcglib/vcg/complex/algorithms/clean.h	/^            static int MeshGenus(int nvert,int nedges,int nfaces, int numholes, int numcomponents)$/;"	f	class:vcg::tri::Clean
MeshGrid	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    typedef GridStaticPtr<VertexType, ScalarType > MeshGrid;$/;"	t	class:OverlapEstimation
MeshGridType	vcglib/vcg/complex/algorithms/update/curvature.h	/^  typedef vcg::GridStaticPtr	<FaceType, ScalarType >		MeshGridType;$/;"	t	class:vcg::tri::UpdateCurvature
MeshInfo	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^struct MeshInfo$/;"	s	file:
MeshSHT	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename vcg::SpatialHashTable<FaceType, ScalarType> MeshSHT;$/;"	t	class:vcg::tri::SurfaceSampling
MeshSHTIterator	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename vcg::SpatialHashTable<FaceType, ScalarType>::CellIterator MeshSHTIterator;$/;"	t	class:vcg::tri::SurfaceSampling
MeshSampler	vcglib/vcg/complex/algorithms/point_sampling.h	/^  MeshSampler(MeshType &_m):m(_m){}$/;"	f	class:vcg::tri::MeshSampler
MeshSampler	vcglib/vcg/complex/algorithms/point_sampling.h	/^class MeshSampler$/;"	c	namespace:vcg::tri
MeshScalingFactor	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^            static void MeshScalingFactor(const MeshType &m,$/;"	f	class:vcg::tri::Distortion
MeshSystemInfo	vcglib/wrap/miq/core/vertex_indexing.h	/^struct MeshSystemInfo$/;"	s
MeshTag	vcglib/wrap/dae/colladaformat.h	/^		MeshTag()$/;"	f	class:Collada::Tags::MeshTag
MeshTag	vcglib/wrap/dae/colladaformat.h	/^	class MeshTag : public XMLTag$/;"	c	namespace:Collada::Tags
MeshType	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^typedef _MeshType MeshType;$/;"	t	class:vcg::tri::BitQuadCreation
MeshType	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^typedef typename BQ::MeshType MeshType;$/;"	t	class:vcg::tri::BitQuadOptimization
MeshType	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef _MeshType MeshType;$/;"	t	class:vcg::tri::BitQuad
MeshType	vcglib/vcg/complex/algorithms/clean.h	/^  typedef CleanMeshType MeshType;$/;"	t	class:vcg::tri::Clean
MeshType	vcglib/vcg/complex/algorithms/clean.h	/^  typedef ConnectedMeshType MeshType;$/;"	t	class:vcg::tri::ConnectedComponentIterator
MeshType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef MESH MeshType;$/;"	t	class:vcg::tri::ClosestFaceEPIterator
MeshType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef MESH MeshType;$/;"	t	class:vcg::tri::ClosestVertexIterator
MeshType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef MESH MeshType;$/;"	t	class:vcg::tri::TriRayIterator
MeshType	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    typedef MESH_TYPE MeshType;$/;"	t	class:OverlapEstimation
MeshType	vcglib/vcg/complex/algorithms/smooth.h	/^            typedef SmoothMeshType MeshType;$/;"	t	class:vcg::tri::Smooth
MeshType	vcglib/vcg/complex/algorithms/stat.h	/^  typedef StatMeshType MeshType;$/;"	t	class:vcg::tri::Stat
MeshType	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef MESH_TYPE MeshType;$/;"	t	class:vcg::tri::AreaPreservingTextureOptimizer
MeshType	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef MESH_TYPE MeshType;$/;"	t	class:vcg::tri::TextureOptimizer
MeshType	vcglib/vcg/complex/algorithms/update/bounding.h	/^typedef ComputeMeshType MeshType; $/;"	t	class:vcg::tri::UpdateBounding
MeshType	vcglib/vcg/complex/algorithms/update/component_ep.h	/^		typedef ComputeMeshType MeshType; $/;"	t	class:vcg::tri::UpdateComponentEP
MeshType	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef UpdateMeshType MeshType;$/;"	t	class:vcg::tri::UpdateFlags
MeshType	vcglib/vcg/complex/algorithms/update/normal.h	/^typedef ComputeMeshType MeshType; 	$/;"	t	class:vcg::tri::UpdateNormal
MeshType	vcglib/vcg/complex/algorithms/update/position.h	/^typedef ComputeMeshType MeshType; $/;"	t	class:vcg::tri::UpdatePosition
MeshType	vcglib/vcg/complex/algorithms/update/quality.h	/^  typedef UpdateMeshType MeshType;$/;"	t	class:vcg::tri::UpdateQuality
MeshType	vcglib/vcg/complex/algorithms/update/selection.h	/^typedef ComputeMeshType MeshType;$/;"	t	class:vcg::tri::UpdateSelection
MeshType	vcglib/vcg/complex/algorithms/update/texture.h	/^typedef ComputeMeshType MeshType; $/;"	t	class:vcg::tri::UpdateTexture
MeshType	vcglib/vcg/complex/algorithms/update/topology.h	/^typedef UpdateMeshType MeshType;$/;"	t	class:vcg::tri::UpdateTopology
MeshType	vcglib/vcg/complex/base.h	/^    typedef TriMesh<Container0, Container1,Container2,Container3> MeshType;$/;"	t	class:vcg::tri::TriMesh
MeshTypeHolder	vcglib/vcg/complex/base.h	/^                        struct MeshTypeHolder: public T {};$/;"	s	namespace:vcg::tri
MeshTypeHolder	vcglib/vcg/complex/base.h	/^                        struct MeshTypeHolder<T, CONT, AllTypes::AVertexType>: public T {$/;"	s	namespace:vcg::tri
MeshTypeHolder	vcglib/vcg/complex/base.h	/^                    struct MeshTypeHolder< T, CONT,  AllTypes::AFaceType>:public T {$/;"	s	namespace:vcg::tri
MeshTypeHolder	vcglib/vcg/complex/base.h	/^                    struct MeshTypeHolder< T, CONT, AllTypes::AEdgeType>: public T{$/;"	s	namespace:vcg::tri
MeshTypeHolder	vcglib/vcg/complex/base.h	/^                    struct MeshTypeHolder< T, CONT, AllTypes::AHEdgeType>: public T{$/;"	s	namespace:vcg::tri
Message	vcglib/wrap/minpack/minpack.h	/^static char * Message(const int & i){$/;"	f	class:LMDiff
MetroMeshAABB	vcglib/apps/metro/sampling.h	/^	typedef AABBBinaryTreeIndex	<FaceType, typename MetroMesh::ScalarType, vcg::EmptyClass>	MetroMeshAABB;$/;"	t	class:vcg::Sampling
MetroMeshGrid	vcglib/apps/metro/sampling.h	/^		typedef GridStaticPtr				<FaceType, typename MetroMesh::ScalarType >									MetroMeshGrid;$/;"	t	class:vcg::Sampling
MetroMeshHash	vcglib/apps/metro/sampling.h	/^	  typedef SpatialHashTable		<FaceType, typename MetroMesh::ScalarType >									MetroMeshHash;$/;"	t	class:vcg::Sampling
MetroMeshOctree	vcglib/apps/metro/sampling.h	/^		typedef Octree							<FaceType, typename MetroMesh::ScalarType >                 MetroMeshOctree;$/;"	t	class:vcg::Sampling
Mfit_coeff	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            static float& Mfit_coeff()$/;"	f	class:vcg::tri::FitmapsCollapse
MidPoint	vcglib/vcg/complex/algorithms/refine.h	/^     MidPoint(MESH_TYPE *_mp,$/;"	f	struct:vcg::tri::MidPoint
MidPoint	vcglib/vcg/complex/algorithms/refine.h	/^struct MidPoint : public   std::unary_function<face::Pos<typename MESH_TYPE::FaceType> ,  typename MESH_TYPE::CoordType >$/;"	s	namespace:vcg::tri
MidPoint	vcglib/vcg/space/segment2.h	/^    inline PointType MidPoint( ) const$/;"	f	class:vcg::Segment2
MidPoint	vcglib/vcg/space/segment3.h	/^	inline PointType MidPoint( ) const$/;"	f	class:vcg::Segment3
MidPointArc	vcglib/vcg/complex/algorithms/refine.h	/^struct MidPointArc : public std::unary_function<face::Pos<typename MESH_TYPE::FaceType> ,  typename MESH_TYPE::CoordType>$/;"	s	namespace:vcg::tri
MidPointArcNaive	vcglib/vcg/complex/algorithms/refine.h	/^struct MidPointArcNaive : public std::unary_function< face::Pos<typename MESH_TYPE::FaceType> , typename MESH_TYPE::CoordType>$/;"	s	namespace:vcg::tri
MidPointButterfly	vcglib/vcg/complex/algorithms/refine.h	/^  MidPointButterfly(MESH_TYPE &_m):m(_m){}$/;"	f	struct:vcg::tri::MidPointButterfly
MidPointButterfly	vcglib/vcg/complex/algorithms/refine.h	/^struct MidPointButterfly : public std::unary_function<face::Pos<typename MESH_TYPE::FaceType> , typename MESH_TYPE::CoordType>$/;"	s	namespace:vcg::tri
MidPointButterfly2	vcglib/vcg/complex/algorithms/refine.h	/^struct MidPointButterfly2 : public std::unary_function<face::Pos<typename MESH_TYPE::FaceType> , typename MESH_TYPE::CoordType>$/;"	s	namespace:vcg::tri
MidPointSphere	vcglib/vcg/complex/algorithms/refine.h	/^struct MidPointSphere : public std::unary_function<face::Pos<typename MESH_TYPE::FaceType> , typename MESH_TYPE::CoordType>$/;"	s	namespace:vcg::tri
MightEnableVml	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      MightEnableVml =  vml_call<UnaryOp>::IsSupported && StorageOrdersAgree && DstHasDirectAccess && SrcHasDirectAccess$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
MightLinearize	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      MightLinearize = MightEnableVml && (int(Dst::Flags) & int(Src::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
MightVectorize	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    MightVectorize = StorageOrdersAgree$/;"	e	enum:Eigen::internal::assign_traits::__anon36
MightVectorize	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)$/;"	e	enum:Eigen::internal::redux_traits::__anon224
Min	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Min	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  CoordType Min() const$/;"	f	struct:vcg::tri::VoronoiProcessing::QuadricSumDistance
Min	vcglib/vcg/math/base.h	/^  template<class T> inline const T & Min(const T &a, const T &b,const T &c){$/;"	f	namespace:vcg::math
Min	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar Min() const { return minCoeff(); }$/;"	f
Min	vcglib/vcg/math/histogram.h	/^	 ScalarType Min() { return min_v; }	$/;"	f	class:vcg::Distribution
Min	vcglib/vcg/space/box.h	/^  inline PointType &Min() { return _min; } $/;"	f	class:vcg::Box
Min	vcglib/vcg/space/box.h	/^  inline const PointType &Min() const { return _min; } $/;"	f	class:vcg::Box
Min	vcglib/vcg/space/deprecated_point.h	/^	inline S Min() const {$/;"	f	class:vcg::ndim::Point2
Min	vcglib/vcg/space/deprecated_point.h	/^	inline S Min() const {$/;"	f	class:vcg::ndim::Point3
Min	vcglib/vcg/space/deprecated_point.h	/^	inline S Min() const {$/;"	f	class:vcg::ndim::Point4
MinDim	vcglib/vcg/space/box3.h	/^    inline unsigned char MinDim() const {$/;"	f	class:vcg::Box3
MinElem	vcglib/vcg/math/histogram.h	/^  ScalarType MinElem() {return minElem;}; 	\/\/! Minimum element added to the histogram. It could be < or > than MinV;.$/;"	f	class:vcg::Histogram
MinFilterTag	vcglib/wrap/dae/colladaformat.h	/^		MinFilterTag(const QString& filter)$/;"	f	class:Collada::Tags::MinFilterTag
MinFilterTag	vcglib/wrap/dae/colladaformat.h	/^	class MinFilterTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
MinI	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline int MinI() const { EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived); int i; minCoeff(&i,0); return i; }$/;"	f
MinI	vcglib/vcg/space/deprecated_point.h	/^	inline int MinI() const {$/;"	f	class:vcg::ndim::Point2
MinI	vcglib/vcg/space/deprecated_point.h	/^	inline int MinI() const {$/;"	f	class:vcg::ndim::Point3
MinI	vcglib/vcg/space/deprecated_point.h	/^	inline int MinI() const {$/;"	f	class:vcg::ndim::Point4
MinRowsAtCompileTime	vcglib/eigenlib/Eigen/src/Geometry/Umeyama.h	/^    MinRowsAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, OtherMatrixType::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon380
MinSize	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^      MinSize = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime)$/;"	e	enum:Eigen::SVD::__anon349
MinV	vcglib/vcg/math/histogram.h	/^	ScalarType MinV() {return minv;}; 	\/\/! Minimum value.$/;"	f	class:vcg::Histogram
MinWastedSpace	vcglib/vcg/space/rasterized_outline2_packer.h	/^          MinWastedSpace,$/;"	e	enum:vcg::RasterizedOutline2Packer::Parameters::costFuncEnum
Minimum	vcglib/vcg/math/quadric.h	/^bool Minimum(Point3<ReturnScalarType> &x)$/;"	f	class:vcg::math::Quadric
Minimum	vcglib/vcg/math/quadric.h	/^bool Minimum(Point3<ScalarType> &x,Point3<ScalarType> &pa,Point3<ScalarType> &pb){$/;"	f	class:vcg::math::Quadric
Minimum	vcglib/vcg/math/quadric5.h	/^  bool Minimum(ScalarType x[5]) const$/;"	f	class:vcg::Quadric5
MinimumNew	vcglib/vcg/math/quadric.h	/^bool MinimumNew(Point3<ScalarType> &x) const$/;"	f	class:vcg::math::Quadric
MinimumSVD	vcglib/vcg/math/quadric.h	/^bool MinimumSVD(Point3<ReturnScalarType> &x)$/;"	f	class:vcg::math::Quadric
MinimumWeightEar	vcglib/vcg/complex/algorithms/hole.h	/^  MinimumWeightEar(){}$/;"	f	class:vcg::tri::MinimumWeightEar
MinimumWeightEar	vcglib/vcg/complex/algorithms/hole.h	/^  MinimumWeightEar(const typename face::Pos<typename MESH::FaceType>& ep) : TrivialEar<MESH>(ep)$/;"	f	class:vcg::tri::MinimumWeightEar
MinimumWeightEar	vcglib/vcg/complex/algorithms/hole.h	/^template<class MESH> class MinimumWeightEar : public TrivialEar<MESH>$/;"	c	namespace:vcg::tri
MinimumWeightFill	vcglib/vcg/complex/algorithms/hole.h	/^  static void MinimumWeightFill(MESH &m, int holeSize, bool Selected)$/;"	f	class:vcg::tri::Hole
MinimumWithGeoContraints	vcglib/vcg/math/quadric5.h	/^  bool MinimumWithGeoContraints(ScalarType x[5],const ScalarType geo[5]) const$/;"	f	class:vcg::Quadric5
Minor	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    inline Minor(const MatrixType& matrix,$/;"	f	class:Eigen::Minor
Minor	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^template<typename MatrixType> class Minor$/;"	c	namespace:Eigen
Miq_Gl_Utils	vcglib/wrap/miq/core/glUtils.h	/^class Miq_Gl_Utils$/;"	c
Mirror	vcglib/vcg/space/line2.h	/^vcg::Point2<ScalarType> Mirror(const vcg::Line2<ScalarType, NORM> &l, $/;"	f	namespace:vcg
MissMatchByCross	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static int MissMatchByCross(const CoordType &dir0,$/;"	f	class:vcg::tri::CrossField
MissMatchByCross	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^            static int MissMatchByCross(const FaceType &f0,$/;"	f	class:vcg::tri::CrossField
MissingCompactnessException	vcglib/vcg/complex/exception.h	/^  MissingCompactnessException(const std::string &err):std::runtime_error(err)$/;"	f	class:vcg::MissingCompactnessException
MissingCompactnessException	vcglib/vcg/complex/exception.h	/^class MissingCompactnessException : public std::runtime_error$/;"	c	namespace:vcg
MissingComponentException	vcglib/vcg/complex/exception.h	/^  MissingComponentException(const std::string &err):std::runtime_error(err)$/;"	f	class:vcg::MissingComponentException
MissingComponentException	vcglib/vcg/complex/exception.h	/^class MissingComponentException : public std::runtime_error$/;"	c	namespace:vcg
MissingTriangularRequirementException	vcglib/vcg/complex/exception.h	/^  MissingTriangularRequirementException(const std::string &err):std::runtime_error(err)$/;"	f	class:vcg::MissingTriangularRequirementException
MissingTriangularRequirementException	vcglib/vcg/complex/exception.h	/^class MissingTriangularRequirementException : public std::runtime_error$/;"	c	namespace:vcg
MixedCost	vcglib/vcg/space/rasterized_outline2_packer.h	/^          MixedCost$/;"	e	enum:vcg::RasterizedOutline2Packer::Parameters::costFuncEnum
MixedIntegerSolve	vcglib/wrap/miq/core/poisson_solver.h	/^	void MixedIntegerSolve(double cone_grid_res=1, $/;"	f	class:PoissonSolver
Mode	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^      Mode = internal::traits<SelfAdjointView>::Mode$/;"	e	enum:Eigen::SelfAdjointView::__anon240
Mode	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    Mode = UpLo | SelfAdjoint,$/;"	e	enum:Eigen::internal::traits::__anon239
Mode	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::TriangularView::__anon253
Mode	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      Mode = internal::traits<Derived>::Mode,$/;"	e	enum:Eigen::TriangularBase::__anon251
Mode	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::internal::traits::__anon252
Mode	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    Mode = Transform::Mode,$/;"	e	enum:Eigen::internal::transform_traits::__anon372
Mode	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::Transform::__anon373
Mode	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    Mode =$/;"	e	enum:Eigen::internal::transform_product_result::__anon375
Mode	vcglib/wrap/qt/gl_label.h	/^      Mode()$/;"	f	class:vcg::glLabel::Mode
Mode	vcglib/wrap/qt/gl_label.h	/^      Mode(QFont &_qFont, vcg::Color4b _color, float _angle,bool _rightAlign)$/;"	f	class:vcg::glLabel::Mode
Mode	vcglib/wrap/qt/gl_label.h	/^    class Mode$/;"	c	class:vcg::glLabel
ModifiedTag	vcglib/wrap/dae/colladaformat.h	/^		ModifiedTag()$/;"	f	class:Collada::Tags::ModifiedTag
ModifiedTag	vcglib/wrap/dae/colladaformat.h	/^	class ModifiedTag : public XMLLeafTag\/\/added$/;"	c	namespace:Collada::Tags
ModifierType	vcglib/vcg/complex/algorithms/local_optimization.h	/^enum ModifierType{	TetraEdgeCollapseOp, TriEdgeSwapOp, TriVertexSplitOp,$/;"	g	namespace:vcg
Montecarlo	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void Montecarlo(MetroMesh & m, VertexSampler &ps,int sampleNum)$/;"	f	class:vcg::tri::SurfaceSampling
MontecarloFaceSampling	vcglib/apps/metro/sampling.h	/^void Sampling<MetroMesh>::MontecarloFaceSampling()$/;"	f	class:vcg::Sampling
MontecarloPoisson	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void MontecarloPoisson(MetroMesh & m, VertexSampler &ps,int sampleNum)$/;"	f	class:vcg::tri::SurfaceSampling
MontecarloSHT	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename vcg::SpatialHashTable<VertexType, ScalarType> MontecarloSHT;$/;"	t	class:vcg::tri::SurfaceSampling
MontecarloSHTIterator	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename vcg::SpatialHashTable<VertexType, ScalarType>::CellIterator MontecarloSHTIterator;$/;"	t	class:vcg::tri::SurfaceSampling
MontecarloSampling	vcglib/vcg/complex/algorithms/point_sampling.h	/^void MontecarloSampling(MeshType &m, \/\/ the mesh that has to be sampled$/;"	f	namespace:vcg::tri
MouseDown	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::MouseDown(int x, int y, \/*Button*\/ int button)$/;"	f	class:ActiveCoordinateFrame
MouseDown	vcglib/wrap/gui/trackball.cpp	/^void Trackball::MouseDown(int button) {$/;"	f	class:Trackball
MouseDown	vcglib/wrap/gui/trackball.cpp	/^void Trackball::MouseDown(int x, int y, int button) {$/;"	f	class:Trackball
MouseMove	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::MouseMove(int x, int y)$/;"	f	class:ActiveCoordinateFrame
MouseMove	vcglib/wrap/gui/trackball.cpp	/^void Trackball::MouseMove(int x, int y) {$/;"	f	class:Trackball
MouseUp	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::MouseUp(int x, int y, \/*Button *\/ int button) $/;"	f	class:ActiveCoordinateFrame
MouseUp	vcglib/wrap/gui/trackball.cpp	/^void Trackball::MouseUp(int \/* x *\/, int \/* y *\/, int button) {$/;"	f	class:Trackball
MouseWheel	vcglib/wrap/gui/trackball.cpp	/^void Trackball::MouseWheel(float notch)$/;"	f	class:Trackball
MouseWheel	vcglib/wrap/gui/trackball.cpp	/^void Trackball::MouseWheel(float notch, int button)$/;"	f	class:Trackball
MovableCoordinateFrame	vcglib/wrap/gui/coordinateframe.cpp	/^MovableCoordinateFrame::MovableCoordinateFrame(float size)$/;"	f	class:MovableCoordinateFrame
MovableCoordinateFrame	vcglib/wrap/gui/coordinateframe.h	/^class MovableCoordinateFrame: public CoordinateFrame$/;"	c	namespace:vcg
Move	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::Move(const Similarityf track)$/;"	f	class:ActiveCoordinateFrame
Move	vcglib/wrap/gui/coordinateframe.cpp	/^void MovableCoordinateFrame::Move(const Similarityf track)$/;"	f	class:MovableCoordinateFrame
Move	vcglib/wrap/gui/trackmode.cpp	/^Point3f AreaMode::Move(Point3f start,Point3f end)$/;"	f	class:AreaMode
MoveBack	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  void MoveBack(std::list<FrontEdge>::iterator e) {$/;"	f	class:vcg::tri::AdvancingFront
MoveFront	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  void MoveFront(std::list<FrontEdge>::iterator e) {$/;"	f	class:vcg::tri::AdvancingFront
MoveOuter	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^      MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon422
MoveOuter	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::traits::__anon421
Movie15Parameters	vcglib/wrap/io_trimesh/export_u3d.h	/^		Movie15Parameters()$/;"	f	struct:vcg::tri::io::u3dparametersclasses::Movie15Parameters
Movie15Parameters	vcglib/wrap/io_trimesh/export_u3d.h	/^	struct Movie15Parameters$/;"	s	namespace:vcg::tri::io::u3dparametersclasses
MulCost	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^    MulCost = 1$/;"	e	enum:Eigen::GenericNumTraits::__anon185
MulCost	vcglib/vcg/math/eigen.h	/^		MulCost = 0$/;"	e	enum:Eigen::NumTraits::__anon488
MulCost	vcglib/vcg/math/eigen.h	/^    MulCost = 1$/;"	e	enum:Eigen::NumTraits::__anon486
MulCost	vcglib/vcg/math/eigen.h	/^    MulCost = 1$/;"	e	enum:Eigen::NumTraits::__anon487
MulCost	vcglib/vcg/space/point3.h	/^    MulCost = 3$/;"	e	enum:Eigen::NumTraits::__anon511
MultMatrix	vcglib/vcg/math/shot.h	/^  void MultMatrix(    vcg::Matrix44<S>    m44)$/;"	f	class:vcg::Shot
MultSimilarity	vcglib/vcg/math/shot.h	/^  void MultSimilarity( const Similarity<S> & s){ MultMatrix(s.Matrix());}$/;"	f	class:vcg::Shot
MultiDistanceFromMesh	vcglib/vcg/complex/algorithms/create/resampler.h	/^	field_value MultiDistanceFromMesh(Point3f &pp, Old_Mesh *\/*mesh*\/)$/;"	f	class:vcg::tri::Resampler::Walker
MultiSampleFlag	vcglib/vcg/complex/algorithms/create/resampler.h	/^		bool MultiSampleFlag;$/;"	m	class:vcg::tri::Resampler::Walker
MyAlgorithms	vcg_mesh.cpp	/^namespace MyAlgorithms {$/;"	n	namespace:vcg	file:
MyAlgorithms	vcg_mesh.hpp	/^namespace MyAlgorithms {$/;"	n	namespace:vcg
MyCollapse	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^    MyCollapse(HEdgePointer he, int mark):constructor(he,mark){}$/;"	f	class:MyCollapse
MyCollapse	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^class MyCollapse: public vcg::tri::QuadDiagonalCollapseBase< MyPolyMesh, MyCollapse, CMesh , vcg::tri::VertReg<MyPolyMesh> >$/;"	c	file:
MyCollapseAdaptive	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^    MyCollapseAdaptive(HEdgePointer he, int mark):constructor(he,mark){}$/;"	f	class:MyCollapseAdaptive
MyCollapseAdaptive	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^class MyCollapseAdaptive: public vcg::tri::QuadDiagonalCollapse< MyPolyMesh, MyCollapseAdaptive, CMesh , vcg::tri::VertReg<MyPolyMesh> ,vcg::tri::FitmapsCollapse<MyPolyMesh, CMesh> , vcg::tri::FitmapsCollapse<MyPolyMesh, CMesh> >$/;"	c	file:
MyDelaunayFlip	vcglib/apps/sample/trimesh_hole/trimesh_hole.cpp	/^    inline MyDelaunayFlip(  const TEF::PosType &p, int i,BaseParameterClass *pp) :TEF(p,i,pp){}$/;"	f	class:MyDelaunayFlip
MyDelaunayFlip	vcglib/apps/sample/trimesh_hole/trimesh_hole.cpp	/^class MyDelaunayFlip: public vcg::tri::TriEdgeFlip< MyMesh, MyDelaunayFlip > {$/;"	c	file:
MyEdge	poissonDisk.cpp	/^class MyEdge    : public Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/polygonmesh_zonohedra/polygonmesh_zonohedra.cpp	/^class MyEdge : public vcg::Edge< MyUsedTypes > {};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_base/trimesh_base.cpp	/^class MyEdge    : public vcg::Edge<   MyUsedTypes> {};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^class MyEdge : public vcg::Edge< MyUsedTypes> {};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_curvature/trimesh_curvature.cpp	/^class MyEdge    : public vcg::Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_cylclip/trimesh_cylclip.cpp	/^class MyEdge   : public Edge<MyUsedTypes, edge::BitFlags>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_diskparam/trimesh_diskparam.cpp	/^class MyEdge    : public Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_edge/trimesh_edge.cpp	/^class MyEdge    : public Edge<MyUsedTypes, edge::VertexRef,edge::BitFlags,edge::EEAdj>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_fitting/trimesh_fitting.cpp	/^class MyEdge    : public vcg::Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_geodesic/trimesh_geodesic.cpp	/^class MyEdge    : public Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_inertia/trimesh_inertia.cpp	/^class MyEdge    : public vcg::Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_intersection/trimesh_intersection.cpp	/^class MyEdge    : public Edge< MyUsedTypes, edge::VertexRef, edge::EVAdj> {};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_kdtree/trimesh_kdtree.cpp	/^class MyEdge    : public Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_normal/trimesh_normal.cpp	/^class MyEdge    : public Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_pointcloud_sampling/trimesh_pointcloud_sampling.cpp	/^class MyEdge    : public Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_pointmatching/trimesh_pointmatching.cpp	/^class MyEdge    : public vcg::Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_ray/trimesh_ray.cpp	/^class MyEdge    : public Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_sampling/trimesh_sampling.cpp	/^class MyEdge    : public Edge<MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_voronoi/trimesh_voronoi.cpp	/^class MyEdge    : public Edge< MyUsedTypes, edge::VertexRef, edge::BitFlags>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_voronoiatlas/trimesh_voronoiatlas.cpp	/^class MyEdge    : public Edge< MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_voronoiclustering/trimesh_voronoiclustering.cpp	/^class MyEdge    : public Edge< MyUsedTypes>{};$/;"	c	file:
MyEdge	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^class MyEdge    : public Edge< MyUsedTypes, edge::VertexRef, edge::BitFlags>{};$/;"	c	file:
MyEdge	vcglib/apps/tridecimator/tridecimator.cpp	/^class MyEdge : public Edge< MyUsedTypes> {};$/;"	c	file:
MyEdge	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^class MyEdge : public Edge< MyUsedTypes> {};$/;"	c	file:
MyEdgeMesh	vcglib/apps/sample/trimesh_intersection/trimesh_intersection.cpp	/^class MyEdgeMesh: public tri::TriMesh< vector<MyVertex>, vector<MyEdge> > {};$/;"	c	file:
MyFace	poissonDisk.cpp	/^class MyFace    : public Face< MyUsedTypes, face::VFAdj, face::FFAdj, face::VertexRef, face::BitFlags > {};$/;"	c	file:
MyFace	vcg_mesh.hpp	/^class MyFace : public vcg::Face<MyUsedTypes, vcg::face::VertexRef> { };$/;"	c	namespace:vcg
MyFace	vcglib/apps/plyrefine/main.cpp	/^struct MyFace: public FaceAF<MyVertex,MyEdge,MyFace>{};$/;"	s	file:
MyFace	vcglib/apps/sample/polygonmesh_zonohedra/polygonmesh_zonohedra.cpp	/^class MyFace : public vcg::Face< MyUsedTypes,$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_allocate/trimesh_allocate.cpp	/^class MyFace    : public vcg::Face< MyUsedTypes, vcg::face::VertexRef, vcg::face::Normal3f> {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_attribute/trimesh_attribute.cpp	/^class MyFace    : public vcg::Face< MyUsedTypes, vcg::face::VertexRef, vcg::face::Normal3f> {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_ball_pivoting/trimesh_ball_pivoting.cpp	/^class MyFace    : public Face  < MyUsedTypes, face::VertexRef, face::Normal3f, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_base/trimesh_base.cpp	/^class MyFace    : public vcg::Face<   MyUsedTypes, vcg::face::FFAdj,  vcg::face::VertexRef, vcg::face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_clustering/trimesh_clustering.cpp	/^class MyFace    : public vcg::Face < MyUsedTypes, vcg::face::VertexRef, vcg::face::Normal3f, vcg::face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_color/trimesh_color.cpp	/^class MyFace    : public vcg::Face < MyUsedTypes, vcg::face::VertexRef, vcg::face::Normal3f, vcg::face::Color4b, vcg::face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^class MyFace    : public vcg::Face< MyUsedTypes,$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_curvature/trimesh_curvature.cpp	/^class MyFace    : public vcg::Face< MyUsedTypes, vcg::face::FFAdj,  vcg::face::VertexRef, vcg::face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_cylclip/trimesh_cylclip.cpp	/^class MyFace   : public Face<MyUsedTypes, face::Mark, face::Normal3f, face::FFAdj, face::BitFlags, face::VertexRef, face::Color4b > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_diskparam/trimesh_diskparam.cpp	/^class MyFace    : public Face< MyUsedTypes, face::VertexRef, face::BitFlags, face::FFAdj , face::WedgeTexCoord2f> {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_edge/trimesh_edge.cpp	/^class MyFace    : public Face< MyUsedTypes, face::FFAdj,  face::VertexRef, face::BitFlags >{};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_fitting/trimesh_fitting.cpp	/^class MyFace    : public vcg::Face< MyUsedTypes, vcg::face::FFAdj,  vcg::face::VertexRef, vcg::face::Normal3f, vcg::face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_geodesic/trimesh_geodesic.cpp	/^class MyFace    : public Face< MyUsedTypes, face::FFAdj,  face::VertexRef, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_hole/trimesh_hole.cpp	/^class MyFace    : public Face  < MyUsedTypes, face::VertexRef,face::FFAdj, face::Mark, face::BitFlags, face::Normal3f> {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_inertia/trimesh_inertia.cpp	/^class MyFace    : public vcg::Face< MyUsedTypes, vcg::face::FFAdj, vcg::face::Normal3f, vcg::face::VertexRef, vcg::face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_intersection/trimesh_intersection.cpp	/^class MyFace    : public Face  <MyUsedTypes, face::VertexRef,face::FFAdj, face::BitFlags, face::Normal3f> {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_isosurface/trimesh_isosurface.cpp	/^class MyFace       : public Face< MyUsedTypes, face::VertexRef, face::BitFlags> {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_join/trimesh_join.cpp	/^class MyFace    : public Face   < MyUsedTypes, face::VertexRef, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_kdtree/trimesh_kdtree.cpp	/^class MyFace    : public Face< MyUsedTypes,  face::VertexRef, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_normal/trimesh_normal.cpp	/^class MyFace    : public Face< MyUsedTypes, face::FFAdj,  face::VertexRef, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_optional/trimesh_optional.cpp	/^class MyFace       : public vcg::Face< MyUsedTypes,$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_optional/trimesh_optional_occ.cpp	/^class MyFace: public vcg::FaceSimp2<MyVertex,MyEdge,MyFace,vcg::face::VertexRef>{};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_optional/trimesh_optional_ocf.cpp	/^class MyFace: public vcg::FaceSimp2<MyVertex,MyEdge,MyFace,vcg::face::VertexRef>{};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_optional/trimesh_simpdata_simp.cpp	/^class MyFace: public vcg::FaceSimp2<MyVertex,MyEdge,MyFace, vcg::face::VertexRef>{};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_pointcloud_sampling/trimesh_pointcloud_sampling.cpp	/^class MyFace    : public Face< MyUsedTypes, face::FFAdj,  face::Normal3f, face::VertexRef, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_pointmatching/trimesh_pointmatching.cpp	/^class MyFace    : public vcg::Face< MyUsedTypes, vcg::face::FFAdj,  vcg::face::VertexRef, vcg::face::Normal3f, vcg::face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_pos_demo/trimesh_pos_demo.cpp	/^class MyFace: public vcg::FaceSimp2<MyVertex,MyEdge,MyFace, vcg::face::VertexRef,vcg::face::FFAdj>{};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_pos_demo/trimesh_vfiter_demo.cpp	/^class MyFace: public vcg::FaceSimp2<MyVertex,MyEdge,MyFace, vcg::face::VertexRef,vcg::face::VFAdj>{};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_ray/trimesh_ray.cpp	/^class MyFace    : public Face  <MyUsedTypes, face::VertexRef,face::BitFlags,face::Mark, face::Normal3f> {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_refine/trimesh_refine.cpp	/^class MyFace    : public Face  < MyUsedTypes, face::InfoOcf, face::FFAdjOcf,  face::VertexRef, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_sampling/trimesh_sampling.cpp	/^class MyFace    : public Face< MyUsedTypes, face::FFAdj,  face::Normal3f, face::VertexRef, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_smooth/trimesh_smooth.cpp	/^class MyFace    : public Face  < MyUsedTypes, face::VFAdj, face::Normal3f, face::VertexRef, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_texture/trimesh_texture.cpp	/^class MyFace    : public Face  < MyUsedTypes, face::VertexRef, face::FFAdj, face::WedgeTexCoord2f, face::Mark, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_topology/trimesh_topology.cpp	/^class MyFace    : public Face  < MyUsedTypes, face::VertexRef,face::FFAdj, face::Mark, face::BitFlags > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_voronoi/trimesh_voronoi.cpp	/^class MyFace    : public Face< MyUsedTypes,   face::VertexRef, face::Normal3f, face::Mark, face::BitFlags, face::VFAdj, face::FFAdj > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_voronoiatlas/trimesh_voronoiatlas.cpp	/^class MyFace    : public Face< MyUsedTypes, face::InfoOcf, face::VertexRef, face::BitFlags, face::FFAdjOcf ,face::VFAdj , face::WedgeTexCoord2f> {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_voronoiclustering/trimesh_voronoiclustering.cpp	/^class MyFace    : public Face< MyUsedTypes,   face::VertexRef, face::BitFlags, face::VFAdj > {};$/;"	c	file:
MyFace	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^class MyFace    : public Face< MyUsedTypes,   face::VertexRef, face::Normal3f, face::BitFlags, face::Mark, face::VFAdj, face::FFAdj > {};$/;"	c	file:
MyFace	vcglib/apps/tridecimator/tridecimator.cpp	/^class MyFace    : public Face< MyUsedTypes,$/;"	c	file:
MyFace	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^class MyFace :public FaceAFAV<MyVertex,MyEdge,MyFace>{};$/;"	c	file:
MyFace	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^class MyFace     : public FaceSimp2<  MyVertex,MyEdge,MyFace,face::VertexRef, face::Normal3f,face::BitFlags> {};$/;"	c	file:
MyFace	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^class MyFace    : public Face< MyUsedTypes,$/;"	c	file:
MyFaceC	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^class MyFaceC     : public FaceSimp2< MyVertexC,MyEdge,MyFaceC,face::VertexRef, face::Normal3f,face::BitFlags> {};$/;"	c	file:
MyFaceOcf	vcglib/apps/sample/trimesh_optional/trimesh_optional.cpp	/^class MyFaceOcf    : public vcg::Face< MyUsedTypesOcf,$/;"	c	file:
MyMarchingCubes	vcglib/vcg/complex/algorithms/create/resampler.h	/^typedef vcg::tri::MarchingCubes<New_Mesh, MyWalker> MyMarchingCubes;$/;"	t	class:vcg::tri::Resampler
MyMark	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^MyMarker MyMark;$/;"	v
MyMarker	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^	MyMarker(){mark=0;}$/;"	f	class:MyMarker
MyMarker	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^class MyMarker$/;"	c	file:
MyMesh	poissonDisk.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyFace> , vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcg_mesh.cpp	/^MyMesh::MyMesh() : vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> >()$/;"	f	class:vcg::MyMesh
MyMesh	vcg_mesh.cpp	/^MyMesh::MyMesh(const MyMesh& m){$/;"	f	class:vcg::MyMesh
MyMesh	vcg_mesh.hpp	/^class MyMesh : public vcg::tri::TriMesh$/;"	c	namespace:vcg
MyMesh	vcglib/apps/plyrefine/main.cpp	/^struct MyMesh: public tri::TriMesh< vector<MyVertex>, vector<MyFace> >{};$/;"	s	file:
MyMesh	vcglib/apps/sample/polygonmesh_zonohedra/polygonmesh_zonohedra.cpp	/^class MyMesh : public vcg::tri::TriMesh<std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_allocate/trimesh_allocate.cpp	/^class MyMesh : public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_attribute/trimesh_attribute.cpp	/^class MyMesh : public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_ball_pivoting/trimesh_ball_pivoting.cpp	/^class MyMesh    : public vcg::tri::TriMesh< vector<MyVertex>, vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_base/trimesh_base.cpp	/^class MyMesh    : public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> , std::vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_clustering/trimesh_clustering.cpp	/^class MyMesh    : public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_color/trimesh_color.cpp	/^class MyMesh    : public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^class MyMesh    : public vcg::tri::TriMesh<std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_curvature/trimesh_curvature.cpp	/^class MyMesh    : public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> , std::vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_cylclip/trimesh_cylclip.cpp	/^class MyMesh   : public tri::TriMesh< vector<MyVertex>, vector<MyFace> , vector<MyEdge> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_diskparam/trimesh_diskparam.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyFace> , vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_edge/trimesh_edge.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyFace> , vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_fitting/trimesh_fitting.cpp	/^class MyMesh    : public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> , std::vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_geodesic/trimesh_geodesic.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyFace> , vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_hole/trimesh_hole.cpp	/^class MyMesh : public tri::TriMesh< vector<MyVertex>, vector<MyFace > >{};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_inertia/trimesh_inertia.cpp	/^class MyMesh    : public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> , std::vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_intersection/trimesh_intersection.cpp	/^class MyMesh : public tri::TriMesh< vector<MyVertex>, vector<MyFace > >{};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_isosurface/trimesh_isosurface.cpp	/^class MyMesh		: public vcg::tri::TriMesh< std::vector< MyVertex>, std::vector< MyFace > > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_join/trimesh_join.cpp	/^class MyMesh    : public vcg::tri::TriMesh< vector<MyVertex>, vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_kdtree/trimesh_kdtree.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyFace> , vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_normal/trimesh_normal.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyFace> , vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_optional/trimesh_optional.cpp	/^class MyMesh       : public vcg::tri::TriMesh<     std::vector<MyVertex   >,           std::vector<MyFace   > > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_optional/trimesh_optional_occ.cpp	/^class MyMesh: public vcg::tri::TriMesh< vcg::vert::vector_ocf<MyVertex>, std::vector<MyFace> >{};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_optional/trimesh_optional_ocf.cpp	/^class MyMesh: public vcg::tri::TriMesh< vcg::vert::vector_occ<MyVertex>, std::vector<MyFace> >{};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_optional/trimesh_simpdata_simp.cpp	/^class MyMesh: public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_pointcloud_sampling/trimesh_pointcloud_sampling.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyFace> , vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_pointmatching/trimesh_pointmatching.cpp	/^class MyMesh    : public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> , std::vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_pos_demo/trimesh_pos_demo.cpp	/^class MyMesh: public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_pos_demo/trimesh_vfiter_demo.cpp	/^class MyMesh: public vcg::tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_ray/trimesh_ray.cpp	/^class MyMesh : public tri::TriMesh< vector<MyVertex>, vector<MyFace > >{};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_refine/trimesh_refine.cpp	/^class MyMesh    : public vcg::tri::TriMesh< vector<MyVertex>, face::vector_ocf<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_sampling/trimesh_sampling.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyFace> , vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_smooth/trimesh_smooth.cpp	/^class MyMesh    : public vcg::tri::TriMesh<vector<MyVertex>, vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_texture/trimesh_texture.cpp	/^class MyMesh : public tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace > >{};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_topology/trimesh_topology.cpp	/^class MyMesh : public tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace > >{};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_voronoi/trimesh_voronoi.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyEdge>, vector<MyFace>   > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_voronoiatlas/trimesh_voronoiatlas.cpp	/^class MyMesh    : public tri::TriMesh< vertex::vector_ocf<MyVertex>, face::vector_ocf<MyFace> , vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_voronoiclustering/trimesh_voronoiclustering.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyFace> , vector<MyEdge>  > {};$/;"	c	file:
MyMesh	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^class MyMesh    : public tri::TriMesh< vector<MyVertex>, vector<MyEdge>, vector<MyFace>   > {};$/;"	c	file:
MyMesh	vcglib/apps/tridecimator/tridecimator.cpp	/^class MyMesh    : public vcg::tri::TriMesh<std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^class MyMesh: public tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace > >{};$/;"	c	file:
MyMesh	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^class MyMesh     : public tri::TriMesh< std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMesh	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^class MyMesh    : public vcg::tri::TriMesh<std::vector<MyVertex>, std::vector<MyFace> > {};$/;"	c	file:
MyMeshC	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^class MyMeshC     : public tri::TriMesh< std::vector<MyVertexC>, std::vector<MyFaceC> > {};$/;"	c	file:
MyMeshOcf	vcglib/apps/sample/trimesh_optional/trimesh_optional.cpp	/^class MyMeshOcf : public vcg::tri::TriMesh< vcg::vertex::vector_ocf<MyVertexOcf>, vcg::face::vector_ocf<MyFaceOcf> > {};$/;"	c	file:
MyPolyFace	vcglib/apps/quadrangulator/quadrangulator.cpp	/^class MyPolyFace:public Face<   PolyUsedTypes,$/;"	c	file:
MyPolyFace	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^class MyPolyFace:public vcg::Face<$/;"	c	file:
MyPolyFace	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^class MyPolyFace:public Face<$/;"	c	file:
MyPolyMesh	vcglib/apps/quadrangulator/quadrangulator.cpp	/^class MyPolyMesh: public$/;"	c	file:
MyPolyMesh	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^class MyPolyMesh: public $/;"	c	file:
MyPolyMesh	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^class MyPolyMesh: public tri::TriMesh<$/;"	c	file:
MyPolyVertex	vcglib/apps/quadrangulator/quadrangulator.cpp	/^class MyPolyVertex:public Vertex<	PolyUsedTypes,$/;"	c	file:
MyPolyVertex	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^class MyPolyVertex:public vcg::Vertex<	PolyUsedTypes,$/;"	c	file:
MyPolyVertex	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^class MyPolyVertex:public Vertex<$/;"	c	file:
MyPolygon	vcglib/wrap/dae/poly_triangulator.h	/^		MyPolygon(int n)$/;"	f	class:vcg::tri::io::MyPolygon
MyPolygon	vcglib/wrap/dae/poly_triangulator.h	/^	class MyPolygon $/;"	c	namespace:vcg::tri::io
MySampler	vcg_mesh.hpp	/^    MySampler(MyMesh* _m) : mesh(_m)$/;"	f	class:vcg::MySampler
MySampler	vcg_mesh.hpp	/^class MySampler {$/;"	c	namespace:vcg
MyScalarType	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^typedef double MyScalarType;$/;"	t	file:
MySegmentType	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^	MySegmentType(){}$/;"	f	class:MySegmentType
MySegmentType	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^	MySegmentType(const vcg::Point2<MyScalarType> &_P0,$/;"	f	class:MySegmentType
MySegmentType	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^    MySegmentType(const MySegmentType &s1):vcg::Segment2<MyScalarType>(s1)$/;"	f	class:MySegmentType
MySegmentType	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^class MySegmentType:public vcg::Segment2<MyScalarType>$/;"	c	file:
MyStraightMesh	vcglib/apps/sample/trimesh_pos_demo/mesh_type.h	/^class MyStraightMesh: public vcg::tri::TriMesh< std::vector<StraightVertex>,std::vector<StraightFace> >{};$/;"	c
MyTriEdgeCollapse	vcglib/apps/tridecimator/tridecimator.cpp	/^            inline MyTriEdgeCollapse(  const VertexPair &p, int i, BaseParameterClass *pp) :TECQ(p,i,pp){}$/;"	f	class:MyTriEdgeCollapse
MyTriEdgeCollapse	vcglib/apps/tridecimator/tridecimator.cpp	/^class MyTriEdgeCollapse: public vcg::tri::TriEdgeCollapseQuadric< MyMesh, VertexPair, MyTriEdgeCollapse, QInfoStandard<MyVertex>  > {$/;"	c	file:
MyTriEdgeCollapseQTex	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^            inline MyTriEdgeCollapseQTex(  const VertexPair &p, int i,BaseParameterClass *pp) :TECQ(p,i,pp){}$/;"	f	class:MyTriEdgeCollapseQTex
MyTriEdgeCollapseQTex	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^class MyTriEdgeCollapseQTex: public TriEdgeCollapseQuadricTex< MyMesh, VertexPair, MyTriEdgeCollapseQTex, QuadricTexHelper<MyMesh> > {$/;"	c	file:
MyTypes	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^struct MyTypes: public UsedTypes< Use<CVertex>::AsVertexType,Use<CFace>::AsFaceType>{};$/;"	s	file:
MyUsedTypes	poissonDisk.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcg_mesh.hpp	/^class MyUsedTypes : public vcg::UsedTypes$/;"	c	namespace:vcg
MyUsedTypes	vcglib/apps/quadrangulator/quadrangulator.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<CVertex>::AsVertexType, Use<CFace>::AsFaceType >{};$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^struct MyUsedTypes : public vcg::UsedTypes<	vcg::Use<AVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/polygonmesh_zonohedra/polygonmesh_zonohedra.cpp	/^struct MyUsedTypes: public vcg::UsedTypes<vcg::Use<MyVertex>::AsVertexType,vcg::Use<MyEdge>::AsEdgeType,vcg::Use<MyFace>::AsFaceType>{};$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_QT/glarea.h	/^struct MyUsedTypes : public UsedTypes<	Use<CVertex>		::AsVertexType,$/;"	s
MyUsedTypes	vcglib/apps/sample/trimesh_allocate/trimesh_allocate.cpp	/^struct MyUsedTypes : public vcg::UsedTypes<	vcg::Use<MyVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<CVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_ant_qt/glwidget.h	/^struct MyUsedTypes : public UsedTypes<	Use<CVertex>		::AsVertexType,$/;"	s
MyUsedTypes	vcglib/apps/sample/trimesh_attribute/trimesh_attribute.cpp	/^struct MyUsedTypes : public vcg::UsedTypes<	vcg::Use<MyVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_ball_pivoting/trimesh_ball_pivoting.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_base/trimesh_base.cpp	/^struct MyUsedTypes : public vcg::UsedTypes<vcg::Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_clustering/trimesh_clustering.cpp	/^struct MyUsedTypes : public vcg::UsedTypes<	vcg::Use<MyVertex>::AsVertexType,    vcg::Use<MyFace>::AsFaceType>{};$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_color/trimesh_color.cpp	/^struct MyUsedTypes : public vcg::UsedTypes<	vcg::Use<MyVertex>::AsVertexType,    vcg::Use<MyFace>::AsFaceType>{};$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^struct MyUsedTypes: public vcg::UsedTypes<vcg::Use<MyVertex>::AsVertexType,vcg::Use<MyEdge>::AsEdgeType,vcg::Use<MyFace>::AsFaceType>{};$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_curvature/trimesh_curvature.cpp	/^struct MyUsedTypes : public vcg::UsedTypes<	vcg::Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_cylclip/trimesh_cylclip.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_diskparam/trimesh_diskparam.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_edge/trimesh_edge.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_fitting/trimesh_fitting.cpp	/^struct MyUsedTypes : public vcg::UsedTypes<	vcg::Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_geodesic/trimesh_geodesic.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_hole/trimesh_hole.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_inertia/trimesh_inertia.cpp	/^struct MyUsedTypes : public vcg::UsedTypes<	vcg::Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_intersection/trimesh_intersection.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_isosurface/trimesh_isosurface.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_join/trimesh_join.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_kdtree/trimesh_kdtree.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_normal/trimesh_normal.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_optional/trimesh_optional.cpp	/^struct MyUsedTypes:    public	vcg::UsedTypes<$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_pointcloud_sampling/trimesh_pointcloud_sampling.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_pointmatching/trimesh_pointmatching.cpp	/^struct MyUsedTypes : public vcg::UsedTypes<	vcg::Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_ray/trimesh_ray.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_refine/trimesh_refine.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_sampling/trimesh_sampling.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_smooth/trimesh_smooth.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>::AsVertexType, Use<MyFace>::AsFaceType>{};$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_texture/trimesh_texture.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>::AsVertexType, Use<MyFace>::AsFaceType>{};$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_topology/trimesh_topology.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>::AsVertexType, Use<MyFace>::AsFaceType>{};$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_voronoi/trimesh_voronoi.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_voronoiatlas/trimesh_voronoiatlas.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_voronoiclustering/trimesh_voronoiclustering.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<MyVertex>   ::AsVertexType,$/;"	s	file:
MyUsedTypes	vcglib/apps/tridecimator/tridecimator.cpp	/^struct MyUsedTypes: public UsedTypes<Use<MyVertex>::AsVertexType,Use<MyEdge>::AsEdgeType,Use<MyFace>::AsFaceType>{};$/;"	s	file:
MyUsedTypes	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^struct MyUsedTypes: public UsedTypes<Use<MyVertex>::AsVertexType, Use<MyEdge>::AsEdgeType, Use<MyFace>::AsFaceType>{};$/;"	s	file:
MyUsedTypes	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^struct MyUsedTypes : public UsedTypes<	Use<CVertex>		::AsVertexType,$/;"	s	file:
MyUsedTypesOcf	vcglib/apps/sample/trimesh_optional/trimesh_optional.cpp	/^struct MyUsedTypesOcf: public	vcg::UsedTypes<$/;"	s	file:
MyVertex	poissonDisk.cpp	/^class MyVertex  : public Vertex<MyUsedTypes, vertex::VFAdj, vertex::Coord3f, vertex::Normal3f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcg_mesh.hpp	/^class MyVertex : public vcg::Vertex$/;"	c	namespace:vcg
MyVertex	vcglib/apps/plyrefine/main.cpp	/^struct MyVertex: public VertexAFVNf<MyEdge,MyFace,MyTetra>{};$/;"	s	file:
MyVertex	vcglib/apps/sample/polygonmesh_zonohedra/polygonmesh_zonohedra.cpp	/^class MyVertex : public vcg::Vertex< MyUsedTypes,vcg::vertex::Coord3f,vcg::vertex::BitFlags >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_allocate/trimesh_allocate.cpp	/^class MyVertex  : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f,vcg::vertex::Normal3f>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_attribute/trimesh_attribute.cpp	/^class MyVertex  : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f,vcg::vertex::Normal3f>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_ball_pivoting/trimesh_ball_pivoting.cpp	/^class MyVertex  : public Vertex< MyUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::BitFlags, vertex::Mark>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_base/trimesh_base.cpp	/^class MyVertex  : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_clustering/trimesh_clustering.cpp	/^class MyVertex  : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_color/trimesh_color.cpp	/^class MyVertex  : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::Color4b, vcg::vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^class MyVertex  : public vcg::Vertex< MyUsedTypes,vcg::vertex::VFAdj,vcg::vertex::Coord3f,vcg::vertex::Normal3f,vcg::vertex::Mark,vcg::vertex::BitFlags  >$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_curvature/trimesh_curvature.cpp	/^class MyVertex  : public vcg::Vertex<MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_cylclip/trimesh_cylclip.cpp	/^class MyVertex : public Vertex<MyUsedTypes, vertex::Normal3f, vertex::Coord3f, vertex::BitFlags, vertex::Color4b >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_diskparam/trimesh_diskparam.cpp	/^class MyVertex  : public Vertex<MyUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::TexCoord2f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_edge/trimesh_edge.cpp	/^class MyVertex  : public Vertex<MyUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::Qualityf,vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_fitting/trimesh_fitting.cpp	/^class MyVertex  : public vcg::Vertex<MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_geodesic/trimesh_geodesic.cpp	/^class MyVertex  : public Vertex<MyUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_hole/trimesh_hole.cpp	/^class MyVertex  : public Vertex< MyUsedTypes, vertex::Coord3f, vertex::BitFlags, vertex::Normal3f, vertex::Mark, vertex::Color4b >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_inertia/trimesh_inertia.cpp	/^class MyVertex  : public vcg::Vertex<MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_intersection/trimesh_intersection.cpp	/^class MyVertex  : public Vertex< MyUsedTypes, vertex::Coord3f, vertex::BitFlags, vertex::Normal3f, vertex::Mark>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_isosurface/trimesh_isosurface.cpp	/^class MyVertex     : public Vertex< MyUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::BitFlags>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_join/trimesh_join.cpp	/^class MyVertex  : public Vertex <MyUsedTypes, vertex::Coord3f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_kdtree/trimesh_kdtree.cpp	/^class MyVertex  : public Vertex<MyUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::Qualityf, vertex::Color4b, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_normal/trimesh_normal.cpp	/^class MyVertex  : public Vertex<MyUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_optional/trimesh_optional.cpp	/^class MyVertex     : public vcg::Vertex<	MyUsedTypes,$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_optional/trimesh_optional_occ.cpp	/^class MyVertex: public vcg::VertexSimp2<MyVertex,MyEdge,MyFace, vcg::vert::InfoOcf,vcg::vert::Coord3d, vcg::vert::Normal3fOcf>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_optional/trimesh_optional_ocf.cpp	/^class MyVertex: public vcg::VertexSimp2<MyVertex,MyEdge,MyFace, vcg::vert::InfoOcf,vcg::vert::Coord3d, vcg::vert::Normal3fOcc>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_optional/trimesh_simpdata_simp.cpp	/^class MyVertex: public vcg::VertexSimp2<MyVertex,MyEdge,MyFace, vcg::vert::Coord3d, vcg::vert::Normal3f>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_pointcloud_sampling/trimesh_pointcloud_sampling.cpp	/^class MyVertex  : public Vertex<MyUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_pointmatching/trimesh_pointmatching.cpp	/^class MyVertex  : public vcg::Vertex<MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_pos_demo/trimesh_pos_demo.cpp	/^class MyVertex: public vcg::VertexSimp2<MyVertex,MyEdge,MyFace, vcg::vert::Coord3d, vcg::vert::Normal3f>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_pos_demo/trimesh_vfiter_demo.cpp	/^class MyVertex: public vcg::VertexSimp2<MyVertex,MyEdge,MyFace, vcg::vert::Coord3d, vcg::vert::Normal3f,vcg::vert::VFAdj>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_ray/trimesh_ray.cpp	/^class MyVertex  : public Vertex< MyUsedTypes, vertex::Coord3f, vertex::BitFlags, vertex::Normal3f, vertex::Mark,vertex::Color4b, vertex::Qualityf>{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_refine/trimesh_refine.cpp	/^class MyVertex  : public Vertex< MyUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_sampling/trimesh_sampling.cpp	/^class MyVertex  : public Vertex<MyUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_smooth/trimesh_smooth.cpp	/^class MyVertex  : public Vertex< MyUsedTypes, vertex::VFAdj, vertex::Coord3f, vertex::Normal3f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_texture/trimesh_texture.cpp	/^class MyVertex  : public Vertex< MyUsedTypes, vertex::Coord3f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_topology/trimesh_topology.cpp	/^class MyVertex  : public Vertex< MyUsedTypes, vertex::Coord3f, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_voronoi/trimesh_voronoi.cpp	/^class MyVertex  : public Vertex<MyUsedTypes,  vertex::Coord3f, vertex::Normal3f, vertex::VFAdj, vertex::Qualityf, vertex::Color4b, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_voronoiatlas/trimesh_voronoiatlas.cpp	/^class MyVertex  : public Vertex<MyUsedTypes, vertex::InfoOcf, vertex::Coord3f, vertex::Normal3f, vertex::TexCoord2f, vertex::VFAdj , vertex::Qualityf, vertex::Color4b, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_voronoiclustering/trimesh_voronoiclustering.cpp	/^class MyVertex  : public Vertex<MyUsedTypes,  vertex::Coord3f, vertex::Normal3f, vertex::VFAdj , vertex::Qualityf, vertex::Color4b, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^class MyVertex  : public Vertex<MyUsedTypes,  vertex::Coord3f, vertex::Normal3f, vertex::VFAdj, vertex::Qualityf, vertex::Color4b, vertex::BitFlags  >{};$/;"	c	file:
MyVertex	vcglib/apps/tridecimator/tridecimator.cpp	/^class MyVertex  : public Vertex< MyUsedTypes,$/;"	c	file:
MyVertex	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^class MyVertex:public Vertex<float,MyEdge,MyFace>{};$/;"	c	file:
MyVertex	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^class MyVertex   : public VertexSimp2<MyVertex,MyEdge,MyFace,vert::Coord3f,vert::Normal3f,vert::BitFlags> {};$/;"	c	file:
MyVertex	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^class MyVertex  : public Vertex< MyUsedTypes,$/;"	c	file:
MyVertex0	vcglib/apps/sample/trimesh_base/trimesh_base.cpp	/^class MyVertex0  : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::BitFlags  >{};$/;"	c	file:
MyVertex1	vcglib/apps/sample/trimesh_base/trimesh_base.cpp	/^class MyVertex1  : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Normal3f, vcg::vertex::BitFlags  >{};$/;"	c	file:
MyVertex2	vcglib/apps/sample/trimesh_base/trimesh_base.cpp	/^class MyVertex2  : public vcg::Vertex< MyUsedTypes, vcg::vertex::Coord3f, vcg::vertex::Color4b, vcg::vertex::CurvatureDirf,$/;"	c	file:
MyVertexC	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^class MyVertexC   : public VertexSimp2<MyVertexC,MyEdge,MyFaceC,vert::Coord3f,vert::Color4b,vert::Qualityf,vert::Normal3f,vert::BitFlags> {};$/;"	c	file:
MyVertexOcf	vcglib/apps/sample/trimesh_optional/trimesh_optional.cpp	/^class MyVertexOcf  : public vcg::Vertex< MyUsedTypesOcf,$/;"	c	file:
MyVolume	vcglib/apps/sample/trimesh_isosurface/trimesh_isosurface.cpp	/^typedef SimpleVolume<SimpleVoxel> MyVolume;$/;"	t	file:
MyWalker	vcglib/vcg/complex/algorithms/create/resampler.h	/^typedef Walker  \/*< Old_Mesh,New_Mesh>*\/  MyWalker;$/;"	t	class:vcg::tri::Resampler
N	vcglib/vcg/complex/algorithms/clustering.h	/^  CoordType      N() const {return n;}$/;"	f	class:vcg::tri::AverageColorCell
N	vcglib/vcg/complex/algorithms/clustering.h	/^  CoordType N() const {return bestN;}$/;"	f	class:vcg::tri::NearestToCenter
N	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  vcg::Point3f &N()  { static Point3f _p(0,0,0); return _p;}$/;"	f	class:vcg::SimpleVoxel
N	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  vcg::Point3f &N() {return _n;}$/;"	f	class:vcg::SimpleVoxelWithNormal
N	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  vcg::Point3f N() const {return Point3f(0,0,0);}$/;"	f	class:vcg::SimpleVoxel
N	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  vcg::Point3f N() const {return _n;}$/;"	f	class:vcg::SimpleVoxelWithNormal
N	vcglib/vcg/math/random_generator.h	/^	static const int N = 624;$/;"	m	class:vcg::math::MarsenneTwisterRNG
N	vcglib/vcg/simplex/face/component.h	/^  NormalType &N() { static NormalType dummy_normal(0, 0, 0);  assert(0); return dummy_normal; }$/;"	f	class:vcg::face::EmptyCore
N	vcglib/vcg/simplex/face/component.h	/^  inline NormalType &N() { return _norm; }$/;"	f	class:vcg::face::NormalAbs
N	vcglib/vcg/simplex/face/component_occ.h	/^		InfoType &N() {return CAT< vector_occ<FaceType>,InfoType>::Instance()->Get((FaceType*)this);}$/;"	f	class:vcg::face::InfoOccBase
N	vcglib/vcg/simplex/face/component_occ.h	/^		NormalType &N() {return CAT< vector_occ<FaceType>,NormalType>::Instance()->Get((FaceType*)this);}$/;"	f	class:vcg::face::NormalOcc
N	vcglib/vcg/simplex/face/component_ocf.h	/^  NormalType &N()       {$/;"	f	class:vcg::face::NormalOcf
N	vcglib/vcg/simplex/tetrahedron/component.h	/^	NormalType N(const int & ){ static int dummynormal(0); return dummynormal; }$/;"	f	class:vcg::tetra::EmptyFaceNormal
N	vcglib/vcg/simplex/tetrahedron/component.h	/^	NormalType N(const int & i){  assert((i>=0)&&(i < 4)); return _facenormals[i]; }$/;"	f	class:vcg::tetra::FaceNormal
N	vcglib/vcg/simplex/vertex/component.h	/^  NormalType &N()       { assert(0); static NormalType dummy_normal(0, 0, 0); return dummy_normal; }$/;"	f	class:vcg::vertex::EmptyCore
N	vcglib/vcg/simplex/vertex/component.h	/^  inline       NormalType &N()       { return _norm; }$/;"	f	class:vcg::vertex::Normal
N	vcglib/vcg/simplex/vertex/component.h	/^  inline const NormalType &N() const { return _norm; }$/;"	f	class:vcg::vertex::Normal
N	vcglib/vcg/simplex/vertex/component_occ.h	/^  NormalType &N() {return CAT< vector_occ<VertType>,NormalType>::Instance()->Get((VertType*)this); }$/;"	f	class:vcg::vertex::NormalOcc
N	vcglib/vcg/simplex/vertex/component_ocf.h	/^        NormalType &N()       { assert((*this).Base().NormalEnabled); return (*this).Base().NV[(*this).Index()];  }$/;"	f	class:vcg::vertex::NormalOcf
N	vcglib/vcg/simplex/vertex/component_ocf.h	/^  const NormalType &N() const { assert((*this).Base().NormalEnabled); return (*this).Base().NV[(*this).Index()];  }$/;"	f	class:vcg::vertex::NormalOcf
N	vcglib/vcg/space/texcoord2.h	/^        inline short N() const { return _n[0]; }$/;"	f	class:vcg::TexCoord2
N	vcglib/vcg/space/texcoord2.h	/^        inline short N(const int i) const { assert(i>0 && i<NMAX); return _n[i]; }$/;"	f	class:vcg::TexCoord2
N	vcglib/vcg/space/texcoord2.h	/^    inline short     & N() { return _n[0]; }$/;"	f	class:vcg::TexCoord2
N	vcglib/vcg/space/texcoord2.h	/^    inline short     & N(const int i) { assert(i>0 && i<NMAX); return _n[i]; }$/;"	f	class:vcg::TexCoord2
N	vcglib/vcg/space/texcoord2.h	/^    inline short   N() const { assert(static_n()==0); return 0; }$/;"	f	class:vcg::TexCoord2Simple
N	vcglib/vcg/space/texcoord2.h	/^    inline short   N(const int i) const { (void)i; assert(i==0); return 0; }$/;"	f	class:vcg::TexCoord2Simple
N	vcglib/vcg/space/texcoord2.h	/^    inline short & N()       { assert(static_n()==0); return static_n(); }$/;"	f	class:vcg::TexCoord2Simple
N	vcglib/vcg/space/texcoord2.h	/^    inline short & N(const int i)       { (void)i; assert(i==0); return static_n(); }$/;"	f	class:vcg::TexCoord2Simple
N	vcglib/wrap/opensg/vertex_component.h	/^	CoreType & N() $/;"	f	class:vcg::vert::OSGNormal
N	vcglib/wrap/opensg/vertex_component.h	/^	NormalType & N() { assert(0); return NormalType(); }$/;"	f	class:vcg::vert::EmptyOSGNormal
NColsBlockXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
NEED_GLOBAL_LOCK_INIT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define NEED_GLOBAL_LOCK_INIT$/;"	d	file:
NEWCOMPUTE_INTERVALS	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define NEWCOMPUTE_INTERVALS(/;"	d
NEWCOMPUTE_INTERVALS	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef NEWCOMPUTE_INTERVALS$/;"	d
NMFlat	vcglib/wrap/gl/tetramesh.h	/^	enum NormalMode{NMFlat,NMSmooth, NMUser, NMPerMesh};$/;"	e	enum:vcg::tetra::GLW::NormalMode
NMLast	vcglib/wrap/gl/trimesh.h	/^    enum NormalMode	{NMNone, NMPerVert, NMPerFace, NMPerWedge, NMLast};$/;"	e	enum:vcg::GLW::NormalMode
NMNone	vcglib/wrap/gl/trimesh.h	/^    enum NormalMode	{NMNone, NMPerVert, NMPerFace, NMPerWedge, NMLast};$/;"	e	enum:vcg::GLW::NormalMode
NMPerFace	vcglib/wrap/gl/trimesh.h	/^    enum NormalMode	{NMNone, NMPerVert, NMPerFace, NMPerWedge, NMLast};$/;"	e	enum:vcg::GLW::NormalMode
NMPerMesh	vcglib/wrap/gl/tetramesh.h	/^	enum NormalMode{NMFlat,NMSmooth, NMUser, NMPerMesh};$/;"	e	enum:vcg::tetra::GLW::NormalMode
NMPerVert	vcglib/wrap/gl/trimesh.h	/^    enum NormalMode	{NMNone, NMPerVert, NMPerFace, NMPerWedge, NMLast};$/;"	e	enum:vcg::GLW::NormalMode
NMPerWedge	vcglib/wrap/gl/trimesh.h	/^    enum NormalMode	{NMNone, NMPerVert, NMPerFace, NMPerWedge, NMLast};$/;"	e	enum:vcg::GLW::NormalMode
NMSmooth	vcglib/wrap/gl/tetramesh.h	/^	enum NormalMode{NMFlat,NMSmooth, NMUser, NMPerMesh};$/;"	e	enum:vcg::tetra::GLW::NormalMode
NMUser	vcglib/wrap/gl/tetramesh.h	/^	enum NormalMode{NMFlat,NMSmooth, NMUser, NMPerMesh};$/;"	e	enum:vcg::tetra::GLW::NormalMode
NODE_H	vcglib/apps/trimeshinfo/Node.h	/^#define NODE_H$/;"	d
NOINLINE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define NOINLINE /;"	d	file:
NOINLINE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define NOINLINE$/;"	d	file:
NOMINMAX	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^#define NOMINMAX /;"	d	file:
NONE	vcglib/wrap/dae/poly_triangulator.h	/^		enum PERWEDGEATTRIBUTETYPE {NONE = 0,NORMAL = 1,MULTITEXTURECOORD = 2,MULTICOLOR = 4};$/;"	e	enum:vcg::tri::io::PolygonalMesh::PERWEDGEATTRIBUTETYPE
NON_FLOAT_OR_DOUBLE_TYPE_CompileTimeError	vcglib/img/img_base.h	/^template<> struct NON_FLOAT_OR_DOUBLE_TYPE_CompileTimeError<double> {};$/;"	s
NON_FLOAT_OR_DOUBLE_TYPE_CompileTimeError	vcglib/img/img_base.h	/^template<> struct NON_FLOAT_OR_DOUBLE_TYPE_CompileTimeError<float> {};$/;"	s
NON_TRUE_EXPR_CompileTimeError	vcglib/img/img_base.h	/^template<> struct NON_TRUE_EXPR_CompileTimeError<true> {};$/;"	s
NORMAL	vcglib/wrap/bmt/strip_mesh.h	/^  enum Signature { NORMAL = 1, COLOR = 2, STRIP = 4 };$/;"	e	enum:vcg::StripMesh::Signature
NORMAL	vcglib/wrap/dae/poly_triangulator.h	/^		enum PERWEDGEATTRIBUTETYPE {NONE = 0,NORMAL = 1,MULTITEXTURECOORD = 2,MULTICOLOR = 4};$/;"	e	enum:vcg::tri::io::PolygonalMesh::PERWEDGEATTRIBUTETYPE
NORMAL_EXTRAPOLATION_H	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^#define NORMAL_EXTRAPOLATION_H$/;"	d
NORMAL_PER_FACE	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            NORMAL_PER_FACE     = (1 << 3),$/;"	e	enum:vcg::tri::AttributeSeam::ASMask
NORMAL_PER_VERTEX	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            NORMAL_PER_VERTEX   = (1 << 1),$/;"	e	enum:vcg::tri::AttributeSeam::ASMask
NORMAL_PER_WEDGE	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            NORMAL_PER_WEDGE    = (1 << 2),$/;"	e	enum:vcg::tri::AttributeSeam::ASMask
NORMX	vcglib/vcg/simplex/face/base.h	/^		NORMX				= 0x00000200,$/;"	e	enum:vcg::FaceArityMax::__anon497
NORMY	vcglib/vcg/simplex/face/base.h	/^		NORMY				= 0x00000400,$/;"	e	enum:vcg::FaceArityMax::__anon497
NORMZ	vcglib/vcg/simplex/face/base.h	/^		NORMZ				= 0x00000800,$/;"	e	enum:vcg::FaceArityMax::__anon497
NOTHING	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  enum{ PAIR, AROUND , NOTHING } mode;$/;"	e	enum:vcg::tri::BitQuad::Pos::__anon479
NOTREAD	vcglib/vcg/connectors/hedge.h	/^		NOTREAD    = 0x0002,		\/\/ This bit indicate that the edge of the mesh is not readable$/;"	e	enum:vcg::HEdgeArityMax::__anon484
NOTREAD	vcglib/vcg/simplex/edge/base.h	/^		NOTREAD    = 0x0002,		\/\/ This bit indicate that the edge of the mesh is not readable$/;"	e	enum:vcg::EdgeArityMax::__anon496
NOTREAD	vcglib/vcg/simplex/face/base.h	/^		NOTREAD     = 0x00000002,		\/\/ Face of the mesh is not readable$/;"	e	enum:vcg::FaceArityMax::__anon497
NOTREAD	vcglib/vcg/simplex/tetrahedron/base.h	/^		NOTREAD     = 0x00000002,		\/\/ Face of the mesh is not readable$/;"	e	enum:vcg::TetraArityMax::__anon498
NOTREAD	vcglib/vcg/simplex/vertex/base.h	/^		NOTREAD    = 0x0002,		\/\/ This bit indicate that the vertex of the mesh is not readable$/;"	e	enum:vcg::VertexArityMax::__anon499
NOTWRITE	vcglib/vcg/connectors/hedge.h	/^		NOTWRITE   = 0x0004,		\/\/ This bit indicate that the edge is not modifiable$/;"	e	enum:vcg::HEdgeArityMax::__anon484
NOTWRITE	vcglib/vcg/simplex/edge/base.h	/^		NOTWRITE   = 0x0004,		\/\/ This bit indicate that the edge is not modifiable$/;"	e	enum:vcg::EdgeArityMax::__anon496
NOTWRITE	vcglib/vcg/simplex/face/base.h	/^		NOTWRITE    = 0x00000004,		\/\/ Face of the mesh is not writable$/;"	e	enum:vcg::FaceArityMax::__anon497
NOTWRITE	vcglib/vcg/simplex/tetrahedron/base.h	/^		NOTWRITE    = 0x00000004,		\/\/ Face of the mesh is not writable$/;"	e	enum:vcg::TetraArityMax::__anon498
NOTWRITE	vcglib/vcg/simplex/vertex/base.h	/^		NOTWRITE   = 0x0004,		\/\/ This bit indicate that the vertex is not modifiable$/;"	e	enum:vcg::VertexArityMax::__anon499
NO_CHANNELS	vcglib/vcg/complex/algorithms/update/color.h	/^enum rgbChMask {ALL_CHANNELS = 7, RED_CHANNEL = 4, GREEN_CHANNEL = 2, BLUE_CHANNEL = 1, NO_CHANNELS = 0 };$/;"	e	enum:vcg::tri::UpdateColor::rgbChMask
NO_FLIP	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            enum FlipType { NO_FLIP, CW_FLIP, CCW_FLIP};$/;"	e	enum:vcg::tri::EdgeFlipPriority::FlipType
NO_MALLINFO	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define NO_MALLINFO /;"	d	file:
NO_MALLINFO	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define NO_MALLINFO /;"	d
NO_SAMPLES_PER_FACE	vcglib/apps/metro/metro.cpp	/^#define NO_SAMPLES_PER_FACE /;"	d	file:
NO_SAMPLES_PER_FACE	vcglib/apps/trimeshinfo/defs.h	/^#define NO_SAMPLES_PER_FACE /;"	d
NO_SAMPLES_PER_FACE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define NO_SAMPLES_PER_FACE /;"	d
NO_SAMPLING	vcglib/apps/metro/sampling.h	/^						NO_SAMPLING     			          = 0x0070,$/;"	e	enum:vcg::SamplingFlags::__anon1
NO_SEGMENT_TRAVERSAL	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define NO_SEGMENT_TRAVERSAL /;"	d	file:
NO_STIFF	vcglib/wrap/miq/MIQ.h	/^  enum StiffMode{NO_STIFF = 0,GAUSSIAN = 1,ITERATIVE = 2};$/;"	e	enum:MIQ_parametrization::StiffMode
NRowsBlockXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
NSMALLBINS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define NSMALLBINS /;"	d	file:
NTREEBINS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define NTREEBINS /;"	d	file:
NTSC_RGB	vcglib/vcg/space/colorspace.h	/^		NTSC_RGB = 10,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
NULL	vcglib/img/img_base.h	/^  #define NULL /;"	d
NULL	vcglib/wrap/io_tetramesh/import_ts.h	/^#define NULL /;"	d
NUMBER_DIRECTIONS	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^#define NUMBER_DIRECTIONS /;"	d	file:
NUMERIC_TYPE_MUST_BE_REAL	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        NUMERIC_TYPE_MUST_BE_REAL,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
NV	vcglib/vcg/simplex/face/component_ocf.h	/^  std::vector<typename VALUE_TYPE::NormalType> NV;$/;"	m	class:vcg::face::vector_ocf
NV	vcglib/vcg/simplex/vertex/component_ocf.h	/^  std::vector<typename VALUE_TYPE::NormalType> NV;$/;"	m	class:vcg::vertex::vector_ocf
N_HIST_BINS	vcglib/apps/metro/metro.cpp	/^#define N_HIST_BINS /;"	d	file:
N_HIST_BINS	vcglib/apps/trimeshinfo/defs.h	/^#define N_HIST_BINS /;"	d
N_HIST_BINS	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define N_HIST_BINS /;"	d
N_SAMPLES_EDGE_TO_FACE_RATIO	vcglib/apps/metro/metro.cpp	/^#define N_SAMPLES_EDGE_TO_FACE_RATIO /;"	d	file:
N_SAMPLES_EDGE_TO_FACE_RATIO	vcglib/apps/trimeshinfo/defs.h	/^#define N_SAMPLES_EDGE_TO_FACE_RATIO /;"	d
N_SAMPLES_EDGE_TO_FACE_RATIO	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define N_SAMPLES_EDGE_TO_FACE_RATIO /;"	d
Name	vcglib/vcg/complex/used_types.h	/^    static void Name(std::vector<std::string> & \/*name*\/){}$/;"	f	struct:vcg::DummyTypes
Name	vcglib/vcg/connectors/hedge.h	/^  static void Name(std::vector<std::string> & \/*name*\/){}$/;"	f	class:vcg::HEdgeTypeHolder
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){ T::Name(name);}$/;"	f	class:vcg::hedge::EmptyHFAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){ T::Name(name);}$/;"	f	class:vcg::hedge::EmptyHHAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){ T::Name(name);}$/;"	f	class:vcg::hedge::EmptyHNextAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){ T::Name(name);}$/;"	f	class:vcg::hedge::EmptyHOppAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){ T::Name(name);}$/;"	f	class:vcg::hedge::EmptyHVAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){T::Name(name);}$/;"	f	class:vcg::hedge::EmptyBitFlags
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){T::Name(name);}$/;"	f	class:vcg::hedge::EmptyMark
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("BitFlags"));T::Name(name);}$/;"	f	class:vcg::hedge::BitFlags
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("HFAdj"));T::Name(name);}$/;"	f	class:vcg::hedge::HFAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("HHAdj"));T::Name(name);}$/;"	f	class:vcg::hedge::HHAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("HNextAdj"));T::Name(name);}$/;"	f	class:vcg::hedge::HNextAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("HOppAdj"));T::Name(name);}$/;"	f	class:vcg::hedge::HOppAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("HPrevAdj"));T::Name(name);}$/;"	f	class:vcg::hedge::HPrevAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("HVAdj"));T::Name(name);}$/;"	f	class:vcg::hedge::HVAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("Mark"));T::Name(name);}$/;"	f	class:vcg::hedge::Mark
Name	vcglib/vcg/connectors/hedge_component.h	/^        static void Name(std::vector<std::string> & name){ T::Name(name);}$/;"	f	class:vcg::hedge::EmptyHEAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^        static void Name(std::vector<std::string> & name){name.push_back(std::string("HEAdj"));T::Name(name);}$/;"	f	class:vcg::hedge::HEAdj
Name	vcglib/vcg/connectors/hedge_component.h	/^  static void Name(std::vector<std::string> & name){ T::Name(name);}$/;"	f	class:vcg::hedge::EmptyHPrevAdj
Name	vcglib/vcg/simplex/edge/base.h	/^  static void Name(std::vector<std::string> & \/*name*\/){}$/;"	f	class:vcg::EdgeTypeHolder
Name	vcglib/vcg/simplex/edge/component.h	/^	public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Color4b"));TT::Name(name);}$/;"	f	class:vcg::edge::Color4b
Name	vcglib/vcg/simplex/edge/component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("BitFlags"));T::Name(name);}$/;"	f	class:vcg::edge::BitFlags
Name	vcglib/vcg/simplex/edge/component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("Color"));T::Name(name);}$/;"	f	class:vcg::edge::Color
Name	vcglib/vcg/simplex/edge/component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("EEAdj"));T::Name(name);}$/;"	f	class:vcg::edge::EEAdj
Name	vcglib/vcg/simplex/edge/component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("EHAdj"));T::Name(name);}$/;"	f	class:vcg::edge::EHAdj
Name	vcglib/vcg/simplex/edge/component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("Quality"));TT::Name(name);}$/;"	f	class:vcg::edge::Quality
Name	vcglib/vcg/simplex/edge/component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("VEAdj"));T::Name(name);}$/;"	f	class:vcg::edge::VEAdj
Name	vcglib/vcg/simplex/edge/component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("VertexRef"));T::Name(name);}$/;"	f	class:vcg::edge::VertexRef
Name	vcglib/vcg/simplex/edge/component.h	/^    static void Name(std::vector<std::string> & name){T::Name(name);}$/;"	f	class:vcg::edge::EmptyCore
Name	vcglib/vcg/simplex/edge/component.h	/^    static void Name(std::vector<std::string> & name){name.push_back(std::string("Mark"));T::Name(name);}$/;"	f	class:vcg::edge::Mark
Name	vcglib/vcg/simplex/edge/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("EFAdj"));T::Name(name);}$/;"	f	class:vcg::edge::EFAdj
Name	vcglib/vcg/simplex/edge/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Qualityd"));TT::Name(name);}$/;"	f	class:vcg::edge::Qualityd
Name	vcglib/vcg/simplex/edge/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Qualityf"));TT::Name(name);}$/;"	f	class:vcg::edge::Qualityf
Name	vcglib/vcg/simplex/edge/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Qualitys"));TT::Name(name);}$/;"	f	class:vcg::edge::Qualitys
Name	vcglib/vcg/simplex/face/base.h	/^    static void Name(std::vector<std::string> & \/* name *\/){}$/;"	f	class:vcg::FaceTypeHolder
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){T::Name(name);}$/;"	f	class:vcg::face::EmptyCore
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("BitFlags"));T::Name(name);}$/;"	f	class:vcg::face::BitFlags
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("Color"));T::Name(name);}$/;"	f	class:vcg::face::Color
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDir"));TT::Name(name);}$/;"	f	class:vcg::face::CurvatureDir
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("EFAdj"));T::Name(name);}$/;"	f	class:vcg::face::EFAdj
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("FEAdj"));T::Name(name);}$/;"	f	class:vcg::face::FEAdj
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("FFAdj"));T::Name(name);}$/;"	f	class:vcg::face::FFAdj
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("FHAdj"));T::Name(name);}$/;"	f	class:vcg::face::FHAdj
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("Mark"));T::Name(name);}$/;"	f	class:vcg::face::Mark
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("NormalAbs"));T::Name(name);}$/;"	f	class:vcg::face::NormalAbs
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("Quality"));T::Name(name);}$/;"	f	class:vcg::face::Quality
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("Quality3"));T::Name(name);}$/;"	f	class:vcg::face::Quality3
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("VFAdj"));T::Name(name);}$/;"	f	class:vcg::face::VFAdj
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("VertexRef"));T::Name(name);}$/;"	f	class:vcg::face::VertexRef
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeColor"));T::Name(name);}$/;"	f	class:vcg::face::WedgeColor
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeNormal"));T::Name(name);}$/;"	f	class:vcg::face::WedgeNormal
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeRealNormal"));T::Name(name);}$/;"	f	class:vcg::face::WedgeRealNormal
Name	vcglib/vcg/simplex/face/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeTexCoord"));T::Name(name);}$/;"	f	class:vcg::face::WedgeTexCoord
Name	vcglib/vcg/simplex/face/component.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDird"));T::Name(name);}$/;"	f	class:vcg::face::CurvatureDird
Name	vcglib/vcg/simplex/face/component.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDirf"));T::Name(name);}$/;"	f	class:vcg::face::CurvatureDirf
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3f"));T::Name(name);}$/;"	f	class:vcg::face::Normal3f
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("Quality3d"));T::Name(name);}$/;"	f	class:vcg::face::Quality3d
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("Quality3f"));T::Name(name);}$/;"	f	class:vcg::face::Quality3f
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("Quality3s"));T::Name(name);}$/;"	f	class:vcg::face::Quality3s
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("Qualityd"));T::Name(name);}$/;"	f	class:vcg::face::Qualityd
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("Qualityf"));T::Name(name);}$/;"	f	class:vcg::face::Qualityf
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("Qualitys"));T::Name(name);}$/;"	f	class:vcg::face::Qualitys
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeRealNormal2d"));TT::Name(name);}};$/;"	f	class:vcg::face::WedgeRealNormal3d
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeRealNormal2f"));TT::Name(name);}};$/;"	f	class:vcg::face::WedgeRealNormal3f
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeRealNormal2s"));TT::Name(name);}};$/;"	f	class:vcg::face::WedgeRealNormal3s
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeTexCoord2f"));TT::Name(name);}$/;"	f	class:vcg::face::WedgeTexCoord2f
Name	vcglib/vcg/simplex/face/component.h	/^public:  static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeTexCoord2s"));TT::Name(name);}$/;"	f	class:vcg::face::WedgeTexCoord2s
Name	vcglib/vcg/simplex/face/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Color4b"));T::Name(name);}$/;"	f	class:vcg::face::Color4b
Name	vcglib/vcg/simplex/face/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3d"));T::Name(name);}$/;"	f	class:vcg::face::Normal3d
Name	vcglib/vcg/simplex/face/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeColor4b"));T::Name(name);}$/;"	f	class:vcg::face::WedgeColor4b
Name	vcglib/vcg/simplex/face/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeColor4f"));T::Name(name);}$/;"	f	class:vcg::face::WedgeColor4f
Name	vcglib/vcg/simplex/face/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("WedgeTexCoord2d"));TT::Name(name);}$/;"	f	class:vcg::face::WedgeTexCoord2d
Name	vcglib/vcg/simplex/face/component.h	/^public:static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3s"));T::Name(name);}$/;"	f	class:vcg::face::Normal3s
Name	vcglib/vcg/simplex/face/component_ep.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("EdgePlane"));T::Name(name);}$/;"	f	class:vcg::face::EdgePlane
Name	vcglib/vcg/simplex/face/component_ep.h	/^static void Name(std::vector<std::string> & name){name.push_back(std::string(""));T::Name(name);}$/;"	f	class:vcg::face::EmptyEdgePlane
Name	vcglib/vcg/simplex/face/component_ocf.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDirdOcf"));T::Name(name);}$/;"	f	class:vcg::face::CurvatureDirdOcf
Name	vcglib/vcg/simplex/face/component_ocf.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDirfOcf"));T::Name(name);}$/;"	f	class:vcg::face::CurvatureDirfOcf
Name	vcglib/vcg/simplex/face/component_polygon.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("PFEAdj"));T::Name(name);}$/;"	f	class:vcg::face::PFEAdj
Name	vcglib/vcg/simplex/face/component_polygon.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("PFFAdj"));T::Name(name);}$/;"	f	class:vcg::face::PFFAdj
Name	vcglib/vcg/simplex/face/component_polygon.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("PFHAdj"));T::Name(name);}$/;"	f	class:vcg::face::PFHAdj
Name	vcglib/vcg/simplex/face/component_polygon.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("PFVAdj"));T::Name(name);}$/;"	f	class:vcg::face::PFVAdj
Name	vcglib/vcg/simplex/face/component_polygon.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("PVFAdj"));T::Name(name);}$/;"	f	class:vcg::face::PVFAdj
Name	vcglib/vcg/simplex/tetrahedron/base.h	/^  static void Name(std::vector<std::string> & name){}$/;"	f	class:vcg::TetraTypeHolder
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^	static void Name( std::vector< std::string > & name ) { name.push_back( std::string("VTAdj") ); T::Name(name); }$/;"	f	class:vcg::tetra::VTAdj
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^	static void Name( std::vector< std::string > & name ){ T::Name(name); }$/;"	f	class:vcg::tetra::EmptyAdj
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^	static void Name(std::vector<std::string> & name){T::Name(name);}$/;"	f	class:vcg::tetra::EmptyBitFlags
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^	static void Name(std::vector<std::string> & name){T::Name(name);}$/;"	f	class:vcg::tetra::EmptyFaceNormal
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^	static void Name(std::vector<std::string> & name){T::Name(name);}$/;"	f	class:vcg::tetra::EmptyVertexRef
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("VertexRef"));T::Name(name);}$/;"	f	class:vcg::tetra::VertexRef
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^  static void Name(std::vector<std::string> & name){T::Name(name);}$/;"	f	class:vcg::tetra::EmptyMark
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("BitFlags"));T::Name(name);}$/;"	f	class:vcg::tetra::BitFlags
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("FaceNormal"));T::Name(name);}$/;"	f	class:vcg::tetra::FaceNormal
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("Mark"));T::Name(name);}$/;"	f	class:vcg::tetra::Mark
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("TTAdj"));T::Name(name);}$/;"	f	class:vcg::tetra::TTAdj
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^public:static void Name(std::vector<std::string> & name){name.push_back(std::string("FaceNormal3d"));T::Name(name);} };$/;"	f	class:vcg::tetra::FaceNormal3d
Name	vcglib/vcg/simplex/tetrahedron/component.h	/^public:static void Name(std::vector<std::string> & name){name.push_back(std::string("FaceNormal3f"));T::Name(name);} };$/;"	f	class:vcg::tetra::FaceNormal3f
Name	vcglib/vcg/simplex/vertex/component.h	/^	static void Name( std::vector< std::string > & name ) { name.push_back( std::string("VTAdj") ); T::Name(name); }$/;"	f	class:vcg::vertex::VTAdj
Name	vcglib/vcg/simplex/vertex/component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDir"));TT::Name(name);}$/;"	f	class:vcg::vertex::CurvatureDir
Name	vcglib/vcg/simplex/vertex/component.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("VHAdj"));T::Name(name);}$/;"	f	class:vcg::vertex::VHAdj
Name	vcglib/vcg/simplex/vertex/component.h	/^    public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Color4b"));TT::Name(name);}$/;"	f	class:vcg::vertex::Color4b
Name	vcglib/vcg/simplex/vertex/component.h	/^    static void Name(std::vector<std::string> & name){name.push_back(std::string("Curvature"));TT::Name(name);}$/;"	f	class:vcg::vertex::Curvature
Name	vcglib/vcg/simplex/vertex/component.h	/^    static void Name(std::vector<std::string> & name){name.push_back(std::string("Radius"));TT::Name(name);}$/;"	f	class:vcg::vertex::Radius
Name	vcglib/vcg/simplex/vertex/component.h	/^    static void Name(std::vector<std::string> & name){name.push_back(std::string("TexCoord"));TT::Name(name);}$/;"	f	class:vcg::vertex::TexCoord
Name	vcglib/vcg/simplex/vertex/component.h	/^    static void Name(std::vector<std::string> & name){name.push_back(std::string("VFAdj"));T::Name(name);}$/;"	f	class:vcg::vertex::VFAdj
Name	vcglib/vcg/simplex/vertex/component.h	/^  public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Curvatured"));T::Name(name);}$/;"	f	class:vcg::vertex::Curvatured
Name	vcglib/vcg/simplex/vertex/component.h	/^  public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Curvaturef"));T::Name(name);}$/;"	f	class:vcg::vertex::Curvaturef
Name	vcglib/vcg/simplex/vertex/component.h	/^  static void Name(std::vector<std::string> & name){TT::Name(name);}$/;"	f	class:vcg::vertex::EmptyCore
Name	vcglib/vcg/simplex/vertex/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("BitFlags"));T::Name(name);}$/;"	f	class:vcg::vertex::BitFlags
Name	vcglib/vcg/simplex/vertex/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("Color"));T::Name(name);}$/;"	f	class:vcg::vertex::Color
Name	vcglib/vcg/simplex/vertex/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("Coord"));T::Name(name);}$/;"	f	class:vcg::vertex::Coord
Name	vcglib/vcg/simplex/vertex/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("Mark"));T::Name(name);}$/;"	f	class:vcg::vertex::Mark
Name	vcglib/vcg/simplex/vertex/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal"));T::Name(name);}$/;"	f	class:vcg::vertex::Normal
Name	vcglib/vcg/simplex/vertex/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("Quality"));TT::Name(name);}$/;"	f	class:vcg::vertex::Quality
Name	vcglib/vcg/simplex/vertex/component.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("VEAdj"));T::Name(name);}$/;"	f	class:vcg::vertex::VEAdj
Name	vcglib/vcg/simplex/vertex/component.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Coord3f"));T::Name(name);}$/;"	f	class:vcg::vertex::Coord3f
Name	vcglib/vcg/simplex/vertex/component.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDird"));T::Name(name);}$/;"	f	class:vcg::vertex::CurvatureDird
Name	vcglib/vcg/simplex/vertex/component.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDirf"));T::Name(name);}$/;"	f	class:vcg::vertex::CurvatureDirf
Name	vcglib/vcg/simplex/vertex/component.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3d"));T::Name(name);}$/;"	f	class:vcg::vertex::Normal3d
Name	vcglib/vcg/simplex/vertex/component.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3f"));T::Name(name);}$/;"	f	class:vcg::vertex::Normal3f
Name	vcglib/vcg/simplex/vertex/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Coord3d"));T::Name(name);}$/;"	f	class:vcg::vertex::Coord3d
Name	vcglib/vcg/simplex/vertex/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Qualityd"));TT::Name(name);}$/;"	f	class:vcg::vertex::Qualityd
Name	vcglib/vcg/simplex/vertex/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Qualityf"));TT::Name(name);}$/;"	f	class:vcg::vertex::Qualityf
Name	vcglib/vcg/simplex/vertex/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Qualitys"));TT::Name(name);}$/;"	f	class:vcg::vertex::Qualitys
Name	vcglib/vcg/simplex/vertex/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Radiusf"));TT::Name(name);}$/;"	f	class:vcg::vertex::Radiusf
Name	vcglib/vcg/simplex/vertex/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("TexCoord2d"));TT::Name(name);}$/;"	f	class:vcg::vertex::TexCoord2d
Name	vcglib/vcg/simplex/vertex/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("TexCoord2f"));TT::Name(name);}$/;"	f	class:vcg::vertex::TexCoord2f
Name	vcglib/vcg/simplex/vertex/component.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("TexCoord2s"));TT::Name(name);}$/;"	f	class:vcg::vertex::TexCoord2s
Name	vcglib/vcg/simplex/vertex/component.h	/^public:static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3s"));T::Name(name);}$/;"	f	class:vcg::vertex::Normal3s
Name	vcglib/vcg/simplex/vertex/component_occ.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDir"));TT::Name(name);}$/;"	f	class:vcg::vertex::CurvatureDirOcc
Name	vcglib/vcg/simplex/vertex/component_occ.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureOcc"));TT::Name(name);}$/;"	f	class:vcg::vertex::CurvatureOcc
Name	vcglib/vcg/simplex/vertex/component_occ.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvaturedOcc"));T::Name(name);}$/;"	f	class:vcg::vertex::CurvaturedOcc
Name	vcglib/vcg/simplex/vertex/component_occ.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvaturefOcc"));T::Name(name);}$/;"	f	class:vcg::vertex::CurvaturefOcc
Name	vcglib/vcg/simplex/vertex/component_occ.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("RadiusOcc"));TT::Name(name);}$/;"	f	class:vcg::vertex::RadiusOcc
Name	vcglib/vcg/simplex/vertex/component_occ.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("RadiusdOcc"));T::Name(name);}$/;"	f	class:vcg::vertex::RadiusdOcc
Name	vcglib/vcg/simplex/vertex/component_occ.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("RadiusfOcc"));T::Name(name);}$/;"	f	class:vcg::vertex::RadiusfOcc
Name	vcglib/vcg/simplex/vertex/component_occ.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDird"));T::Name(name);}$/;"	f	class:vcg::vertex::CurvatureDirdOcc
Name	vcglib/vcg/simplex/vertex/component_occ.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDirf"));T::Name(name);}$/;"	f	class:vcg::vertex::CurvatureDirfOcc
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^   static void Name(std::vector<std::string> & name){name.push_back(std::string("VFAdjOcf"));T::Name(name);}$/;"	f	class:vcg::vertex::VFAdjOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDirOcf"));TT::Name(name);}$/;"	f	class:vcg::vertex::CurvatureDirOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("IMark"));T::Name(name);}$/;"	f	class:vcg::vertex::MarkOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^  static void Name(std::vector<std::string> & name){name.push_back(std::string("RadiusOcf")); TT::Name(name);}$/;"	f	class:vcg::vertex::RadiusOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDirdOcf"));T::Name(name);}$/;"	f	class:vcg::vertex::CurvatureDirdOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvatureDirfOcf"));T::Name(name);}$/;"	f	class:vcg::vertex::CurvatureDirfOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Color4bOcf"));T::Name(name);}$/;"	f	class:vcg::vertex::Color4bOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("QualityfOcf"));T::Name(name);}$/;"	f	class:vcg::vertex::QualityfOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^public: static void Name(std::vector<std::string> & name){name.push_back(std::string("TexCoordfOcf"));T::Name(name);}$/;"	f	class:vcg::vertex::TexCoordfOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class CurvaturedOcf: public CurvatureOcf<double, T> {public: static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvaturedOcf"));T::Name(name);} };$/;"	f	class:vcg::vertex::CurvaturedOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class CurvaturefOcf: public CurvatureOcf<float, T> {public: static void Name(std::vector<std::string> & name){name.push_back(std::string("CurvaturefOcf"));T::Name(name);} };$/;"	f	class:vcg::vertex::CurvaturefOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class Normal3dOcf: public NormalOcf<vcg::Point3d, T> {public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3dOcf"));T::Name(name);}};$/;"	f	class:vcg::vertex::Normal3dOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class Normal3fOcf: public NormalOcf<vcg::Point3f, T> {public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3fOcf"));T::Name(name);}};$/;"	f	class:vcg::vertex::Normal3fOcf
Name	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class Normal3sOcf: public NormalOcf<vcg::Point3s, T> {public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3sOcf"));T::Name(name);}};$/;"	f	class:vcg::vertex::Normal3sOcf
Name	vcglib/vcg/simplex/vertex/component_sph.h	/^	public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Sph16d"));T::Name(name);}$/;"	f	class:vcg::vertex::Sph16d
Name	vcglib/vcg/simplex/vertex/component_sph.h	/^	public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Sph16f"));T::Name(name);}$/;"	f	class:vcg::vertex::Sph16f
Name	vcglib/vcg/simplex/vertex/component_sph.h	/^	public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Sph25d"));T::Name(name);}$/;"	f	class:vcg::vertex::Sph25d
Name	vcglib/vcg/simplex/vertex/component_sph.h	/^	public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Sph25f"));T::Name(name);}$/;"	f	class:vcg::vertex::Sph25f
Name	vcglib/vcg/simplex/vertex/component_sph.h	/^	public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Sph36d"));T::Name(name);}$/;"	f	class:vcg::vertex::Sph36d
Name	vcglib/vcg/simplex/vertex/component_sph.h	/^	public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Sph36f"));T::Name(name);}$/;"	f	class:vcg::vertex::Sph36f
Name	vcglib/vcg/simplex/vertex/component_sph.h	/^	public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Sph49f"));T::Name(name);}$/;"	f	class:vcg::vertex::Sph49f
Name	vcglib/vcg/simplex/vertex/component_sph.h	/^	public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Sph9d"));T::Name(name);}$/;"	f	class:vcg::vertex::Sph9d
Name	vcglib/vcg/simplex/vertex/component_sph.h	/^	public:	static void Name(std::vector<std::string> & name){name.push_back(std::string("Sph9f"));T::Name(name);}$/;"	f	class:vcg::vertex::Sph9f
Name	vcglib/vcg/simplex/vertex/component_sph.h	/^	static void Name(std::vector<std::string> & name){name.push_back(std::string("Spherical Harmonics"));T::Name(name);}$/;"	f	class:vcg::vertex::Sph
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::AreaMode
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::AxisMode
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::CylinderMode
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::InactiveMode
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::NavigatorWasdMode
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::PanMode
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::PathMode
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::PolarMode
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::ScaleMode
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::SphereMode
Name	vcglib/wrap/gui/trackmode.h	/^  const char *Name () {$/;"	f	class:vcg::ZMode
Name	vcglib/wrap/gui/trackmode.h	/^  virtual const char *Name (){$/;"	f	class:vcg::TrackMode
Name	vcglib/wrap/gui/trackmode.h	/^ const char *Name () {$/;"	f	class:vcg::PlaneMode
Name	vcglib/wrap/opensg/vertex_component.h	/^	static void Name( std::vector< std::string > & name ) { T::Name(name); }$/;"	f	class:vcg::vert::EmptyOSGColor
Name	vcglib/wrap/opensg/vertex_component.h	/^	static void Name( std::vector< std::string > & name ) { T::Name(name); }$/;"	f	class:vcg::vert::EmptyOSGCoord
Name	vcglib/wrap/opensg/vertex_component.h	/^	static void Name( std::vector< std::string > & name ) { T::Name(name); }$/;"	f	class:vcg::vert::EmptyOSGNormal
Name	vcglib/wrap/opensg/vertex_component.h	/^	static void Name( std::vector< std::string > & name ) { name.push_back( std::string( "OSGColor" ) ); T::Name(name); }$/;"	f	class:vcg::vert::OSGColor
Name	vcglib/wrap/opensg/vertex_component.h	/^	static void Name( std::vector< std::string > & name ) { name.push_back( std::string( "OSGNormal" ) );T::Name(name); }$/;"	f	class:vcg::vert::OSGNormal
Name	vcglib/wrap/opensg/vertex_component.h	/^	static void Name( std::vector< std::string > & name ) { name.push_back( std::string("OSGCoord") ); T::Name(name); }$/;"	f	class:vcg::vert::OSGCoord
Name	vcglib/wrap/opensg/vertex_component.h	/^{ public : static void Name( std::vector< std::string > & name ) { name.push_back( std::string( "OSGCoord3f" ) ); T::Name(name); } };$/;"	f	class:vcg::vert::OSGCoord3f
Name	vcglib/wrap/opensg/vertex_component.h	/^{ public : static void Name( std::vector< std::string > & name ) { name.push_back( std::string( "OSGNormal3f" ) ); T::Name(name); } };$/;"	f	class:vcg::vert::OSGNormal3f
Name	vcglib/wrap/opensg/vertex_component.h	/^{ static void Name( std::vector< std::string > & name ) { name.push_back( std::string( "OSGColor3f" ) ); T::Name(name); } };$/;"	f	class:vcg::vert::OSGColor3f
NavigatorWasdMode	vcglib/wrap/gui/trackmode.cpp	/^NavigatorWasdMode::NavigatorWasdMode() { $/;"	f	class:NavigatorWasdMode
NavigatorWasdMode	vcglib/wrap/gui/trackmode.h	/^class NavigatorWasdMode:public TrackMode {$/;"	c	namespace:vcg
NearestPoint	vcglib/vcg/space/index/space_iterators.h	/^		CoordType NearestPoint()$/;"	f	class:vcg::ClosestIterator
NearestToCenter	vcglib/vcg/complex/algorithms/clustering.h	/^  NearestToCenter(): valid(false){}$/;"	f	class:vcg::tri::NearestToCenter
NearestToCenter	vcglib/vcg/complex/algorithms/clustering.h	/^class  NearestToCenter$/;"	c	namespace:vcg::tri
NeedToConjugate	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex$/;"	e	enum:Eigen::internal::blas_traits::__anon256
NeedToConjugate	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon255
NeedUpdate	vcglib/vcg/complex/allocate.h	/^                bool NeedUpdate() {if((oldBase && newBase!=oldBase && !preventUpdateFlag) || !remap.empty()) return true; else return false;}$/;"	f	class:vcg::tri::Allocator::PointerUpdater
NeedsToAlign	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };$/;"	e	enum:Eigen::PlainObjectBase::__anon190
Neg1_1ToViewportPx	vcglib/vcg/math/camera.h	/^vcg::Point2<S> Camera<S>::Neg1_1ToViewportPx(const vcg::Point2<S> & p) const$/;"	f	class:vcg::Camera
Neigh	vcglib/vcg/simplex/face/component_ocf.h	/^  typename T::FacePointer  &Neigh( const int j )		{ return FFp(j);}$/;"	f	class:vcg::face::FFAdjOcf
Neighbor	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 Neighbor() $/;"	f	struct:vcg::PerfectSpatialHashing::Neighbor
Neighbor	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 Neighbor(ObjectPointer pObject, ScalarType dist, CoordinateType point)$/;"	f	struct:vcg::PerfectSpatialHashing::Neighbor
Neighbor	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		 struct Neighbor$/;"	s	class:vcg::PerfectSpatialHashing
NeighboringEntryIterator	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			NeighboringEntryIterator(const vcg::Point3i &entry, const int table_size)$/;"	f	struct:vcg::PerfectSpatialHashing::NeighboringEntryIterator
NeighboringEntryIterator	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		struct NeighboringEntryIterator$/;"	s	class:vcg::PerfectSpatialHashing
Neighbour	vcglib/vcg/space/index/octree.h	/^            Neighbour()$/;"	f	struct:vcg::Octree::Neighbour
Neighbour	vcglib/vcg/space/index/octree.h	/^            Neighbour(ObjectPointer &object, CoordType &point, ScalarType distance)$/;"	f	struct:vcg::Octree::Neighbour
Neighbour	vcglib/vcg/space/index/octree.h	/^        struct Neighbour$/;"	s	class:vcg::Octree
NeighbourIterator	vcglib/vcg/space/index/octree.h	/^        typedef typename std::vector< Neighbour >::iterator   NeighbourIterator;$/;"	t	class:vcg::Octree
NestByRefBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int NestByRefBit = 0x100;$/;"	m	namespace:Eigen
NestByValue	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline NestByValue(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::NestByValue
NestByValue	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^template<typename ExpressionType> class NestByValue$/;"	c	namespace:Eigen
Nested	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalWrapper Nested;$/;"	t	class:Eigen::DiagonalWrapper
Nested	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef const DiagonalMatrix& Nested;$/;"	t	class:Eigen::DiagonalMatrix
Nested	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef AutoDiffScalar<DerType>& Nested;$/;"	t	struct:Eigen::NumTraits
NestedExpressionType	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::ArrayWrapper
NestedExpressionType	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::MatrixWrapper
New	vcglib/vcg/container/container_allocation_table.h	/^New(){$/;"	f	class:vcg::CAT
NewBitFlag	vcglib/vcg/connectors/hedge.h	/^	static inline int NewBitFlag()$/;"	f	class:vcg::HEdgeArityMax
NewBitFlag	vcglib/vcg/simplex/edge/base.h	/^	static inline int NewBitFlag()$/;"	f	class:vcg::EdgeArityMax
NewBitFlag	vcglib/vcg/simplex/face/base.h	/^	static inline int NewBitFlag()$/;"	f	class:vcg::FaceArityMax
NewBitFlag	vcglib/vcg/simplex/tetrahedron/base.h	/^	static inline int NewBitFlag()$/;"	f	class:vcg::TetraArityMax
NewBitFlag	vcglib/vcg/simplex/vertex/base.h	/^	static inline int NewBitFlag()$/;"	f	class:vcg::VertexArityMax
NewCoordType	vcglib/vcg/complex/algorithms/create/resampler.h	/^		typedef typename New_Mesh::CoordType NewCoordType;$/;"	t	class:vcg::tri::Resampler::Walker
NewInf	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen::internal
NewInf	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen
NewNode	vcglib/vcg/space/index/octree_template.h	/^	NodePointer NewNode(NodePointer parent, int i)$/;"	f	class:vcg::OctreeTemplate
NewParamTag	vcglib/wrap/dae/colladaformat.h	/^		NewParamTag(const QString& sid)$/;"	f	class:Collada::Tags::NewParamTag
NewParamTag	vcglib/wrap/dae/colladaformat.h	/^	class NewParamTag : public XMLTag$/;"	c	namespace:Collada::Tags
NewSup	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen::internal
NewSup	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen
New_Mesh	vcglib/vcg/complex/algorithms/create/resampler.h	/^		typedef  NEW_MESH_TYPE New_Mesh;$/;"	t	class:vcg::tri::Resampler::Walker
New_Mesh	vcglib/vcg/complex/algorithms/create/resampler.h	/^	typedef NEW_MESH_TYPE New_Mesh;$/;"	t	class:vcg::tri::Resampler
Next	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    inline void Next () {$/;"	f	class:vcg::tri::PolychordCollapse::PC_Chords
Next	vcglib/vcg/connectors/hedge_component.h	/^        typename T::HEdgePointer & Next()                       { return this->HNp();}$/;"	f	class:vcg::hedge::HEdgeData
Next	vcglib/vcg/simplex/face/base.h	/^        inline int Next(const int & i) const { return (i+1)%3;}$/;"	f	class:vcg::FaceTypeHolder
Next	vcglib/vcg/simplex/face/component_polygon.h	/^  inline int Next(const int & i){ return (i+1)%VN();}$/;"	f	class:vcg::face::PolyInfo
NextB	vcglib/vcg/simplex/face/pos.h	/^	void NextB( )$/;"	f	class:vcg::face::Pos
NextE	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  Pos NextE()const {return Pos(f, (e+1)%3); }$/;"	f	class:vcg::tri::BitQuad::Pos
NextE	vcglib/vcg/simplex/edge/pos.h	/^	void NextE()$/;"	f	class:vcg::edge::Pos
NextE	vcglib/vcg/simplex/face/pos.h	/^	void NextE()$/;"	f	class:vcg::face::Pos
NextF	vcglib/vcg/simplex/edge/pos.h	/^	void NextF()$/;"	f	class:vcg::edge::VertexStar
NextF	vcglib/vcg/simplex/face/pos.h	/^	void NextF()$/;"	f	class:vcg::face::Pos
NextFE	vcglib/vcg/simplex/face/jumping_pos.h	/^			bool NextFE()$/;"	f	class:vcg::face::JumpingPos
NextSlice	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	void NextSlice() $/;"	f	class:Walker
NextSlice	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    void NextSlice()$/;"	f	class:vcg::tri::TrivialWalker
NextSlice	vcglib/vcg/complex/algorithms/create/resampler.h	/^		void NextSlice()$/;"	f	class:vcg::tri::Resampler::Walker
NextT	vcglib/vcg/simplex/tetrahedron/pos.h	/^	void NextT( )$/;"	f	class:vcg::tetra::Pos
NextT	vcglib/vcg/simplex/tetrahedron/pos.h	/^	void NextT()$/;"	f	class:vcg::tetra::PosJump
NextT	vcglib/vcg/simplex/tetrahedron/pos.h	/^	void NextT()$/;"	f	class:vcg::tetra::PosLoop
NoAlias	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^    NoAlias(ExpressionType& expression) : m_expression(expression) {}$/;"	f	class:Eigen::NoAlias
NoAlias	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^class NoAlias$/;"	c	namespace:Eigen
NoChange	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	e	enum:Eigen::NoChange_t
NoChange_t	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	g	namespace:Eigen
NoConvergence	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  NoConvergence = 2,$/;"	e	enum:Eigen::ComputationInfo
NoDivTriTriIsect	vcglib/vcg/space/intersection/triangle_triangle3.h	/^bool NoDivTriTriIsect(const Point3<T> V0,const Point3<T> V1,const Point3<T> V2,$/;"	f	namespace:vcg
NoError	vcglib/wrap/io_trimesh/import_gts.h	/^				enum GTSCodes {NoError=0, CantOpen, InvalidFile,$/;"	e	enum:vcg::tri::io::ImporterGTS::GTSCodes
NoError	vcglib/wrap/io_trimesh/import_off.h	/^  enum OFFCodes {NoError=0, CantOpen, InvalidFile,$/;"	e	enum:vcg::tri::io::ImporterOFF::OFFCodes
NoPivoting	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  NoPivoting          = 0x02, $/;"	e	enum:Eigen::DecompositionOptions
NoQRPreconditioner	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  NoQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
NoType	vcglib/wrap/glw/bookkeeping.h	/^                                  struct NoType                    {                                                                         };$/;"	s	namespace:glw::detail
NoUnrolling	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  NoUnrolling,$/;"	e	enum:Eigen::__anon261
Node	vcglib/apps/trimeshinfo/Node.h	/^class Node$/;"	c
Node	vcglib/vcg/space/index/kdtree/kdtree.h	/^	struct Node$/;"	s	class:KdTree
Node	vcglib/vcg/space/index/octree_template.h	/^		Node()$/;"	f	struct:vcg::OctreeTemplate::Node
Node	vcglib/vcg/space/index/octree_template.h	/^		Node(NodePointer parent, int level)$/;"	f	struct:vcg::OctreeTemplate::Node
Node	vcglib/vcg/space/index/octree_template.h	/^	struct Node$/;"	s	class:vcg::OctreeTemplate
Node	vcglib/wrap/mt/mt.h	/^  struct Node {  $/;"	s	class:vcg::MT
NodeAuxData	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	typedef NODEAUXDATA NodeAuxData;$/;"	t	class:vcg::AABBBinaryTreeIndex
NodeAuxDataType	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		typedef NODEAUXDATATYPE NodeAuxDataType;$/;"	t	class:vcg::AABBBinaryTree
NodeCount	vcglib/vcg/space/index/octree_template.h	/^	inline int					NodeCount()									const { return int(nodes.size()); }$/;"	f	class:vcg::OctreeTemplate
NodeGroup	vcglib/apps/trimeshinfo/Node.h	/^class NodeGroup :public Node$/;"	c
NodeIndex	vcglib/vcg/space/index/octree.h	/^        typedef typename TemplatedOctree::NodeIndex						NodeIndex;$/;"	t	class:vcg::Octree
NodeIndex	vcglib/vcg/space/index/octree_template.h	/^	typedef	int												NodeIndex;$/;"	t	class:vcg::OctreeTemplate
NodeList	vcglib/vcg/space/index/kdtree/kdtree.h	/^	typedef std::vector<Node> NodeList;$/;"	t	class:KdTree
NodePointer	vcglib/vcg/space/index/octree.h	/^        typedef typename TemplatedOctree::NodePointer 				NodePointer;$/;"	t	class:vcg::Octree
NodePointer	vcglib/vcg/space/index/octree_template.h	/^	typedef NodeType								* NodePointer;$/;"	t	class:vcg::OctreeTemplate
NodeTag	vcglib/wrap/dae/colladaformat.h	/^		NodeTag(const QString& id,const QString& name)$/;"	f	class:Collada::Tags::NodeTag
NodeTag	vcglib/wrap/dae/colladaformat.h	/^	class NodeTag : public XMLTag$/;"	c	namespace:Collada::Tags
NodeType	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		typedef AABBBinaryTreeNode NodeType;$/;"	t	class:vcg::AABBBinaryTree
NodeType	vcglib/vcg/space/index/aabb_binary_tree/closest.h	/^	typedef typename TreeType::NodeType NodeType;$/;"	t	class:vcg::AABBBinaryTreeClosest
NodeType	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	typedef typename TreeType::NodeType NodeType;$/;"	t	class:vcg::AABBBinaryTreeFrustumCull
NodeType	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^	typedef typename TreeType::NodeType NodeType;$/;"	t	class:vcg::AABBBinaryTreeKClosest
NodeType	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^	typedef typename TreeType::NodeType NodeType;$/;"	t	class:vcg::AABBBinaryTreeRay
NodeType	vcglib/vcg/space/index/octree.h	/^        typedef typename TemplatedOctree::NodeType						NodeType;$/;"	t	class:vcg::Octree
NodeType	vcglib/vcg/space/index/octree_template.h	/^	typedef Node											NodeType;$/;"	t	class:vcg::OctreeTemplate
NodeVsFrustum	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	static inline void NodeVsFrustum(NodeType * node, const Point3<ScalarType> & viewerPosition, const VFrustum & f, unsigned char inMask, unsigned int minNodeObjectsCount, NODEAPPLYFUNCTOR & nodeApply) {$/;"	f	class:vcg::AABBBinaryTreeFrustumCull
Noise	vcglib/vcg/math/perlin_noise.h	/^   static double Noise(double x, double y, double z) {$/;"	f	class:vcg::math::Perlin
NonConstImagReturnType	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryView<internal::scalar_imag_ref_op<Scalar>, Derived> NonConstImagReturnType;$/;"	t
NonConstRealReturnType	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type NonConstRealReturnType;$/;"	t
NonCopyable	vcglib/wrap/glw/noncopyable.h	/^		NonCopyable(const ThisType & that)$/;"	f	class:glw::detail::NonCopyable
NonCopyable	vcglib/wrap/glw/noncopyable.h	/^		NonCopyable(void)$/;"	f	class:glw::detail::NonCopyable
NonCopyable	vcglib/wrap/glw/noncopyable.h	/^class NonCopyable$/;"	c	namespace:glw::detail
NonInteger	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::NonInteger NonInteger;$/;"	t	struct:Eigen::internal::random_default_impl
NonInteger	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::NonInteger      NonInteger;$/;"	t	class:Eigen::AlignedBox
NonInteger	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef AutoDiffScalar<DerType> NonInteger;$/;"	t	struct:Eigen::NumTraits
NonSymmetric	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^  NonSymmetric = 0x0$/;"	e	enum:Eigen::__anon458
None	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^    None=0,$/;"	e	enum:vcg::tri::VoronoiProcessingParameter::__anon483
Norm	vcglib/vcg/math/eigen.h	/^inline typename Eigen::ei_traits<Derived1>::Scalar Norm( const Eigen::MatrixBase<Derived1>& p)$/;"	f	namespace:vcg
Norm	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar Norm() const { return norm(); };$/;"	f
Norm	vcglib/vcg/math/matrix33.h	/^ScalarType Norm()$/;"	f	class:vcg::Matrix33
Norm	vcglib/vcg/math/old_matrix33.h	/^	Scalar Norm() { return Base::cwise().abs2().sum(); }$/;"	f	class:vcg::Matrix33
Norm	vcglib/vcg/space/deprecated_point.h	/^	inline S Norm() const {$/;"	f	class:vcg::ndim::Point2
Norm	vcglib/vcg/space/deprecated_point.h	/^	inline S Norm() const {$/;"	f	class:vcg::ndim::Point3
Norm	vcglib/vcg/space/deprecated_point.h	/^	inline S Norm() const {$/;"	f	class:vcg::ndim::Point4
Norm	vcglib/vcg/space/deprecated_point.h	/^	template <class PT> static S Norm(const PT &p ) {$/;"	f	class:vcg::ndim::Point2
Norm	vcglib/vcg/space/deprecated_point.h	/^	template <class PT> static S Norm(const PT &p ) {$/;"	f	class:vcg::ndim::Point3
Norm	vcglib/vcg/space/deprecated_point.h	/^	template <class PT> static S Norm(const PT &p ) {$/;"	f	class:vcg::ndim::Point4
Norm	vcglib/vcg/space/deprecated_point.h	/^inline S Norm( Point<N,S> const & p )$/;"	f	namespace:vcg::ndim
Norm	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType Norm( void ) const$/;"	f	class:vcg::Point2
Norm	vcglib/vcg/space/deprecated_point2.h	/^inline T Norm( Point2<T> const & p ){$/;"	f	namespace:vcg
Norm	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType Norm() const$/;"	f	class:vcg::Point3
Norm	vcglib/vcg/space/deprecated_point3.h	/^inline P3ScalarType Norm( Point3<P3ScalarType> const & p )$/;"	f	namespace:vcg
Norm	vcglib/vcg/space/deprecated_point4.h	/^    inline T Norm() const$/;"	f	class:vcg::Point4
Norm	vcglib/vcg/space/deprecated_point4.h	/^inline T Norm( const Point4<T> & p )$/;"	f	namespace:vcg
NormDevCoordToWindowCoord	vcglib/wrap/gui/view.h	/^template <class T> Point3<T> View<T>::NormDevCoordToWindowCoord(const Point3<T> &p) const {$/;"	f	class:vcg::View
NormInfinity	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar NormInfinity() const { return derived().cwise().abs().maxCoeff(); }$/;"	f
NormInfinity	vcglib/vcg/space/deprecated_point.h	/^	inline S NormInfinity() const {$/;"	f	class:vcg::ndim::Point2
NormInfinity	vcglib/vcg/space/deprecated_point.h	/^	inline S NormInfinity() const {$/;"	f	class:vcg::ndim::Point3
NormInfinity	vcglib/vcg/space/deprecated_point.h	/^	inline S NormInfinity() const {$/;"	f	class:vcg::ndim::Point4
NormOne	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar NormOne() const { return derived().cwise().abs().sum(); }$/;"	f
NormOne	vcglib/vcg/space/deprecated_point.h	/^	inline S NormOne() const {$/;"	f	class:vcg::ndim::Point2
NormOne	vcglib/vcg/space/deprecated_point.h	/^	inline S NormOne() const {$/;"	f	class:vcg::ndim::Point3
NormOne	vcglib/vcg/space/deprecated_point.h	/^	inline S NormOne() const {$/;"	f	class:vcg::ndim::Point4
Normal	vcglib/vcg/simplex/vertex/component.h	/^template <class A, class T> class Normal: public T {$/;"	c	namespace:vcg::vertex
Normal	vcglib/vcg/space/tetra3.h	/^Point3<typename TetraType::ScalarType> Normal( const TetraType &t,const int &face)$/;"	f	namespace:vcg
Normal	vcglib/vcg/space/triangle3.h	/^Point3<typename TriangleType::ScalarType> Normal(const TriangleType &t)$/;"	f	namespace:vcg
Normal	vcglib/vcg/space/triangle3.h	/^Point3Type Normal( Point3Type const &p0, Point3Type const & p1,  Point3Type const & p2)$/;"	f	namespace:vcg
Normal3d	vcglib/vcg/simplex/face/component.h	/^template <class T> class Normal3d: public NormalAbs<vcg::Point3d, T> {$/;"	c	namespace:vcg::face
Normal3d	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class Normal3d: public Normal<vcg::Point3d, T> {$/;"	c	namespace:vcg::vertex
Normal3dOcc	vcglib/vcg/simplex/face/component_occ.h	/^	template <class T> class Normal3dOcc: public NormalOcc<vcg::Point3d, T> {};$/;"	c	namespace:vcg::face
Normal3dOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class Normal3dOcc: public NormalOcc<vcg::Point3d, T> {};$/;"	c	namespace:vcg::vertex
Normal3dOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class Normal3dOcf: public NormalOcf<vcg::Point3d, T> {};$/;"	c	namespace:vcg::face
Normal3dOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class Normal3dOcf: public NormalOcf<vcg::Point3d, T> {public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3dOcf"));T::Name(name);}};$/;"	c	namespace:vcg::vertex
Normal3f	vcglib/vcg/simplex/face/component.h	/^template <class T> class Normal3f: public NormalAbs<vcg::Point3f, T> {$/;"	c	namespace:vcg::face
Normal3f	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class Normal3f: public Normal<vcg::Point3f, T> {$/;"	c	namespace:vcg::vertex
Normal3fOcc	vcglib/vcg/simplex/face/component_occ.h	/^	template <class T> class Normal3fOcc: public NormalOcc<vcg::Point3f, T> {};$/;"	c	namespace:vcg::face
Normal3fOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class Normal3fOcc: public NormalOcc<vcg::Point3f, T> {};$/;"	c	namespace:vcg::vertex
Normal3fOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class Normal3fOcf: public NormalOcf<vcg::Point3f, T> {};$/;"	c	namespace:vcg::face
Normal3fOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class Normal3fOcf: public NormalOcf<vcg::Point3f, T> {public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3fOcf"));T::Name(name);}};$/;"	c	namespace:vcg::vertex
Normal3s	vcglib/vcg/simplex/face/component.h	/^template <class T> class Normal3s: public NormalAbs<vcg::Point3s, T> {$/;"	c	namespace:vcg::face
Normal3s	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class Normal3s: public Normal<vcg::Point3s, T> {$/;"	c	namespace:vcg::vertex
Normal3sOcc	vcglib/vcg/simplex/face/component_occ.h	/^	template <class T> class Normal3sOcc: public NormalOcc<vcg::Point3s, T> {};$/;"	c	namespace:vcg::face
Normal3sOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class Normal3sOcc: public NormalOcc<vcg::Point3s, T> {};$/;"	c	namespace:vcg::vertex
Normal3sOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class Normal3sOcf: public NormalOcf<vcg::Point3s, T> {};$/;"	c	namespace:vcg::face
Normal3sOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class Normal3sOcf: public NormalOcf<vcg::Point3s, T> {public: static void Name(std::vector<std::string> & name){name.push_back(std::string("Normal3sOcf"));T::Name(name);}};$/;"	c	namespace:vcg::vertex
NormalAbs	vcglib/vcg/simplex/face/component.h	/^template <class A, class T> class NormalAbs: public T {$/;"	c	namespace:vcg::face
NormalCheck	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      NormalCheck;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
NormalCheck	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  bool    NormalCheck;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
NormalEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  bool NormalEnabled;$/;"	m	class:vcg::face::vector_ocf
NormalEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  bool NormalEnabled;$/;"	m	class:vcg::vertex::vector_ocf
NormalMode	vcglib/wrap/gl/tetramesh.h	/^	enum NormalMode{NMFlat,NMSmooth, NMUser, NMPerMesh};$/;"	g	class:vcg::tetra::GLW
NormalMode	vcglib/wrap/gl/trimesh.h	/^    enum NormalMode	{NMNone, NMPerVert, NMPerFace, NMPerWedge, NMLast};$/;"	g	class:vcg::GLW
NormalOcc	vcglib/vcg/simplex/face/component_occ.h	/^	template <class A, class T> class NormalOcc: public T {$/;"	c	namespace:vcg::face
NormalOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class A, class T> class NormalOcc: public T {$/;"	c	namespace:vcg::vertex
NormalOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class A, class T> class NormalOcf: public T {$/;"	c	namespace:vcg::face
NormalOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class A, class T> class NormalOcf: public T {$/;"	c	namespace:vcg::vertex
NormalReturnType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane
NormalReturnType	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane
NormalTest	vcglib/apps/sample/trimesh_hole/trimesh_hole.cpp	/^bool NormalTest(typename face::Pos<typename MESH::FaceType> pos)$/;"	f
NormalThrRad	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  double    NormalThrRad;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
NormalThrRad	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  double	  NormalThrRad;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
NormalType	vcg_mesh.hpp	/^    typedef vcg::Point3f NormalType;$/;"	t	class:vcg::MyMesh
NormalType	vcglib/vcg/complex/algorithms/update/normal.h	/^typedef typename VertexType::NormalType     NormalType;$/;"	t	class:vcg::tri::UpdateNormal
NormalType	vcglib/vcg/simplex/face/component.h	/^  typedef A NormalType;$/;"	t	class:vcg::face::NormalAbs
NormalType	vcglib/vcg/simplex/face/component.h	/^  typedef A NormalType;$/;"	t	class:vcg::face::WedgeRealNormal
NormalType	vcglib/vcg/simplex/face/component.h	/^  typedef typename T::VertexType::NormalType NormalType;$/;"	t	class:vcg::face::EmptyCore
NormalType	vcglib/vcg/simplex/face/component.h	/^  typedef typename T::VertexType::NormalType NormalType;$/;"	t	class:vcg::face::WedgeNormal
NormalType	vcglib/vcg/simplex/face/component_occ.h	/^		typedef A NormalType;$/;"	t	class:vcg::face::NormalOcc
NormalType	vcglib/vcg/simplex/face/component_ocf.h	/^  typedef A NormalType;$/;"	t	class:vcg::face::NormalOcf
NormalType	vcglib/vcg/simplex/face/component_ocf.h	/^  typedef A NormalType;$/;"	t	class:vcg::face::WedgeNormalOcf
NormalType	vcglib/vcg/simplex/tetrahedron/component.h	/^	typedef ::vcg::Point3<A> NormalType;$/;"	t	class:vcg::tetra::EmptyFaceNormal
NormalType	vcglib/vcg/simplex/tetrahedron/component.h	/^	typedef ::vcg::Point3<A> NormalType;$/;"	t	class:vcg::tetra::FaceNormal
NormalType	vcglib/vcg/simplex/vertex/component.h	/^  typedef A NormalType;$/;"	t	class:vcg::vertex::Normal
NormalType	vcglib/vcg/simplex/vertex/component.h	/^  typedef vcg::Point3s NormalType;$/;"	t	class:vcg::vertex::EmptyCore
NormalType	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef A NormalType;$/;"	t	class:vcg::vertex::NormalOcc
NormalType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef A NormalType;$/;"	t	class:vcg::vertex::NormalOcf
NormalType	vcglib/wrap/opensg/vertex_component.h	/^	typedef A NormalType;														\/\/\/ Must be a OSG::Vec3 type as : OSG::Vec3s, OSG:Vec3f, OSG::Vec3d etc...$/;"	t	class:vcg::vert::OSGNormal
NormalType	vcglib/wrap/opensg/vertex_component.h	/^	typedef OSG::Vec3f NormalType;$/;"	t	class:vcg::vert::EmptyOSGNormal
NormalType	vcglib/wrap/opensg/vertex_component.h	/^	typedef T NormalType;$/;"	t	class:vcg::vert::OSGNormalCore
Normalize	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Derived& Normalize() { normalize(); return derived(); };$/;"	f
Normalize	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline const PlainMatrixType Normalize() const { return normalized(); };$/;"	f
Normalize	vcglib/vcg/space/box2.h	/^	inline void Normalize( PointType & p )$/;"	f	class:vcg::Box2
Normalize	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 & Normalize() {$/;"	f	class:vcg::ndim::Point2
Normalize	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & Normalize() {$/;"	f	class:vcg::ndim::Point3
Normalize	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & Normalize() {$/;"	f	class:vcg::ndim::Point4
Normalize	vcglib/vcg/space/deprecated_point.h	/^	template <class PT>  PointType & Normalize(const PT &p){$/;"	f	class:vcg::ndim::Point4
Normalize	vcglib/vcg/space/deprecated_point.h	/^inline Point<N,S> & Normalize( Point<N,S> & p )$/;"	f	namespace:vcg::ndim
Normalize	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 & Normalize( void )$/;"	f	class:vcg::Point2
Normalize	vcglib/vcg/space/deprecated_point2.h	/^inline Point2<T> & Normalize( Point2<T> & p ){$/;"	f	namespace:vcg
Normalize	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 & Normalize()$/;"	f	class:vcg::Point3
Normalize	vcglib/vcg/space/deprecated_point3.h	/^inline Point3<P3ScalarType> & Normalize( Point3<P3ScalarType> & p )$/;"	f	namespace:vcg
Normalize	vcglib/vcg/space/deprecated_point4.h	/^  inline Point4 & Normalize()$/;"	f	class:vcg::Point4
Normalize	vcglib/vcg/space/line2.h	/^	inline Line2<ScalarType,true> &Normalize()$/;"	f	class:vcg::Line2
Normalize	vcglib/vcg/space/line2.h	/^	static Line2<ScalarType,true> &Normalize(LineType &p)$/;"	f	class:vcg::Line2
Normalize	vcglib/vcg/space/line3.h	/^	inline Line3<ScalarType,true> &Normalize()$/;"	f	class:vcg::Line3
Normalize	vcglib/vcg/space/line3.h	/^	static Line3<ScalarType,true> &Normalize(LineType &p)$/;"	f	class:vcg::Line3
Normalize	vcglib/vcg/space/plane3.h	/^  void Normalize() {$/;"	f	class:vcg::Plane3
Normalize	vcglib/vcg/space/ray2.h	/^	inline Ray2<ScalarType,true> &Normalize()$/;"	f	class:vcg::Ray2
Normalize	vcglib/vcg/space/ray2.h	/^	static Ray2<ScalarType,true> &Normalize(RayType &p)$/;"	f	class:vcg::Ray2
Normalize	vcglib/vcg/space/ray3.h	/^	inline Ray3<ScalarType,true> &Normalize()$/;"	f	class:vcg::Ray3
Normalize	vcglib/vcg/space/ray3.h	/^	static Ray3<ScalarType,true> &Normalize(RayType &p)$/;"	f	class:vcg::Ray3
Normalize	vcglib/wrap/gui/trackmode.cpp	/^float PathMode::Normalize(float state)$/;"	f	class:PathMode
NormalizePerFace	vcglib/vcg/complex/algorithms/update/normal.h	/^static void NormalizePerFace(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
NormalizePerFaceByArea	vcglib/vcg/complex/algorithms/update/normal.h	/^static void NormalizePerFaceByArea(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
NormalizePerVertex	vcglib/vcg/complex/algorithms/update/normal.h	/^static void NormalizePerVertex(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
NormalizedDirection	vcglib/vcg/space/segment3.h	/^	inline PointType NormalizedDirection( ) const$/;"	f	class:vcg::Segment3
NormalizedNormal	vcglib/vcg/space/triangle3.h	/^Point3<typename TriangleType::ScalarType> NormalizedNormal(const TriangleType &t)$/;"	f	namespace:vcg
NormalizedNormal	vcglib/vcg/space/triangle3.h	/^Point3Type NormalizedNormal( Point3Type const &p0, Point3Type const & p1,  Point3Type const & p2)$/;"	f	namespace:vcg
NotMakingProgressIterations	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        NotMakingProgressIterations = 5,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
NotMakingProgressJacobian	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        NotMakingProgressJacobian = 4,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
NotStarted	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        NotStarted = -2,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
Nring	vcglib/vcg/complex/algorithms/nring.h	/^    Nring(VertexType* v, MeshType* m) : m(m)$/;"	f	class:vcg::tri::Nring
Nring	vcglib/vcg/complex/algorithms/nring.h	/^class Nring$/;"	c	namespace:vcg::tri
Ns	vcglib/wrap/io_trimesh/io_material.h	/^		float Ns;$/;"	m	struct:vcg::tri::io::Material
NullaryExpr	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NullaryExpr	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index size, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NullaryExpr	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NumFlips	vcglib/wrap/miq/core/param_stats.h	/^int NumFlips(MeshType &Tmesh)$/;"	f
NumOfDerivativesAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { NumOfDerivativesAtCompileTime = OrderAtCompileTime \/*!< The number of derivatives defined for the current spline. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon469
NumOfDerivativesAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { NumOfDerivativesAtCompileTime = _DerivativeOrder==Dynamic ? Dynamic : _DerivativeOrder+1 \/*!< The number of derivatives defined for the current spline. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon471
NumTraits	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^template<typename DerType> struct NumTraits<AutoDiffScalar<DerType> >$/;"	s	namespace:Eigen
NumTraits	vcglib/vcg/math/eigen.h	/^template<> struct NumTraits<short int>$/;"	s	namespace:Eigen
NumTraits	vcglib/vcg/math/eigen.h	/^template<> struct NumTraits<unsigned char>$/;"	s	namespace:Eigen
NumTraits	vcglib/vcg/math/eigen.h	/^template<typename T> struct NumTraits$/;"	s	namespace:Eigen
NumTraits	vcglib/vcg/space/point3.h	/^struct NumTraits<vcg::Point3<Scalar> > : NumTraits<Scalar>$/;"	s	namespace:Eigen
NumberOfFacesOnEdge	vcglib/vcg/simplex/face/pos.h	/^  int NumberOfFacesOnEdge() const$/;"	f	class:vcg::face::Pos
NumberOfIncidentFaces	vcglib/vcg/simplex/face/pos.h	/^	int NumberOfIncidentFaces()$/;"	f	class:vcg::face::Pos
NumberOfIncidentVertices	vcglib/vcg/simplex/face/pos.h	/^	int NumberOfIncidentVertices()$/;"	f	class:vcg::face::Pos
NumberOfRegisters	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
NumberOfRegisters	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
NumberOfRegisters	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
NumericalDiff	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^        NumericalDiff(const T0& a0) : Functor(a0), epsfcn(0) {}$/;"	f	class:Eigen::NumericalDiff
NumericalDiff	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^        NumericalDiff(const T0& a0, const T1& a1) : Functor(a0, a1), epsfcn(0) {}$/;"	f	class:Eigen::NumericalDiff
NumericalDiff	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^        NumericalDiff(const T0& a0, const T1& a1, const T2& a2) : Functor(a0, a1, a2), epsfcn(0) {}$/;"	f	class:Eigen::NumericalDiff
NumericalDiff	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    NumericalDiff(Scalar _epsfcn=0.) : Functor(), epsfcn(_epsfcn) {}$/;"	f	class:Eigen::NumericalDiff
NumericalDiff	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    NumericalDiff(const Functor& f, Scalar _epsfcn=0.) : Functor(f), epsfcn(_epsfcn) {}$/;"	f	class:Eigen::NumericalDiff
NumericalDiff	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^class NumericalDiff : public _Functor$/;"	c	namespace:Eigen
NumericalDiffMode	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^enum NumericalDiffMode {$/;"	g	namespace:Eigen
NumericalIssue	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  NumericalIssue = 1, $/;"	e	enum:Eigen::ComputationInfo
OBJECTS	Makefile	/^OBJECTS    = $(SOURCES:.cpp=.o)$/;"	m
OBJError	vcglib/wrap/io_trimesh/import_obj.h	/^                enum OBJError {$/;"	g	class:vcg::tri::io::ImporterOBJ
OFD	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	static int OFD(){static int ofd=0; return ofd++;}$/;"	f	struct:FAIL
OFF	vcglib/wrap/gui/trackrecorder.h	/^	enum { PLAY,REC,OFF } mode;$/;"	e	enum:vcg::TrackRecorder::__anon521
OFFCodes	vcglib/wrap/io_trimesh/import_off.h	/^  enum OFFCodes {NoError=0, CantOpen, InvalidFile,$/;"	g	class:vcg::tri::io::ImporterOFF
OMV	vcglib/apps/unsupported/shadevis/visshader.h	/^  std::vector<MESH_TYPE *> OMV;  \/\/ Occluder Mesh Vector;$/;"	m	class:vcg::VisShader
ONE_QUAD_X_EDGE	vcglib/apps/sample/trimesh_refine/trimesh_refine.cpp	/^#define ONE_QUAD_X_EDGE /;"	d	file:
ONLY_MSPACES	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ONLY_MSPACES /;"	d	file:
ONLY_MSPACES	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define ONLY_MSPACES /;"	d
ONLY_SEL	vcglib/apps/plyrefine/main.cpp	/^#define ONLY_SEL /;"	d	file:
OPTION	vcglib/wrap/system/qgetopt.h	/^    enum Type { SWITCH, OPTION, ARGUMENT, OPTIONAL };$/;"	e	enum:GetOpt::Option::Type
OPTIONAL	vcglib/wrap/system/qgetopt.h	/^    enum Type { SWITCH, OPTION, ARGUMENT, OPTIONAL };$/;"	e	enum:GetOpt::Option::Type
ORTHO	vcglib/vcg/math/camera.h	/^        ORTHO       =	1,$/;"	e	enum:vcg::Camera::__anon485
OSGColor	vcglib/wrap/opensg/vertex_component.h	/^	OSGColor() { _corep = NULL; }$/;"	f	class:vcg::vert::OSGColor
OSGColor	vcglib/wrap/opensg/vertex_component.h	/^template< class A, class T > class OSGColor : public T $/;"	c	namespace:vcg::vert
OSGColor3f	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class OSGColor3f : public OSGColor< OSG::Color3f, T > $/;"	c	namespace:vcg::vert
OSGColorCore	vcglib/wrap/opensg/vertex_component.h	/^	OSGColorCore( OSG::GeometryPtr p, int i ) { _geopointer = p; _vertexindex = i; }$/;"	f	class:vcg::vert::OSGColorCore
OSGColorCore	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class OSGColorCore$/;"	c	namespace:vcg::vert
OSGColorCore3f	vcglib/wrap/opensg/vertex_component.h	/^class OSGColorCore3f : public OSGColorCore< OSG::Color3f > {};$/;"	c	namespace:vcg::vert
OSGCoord	vcglib/wrap/opensg/vertex_component.h	/^	OSGCoord() { _corep = NULL; }$/;"	f	class:vcg::vert::OSGCoord
OSGCoord	vcglib/wrap/opensg/vertex_component.h	/^template< class A, class T > class OSGCoord : public T $/;"	c	namespace:vcg::vert
OSGCoord3f	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class OSGCoord3f : public OSGCoord< OSG::Pnt3f, T > $/;"	c	namespace:vcg::vert
OSGCoordCore	vcglib/wrap/opensg/vertex_component.h	/^	OSGCoordCore( OSG::GeometryPtr p, int i ) { _geopointer = p; _vertexindex = i; }$/;"	f	class:vcg::vert::OSGCoordCore
OSGCoordCore	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class OSGCoordCore$/;"	c	namespace:vcg::vert
OSGCoordCore3f	vcglib/wrap/opensg/vertex_component.h	/^class OSGCoordCore3f : public OSGCoordCore< OSG::Pnt3f > {};$/;"	c	namespace:vcg::vert
OSGInfo	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class OSGInfo : public T $/;"	c	namespace:vcg::vert
OSGNormal	vcglib/wrap/opensg/vertex_component.h	/^	OSGNormal() { _corep = NULL; }$/;"	f	class:vcg::vert::OSGNormal
OSGNormal	vcglib/wrap/opensg/vertex_component.h	/^template< class A, class T > class OSGNormal : public T $/;"	c	namespace:vcg::vert
OSGNormal3f	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class OSGNormal3f : public OSGNormal< OSG::Vec3f, T > $/;"	c	namespace:vcg::vert
OSGNormalCore	vcglib/wrap/opensg/vertex_component.h	/^	OSGNormalCore( OSG::GeometryPtr p, int i ) { _geopointer = p; _vertexindex = i; }$/;"	f	class:vcg::vert::OSGNormalCore
OSGNormalCore	vcglib/wrap/opensg/vertex_component.h	/^template< class T > class OSGNormalCore$/;"	c	namespace:vcg::vert
OSGNormalCore3f	vcglib/wrap/opensg/vertex_component.h	/^class OSGNormalCore3f : public OSGNormalCore< OSG::Vec3f > {};$/;"	c	namespace:vcg::vert
OUTLINE_SUPPORT_H	vcglib/vcg/complex/algorithms/outline_support.h	/^#define OUTLINE_SUPPORT_H$/;"	d
OUTPUT_DEPTH_BIT	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		OUTPUT_DEPTH_BIT			= 0x000004,$/;"	e	enum:SplatRenderer::__anon519
OUTSIDE	vcglib/wrap/gcache/token.h	/^    enum Status { LOCKED = 1, READY = 0, CACHE = -1, REMOVE = -2, OUTSIDE = -3 };$/;"	e	enum:vcg::Token::Status
OVERLAP_ESTIMATION_H	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^#define OVERLAP_ESTIMATION_H$/;"	d
OWNSLOTS_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		OWNSLOTS_NODE=			8; $/;"	v
OWNSLOT_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		OWNSLOT_NODE=			3; $/;"	v
ObjIndexedFace	vcglib/wrap/io_trimesh/import_obj.h	/^                struct ObjIndexedFace$/;"	s	class:vcg::tri::io::ImporterOBJ
ObjPtr	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	typedef ObjType * ObjPtr;$/;"	t	class:vcg::AABBBinaryTreeIndex
ObjPtr	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		typedef ObjType * ObjPtr;$/;"	t	class:vcg::AABBBinaryTree
ObjPtr	vcglib/vcg/space/index/aabb_binary_tree/closest.h	/^	typedef typename TreeType::ObjPtr ObjPtr;$/;"	t	class:vcg::AABBBinaryTreeClosest
ObjPtr	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	typedef typename TreeType::ObjPtr ObjPtr;$/;"	t	class:vcg::AABBBinaryTreeFrustumCull
ObjPtr	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^	typedef typename TreeType::ObjPtr ObjPtr;$/;"	t	class:vcg::AABBBinaryTreeKClosest
ObjPtr	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^	typedef typename TreeType::ObjPtr ObjPtr;$/;"	t	class:vcg::AABBBinaryTreeRay
ObjPtr	vcglib/vcg/space/index/base.h	/^	typedef ObjType * ObjPtr;$/;"	t	class:vcg::SpatialIndex
ObjPtr	vcglib/vcg/space/index/grid_static_ptr.h	/^		typedef ObjType* ObjPtr;$/;"	t	class:vcg::GridStaticPtr
ObjPtr	vcglib/vcg/space/index/index2D/base_2d.h	/^	typedef ObjType * ObjPtr;$/;"	t	class:vcg::SpatialIndex2D
ObjPtr	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        typedef ObjType* ObjPtr;$/;"	t	class:vcg::SpatialHashTable2D
ObjPtr	vcglib/vcg/space/index/spatial_hashing.h	/^		typedef typename SpatialHashTable<ContainerType,FLT>::ObjPtr ObjPtr;$/;"	t	class:vcg::DynamicSpatialHashTable
ObjPtr	vcglib/vcg/space/index/spatial_hashing.h	/^	typedef ObjType* ObjPtr;$/;"	t	class:vcg::SpatialHashTable
ObjPtrVector	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		typedef std::vector<ObjPtr> ObjPtrVector;$/;"	t	class:vcg::AABBBinaryTree
ObjPtrVectorConstIterator	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		typedef typename ObjPtrVector::const_iterator ObjPtrVectorConstIterator;$/;"	t	class:vcg::AABBBinaryTree
ObjPtrVectorIterator	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		typedef typename ObjPtrVector::iterator ObjPtrVectorIterator;$/;"	t	class:vcg::AABBBinaryTree
ObjTexCoord	vcglib/wrap/io_trimesh/import_obj.h	/^                struct ObjTexCoord$/;"	s	class:vcg::tri::io::ImporterOBJ
ObjType	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	typedef OBJTYPE ObjType;$/;"	t	class:vcg::AABBBinaryTreeIndex
ObjType	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		typedef OBJTYPE ObjType;$/;"	t	class:vcg::AABBBinaryTree
ObjType	vcglib/vcg/space/index/base.h	/^	typedef OBJTYPE ObjType;$/;"	t	class:vcg::SpatialIndex
ObjType	vcglib/vcg/space/index/grid_static_ptr.h	/^		typedef OBJTYPE ObjType;$/;"	t	class:vcg::GridStaticPtr
ObjType	vcglib/vcg/space/index/index2D/base_2d.h	/^	typedef OBJTYPE ObjType;$/;"	t	class:vcg::SpatialIndex2D
ObjType	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename Spatial_Idexing::ObjType ObjType;$/;"	t	class:vcg::ClosestIterator
ObjType	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename Spatial_Idexing::ObjType ObjType;$/;"	t	class:vcg::RayIterator
ObjType	vcglib/vcg/space/index/spatial_hashing.h	/^		typedef typename SpatialHashTable<ContainerType,FLT>::ObjType ObjType;$/;"	t	class:vcg::DynamicSpatialHashTable
Object	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef _Object Object;$/;"	t	class:Eigen::KdBVH
Object	vcglib/wrap/glw/object.h	/^		Object(Context * ctx)$/;"	f	class:glw::Object
Object	vcglib/wrap/glw/object.h	/^class Object : public detail::NonCopyable$/;"	c	namespace:glw
ObjectArguments	vcglib/wrap/glw/object.h	/^		ObjectArguments(void)$/;"	f	class:glw::ObjectArguments
ObjectArguments	vcglib/wrap/glw/object.h	/^class ObjectArguments$/;"	c	namespace:glw
ObjectBase	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase  <BoundBuffer> { typedef Buffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundFeedbackBuffer> { typedef Buffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundIndexBuffer> { typedef Buffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundPixelPackBuffer> { typedef Buffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundPixelUnpackBuffer> { typedef Buffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundUniformBuffer> { typedef Buffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundVertexBuffer> { typedef Buffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <SafeBuffer> { typedef Buffer     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectBase  <BoundFragmentShader> { typedef FragmentShader      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectBase <SafeFragmentShader> { typedef FragmentShader     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase  <BoundFramebuffer> { typedef Framebuffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <BoundDrawFramebuffer> { typedef Framebuffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <BoundReadDrawFramebuffer> { typedef Framebuffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <BoundReadFramebuffer> { typedef Framebuffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <SafeFramebuffer> { typedef Framebuffer     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectBase  <BoundGeometryShader> { typedef GeometryShader      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectBase <SafeGeometryShader> { typedef GeometryShader     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectBase  <BoundObject> { typedef Object                      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectBase <SafeObject> { typedef Object                     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ObjectBase  { typedef NoType        Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectBase  <BoundProgram> { typedef Program      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectBase <SafeProgram> { typedef Program     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectBase  <BoundRenderable> { typedef Renderable      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectBase <SafeRenderable> { typedef Renderable     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectBase  <BoundRenderbuffer> { typedef Renderbuffer      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectBase <SafeRenderbuffer> { typedef Renderbuffer     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectBase  <BoundShader> { typedef Shader      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectBase <SafeShader> { typedef Shader     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectBase  <BoundTexture> { typedef Texture      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectBase <SafeTexture> { typedef Texture     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectBase  <BoundTexture2D> { typedef Texture2D      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectBase <SafeTexture2D> { typedef Texture2D     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectBase  <BoundTextureCube> { typedef TextureCube      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectBase <SafeTextureCube> { typedef TextureCube     Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectBase  <BoundVertexShader> { typedef VertexShader      Type; }; };$/;"	s	namespace:glw::detail
ObjectBase	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectBase <SafeVertexShader> { typedef VertexShader     Type; }; };$/;"	s	namespace:glw::detail
ObjectBindingParams	vcglib/wrap/glw/object.h	/^		ObjectBindingParams(GLenum aTarget, GLenum aUnit)$/;"	f	class:glw::ObjectBindingParams
ObjectBindingParams	vcglib/wrap/glw/object.h	/^		ObjectBindingParams(void)$/;"	f	class:glw::ObjectBindingParams
ObjectBindingParams	vcglib/wrap/glw/object.h	/^class ObjectBindingParams$/;"	c	namespace:glw
ObjectBound	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBound <Buffer     > { typedef BoundBuffer Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectBound <FragmentShader     > { typedef BoundFragmentShader Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBound <Framebuffer     > { typedef BoundFramebuffer Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectBound <GeometryShader     > { typedef BoundGeometryShader Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectBound <Object     > { typedef BoundObject                 Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ObjectBound { typedef NoType        Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectBound <Program     > { typedef BoundProgram Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectBound <Renderable     > { typedef BoundRenderable Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectBound <Renderbuffer     > { typedef BoundRenderbuffer Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectBound <Shader     > { typedef BoundShader Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectBound <Texture     > { typedef BoundTexture Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectBound <Texture2D     > { typedef BoundTexture2D Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectBound <TextureCube     > { typedef BoundTextureCube Type; }; };$/;"	s	namespace:glw::detail
ObjectBound	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectBound <VertexShader     > { typedef BoundVertexShader Type; }; };$/;"	s	namespace:glw::detail
ObjectBoundFromObject	vcglib/wrap/glw/context.h	/^		struct ObjectBoundFromObject$/;"	s	class:glw::Context
ObjectBoundType	vcglib/wrap/glw/context.h	/^			typedef typename ObjectBoundFromObject<TObject>::Type ObjectBoundType;$/;"	t	struct:glw::Context::BindingHandleFromObject
ObjectBoundType	vcglib/wrap/glw/context.h	/^			typedef typename ObjectBoundFromObject<TObject>::Type ObjectBoundType;$/;"	t	struct:glw::Context::RefCountedBindingHandleFromObject
ObjectDeleter	vcglib/wrap/glw/objectdeleter.h	/^class ObjectDeleter$/;"	c	namespace:glw::detail
ObjectFromBinding	vcglib/wrap/glw/context.h	/^		struct ObjectFromBinding$/;"	s	class:glw::Context
ObjectHandle	vcglib/wrap/glw/object.h	/^typedef  detail::ObjectSharedPointerTraits       <SafeObject> ::Type  ObjectHandle;$/;"	t	namespace:glw
ObjectID	vcglib/wrap/gl/gl_object.h	/^	GLuint ObjectID(void) const$/;"	f	class:GLObject
ObjectIterator	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef const Object *ObjectIterator;$/;"	t	class:Eigen::KdBVH
ObjectList	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef std::vector<Object, aligned_allocator<Object> > ObjectList;$/;"	t	class:Eigen::KdBVH
ObjectPlaceholder	vcglib/vcg/space/index/octree.h	/^            ObjectPlaceholder() { z_order = object_index = -1, leaf_pointer = NULL;}$/;"	f	struct:vcg::Octree::ObjectPlaceholder
ObjectPlaceholder	vcglib/vcg/space/index/octree.h	/^            ObjectPlaceholder(ZOrderType zOrder, void* leafPointer, unsigned int objectIndex)$/;"	f	struct:vcg::Octree::ObjectPlaceholder
ObjectPlaceholder	vcglib/vcg/space/index/octree.h	/^        struct ObjectPlaceholder$/;"	s	class:vcg::Octree
ObjectPointer	vcglib/vcg/math/disjoint_set.h	/^		typedef OBJECT_TYPE*																							ObjectPointer;$/;"	t	class:vcg::DisjointSet
ObjectPointer	vcglib/vcg/space/index/octree.h	/^        typedef typename	ReferenceType<OBJECT_TYPE>::Type	* ObjectPointer;$/;"	t	class:vcg::Octree
ObjectPointer	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		typedef typename	ReferenceType< ObjectType >::Type * ObjectPointer;$/;"	t	class:vcg::PerfectSpatialHashing
ObjectPtr	vcglib/wrap/glw/object.h	/^typedef  detail::ObjectSharedPointerTraits      <Object> ::Type ObjectPtr;$/;"	t	namespace:glw
ObjectReference	vcglib/vcg/space/index/octree.h	/^            ObjectReference() {pMark=NULL; pObject=NULL;}$/;"	f	struct:vcg::Octree::ObjectReference
ObjectReference	vcglib/vcg/space/index/octree.h	/^        struct ObjectReference$/;"	s	class:vcg::Octree
ObjectSafe	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectSafe <Buffer    > { typedef SafeBuffer Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectSafe <FragmentShader    > { typedef SafeFragmentShader Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectSafe <Framebuffer    > { typedef SafeFramebuffer Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectSafe <GeometryShader    > { typedef SafeGeometryShader Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectSafe <Object    > { typedef SafeObject                 Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ObjectSafe  { typedef NoType        Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectSafe <Program    > { typedef SafeProgram Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectSafe <Renderable    > { typedef SafeRenderable Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectSafe <Renderbuffer    > { typedef SafeRenderbuffer Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectSafe <Shader    > { typedef SafeShader Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectSafe <Texture    > { typedef SafeTexture Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectSafe <Texture2D    > { typedef SafeTexture2D Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectSafe <TextureCube    > { typedef SafeTextureCube Type; }; };$/;"	s	namespace:glw::detail
ObjectSafe	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectSafe <VertexShader    > { typedef SafeVertexShader Type; }; };$/;"	s	namespace:glw::detail
ObjectSafeFromObject	vcglib/wrap/glw/context.h	/^		struct ObjectSafeFromObject$/;"	s	class:glw::Context
ObjectSafeType	vcglib/wrap/glw/context.h	/^			typedef typename ObjectSafeFromObject<TObject>::Type ObjectSafeType;$/;"	t	struct:glw::Context::RefCountedSafeHandleFromObject
ObjectSafeType	vcglib/wrap/glw/context.h	/^			typedef typename ObjectSafeFromObject<TObject>::Type ObjectSafeType;$/;"	t	struct:glw::Context::SafeHandleFromObject
ObjectSharedPointer	vcglib/wrap/glw/bookkeeping.h	/^		ObjectSharedPointer(RefCountedObjectType * refObject)$/;"	f	class:glw::detail::ObjectSharedPointer
ObjectSharedPointer	vcglib/wrap/glw/bookkeeping.h	/^		ObjectSharedPointer(const ThisType & other)$/;"	f	class:glw::detail::ObjectSharedPointer
ObjectSharedPointer	vcglib/wrap/glw/bookkeeping.h	/^		ObjectSharedPointer(void)$/;"	f	class:glw::detail::ObjectSharedPointer
ObjectSharedPointer	vcglib/wrap/glw/bookkeeping.h	/^class ObjectSharedPointer : public ObjectSharedPointer<TBaseObject, TDeleter, typename BaseOf<TBaseObject>::Type>$/;"	c	namespace:glw::detail
ObjectSharedPointer	vcglib/wrap/glw/bookkeeping.h	/^class ObjectSharedPointer<TObject, TDeleter, NoType>$/;"	c	namespace:glw::detail
ObjectSharedPointerTraits	vcglib/wrap/glw/bookkeeping.h	/^template <typename T> struct ObjectSharedPointerTraits { typedef ObjectSharedPointer<T, typename DeleterOf<typename RootOf<T>::Type>::Type, typename BaseOf<T>::Type> Type; };$/;"	s	namespace:glw::detail
ObjectSorter	vcglib/vcg/space/index/octree.h	/^        struct ObjectSorter$/;"	s	class:vcg::Octree
ObjectType	vcglib/vcg/space/index/octree.h	/^        typedef						OBJECT_TYPE													ObjectType;$/;"	t	class:vcg::Octree
ObjectType	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		typedef						OBJECT_TYPE													ObjectType;$/;"	t	class:vcg::PerfectSpatialHashing
ObjectType	vcglib/wrap/glw/bookkeeping.h	/^		typedef TObject                                                                         ObjectType;$/;"	t	class:glw::detail::ObjectSharedPointer
ObjectType	vcglib/wrap/glw/bookkeeping.h	/^		typedef TObject                                                                     ObjectType;$/;"	t	class:glw::detail::RefCountedObject
ObjectType	vcglib/wrap/glw/bookkeeping.h	/^		typedef TObject                                           ObjectType;$/;"	t	class:glw::detail::ObjectSharedPointer
ObjectType	vcglib/wrap/glw/bookkeeping.h	/^		typedef TObject                                     ObjectType;$/;"	t	class:glw::detail::RefCountedObject
ObjectType	vcglib/wrap/glw/context.h	/^		typedef Object                                                 ObjectType;$/;"	t	class:glw::Context
ObjectsCount	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^unsigned int AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::ObjectsCount(void) const {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
Obox3	vcglib/vcg/space/obox3.h	/^		inline  Obox3():Box3<T>(){}$/;"	f	class:vcg::Obox3
Obox3	vcglib/vcg/space/obox3.h	/^		inline Obox3(const Point3<T> &min, const Point3<T> &max, const Point3<T> *frame):Box3<T>(min,max){$/;"	f	class:vcg::Obox3
Obox3	vcglib/vcg/space/obox3.h	/^                inline  Obox3(const Obox3 &b):Box3<T>(b.min,b.max),m(b.m),mi(b.mi){}$/;"	f	class:vcg::Obox3
Obox3	vcglib/vcg/space/obox3.h	/^        class Obox3:public Box3<T>{$/;"	c	namespace:vcg
Obox3d	vcglib/vcg/space/obox3.h	/^	typedef Obox3<double> Obox3d;$/;"	t	namespace:vcg
Obox3f	vcglib/vcg/space/obox3.h	/^	typedef Obox3<float>  Obox3f;$/;"	t	namespace:vcg
Obox3i	vcglib/vcg/space/obox3.h	/^	typedef Obox3<int>	  Obox3i;$/;"	t	namespace:vcg
Obox3s	vcglib/vcg/space/obox3.h	/^	typedef Obox3<short>  Obox3s;$/;"	t	namespace:vcg
OcfEdge	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^class OcfEdge : public vcg::Edge<OcfUsedTypes>$/;"	c	file:
OcfFace	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^class OcfFace    : public vcg::Face<  OcfUsedTypes,vcg::face::InfoOcf,vcg::face::VertexRef,vcg::face::BitFlags,vcg::face::VFAdjOcf> {};$/;"	c	file:
OcfMesh	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^class OcfMesh    : public vcg::tri::TriMesh< vcg::vertex::vector_ocf<OcfVertex>, vcg::face::vector_ocf<OcfFace> > $/;"	c	file:
OcfUsedTypes	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^class OcfUsedTypes: public vcg::UsedTypes < vcg::Use<OcfVertex>::AsVertexType,$/;"	c	file:
OcfVertex	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^class OcfVertex  : public vcg::Vertex< OcfUsedTypes,vcg::vertex::InfoOcf,vcg::vertex::Coord3f,vcg::vertex::BitFlags,vcg::vertex::Normal3fOcf,vcg::vertex::VFAdjOcf,vcg::vertex::MarkOcf>$/;"	c	file:
OcreeRenderingSetting	vcglib/vcg/space/index/octree.h	/^        OcreeRenderingSetting()$/;"	f	struct:vcg::OcreeRenderingSetting
OcreeRenderingSetting	vcglib/vcg/space/index/octree.h	/^    struct OcreeRenderingSetting$/;"	s	namespace:vcg
OctaLevel	vcglib/vcg/math/gen_normal.h	/^class OctaLevel$/;"	c	class:vcg::GenNormal
Octahedron	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Octahedron(OctMeshType &in)$/;"	f	namespace:vcg::tri
Octree	vcglib/vcg/space/index/octree.h	/^      Octree()$/;"	f	class:vcg::Octree
Octree	vcglib/vcg/space/index/octree.h	/^    class Octree : public vcg::OctreeTemplate< Voxel, SCALAR_TYPE >, public vcg::SpatialIndex< OBJECT_TYPE, SCALAR_TYPE >$/;"	c	namespace:vcg
OctreeTemplate	vcglib/vcg/space/index/octree_template.h	/^class OctreeTemplate$/;"	c	namespace:vcg
OddPointLoop	vcglib/vcg/complex/algorithms/refine_loop.h	/^  OddPointLoop(MESH_TYPE &_m):OddPointLoopGeneric<MESH_TYPE, Centroid<MESH_TYPE> >(_m){}$/;"	f	struct:vcg::tri::OddPointLoop
OddPointLoop	vcglib/vcg/complex/algorithms/refine_loop.h	/^struct OddPointLoop : OddPointLoopGeneric<MESH_TYPE, Centroid<MESH_TYPE> >$/;"	s	namespace:vcg::tri
OddPointLoopGeneric	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline OddPointLoopGeneric(MESH_TYPE &_m, Projection proj = Projection(), Weight weight = Weight()) :$/;"	f	struct:vcg::tri::OddPointLoopGeneric
OddPointLoopGeneric	vcglib/vcg/complex/algorithms/refine_loop.h	/^struct OddPointLoopGeneric : public std::unary_function<face::Pos<typename MESH_TYPE::FaceType> , typename MESH_TYPE::VertexType>$/;"	s	namespace:vcg::tri
Offset	vcglib/vcg/space/box2.h	/^	void Offset(const PointType & delta)$/;"	f	class:vcg::Box2
Offset	vcglib/vcg/space/box2.h	/^  void Offset(const ScalarType s)$/;"	f	class:vcg::Box2
Offset	vcglib/vcg/space/box3.h	/^    void Offset( const BoxScalarType s )$/;"	f	class:vcg::Box3
Offset	vcglib/vcg/space/box3.h	/^    void Offset( const Point3<BoxScalarType> & delta )$/;"	f	class:vcg::Box3
Offset	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			typedef vcg::Point3<OffsetType>	Offset;$/;"	t	class:vcg::PerfectSpatialHashing::OffsetTable
Offset	vcglib/vcg/space/plane3.h	/^  ScalarType &Offset() { return _offset; } $/;"	f	class:vcg::Plane3
Offset	vcglib/vcg/space/plane3.h	/^  const ScalarType &Offset() const { return _offset; } $/;"	f	class:vcg::Plane3
OffsetCol	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^      OffsetCol  = ReverseCol && IsRowMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon237
OffsetPointer	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			typedef Offset								* OffsetPointer;$/;"	t	class:vcg::PerfectSpatialHashing::OffsetTable
OffsetRow	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^      OffsetRow  = ReverseRow && IsColMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon237
OffsetTable	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			OffsetTable() { m_EntryPerSide=-1; m_NumberOfOccupiedEntries=0;}$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
OffsetTable	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		class OffsetTable$/;"	c	class:vcg::PerfectSpatialHashing
OffsetTableConstructionSucceded	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		bool OffsetTableConstructionSucceded(const int offset_table_size, vcg::CallBackPos *callback)$/;"	f	class:vcg::PerfectSpatialHashing
OffsetType	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			typedef unsigned char						OffsetType;$/;"	t	class:vcg::PerfectSpatialHashing::OffsetTable
OldLoadPolygonalListMesh	vcglib/wrap/io_trimesh/import_dae.h	/^        static DAEError	OldLoadPolygonalListMesh(QDomNodeList& polylist,ColladaMesh& m,const size_t offset,InfoDAE& info)$/;"	f	class:vcg::tri::io::ImporterDAE
Old_Mesh	vcglib/vcg/complex/algorithms/create/resampler.h	/^		typedef  OLD_MESH_TYPE Old_Mesh;$/;"	t	class:vcg::tri::Resampler::Walker
Old_Mesh	vcglib/vcg/complex/algorithms/create/resampler.h	/^	typedef OLD_MESH_TYPE Old_Mesh;$/;"	t	class:vcg::tri::Resampler
OnTheLeft	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  OnTheLeft = 1,  $/;"	e	enum:Eigen::__anon264
OnTheRight	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  OnTheRight = 2  $/;"	e	enum:Eigen::__anon264
OneIntegerStep	vcglib/wrap/miq/quadrangulator.h	/^    bool OneIntegerStep(vcg::face::Pos<TriFaceType> &ep)$/;"	f	class:Quadrangulator
OneRingNeighborhood	vcglib/apps/sample/trimesh_pos_demo/trimesh_pos_demo.cpp	/^void OneRingNeighborhood( MyFace * f)$/;"	f
OneRingNeighborhoodJP	vcglib/apps/sample/trimesh_pos_demo/trimesh_pos_demo.cpp	/^void OneRingNeighborhoodJP( MyFace * f)$/;"	f
OneRingNeighborhoodVF	vcglib/apps/sample/trimesh_pos_demo/trimesh_vfiter_demo.cpp	/^void OneRingNeighborhoodVF( MyVertex * v)$/;"	f
Ones	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones()$/;"	f	class:Eigen::DenseBase
Ones	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
Ones	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index size)$/;"	f	class:Eigen::DenseBase
Open	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^static bool Open(const char *filename, VolumeType &V, Point3i sz, DataType d)$/;"	f	class:vcg::RawVolumeImporter
Open	vcglib/wrap/io_tetramesh/import_ply.h	/^static int Open( OpenMeshType &m, const char * filename, CallBackPos *cb=0)$/;"	f	class:vcg::tetra::io::ImporterPLY
Open	vcglib/wrap/io_tetramesh/import_ply.h	/^static int Open( OpenMeshType &m, const char * filename, PlyInfo &pi )$/;"	f	class:vcg::tetra::io::ImporterPLY
Open	vcglib/wrap/io_tetramesh/import_ply.h	/^static int Open( OpenMeshType &m, const char * filename, int & loadmask, CallBackPos *cb =0)$/;"	f	class:vcg::tetra::io::ImporterPLY
Open	vcglib/wrap/io_tetramesh/import_ts.h	/^static int Open( Tetramesh & m, const char * filename )$/;"	f	class:vcg::tetra::io::ImporterTS
Open	vcglib/wrap/io_trimesh/import.h	/^static int Open(OpenMeshType &m, const char *filename, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::Importer
Open	vcglib/wrap/io_trimesh/import.h	/^static int Open(OpenMeshType &m, const char *filename, int &loadmask, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::Importer
Open	vcglib/wrap/io_trimesh/import_asc.h	/^static int Open( MESH_TYPE &m, const char * filename, CallBackPos *cb=0, bool triangulate=false, int lineskip=0)$/;"	f	class:vcg::tri::io::ImporterASC
Open	vcglib/wrap/io_trimesh/import_ctm.h	/^static int Open( OpenMeshType &m, const char * filename, int &loadmask, CallBackPos *\/*cb*\/=0)$/;"	f	class:vcg::tri::io::ImporterCTM
Open	vcglib/wrap/io_trimesh/import_dae.h	/^        static int Open(OpenMeshType& m,const char* filename, InfoDAE& info, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ImporterDAE
Open	vcglib/wrap/io_trimesh/import_fbx.h	/^	static int Open( OpenMeshType &m, const char * filename, Info &oi)$/;"	f	class:ImporterFBX
Open	vcglib/wrap/io_trimesh/import_gts.h	/^				static int Open(MESH_TYPE &mesh, const char *filename, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ImporterGTS
Open	vcglib/wrap/io_trimesh/import_gts.h	/^				static int Open(MESH_TYPE &mesh, const char *filename, int &loadmask,$/;"	f	class:vcg::tri::io::ImporterGTS
Open	vcglib/wrap/io_trimesh/import_nvm.h	/^static int Open( OpenMeshType &m, std::vector<Shot<ScalarType> >  & shots,$/;"	f	class:vcg::tri::io::ImporterNVM
Open	vcglib/wrap/io_trimesh/import_obj.h	/^                static int Open( OpenMeshType &m, const char * filename, Info &oi)$/;"	f	class:vcg::tri::io::ImporterOBJ
Open	vcglib/wrap/io_trimesh/import_obj.h	/^                static int Open(OpenMeshType &mesh, const char *filename, int &loadmask, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ImporterOBJ
Open	vcglib/wrap/io_trimesh/import_off.h	/^  static int Open(MESH_TYPE &mesh, const char *filename, int &loadmask,$/;"	f	class:vcg::tri::io::ImporterOFF
Open	vcglib/wrap/io_trimesh/import_off.h	/^  static int Open(MESH_TYPE &mesh, const char *filename,CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ImporterOFF
Open	vcglib/wrap/io_trimesh/import_out.h	/^static int Open( OpenMeshType &m, std::vector<Shot<ScalarType> >  & shots,$/;"	f	class:vcg::tri::io::ImporterOUT
Open	vcglib/wrap/io_trimesh/import_ply.h	/^static int Open( OpenMeshType &m, const char * filename, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ImporterPLY
Open	vcglib/wrap/io_trimesh/import_ply.h	/^static int Open( OpenMeshType &m, const char * filename, PlyInfo &pi )$/;"	f	class:vcg::tri::io::ImporterPLY
Open	vcglib/wrap/io_trimesh/import_ply.h	/^static int Open( OpenMeshType &m, const char * filename, int & loadmask, CallBackPos *cb =0)$/;"	f	class:vcg::tri::io::ImporterPLY
Open	vcglib/wrap/io_trimesh/import_ptx.h	/^		static int Open( OpenMeshType &m, const char * filename, Info importparams, CallBackPos *cb=NULL)$/;"	f	class:vcg::tri::io::ImporterPTX
Open	vcglib/wrap/io_trimesh/import_raw.h	/^static int Open( MESH_TYPE &m, const char * filename, bool triangulate=false, int lineskip = 0, const char * linedesc = "PX PY PZ")$/;"	f	class:vcg::tri::io::ImporterRAW
Open	vcglib/wrap/io_trimesh/import_smf.h	/^		static int Open(OpenMeshType &m, const char * filename )$/;"	f	class:vcg::tri::io::ImporterSMF
Open	vcglib/wrap/io_trimesh/import_stl.h	/^static int Open( OpenMeshType &m, const char * filename, int &loadMask, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ImporterSTL
Open	vcglib/wrap/io_trimesh/import_vmi.h	/^        static int Open(OpenMeshType &m, const char * filename, int & mask,CallBackPos  * \/*cb*\/ = 0 )       {$/;"	f	class:vcg::tri::io::ImporterVMI
Open	vcglib/wrap/ply/plylib.cpp	/^int PlyFile::Open( const char * filename, int mode )$/;"	f	class:vcg::ply::PlyFile
OpenAscii	vcglib/wrap/io_trimesh/import_stl.h	/^  static int OpenAscii( OpenMeshType &m, const char * filename, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ImporterSTL
OpenBinary	vcglib/wrap/io_trimesh/import_stl.h	/^static int OpenBinary( OpenMeshType &m, const char * filename, int &loadMask, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ImporterSTL
OpenFile	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::OpenFile(){$/;"	f	class:GLWidget
OpenGLSnap	vcglib/apps/unsupported/shadevis/simplepic.h	/^   void OpenGLSnap(GLenum format=0)$/;"	f	class:vcg::SimplePic
OpenMesh	vcglib/apps/metro/metro.cpp	/^void OpenMesh(const char *filename, CMesh &m)$/;"	f
OpenMesh	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^int OpenMesh(const	char *filename, CMesh &m)$/;"	f
OpenMesh	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^void OpenMesh(const char *filename, MyMesh &m)$/;"	f
OpenRead	vcglib/wrap/ply/plylib.cpp	/^int PlyFile::OpenRead( const char * filename )$/;"	f	class:vcg::ply::PlyFile
OpenWrite	vcglib/wrap/ply/plylib.cpp	/^int PlyFile::OpenWrite( const char * \/*filename*\/ )$/;"	f	class:vcg::ply::PlyFile
OperationWeight	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^        class OperationWeight$/;"	c	namespace:vcg::tri
Opposite	vcglib/vcg/connectors/hedge_component.h	/^        typename T::HEdgePointer Opposite()                     { return this->HOp();}$/;"	f	class:vcg::hedge::HEdgeData
OptimalPlacement	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      OptimalPlacement;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
OptimalPlacement	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  bool    OptimalPlacement;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
Option	vcglib/wrap/system/qgetopt.h	/^    Option(): value(NULL), string_value(NULL), double_value(NULL), int_value(NULL), boolean_value(NULL) {}$/;"	f	struct:GetOpt::Option
Option	vcglib/wrap/system/qgetopt.h	/^    Option(Type _type, char _o, QString _name, QString _descr):$/;"	f	struct:GetOpt::Option
Option	vcglib/wrap/system/qgetopt.h	/^  struct Option {$/;"	s	class:GetOpt
Options	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^      Options = MatrixType::Options & ~RowMajorBit, \/\/ these are the options for the TmpMatrixType, we need a ColMajor matrix here!$/;"	e	enum:Eigen::LDLT::__anon4
Options	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::LLT::__anon5
Options	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Array::__anon33
Options	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      Options = internal::traits<Derived>::Options$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon45
Options	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon48
Options	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon49
Options	vcglib/eigenlib/Eigen/src/Core/Map.h	/^  enum { Options }; \/\/ Expressions don't have Options$/;"	e	enum:Eigen::internal::traits::__anon174
Options	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon181
Options	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Matrix::__anon182
Options	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    enum { Options = internal::traits<Derived>::Options };$/;"	e	enum:Eigen::PlainObjectBase::__anon189
Options	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon350
Options	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexSchur::__anon351
Options	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::EigenSolver::__anon352
Options	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon353
Options	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::RealSchur::__anon354
Options	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon355
Options	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::Tridiagonalization::__anon356
Options	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^    Options = _Options$/;"	e	enum:Eigen::Hyperplane::__anon361
Options	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^    Options = _Options$/;"	e	enum:Eigen::ParametrizedLine::__anon362
Options	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    Options = _Options,$/;"	e	enum:Eigen::Transform::__anon373
Options	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivLU::__anon387
Options	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::PartialPivLU::__anon390
Options	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon396
Options	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon397
Options	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HouseholderQR::__anon398
Options	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon439
Options	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon440
Options	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon441
Options	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseMatrix::__anon419
Options	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseVector::__anon432
Options	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    static const int Options = MatrixType::Options;$/;"	m	class:Eigen::MatrixFunction
Options	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^      Options = _Options$/;"	e	enum:Eigen::DynamicSparseMatrix::__anon457
Options	vcglib/wrap/io_trimesh/import_gts.h	/^					Options()$/;"	f	struct:vcg::tri::io::ImporterGTS::Options
Options	vcglib/wrap/io_trimesh/import_gts.h	/^				struct Options$/;"	s	class:vcg::tri::io::ImporterGTS
Ord	vcglib/vcg/container/container_allocation_table.h	/^Ord(const ValueType * pt)$/;"	f	class:vcg::CATEntry
OrderAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { OrderAtCompileTime = _Degree==Dynamic ? Dynamic : _Degree+1 \/*!< The spline curve's order at compile-time. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon468
OrderAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      enum { OrderAtCompileTime = _Degree==Dynamic ? Dynamic : _Degree+1 \/*!< The spline curve's order at compile-time. *\/ };$/;"	e	enum:Eigen::SplineTraits::__anon470
OrientCoherentlyMesh	vcglib/vcg/complex/algorithms/clean.h	/^  static void OrientCoherentlyMesh(MeshType &m, bool &Oriented, bool &Orientable)$/;"	f	class:vcg::tri::Clean
Orientable	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool Orientable,Oriented;$/;"	m	struct:MeshInfo	file:
Oriented	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool Orientable,Oriented;$/;"	m	struct:MeshInfo	file:
OrientedAngleRad	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  ScalarType OrientedAngleRad(Point3x p, Point3x q, Point3x &axis) {$/;"	f	class:vcg::tri::BallPivoting
OrientedAnnulus	vcglib/vcg/complex/algorithms/create/platonic.h	/^void OrientedAnnulus(MeshType & m, Point3f center, Point3f norm, float externalRadius, float internalRadius, int slices)$/;"	f	namespace:vcg::tri
OrientedCylinder	vcglib/vcg/complex/algorithms/create/platonic.h	/^void OrientedCylinder(MeshType & m, const Point3f origin, const Point3f end, float radius, int slices=32, int stacks=4 )$/;"	f	namespace:vcg::tri
OrientedDisk	vcglib/vcg/complex/algorithms/create/platonic.h	/^void OrientedDisk(MeshType &m, int slices, Point3f center, Point3f norm, float radius)$/;"	f	namespace:vcg::tri
OrientedRect	vcglib/vcg/complex/algorithms/create/platonic.h	/^void OrientedRect(MeshType &square, float width, float height, Point3f c, Point3f dir=Point3f(0,0,0), float angleDeg=0,Point3f preRotTra = Point3f(0,0,0))$/;"	f	namespace:vcg::tri
OrientedSquare	vcglib/vcg/complex/algorithms/create/platonic.h	/^void OrientedSquare(MeshType &square, float width, Point3f c, Point3f dir=Point3f(0,0,0), float angleDeg=0,Point3f preRotTra = Point3f(0,0,0))$/;"	f	namespace:vcg::tri
Origin	vcglib/vcg/space/line2.h	/^  inline PointType &Origin() { return _ori; } $/;"	f	class:vcg::Line2
Origin	vcglib/vcg/space/line2.h	/^  inline const PointType &Origin() const { return _ori; } $/;"	f	class:vcg::Line2
Origin	vcglib/vcg/space/line3.h	/^  inline PointType &Origin() { return _ori; } $/;"	f	class:vcg::Line3
Origin	vcglib/vcg/space/line3.h	/^  inline const PointType &Origin() const { return _ori; } $/;"	f	class:vcg::Line3
Origin	vcglib/vcg/space/ray2.h	/^  inline PointType &Origin() { return _ori; } $/;"	f	class:vcg::Ray2
Origin	vcglib/vcg/space/ray2.h	/^  inline const PointType &Origin() const { return _ori; } $/;"	f	class:vcg::Ray2
Origin	vcglib/vcg/space/ray3.h	/^  inline PointType &Origin() { return _ori; } $/;"	f	class:vcg::Ray3
Origin	vcglib/vcg/space/ray3.h	/^  inline const PointType &Origin() const { return _ori; } $/;"	f	class:vcg::Ray3
OtherCols	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon376
OtherCols	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
OtherPlainObject	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename OtherDerived::PlainObject::DenseType OtherPlainObject;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type
OtherRows	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon376
OtherRows	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon377
OutNameMsh	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^string OutNameMsh;$/;"	v
OutOfDate	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	static int &OutOfDate()        {static int ofd=0; return ofd;}$/;"	f	class:vcg::tri::TriEdgeCollapse::FailStat
Out_mem	vcglib/wrap/io_trimesh/export_vmi.h	/^        static char * & Out_mem(){static char *    out_mem; return out_mem;}$/;"	f	class:vcg::tri::io::ExporterVMI
Out_mode	vcglib/wrap/io_trimesh/export_vmi.h	/^        static unsigned int & Out_mode(){static unsigned int  out_mode = 0; return out_mode;}$/;"	f	class:vcg::tri::io::ExporterVMI
OuterPacketMask	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    static const int OuterPacketMask = (1 << OuterPacketBits) - 1;$/;"	m	class:Eigen::RandomSetter
OuterProduct	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::__anon266
OuterProduct	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void OuterProduct(const MatrixBase<OtherDerived1>& a, const MatrixBase<OtherDerived2>& b)$/;"	f
OuterProduct	vcglib/vcg/math/matrix33.h	/^    void OuterProduct(Point3<S> const &p0, Point3<S> const &p1) {$/;"	f	class:vcg::Matrix33
OuterProduct	vcglib/vcg/math/old_deprecated_matrix.h	/^			void OuterProduct(const Point<N,TYPE> a, const Point< M,TYPE> b)$/;"	f	class:vcg::ndim::Matrix
OuterRandomAccessPattern	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^const int OuterRandomAccessPattern  = 0x4 | CoherentAccessPattern;$/;"	m	namespace:Eigen
OuterStride	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    OuterStride() : Base() {}$/;"	f	class:Eigen::OuterStride
OuterStride	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    OuterStride(Index v) : Base(v,0) {}$/;"	f	class:Eigen::OuterStride
OuterStride	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^class OuterStride : public Stride<Value, 0>$/;"	c	namespace:Eigen
OuterStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    OuterStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon50
OuterStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon57
OuterStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret$/;"	e	enum:Eigen::DenseBase::__anon58
OuterStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    OuterStrideAtCompileTime = 0$/;"	e	enum:Eigen::internal::traits::__anon64
OuterStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon173
OuterStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon181
OuterStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    OuterStrideAtCompileTime = Lhs::OuterStrideAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon243
OuterStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^      OuterStrideAtCompileTime = _OuterStrideAtCompileTime$/;"	e	enum:Eigen::Stride::__anon247
OuterStrideAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon248
Outline2Area	vcglib/vcg/complex/algorithms/outline_support.h	/^  static ScalarType Outline2Area(const std::vector< Point2<ScalarType> > &outline2)$/;"	f	class:vcg::tri::OutlineUtil
Outline2BBox	vcglib/vcg/complex/algorithms/outline_support.h	/^  static Box2<ScalarType> Outline2BBox(const std::vector<Point2<ScalarType> > &outline2)$/;"	f	class:vcg::tri::OutlineUtil
Outline2Dumper	vcglib/wrap/qt/Outline2ToQImage.h	/^class Outline2Dumper$/;"	c
Outline2Perimeter	vcglib/vcg/complex/algorithms/outline_support.h	/^  static ScalarType Outline2Perimeter(const std::vector< Point2<ScalarType>  > &outline2)$/;"	f	class:vcg::tri::OutlineUtil
Outline2VecBBox	vcglib/vcg/complex/algorithms/outline_support.h	/^  static Box2<ScalarType> Outline2VecBBox(const std::vector<std::vector<Point2<ScalarType> > > &outline2Vec)$/;"	f	class:vcg::tri::OutlineUtil
OutlineUtil	vcglib/vcg/complex/algorithms/outline_support.h	/^class OutlineUtil$/;"	c	namespace:vcg::tri
Output_File	vcglib/wrap/io_trimesh/export_idtf.h	/^	Output_File(const std::string& file)$/;"	f	class:Output_File
Output_File	vcglib/wrap/io_trimesh/export_idtf.h	/^class Output_File$/;"	c
OverlapEstimation	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    OverlapEstimation() : normBuckets(NULL), gridFix(NULL){}$/;"	f	class:OverlapEstimation
OverlapEstimation	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^template<class MESH_TYPE> class OverlapEstimation$/;"	c
OwnSlotNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^	OwnSlotNode(void){node_type = OWNSLOT_NODE; name = "empty";};$/;"	f	class:OwnSlotNode
OwnSlotNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^class OwnSlotNode: public Node$/;"	c
OwnSlotsNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^	OwnSlotsNode(void){node_type = OWNSLOTS_NODE;};$/;"	f	class:OwnSlotsNode
OwnSlotsNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^class OwnSlotsNode: public Node$/;"	c
P	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  MeshType	*P;	  \/\/ mesh from which the coplanar base is selected$/;"	m	class:vcg::tri::FourPCS
P	vcglib/vcg/complex/algorithms/hole.h	/^  const CoordType &P(int i) const {$/;"	f	class:vcg::tri::TrivialEar
P	vcglib/vcg/math/perlin_noise.h	/^   static int P(int i)$/;"	f	class:vcg::math::Perlin
P	vcglib/vcg/math/quaternion.h	/^#define P(/;"	d
P	vcglib/vcg/math/quaternion.h	/^#undef P$/;"	d
P	vcglib/vcg/simplex/edge/component.h	/^	inline       typename T::CoordType &           P( const int j )       { (void)j; assert(0);  static typename T::CoordType coord(0, 0, 0); return coord; }$/;"	f	class:vcg::edge::EmptyCore
P	vcglib/vcg/simplex/edge/component.h	/^	inline       typename T::CoordType & P( const int j ) 	    {	assert(j>=0 && j<2);		return v[j]->P();	}$/;"	f	class:vcg::edge::VertexRef
P	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::CoordType &           P( const int j ) const { (void)j; assert(0);  static typename T::CoordType coord(0, 0, 0); return coord; }$/;"	f	class:vcg::edge::EmptyCore
P	vcglib/vcg/simplex/face/component.h	/^  inline CoordType &P( const int j ) 	    {	assert(j>=0 && j<3);		return v[j]->P();	} \/\/\/ \\brief Shortcut: the position of the  i-th vertex (equivalent to \\c V(i)->P() )$/;"	f	class:vcg::face::VertexRef
P	vcglib/vcg/simplex/face/component.h	/^  inline typename T::CoordType &P( const int ) 	     { assert(0);		static typename T::CoordType coord(0, 0, 0); return coord;	}$/;"	f	class:vcg::face::EmptyCore
P	vcglib/vcg/simplex/face/component_occ.h	/^	inline       typename T::CoordType & P( const int j ) 	    {	assert(j>=0 && j<3);	return	V(j)->P();	}$/;"	f	class:vcg::face::VertexRefOcc
P	vcglib/vcg/simplex/face/component_occ.h	/^	inline const typename T::CoordType & P( const int j ) const	{	assert(j>=0 && j<3);	return  V(j)->cP(); }$/;"	f	class:vcg::face::VertexRefOcc
P	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        CoordType &P( const int j )       {	assert(j>=0 && j<this->VN());		return _vpoly[j]->P();	}$/;"	f	class:vcg::face::PFVAdj
P	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline       typename T::CoordType & P( const int j ) 	    {	assert(0);		static typename T::CoordType coord(0, 0, 0); return coord;	}$/;"	f	class:vcg::tetra::EmptyVertexRef
P	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline       typename T::CoordType & P( const int j ) 	    {	assert(j>=0 && j<4);		return v[j]->P();	}$/;"	f	class:vcg::tetra::VertexRef
P	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::CoordType & P( const int j ) const	{	assert(j>=0 && j<4);		return v[j]->cP(); }$/;"	f	class:vcg::tetra::VertexRef
P	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::CoordType & P( const int j ) const {	assert(0);		static typename T::CoordType coord(0, 0, 0); return coord;	}$/;"	f	class:vcg::tetra::EmptyVertexRef
P	vcglib/vcg/simplex/vertex/component.h	/^  CoordType &P()       { assert(0); static CoordType coord(0, 0, 0); return coord; }$/;"	f	class:vcg::vertex::EmptyCore
P	vcglib/vcg/simplex/vertex/component.h	/^  inline       CoordType &P()       { return _coord; }$/;"	f	class:vcg::vertex::Coord
P	vcglib/vcg/simplex/vertex/component.h	/^  inline const CoordType &P() const { return _coord; }$/;"	f	class:vcg::vertex::Coord
P	vcglib/vcg/simplex/vertex/component_occ.h	/^	CoordType &P() { return CAT< vector_occ<VertType>,CoordType>::Instance()->Get((VertType*)this); }$/;"	f	class:vcg::vertex::CoordOcc
P	vcglib/vcg/space/box2.h	/^	Point2<BoxScalarType> P(const int & i) const $/;"	f	class:vcg::Box2
P	vcglib/vcg/space/box3.h	/^    Point3<BoxScalarType> P(const int & i) const {$/;"	f	class:vcg::Box3
P	vcglib/vcg/space/line2.h	/^	inline PointType P( const ScalarType t ) const$/;"	f	class:vcg::Line2
P	vcglib/vcg/space/line3.h	/^	inline PointType P( const ScalarType t ) const$/;"	f	class:vcg::Line3
P	vcglib/vcg/space/ray2.h	/^	inline PointType P( const ScalarType t ) const$/;"	f	class:vcg::Ray2
P	vcglib/vcg/space/ray3.h	/^	inline PointType P( const ScalarType t ) const$/;"	f	class:vcg::Ray3
P	vcglib/vcg/space/tetra3.h	/^	inline CoordType & P( const int j ) { return _v[j];}$/;"	f	class:vcg::Tetra3
P	vcglib/vcg/space/texcoord2.h	/^    inline Point2<T>   P() const { return _t; }$/;"	f	class:vcg::TexCoord2Simple
P	vcglib/vcg/space/texcoord2.h	/^    inline Point2<T>   P(const int i) const { (void)i; assert(i==0); return _t; }$/;"	f	class:vcg::TexCoord2Simple
P	vcglib/vcg/space/texcoord2.h	/^    inline Point2<T> & P()       { return _t; }$/;"	f	class:vcg::TexCoord2Simple
P	vcglib/vcg/space/texcoord2.h	/^    inline Point2<T> & P(const int i)       { (void)i; assert(i==0); return _t; }$/;"	f	class:vcg::TexCoord2Simple
P	vcglib/vcg/space/texcoord2.h	/^  inline PointType &P() { return _t[0]; };$/;"	f	class:vcg::TexCoord2
P	vcglib/vcg/space/texcoord2.h	/^  inline PointType &P(const int i) { assert(i>0 && i<NMAX); return _t[i]; };$/;"	f	class:vcg::TexCoord2
P	vcglib/vcg/space/texcoord2.h	/^  inline const PointType &P() const { return _t[0]; };$/;"	f	class:vcg::TexCoord2
P	vcglib/vcg/space/texcoord2.h	/^  inline const PointType &P(const int i) const { assert(i>0 && i<NMAX); return _t[i]; };$/;"	f	class:vcg::TexCoord2
P	vcglib/vcg/space/triangle2.h	/^	inline CoordType & P( const int j ) { return _v[j];}$/;"	f	class:vcg::Triangle2
P	vcglib/vcg/space/triangle2.h	/^	inline const CoordType &  P( const int j ) const { return _v[j];}$/;"	f	class:vcg::Triangle2
P	vcglib/vcg/space/triangle3.h	/^  inline CoordType & P( const int j ) { return _v[j];}$/;"	f	class:vcg::Triangle3
P	vcglib/vcg/space/triangle3.h	/^  inline const CoordType &  P( const int j ) const { return _v[j];}$/;"	f	class:vcg::Triangle3
P	vcglib/wrap/gl/tetramesh.h	/^			Point3x P;$/;"	m	class:vcg::tetra::GlTetramesh::ClipPlane
P	vcglib/wrap/opensg/vertex_component.h	/^	CoordType & P() { assert(0); return CoordType(); }$/;"	f	class:vcg::vert::EmptyOSGCoord
P	vcglib/wrap/opensg/vertex_component.h	/^	CoreType & P() $/;"	f	class:vcg::vert::OSGCoord
P	vcglib/wrap/opensg/vertex_component.h	/^	const CoordType & P() const { assert(0); return CoordType(); }$/;"	f	class:vcg::vert::EmptyOSGCoord
P0	vcglib/vcg/simplex/edge/component.h	/^	inline       typename T::CoordType &  P0( const int j )       { return V(j)->P();}$/;"	f	class:vcg::edge::VertexRef
P0	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::CoordType &  P0( const int j ) const { return V(j)->P();}$/;"	f	class:vcg::edge::VertexRef
P0	vcglib/vcg/simplex/face/component.h	/^  inline       CoordType &  P0( const int j )       { return V(j)->P();}$/;"	f	class:vcg::face::VertexRef
P0	vcglib/vcg/simplex/face/component_occ.h	/^	inline       	CoordType &  P0( const int j )       { return V(j)->P();}$/;"	f	class:vcg::face::VertexRefOcc
P0	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	CoordType &  P0( const int j ) const { return V(j)->P();}$/;"	f	class:vcg::face::VertexRefOcc
P0	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        CoordType & P0( const int j )       { return V(j)->P();}$/;"	f	class:vcg::face::PFVAdj
P0	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline       typename T::CoordType &  P0( const int j )       { return V(j)->P();}$/;"	f	class:vcg::tetra::VertexRef
P0	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::CoordType &  P0( const int j ) const { return V(j)->P();}$/;"	f	class:vcg::tetra::VertexRef
P0	vcglib/vcg/space/segment2.h	/^  inline PointType &P0() { return _p0; }$/;"	f	class:vcg::Segment2
P0	vcglib/vcg/space/segment2.h	/^  inline const PointType &P0() const { return _p0; }$/;"	f	class:vcg::Segment2
P0	vcglib/vcg/space/segment3.h	/^  inline PointType &P0() { return _p0; }$/;"	f	class:vcg::Segment3
P0	vcglib/vcg/space/segment3.h	/^  inline const PointType &P0() const { return _p0; }$/;"	f	class:vcg::Segment3
P0	vcglib/vcg/space/tetra3.h	/^	inline CoordType & P0( const int j ) { return _v[j];}$/;"	f	class:vcg::Tetra3
P0	vcglib/vcg/space/tetra3.h	/^	inline const CoordType &  P0( const int j ) const { return _v[j];}$/;"	f	class:vcg::Tetra3
P0	vcglib/vcg/space/triangle2.h	/^	inline CoordType & P0( const int j ) { return _v[j];}$/;"	f	class:vcg::Triangle2
P0	vcglib/vcg/space/triangle2.h	/^	inline const CoordType &  P0( const int j ) const { return _v[j];}$/;"	f	class:vcg::Triangle2
P0	vcglib/vcg/space/triangle3.h	/^  inline CoordType & P0( const int j ) { return _v[j];}$/;"	f	class:vcg::Triangle3
P0	vcglib/vcg/space/triangle3.h	/^  inline const CoordType &  P0( const int j ) const { return _v[j];}$/;"	f	class:vcg::Triangle3
P1	vcglib/vcg/complex/algorithms/inertia.h	/^ double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;$/;"	m	class:vcg::tri::Inertia
P1	vcglib/vcg/simplex/edge/component.h	/^	inline       typename T::CoordType &  P1( const int j )       { return V((j+1)%2)->P();}$/;"	f	class:vcg::edge::VertexRef
P1	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::CoordType &  P1( const int j ) const { return V((j+1)%2)->P();}$/;"	f	class:vcg::edge::VertexRef
P1	vcglib/vcg/simplex/face/component.h	/^  inline       CoordType &  P1( const int j )       { return V((j+1)%3)->P();}$/;"	f	class:vcg::face::VertexRef
P1	vcglib/vcg/simplex/face/component_occ.h	/^	inline       	CoordType &  P1( const int j )       { return V((j+1)%3)->P();}$/;"	f	class:vcg::face::VertexRefOcc
P1	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	CoordType &  P1( const int j ) const { return V((j+1)%3)->P();}$/;"	f	class:vcg::face::VertexRefOcc
P1	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        CoordType & P1( const int j )       { return V((j+1)%this->VN())->P();}$/;"	f	class:vcg::face::PFVAdj
P1	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline       typename T::CoordType &  P1( const int j )       { return V((j+1)%4)->P();}$/;"	f	class:vcg::tetra::VertexRef
P1	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::CoordType &  P1( const int j ) const { return V((j+1)%4)->P();}$/;"	f	class:vcg::tetra::VertexRef
P1	vcglib/vcg/space/segment2.h	/^  inline PointType &P1() { return _p1; }$/;"	f	class:vcg::Segment2
P1	vcglib/vcg/space/segment2.h	/^  inline const PointType &P1() const { return _p1; }$/;"	f	class:vcg::Segment2
P1	vcglib/vcg/space/segment3.h	/^  inline PointType &P1() { return _p1; }$/;"	f	class:vcg::Segment3
P1	vcglib/vcg/space/segment3.h	/^  inline const PointType &P1() const { return _p1; }$/;"	f	class:vcg::Segment3
P1	vcglib/vcg/space/tetra3.h	/^	inline CoordType & P1( const int j ) { return _v[(j+1)%4];}$/;"	f	class:vcg::Tetra3
P1	vcglib/vcg/space/tetra3.h	/^	inline const CoordType &  P1( const int j ) const { return _v[(j+1)%4];}$/;"	f	class:vcg::Tetra3
P1	vcglib/vcg/space/triangle2.h	/^	inline CoordType & P1( const int j ) { return _v[(j+1)%3];}$/;"	f	class:vcg::Triangle2
P1	vcglib/vcg/space/triangle2.h	/^	inline const CoordType &  P1( const int j ) const { return _v[(j+1)%3];}$/;"	f	class:vcg::Triangle2
P1	vcglib/vcg/space/triangle3.h	/^  inline CoordType & P1( const int j ) { return _v[(j+1)%3];}$/;"	f	class:vcg::Triangle3
P1	vcglib/vcg/space/triangle3.h	/^  inline const CoordType &  P1( const int j ) const { return _v[(j+1)%3];}$/;"	f	class:vcg::Triangle3
P2	vcglib/vcg/simplex/face/component.h	/^  inline       CoordType &  P2( const int j )       { return V((j+2)%3)->P();}$/;"	f	class:vcg::face::VertexRef
P2	vcglib/vcg/simplex/face/component_occ.h	/^	inline       	CoordType &  P2( const int j )       { return V((j+2)%3)->P();}$/;"	f	class:vcg::face::VertexRefOcc
P2	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	CoordType &  P2( const int j ) const { return V((j+2)%3)->P();}$/;"	f	class:vcg::face::VertexRefOcc
P2	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        CoordType & P2( const int j )       { return V((j+2)%this->VN())->P();}$/;"	f	class:vcg::face::PFVAdj
P2	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline       typename T::CoordType &  P2( const int j )       { return V((j+2)%4)->P();}$/;"	f	class:vcg::tetra::VertexRef
P2	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::CoordType &  P2( const int j ) const { return V((j+2)%4)->P();}$/;"	f	class:vcg::tetra::VertexRef
P2	vcglib/vcg/space/tetra3.h	/^	inline CoordType & P2( const int j ) { return _v[(j+2)%4];}$/;"	f	class:vcg::Tetra3
P2	vcglib/vcg/space/tetra3.h	/^	inline const CoordType &  P2( const int j ) const { return _v[(j+2)%4];}$/;"	f	class:vcg::Tetra3
P2	vcglib/vcg/space/triangle2.h	/^	inline CoordType & P2( const int j ) { return _v[(j+2)%3];}$/;"	f	class:vcg::Triangle2
P2	vcglib/vcg/space/triangle2.h	/^	inline const CoordType &  P2( const int j ) const { return _v[(j+2)%3];}$/;"	f	class:vcg::Triangle2
P2	vcglib/vcg/space/triangle3.h	/^  inline CoordType & P2( const int j ) { return _v[(j+2)%3];}$/;"	f	class:vcg::Triangle3
P2	vcglib/vcg/space/triangle3.h	/^  inline const CoordType &  P2( const int j ) const { return _v[(j+2)%3];}$/;"	f	class:vcg::Triangle3
P3	vcglib/vcg/space/tetra3.h	/^  inline CoordType & P3( const int j ) { return _v[(j+3)%4];}$/;"	f	class:vcg::Tetra3
P3	vcglib/vcg/space/tetra3.h	/^  inline const CoordType &  P3( const int j ) const { return _v[(j+3)%4];}$/;"	f	class:vcg::Tetra3
PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
PAIR	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  enum{ PAIR, AROUND , NOTHING } mode;$/;"	e	enum:vcg::tri::BitQuad::Pos::__anon479
PAIte	vcglib/vcg/complex/allocate.h	/^            typedef typename std::set<PointerToAttribute >::iterator PAIte;$/;"	t	class:vcg::tri::Allocator
PALIGN_NEON	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^#define PALIGN_NEON(/;"	d
PALIGN_NEON	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^#undef PALIGN_NEON$/;"	d
PAL_RGB	vcglib/vcg/space/colorspace.h	/^		PAL_RGB = 11,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
PARAM_STATS_H	vcglib/wrap/miq/core/param_stats.h	/^#define PARAM_STATS_H$/;"	d
PC_Chord	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_Chord() : mark(std::numeric_limits<unsigned long>::max()), q(PC_VOID), prev(NULL), next(NULL) { }$/;"	f	struct:vcg::tri::PolychordCollapse::PC_Chord
PC_Chord	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  struct PC_Chord {$/;"	s	class:vcg::tri::PolychordCollapse
PC_Chords	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_Chords (const PolyMeshType &mesh) : _Chords(2*mesh.face.size()), _currentChord(NULL) {$/;"	f	class:vcg::tri::PolychordCollapse::PC_Chords
PC_Chords	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  class PC_Chords {$/;"	c	class:vcg::tri::PolychordCollapse
PC_NOLINKCOND	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_NOLINKCOND = 4,$/;"	e	enum:vcg::tri::PolychordCollapse::PC_ResultCode
PC_NOTMANIF	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_NOTMANIF = 1,$/;"	e	enum:vcg::tri::PolychordCollapse::PC_ResultCode
PC_NOTQUAD	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_NOTQUAD = 2,$/;"	e	enum:vcg::tri::PolychordCollapse::PC_ResultCode
PC_ResultCode	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  enum PC_ResultCode {$/;"	g	class:vcg::tri::PolychordCollapse
PC_SELFINTERSECT	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_SELFINTERSECT = 16,$/;"	e	enum:vcg::tri::PolychordCollapse::PC_ResultCode
PC_SINGBOTH	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_SINGBOTH = 8,$/;"	e	enum:vcg::tri::PolychordCollapse::PC_ResultCode
PC_SUCCESS	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_SUCCESS = 0,$/;"	e	enum:vcg::tri::PolychordCollapse::PC_ResultCode
PC_VOID	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_VOID = 32$/;"	e	enum:vcg::tri::PolychordCollapse::PC_ResultCode
PD1	vcglib/vcg/simplex/face/component.h	/^  Point3f &PD1()       { static Point3f dummy(0,0,0); assert(0); return dummy;}$/;"	f	class:vcg::face::EmptyCore
PD1	vcglib/vcg/simplex/face/component.h	/^  VecType &PD1()       { return _curv.max_dir;}$/;"	f	class:vcg::face::CurvatureDir
PD1	vcglib/vcg/simplex/face/component_ocf.h	/^  VecType &PD1()       {$/;"	f	class:vcg::face::CurvatureDirOcf
PD1	vcglib/vcg/simplex/vertex/component.h	/^	VecType &PD1(){ return _curv.max_dir;}$/;"	f	class:vcg::vertex::CurvatureDir
PD1	vcglib/vcg/simplex/vertex/component.h	/^  VecType &PD1()       {static VecType v(0,0,0); assert(0);return v;}$/;"	f	class:vcg::vertex::EmptyCore
PD1	vcglib/vcg/simplex/vertex/component_occ.h	/^	VecType &PD1(){ return CAT< vector_occ<VertType>,CurvatureDirTypeOcc>::Instance()->Get((VertType*)this).max_dir;}$/;"	f	class:vcg::vertex::CurvatureDirOcc
PD1	vcglib/vcg/simplex/vertex/component_ocf.h	/^  VecType &PD1()       { assert((*this).Base().CurvatureDirEnabled); return (*this).Base().CuDV[(*this).Index()].max_dir;}$/;"	f	class:vcg::vertex::CurvatureDirOcf
PD2	vcglib/vcg/simplex/face/component.h	/^  Point3f &PD2()       { static Point3f dummy(0,0,0); assert(0); return dummy;}$/;"	f	class:vcg::face::EmptyCore
PD2	vcglib/vcg/simplex/face/component.h	/^  VecType &PD2()       { return _curv.min_dir;}$/;"	f	class:vcg::face::CurvatureDir
PD2	vcglib/vcg/simplex/face/component_ocf.h	/^  VecType &PD2()       {$/;"	f	class:vcg::face::CurvatureDirOcf
PD2	vcglib/vcg/simplex/vertex/component.h	/^	VecType &PD2(){ return _curv.min_dir;}$/;"	f	class:vcg::vertex::CurvatureDir
PD2	vcglib/vcg/simplex/vertex/component.h	/^  VecType &PD2()       {static VecType v(0,0,0); assert(0);return v;}$/;"	f	class:vcg::vertex::EmptyCore
PD2	vcglib/vcg/simplex/vertex/component_occ.h	/^	VecType &PD2(){ return CAT< vector_occ<VertType>,CurvatureDirTypeOcc>::Instance()->Get((VertType*)this).min_dir;}$/;"	f	class:vcg::vertex::CurvatureDirOcc
PD2	vcglib/vcg/simplex/vertex/component_ocf.h	/^  VecType &PD2()       { assert((*this).Base().CurvatureDirEnabled); return (*this).Base().CuDV[(*this).Index()].min_dir;}$/;"	f	class:vcg::vertex::CurvatureDirOcf
PDFaceInfo	vcglib/vcg/complex/algorithms/smooth.h	/^  PDFaceInfo(){}$/;"	f	class:vcg::tri::Smooth::PDFaceInfo
PDFaceInfo	vcglib/vcg/complex/algorithms/smooth.h	/^  PDFaceInfo(const CoordType &_m):m(_m){}$/;"	f	class:vcg::tri::Smooth::PDFaceInfo
PDFaceInfo	vcglib/vcg/complex/algorithms/smooth.h	/^class PDFaceInfo$/;"	c	class:vcg::tri::Smooth
PDVertInfo	vcglib/vcg/complex/algorithms/smooth.h	/^class PDVertInfo$/;"	c	class:vcg::tri::Smooth
PDistFunct	vcglib/vcg/complex/algorithms/closest.h	/^			typedef vcg::face::PointDistanceEPFunctor<typename MESH::ScalarType> PDistFunct;$/;"	t	class:vcg::tri::ClosestFaceEPIterator
PERMUTE	vcglib/wrap/system/getopt.cpp	/^  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER$/;"	e	enum:__anon528	file:
PERPOINTS	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^enum DrawMode{SMOOTH=0,PERPOINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:DrawMode	file:
PERSPECTIVE	vcglib/vcg/math/camera.h	/^        PERSPECTIVE =	0,$/;"	e	enum:vcg::Camera::__anon485
PERWEDGEATTRIBUTETYPE	vcglib/wrap/dae/poly_triangulator.h	/^		enum PERWEDGEATTRIBUTETYPE {NONE = 0,NORMAL = 1,MULTITEXTURECOORD = 2,MULTICOLOR = 4};$/;"	g	class:vcg::tri::io::PolygonalMesh
PEdge	vcglib/vcg/complex/algorithms/update/topology.h	/^  PEdge() {}$/;"	f	class:vcg::tri::UpdateTopology::PEdge
PEdge	vcglib/vcg/complex/algorithms/update/topology.h	/^class PEdge$/;"	c	class:vcg::tri::UpdateTopology
PEdgeTex	vcglib/vcg/complex/algorithms/update/topology.h	/^  PEdgeTex() {}$/;"	f	class:vcg::tri::UpdateTopology::PEdgeTex
PEdgeTex	vcglib/vcg/complex/algorithms/update/topology.h	/^class PEdgeTex$/;"	c	class:vcg::tri::UpdateTopology
PFEAdj	vcglib/vcg/simplex/face/component_polygon.h	/^  PFEAdj(){_fepP = NULL;  }$/;"	f	class:vcg::face::PFEAdj
PFEAdj	vcglib/vcg/simplex/face/component_polygon.h	/^template <class T> class PFEAdj: public T {$/;"	c	namespace:vcg::face
PFFAdj	vcglib/vcg/simplex/face/component_polygon.h	/^  PFFAdj(){_ffpP = NULL; _ffiP = NULL; }$/;"	f	class:vcg::face::PFFAdj
PFFAdj	vcglib/vcg/simplex/face/component_polygon.h	/^template <class T> class PFFAdj: public T {$/;"	c	namespace:vcg::face
PFHAdj	vcglib/vcg/simplex/face/component_polygon.h	/^  PFHAdj(){_fhP = NULL;  }$/;"	f	class:vcg::face::PFHAdj
PFHAdj	vcglib/vcg/simplex/face/component_polygon.h	/^template <class T> class PFHAdj: public T {$/;"	c	namespace:vcg::face
PFVAdj	vcglib/vcg/simplex/face/component_polygon.h	/^  PFVAdj(){_vpoly = NULL;}$/;"	f	class:vcg::face::PFVAdj
PFVAdj	vcglib/vcg/simplex/face/component_polygon.h	/^template <class T> class PFVAdj: public T {$/;"	c	namespace:vcg::face
PFace	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  class PFace   : public vcg::Face<   PUsedTypes> {};$/;"	c	class:vcg::tri::FourPCS
PINUSE_BIT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define PINUSE_BIT /;"	d	file:
PLAY	vcglib/wrap/gui/trackrecorder.h	/^	enum { PLAY,REC,OFF } mode;$/;"	e	enum:vcg::TrackRecorder::__anon521
PMesh	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  class PMesh   : public vcg::tri::TriMesh< std::vector<PVertex>, std::vector<PFace> > {};$/;"	c	class:vcg::tri::FourPCS
POINTS	vcglib/apps/sample/trimesh_QT/glarea.h	/^  enum DrawMode{SMOOTH=0,POINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:GLArea::DrawMode
POINT_IN_TRI	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define POINT_IN_TRI(/;"	d
POINT_IN_TRI	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef POINT_IN_TRI$/;"	d
POLAR_DECOMPOSITION_VCG	vcglib/vcg/math/polar_decomposition.h	/^#define POLAR_DECOMPOSITION_VCG$/;"	d
POLYGON_POLYCHORD_COLLAPSE_H	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^#define POLYGON_POLYCHORD_COLLAPSE_H$/;"	d
POLYTOQIMAGE_H	vcglib/wrap/qt/Outline2ToQImage.h	/^#define POLYTOQIMAGE_H$/;"	d
POLY_TRIANGULATOR_H	vcglib/wrap/dae/poly_triangulator.h	/^#define POLY_TRIANGULATOR_H$/;"	d
POSITION_PER_VERTEX	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            POSITION_PER_VERTEX = (1 << 0),$/;"	e	enum:vcg::tri::AttributeSeam::ASMask
POSTACTION	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define POSTACTION(/;"	d	file:
POSTYPE	vcglib/vcg/simplex/edge/pos.h	/^	typedef Pos< EDGETYPE> POSTYPE;$/;"	t	class:vcg::edge::Pos
PQueueType	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^		typedef std::priority_queue<ClosestObjType, std::deque<ClosestObjType>, CompareClosest> PQueueType;$/;"	t	class:vcg::AABBBinaryTreeKClosest
PREACTION	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define PREACTION(/;"	d	file:
PRINT_EVERY_N_ELEMENTS	vcglib/apps/metro/metro.cpp	/^#define PRINT_EVERY_N_ELEMENTS /;"	d	file:
PRINT_EVERY_N_ELEMENTS	vcglib/apps/trimeshinfo/defs.h	/^#define PRINT_EVERY_N_ELEMENTS /;"	d
PRINT_EVERY_N_ELEMENTS	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define PRINT_EVERY_N_ELEMENTS /;"	d
PROCEED_ON_ERROR	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define PROCEED_ON_ERROR /;"	d	file:
PROPHOTO	vcglib/vcg/space/colorspace.h	/^		PROPHOTO = 12,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
PSDist	vcglib/vcg/space/deprecated_point3.h	/^P3ScalarType PSDist( const Point3<P3ScalarType> & p,$/;"	f	namespace:vcg
PSDist	vcglib/vcg/space/point3.h	/^Scalar PSDist( const Point3<Scalar> & p,$/;"	f	namespace:vcg
PS_Base	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef PolynomialSolverBase<_Scalar,1>    PS_Base;$/;"	t	class:Eigen::PolynomialSolver
PS_Base	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef PolynomialSolverBase<_Scalar,_Deg>    PS_Base;$/;"	t	class:Eigen::PolynomialSolver
PTHREAD_MUTEX_RECURSIVE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define PTHREAD_MUTEX_RECURSIVE /;"	d	file:
PTag	vcglib/wrap/dae/colladaformat.h	/^		PTag(const MESHTYPE& m,const unsigned int nedge,QVector<int>& patchfaces,bool vcol = false, bool norm = false,bool texcoord = false)$/;"	f	class:Collada::Tags::PTag
PTag	vcglib/wrap/dae/colladaformat.h	/^		PTag(const MESHTYPE& m,const unsigned int nedge,bool vcol=false, bool norm = false,bool texcoord = false)$/;"	f	class:Collada::Tags::PTag
PTag	vcglib/wrap/dae/colladaformat.h	/^	class PTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
PToIP	vcglib/vcg/space/index/grid_util.h	/^	inline void PToIP(const CoordType & p, Point3i &pi ) const$/;"	f	class:vcg::BasicGrid
PToIP	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		inline void PToIP(const CoordType & p, Point2i &pi ) const$/;"	f	class:vcg::BasicGrid2D
PUsedTypes	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  class PUsedTypes: public vcg::UsedTypes < vcg::Use<PVertex>::template AsVertexType,$/;"	c	class:vcg::tri::FourPCS
PVFAdj	vcglib/vcg/simplex/face/component_polygon.h	/^  PVFAdj(){_vfiP = NULL; _vfiP = NULL;}$/;"	f	class:vcg::face::PVFAdj
PVFAdj	vcglib/vcg/simplex/face/component_polygon.h	/^template <class T> class PVFAdj: public T {$/;"	c	namespace:vcg::face
PVertex	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  class PVertex : public vcg::Vertex< PUsedTypes,vcg::vertex::BitFlags,vcg::vertex::Coord3f ,vcg::vertex::Mark>{};$/;"	c	class:vcg::tri::FourPCS
PVertexEdge	vcglib/vcg/complex/algorithms/update/topology.h	/^  PVertexEdge(  ) {}$/;"	f	class:vcg::tri::UpdateTopology::PVertexEdge
PVertexEdge	vcglib/vcg/complex/algorithms/update/topology.h	/^  PVertexEdge( EdgePointer  pe, const int nz )$/;"	f	class:vcg::tri::UpdateTopology::PVertexEdge
PVertexEdge	vcglib/vcg/complex/algorithms/update/topology.h	/^class PVertexEdge$/;"	c	class:vcg::tri::UpdateTopology
Pa	vcglib/vcg/complex/algorithms/inertia.h	/^ double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;$/;"	m	class:vcg::tri::Inertia
Paa	vcglib/vcg/complex/algorithms/inertia.h	/^ double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;$/;"	m	class:vcg::tri::Inertia
Paaa	vcglib/vcg/complex/algorithms/inertia.h	/^ double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;$/;"	m	class:vcg::tri::Inertia
Paab	vcglib/vcg/complex/algorithms/inertia.h	/^ double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;$/;"	m	class:vcg::tri::Inertia
Pab	vcglib/vcg/complex/algorithms/inertia.h	/^ double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;$/;"	m	class:vcg::tri::Inertia
Pabb	vcglib/vcg/complex/algorithms/inertia.h	/^ double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;$/;"	m	class:vcg::tri::Inertia
Pack	vcglib/vcg/space/rasterized_outline2_packer.h	/^    static bool Pack(std::vector< std::vector< Point2x>  > &polyPointsVec,$/;"	f	class:vcg::RasterizedOutline2Packer
Pack	vcglib/vcg/space/rect_packer.h	/^  static  bool Pack(const std::vector<Box2x > & rectVec,  \/\/\/ the set of rectangles that have to be packed (generic floats, no req.)$/;"	f	class:vcg::RectPacker
PackAsAxisAlignedRect	vcglib/vcg/space/outline2_packer.h	/^static bool PackAsAxisAlignedRect(const std::vector< std::vector<Point2x> > &polyVec,$/;"	f	class:vcg::PolyPacker
PackAsEqualSquares	vcglib/vcg/space/outline2_packer.h	/^static  bool PackAsEqualSquares(const std::vector< std::vector<Point2x> > &polyVec,$/;"	f	class:vcg::PolyPacker
PackAsObjectOrientedRect	vcglib/vcg/space/outline2_packer.h	/^static bool PackAsObjectOrientedRect(const std::vector< std::vector<Point2x> > &polyVec,$/;"	f	class:vcg::PolyPacker
PackInt	vcglib/vcg/space/rect_packer.h	/^static bool PackInt(const std::vector<vcg::Point2i> & sizes, \/\/ the sizes of the rect to be packed$/;"	f	class:vcg::RectPacker
PackIntMulti	vcglib/vcg/space/rect_packer.h	/^static bool PackIntMulti( const std::vector<Point2i> & sizes,$/;"	f	class:vcg::RectPacker
PackMulti	vcglib/vcg/space/rect_packer.h	/^static  bool PackMulti(const std::vector<Box2x > & rectVec,  \/\/\/ the set of rectangles that have to be packed (generic floats, no req.)$/;"	f	class:vcg::RectPacker
PackMultiAsObjectOrientedRect	vcglib/vcg/space/outline2_packer.h	/^static bool PackMultiAsObjectOrientedRect(const std::vector< std::vector<Point2x> > &polyVec,$/;"	f	class:vcg::PolyPacker
PackOccupancy	vcglib/vcg/space/rect_packer.h	/^static  bool PackOccupancy(const std::vector<Box2x > & rectVec,  \/\/\/ the set of rectangles that have to be packed$/;"	f	class:vcg::RectPacker
PackOccupancyMulti	vcglib/vcg/space/rect_packer.h	/^static  bool PackOccupancyMulti(const std::vector<Box2x > & rectVec,  \/\/\/ the set of rectangles that have to be packed$/;"	f	class:vcg::RectPacker
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op_impl
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_acos_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_add_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_asin_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_constant_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_cos_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_exp_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_log_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_multiple_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_quotient1_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sin_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sqrt_op
Packet	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_tan_op
Packet	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SelfCwiseBinaryOp
Packet	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SwapWrapper
Packet	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::PacketScalar Packet;$/;"	t	struct:Eigen::internal::product_coeff_impl
Packet	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::gemm_pack_rhs
Packet16uc	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned char  Packet16uc;$/;"	t	namespace:Eigen::internal
Packet1cd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const __m128d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet2cf	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const __m128& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2d	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128d Packet2d;$/;"	t	namespace:Eigen::internal
Packet4bi	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector __bool int     Packet4bi;$/;"	t	namespace:Eigen::internal
Packet4f	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector float          Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef float32x4_t Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128  Packet4f;$/;"	t	namespace:Eigen::internal
Packet4i	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector int            Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef int32x4_t   Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128i Packet4i;$/;"	t	namespace:Eigen::internal
Packet4ui	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned int   Packet4ui;$/;"	t	namespace:Eigen::internal
Packet4ui	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef uint32x4_t  Packet4ui;$/;"	t	namespace:Eigen::internal
Packet8i	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector short int      Packet8i;$/;"	t	namespace:Eigen::internal
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon81
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon82
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon74
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasACos$/;"	e	enum:Eigen::internal::functor_traits::__anon110
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasASin$/;"	e	enum:Eigen::internal::functor_traits::__anon111
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAbs$/;"	e	enum:Eigen::internal::functor_traits::__anon84
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAdd$/;"	e	enum:Eigen::internal::functor_traits::__anon70
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasConj$/;"	e	enum:Eigen::internal::functor_traits::__anon86
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasCos$/;"	e	enum:Eigen::internal::functor_traits::__anon107
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasDiv$/;"	e	enum:Eigen::internal::functor_traits::__anon80
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMax$/;"	e	enum:Eigen::internal::functor_traits::__anon76
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMin$/;"	e	enum:Eigen::internal::functor_traits::__anon75
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasNegate };$/;"	e	enum:Eigen::internal::functor_traits::__anon83
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSin$/;"	e	enum:Eigen::internal::functor_traits::__anon108
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSqrt$/;"	e	enum:Eigen::internal::functor_traits::__anon106
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSub$/;"	e	enum:Eigen::internal::functor_traits::__anon79
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasTan$/;"	e	enum:Eigen::internal::functor_traits::__anon109
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    PacketAccess = scalar_product_op<LhsScalar,RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon72
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon78
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon77
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon134
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon135
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon136
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon137
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon88
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon89
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon90
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon91
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon132
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon133
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon121
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon122
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon123
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon124
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon125
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon126
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon127
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon128
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon129
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon99
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon97
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon96
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon115
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon112
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon92
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon93
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon95
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon98
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon105
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon85
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon113
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon114
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon94
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon118
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon119
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon120
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon116
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon117
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon139
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon138
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon130
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon131
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon87
PacketAccess	vcglib/eigenlib/Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon222
PacketAccessBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int PacketAccessBit = 0x8;$/;"	m	namespace:Eigen
PacketReturnType	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::DenseCoeffsBase
PacketReturnType	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::SparseMatrixBase
PacketScalar	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::ArrayBase
PacketScalar	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseBase
PacketScalar	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseCoeffsBase
PacketScalar	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename Base::PacketScalar PacketScalar;$/;"	t	class:Eigen::MapBase
PacketScalar	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MapBase
PacketScalar	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MatrixBase
PacketScalar	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::PlainObjectBase
PacketScalar	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_impl
PacketScalar	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller
PacketScalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::SparseMatrixBase
PacketSize	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::LLT::__anon6
PacketSize	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size$/;"	e	enum:Eigen::internal::assign_traits::__anon35
PacketSize	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<Scalar>::size,$/;"	e	enum:Eigen::internal::redux_impl::__anon232
PacketSize	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_traits::__anon223
PacketSize	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon230
PacketSize	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::Reverse::__anon237
PacketSize	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon195
PacketSize	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_impl::__anon197
PacketSize	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_vectorized_unroller::__anon196
PacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon203
PacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon204
PacketSize	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::symm_pack_rhs::__anon212
PacketSize	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::SVD::__anon349
Paint	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    void Paint()$/;"	f	class:OverlapEstimation
PanMode	vcglib/wrap/gui/trackmode.h	/^class PanMode:public TrackMode {$/;"	c	namespace:vcg
Param	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  struct Param$/;"	s	class:vcg::tri::FourPCS
Param	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    Param():$/;"	f	struct:vcg::tri::PointCloudNormal::Param
Param	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^  struct Param$/;"	s	class:vcg::tri::PointCloudNormal
Param	vcglib/wrap/qt/Outline2ToQImage.h	/^      Param()$/;"	f	class:Outline2Dumper::Param
Param	vcglib/wrap/qt/Outline2ToQImage.h	/^  class Param$/;"	c	class:Outline2Dumper
ParamTag	vcglib/wrap/dae/colladaformat.h	/^		ParamTag(const QString& name,const QString& type)$/;"	f	class:Collada::Tags::ParamTag
ParamTag	vcglib/wrap/dae/colladaformat.h	/^	class ParamTag : public XMLTag$/;"	c	namespace:Collada::Tags
ParamType	vcglib/vcg/math/eigen_matrix_addons.h	/^typedef vcg::VoidType   ParamType;$/;"	t
ParamType	vcglib/vcg/space/box.h	/^	typedef Point<N,S> ParamType;$/;"	t	class:vcg::Box
ParamType	vcglib/vcg/space/deprecated_point.h	/^	typedef VoidType   ParamType;$/;"	t	class:vcg::ndim::Point
Parameter	vcglib/wrap/gl/shaders.h	/^	void Parameter(GLenum pname, int value)$/;"	f	class:Program
ParameterType	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Array<Index,64,1,DontAlign> ParameterType;$/;"	t	class:Eigen::PardisoImpl
Parameters	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Parameters()$/;"	f	struct:Eigen::HybridNonLinearSolver::Parameters
Parameters	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    struct Parameters {$/;"	s	class:Eigen::HybridNonLinearSolver
Parameters	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Parameters()$/;"	f	struct:Eigen::LevenbergMarquardt::Parameters
Parameters	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    struct Parameters {$/;"	s	class:Eigen::LevenbergMarquardt
Parameters	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        Parameters()$/;"	f	class:OverlapEstimation::Parameters
Parameters	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    class Parameters$/;"	c	class:OverlapEstimation
Parameters	vcglib/vcg/space/rasterized_outline2_packer.h	/^      Parameters()$/;"	f	class:vcg::RasterizedOutline2Packer::Parameters
Parameters	vcglib/vcg/space/rasterized_outline2_packer.h	/^  class Parameters$/;"	c	class:vcg::RasterizedOutline2Packer
Parametrize	vcglib/wrap/miq/MIQ.h	/^  static void Parametrize(MeshType &mesh,StiffMode stiffMode,$/;"	f	class:MIQ_parametrization
ParametrizedLine	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define ParametrizedLine /;"	d
ParametrizedLine	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef ParametrizedLine$/;"	d
ParametrizedLine	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(int _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
ParametrizedLine	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(Index _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
ParametrizedLine	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim,_Options>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine
Params	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  static TriEdgeCollapseQuadricTexParameter & Params(){static TriEdgeCollapseQuadricTexParameter p; return p;}$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
ParamsOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf    <BoundBuffer> { typedef BufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundFeedbackBuffer> { typedef FeedbackBufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundIndexBuffer> { typedef IndexBufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundPixelPackBuffer> { typedef PixelPackBufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundPixelUnpackBuffer> { typedef PixelUnpackBufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundUniformBuffer> { typedef UniformBufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundVertexBuffer> { typedef VertexBufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ParamsOf    <BoundFragmentShader> { typedef FragmentShaderBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf    <BoundFramebuffer> { typedef FramebufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf   <BoundDrawFramebuffer> { typedef DrawFramebufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf   <BoundReadDrawFramebuffer> { typedef ReadDrawFramebufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf   <BoundReadFramebuffer> { typedef ReadFramebufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ParamsOf    <BoundGeometryShader> { typedef GeometryShaderBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ParamsOf    <BoundObject> { typedef ObjectBindingParams         Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ParamsOf { typedef NoType Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ParamsOf    <BoundProgram> { typedef ProgramBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ParamsOf    <BoundRenderable> { typedef RenderableBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ParamsOf    <BoundRenderbuffer> { typedef RenderbufferBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ParamsOf    <BoundShader> { typedef ShaderBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ParamsOf    <BoundTexture> { typedef TextureBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ParamsOf    <BoundTexture2D> { typedef Texture2DBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ParamsOf    <BoundTextureCube> { typedef TextureCubeBindingParams Type; }; };$/;"	s	namespace:glw::detail
ParamsOf	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ParamsOf    <BoundVertexShader> { typedef VertexShaderBindingParams Type; }; };$/;"	s	namespace:glw::detail
PardisoImpl	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl()$/;"	f	class:Eigen::PardisoImpl
PardisoImpl	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl(PardisoImpl &) {}$/;"	f	class:Eigen::PardisoImpl
PardisoImpl	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoImpl$/;"	c	namespace:Eigen
PardisoLDLT	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT()$/;"	f	class:Eigen::PardisoLDLT
PardisoLDLT	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(PardisoLDLT& ) {}$/;"	f	class:Eigen::PardisoLDLT
PardisoLDLT	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT
PardisoLDLT	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLDLT : public PardisoImpl< PardisoLDLT<MatrixType,Options> >$/;"	c	namespace:Eigen
PardisoLLT	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT()$/;"	f	class:Eigen::PardisoLLT
PardisoLLT	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(PardisoLLT& ) {}$/;"	f	class:Eigen::PardisoLLT
PardisoLLT	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT
PardisoLLT	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLLT : public PardisoImpl< PardisoLLT<MatrixType,_UpLo> >$/;"	c	namespace:Eigen
PardisoLU	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU()$/;"	f	class:Eigen::PardisoLU
PardisoLU	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(PardisoLU& ) {}$/;"	f	class:Eigen::PardisoLU
PardisoLU	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU
PardisoLU	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLU : public PardisoImpl< PardisoLU<MatrixType> >$/;"	c	namespace:Eigen
Parent	vcglib/vcg/space/index/octree_template.h	/^	inline NodePointer	Parent(const NodePointer n) const	{ return n->parent;					}$/;"	f	class:vcg::OctreeTemplate
Parent	vcglib/wrap/math/system_interface_ldl.h	/^    std::vector<int> Li,Lp,Parent,Lnz,Flag,Pattern;$/;"	m	class:SystemLDL
ParseMatrixNode	vcglib/wrap/dae/util_dae.h	/^		static void ParseMatrixNode(vcg::Matrix44f& m,const QDomNode t)$/;"	f	class:vcg::tri::io::UtilDAE
ParseRotationMatrix	vcglib/wrap/dae/util_dae.h	/^		static void ParseRotationMatrix(vcg::Matrix44f& m,const std::vector<QDomNode>& t)$/;"	f	class:vcg::tri::io::UtilDAE
ParseTranslation	vcglib/wrap/dae/util_dae.h	/^		static void ParseTranslation(vcg::Matrix44f& m,const QDomNode t)$/;"	f	class:vcg::tri::io::UtilDAE
Parseline	vcglib/wrap/io_trimesh/import_raw.h	/^static int Parseline(int tokennumber, int *tokenorder, char *rawline, float *linebuffer)$/;"	f	class:vcg::tri::io::ImporterRAW
Parselinedescription	vcglib/wrap/io_trimesh/import_raw.h	/^static int Parselinedescription(const char * linedesc, int &tokennumber, int *order)$/;"	f	class:vcg::tri::io::ImporterRAW
PartialPivLU	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU()$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(Index size)$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^template<typename _MatrixType> class PartialPivLU$/;"	c	namespace:Eigen
PartialReduxExpr	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    PartialReduxExpr(const MatrixType& mat, const MemberOp& func = MemberOp())$/;"	f	class:Eigen::PartialReduxExpr
PartialReduxExpr	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^class PartialReduxExpr : internal::no_assignment_operator,$/;"	c	namespace:Eigen
PassThrough	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	static inline unsigned int PassThrough(const NodeType * node) {$/;"	f	class:vcg::AABBBinaryTreeFrustumCull
PastixBase	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixBase() : m_initisOk(false), m_analysisIsOk(false), m_factorizationIsOk(false), m_isInitialized(false), m_pastixdata(0), m_size(0)$/;"	f	class:Eigen::PastixBase
PastixBase	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixBase : internal::noncopyable$/;"	c	namespace:Eigen
PastixLDLT	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT():Base()$/;"	f	class:Eigen::PastixLDLT
PastixLDLT	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLDLT
PastixLDLT	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLDLT : public PastixBase< PastixLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
PastixLLT	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT() : Base()$/;"	f	class:Eigen::PastixLLT
PastixLLT	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLLT
PastixLLT	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLLT : public PastixBase< PastixLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
PastixLU	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU() : Base()$/;"	f	class:Eigen::PastixLU
PastixLU	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLU
PastixLU	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLU : public PastixBase< PastixLU<_MatrixType> >$/;"	c	namespace:Eigen
PathMode	vcglib/wrap/gui/trackmode.h	/^  PathMode ( const Point3f &start, const Point3f &end )$/;"	f	class:vcg::PathMode
PathMode	vcglib/wrap/gui/trackmode.h	/^  PathMode ( const std::vector < Point3f > &pts, bool w = false)$/;"	f	class:vcg::PathMode
PathMode	vcglib/wrap/gui/trackmode.h	/^class PathMode:public TrackMode {$/;"	c	namespace:vcg
Pattern	vcglib/wrap/math/system_interface_ldl.h	/^    std::vector<int> Li,Lp,Parent,Lnz,Flag,Pattern;$/;"	m	class:SystemLDL
Pb	vcglib/vcg/complex/algorithms/inertia.h	/^ double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;$/;"	m	class:vcg::tri::Inertia
Pbb	vcglib/vcg/complex/algorithms/inertia.h	/^ double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;$/;"	m	class:vcg::tri::Inertia
Pbbb	vcglib/vcg/complex/algorithms/inertia.h	/^ double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;$/;"	m	class:vcg::tri::Inertia
PerBitQuadFaceNormalized	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerBitQuadFaceNormalized(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerEdgeAttributeHandle	vcglib/vcg/complex/base.h	/^                PerEdgeAttributeHandle( void *ah,const int & n):AttributeHandle<ATTR_TYPE,EdgeContainer>(ah,n){}$/;"	f	class:vcg::tri::TriMesh::PerEdgeAttributeHandle
PerEdgeAttributeHandle	vcglib/vcg/complex/base.h	/^        PerEdgeAttributeHandle():AttributeHandle<ATTR_TYPE,EdgeContainer>(){}$/;"	f	class:vcg::tri::TriMesh::PerEdgeAttributeHandle
PerEdgeAttributeHandle	vcglib/vcg/complex/base.h	/^    class PerEdgeAttributeHandle:  public AttributeHandle<ATTR_TYPE,EdgeContainer>{$/;"	c	class:vcg::tri::TriMesh
PerElementSystemReal	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void PerElementSystemReal(FaceType *f,$/;"	f	class:vcg::tri::PoissonSolver
PerElementSystemReal	vcglib/wrap/miq/core/poisson_solver.h	/^	void PerElementSystemReal(FaceType *f,$/;"	f	class:PoissonSolver
PerFace	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerFace(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerFaceAttributeHandle	vcglib/vcg/complex/base.h	/^                PerFaceAttributeHandle( void *ah,const int & n):AttributeHandle<ATTR_TYPE,FaceContainer>(ah,n){}$/;"	f	class:vcg::tri::TriMesh::PerFaceAttributeHandle
PerFaceAttributeHandle	vcglib/vcg/complex/base.h	/^        PerFaceAttributeHandle():AttributeHandle<ATTR_TYPE,FaceContainer>(){}$/;"	f	class:vcg::tri::TriMesh::PerFaceAttributeHandle
PerFaceAttributeHandle	vcglib/vcg/complex/base.h	/^    class PerFaceAttributeHandle: public AttributeHandle<ATTR_TYPE,FaceContainer>{$/;"	c	class:vcg::tri::TriMesh
PerFaceConstant	vcglib/vcg/complex/algorithms/update/color.h	/^  static int PerFaceConstant(MeshType &m, Color4b vs=Color4b::White,bool selected=false)$/;"	f	class:vcg::tri::UpdateColor
PerFaceCoordHandle	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    typedef typename MeshType:: template PerFaceAttributeHandle<CoordType> PerFaceCoordHandle;$/;"	t	class:vcg::tri::PoissonSolver
PerFaceDijsktraCompute	vcglib/vcg/complex/algorithms/geodesic.h	/^  static void PerFaceDijsktraCompute(MeshType &m, const std::vector<FacePointer> &seedVec,$/;"	f	class:vcg::tri::Geodesic
PerFaceFromCurrentVertexNormal	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerFaceFromCurrentVertexNormal(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerFaceFromVertex	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerFaceFromVertex( MeshType &m)$/;"	f	class:vcg::tri::UpdateColor
PerFaceMatrix	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerFaceMatrix(ComputeMeshType &m, const Matrix44<ScalarType> &mat, bool remove_scaling= true)$/;"	f	class:vcg::tri::UpdateNormal
PerFaceNormalized	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerFaceNormalized(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerFacePointerHandle	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::template PerFaceAttributeHandle<VertexPointer> PerFacePointerHandle;$/;"	t	class:vcg::tri::VoronoiProcessing
PerFaceQualityGray	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerFaceQualityGray(MeshType &m, float minq=0, float maxq=0)$/;"	f	class:vcg::tri::UpdateColor
PerFaceQualityRamp	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerFaceQualityRamp(MeshType &m, float minq=0, float maxq=0, bool selected=false)$/;"	f	class:vcg::tri::UpdateColor
PerFaceRW	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerFaceRW(ComputeMeshType &m, bool normalize=false)$/;"	f	class:vcg::tri::UpdateNormal
PerFaceRandom	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerFaceRandom(MeshType &m)$/;"	f	class:vcg::tri::UpdateColor
PerFaceRandomConnectedComponent	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerFaceRandomConnectedComponent( MeshType &m)$/;"	f	class:vcg::tri::UpdateColor
PerMeshAttributeHandle	vcglib/vcg/complex/base.h	/^        PerMeshAttributeHandle(){_handle=NULL;}$/;"	f	class:vcg::tri::TriMesh::PerMeshAttributeHandle
PerMeshAttributeHandle	vcglib/vcg/complex/base.h	/^        PerMeshAttributeHandle(void *ah,const int & n):_handle ( (Attribute<ATTR_TYPE> *)ah ),n_attr(n){}$/;"	f	class:vcg::tri::TriMesh::PerMeshAttributeHandle
PerMeshAttributeHandle	vcglib/vcg/complex/base.h	/^    class PerMeshAttributeHandle{$/;"	c	class:vcg::tri::TriMesh
PerVertUVBox	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			static vcg::Box2<ScalarType> PerVertUVBox(MeshType &m)$/;"	f	class:vcg::tri::UV_Utils
PerVertex	vcglib/vcg/complex/algorithms/update/curvature.h	/^    static void PerVertex(MeshType & m)$/;"	f	class:vcg::tri::UpdateCurvature
PerVertex	vcglib/vcg/complex/algorithms/update/normal.h	/^ static void PerVertex(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerVertexAddNoise	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerVertexAddNoise(MeshType& m, int noiseBits)$/;"	f	class:vcg::tri::UpdateColor
PerVertexAngleWeighted	vcglib/vcg/complex/algorithms/update/normal.h	/^ static void PerVertexAngleWeighted(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerVertexAttributeHandle	vcglib/vcg/complex/base.h	/^                PerVertexAttributeHandle( void *ah,const int & n):AttributeHandle<ATTR_TYPE,VertContainer>(ah,n){}$/;"	f	class:vcg::tri::TriMesh::PerVertexAttributeHandle
PerVertexAttributeHandle	vcglib/vcg/complex/base.h	/^        PerVertexAttributeHandle():AttributeHandle<ATTR_TYPE,VertContainer>(){}$/;"	f	class:vcg::tri::TriMesh::PerVertexAttributeHandle
PerVertexAttributeHandle	vcglib/vcg/complex/base.h	/^    class PerVertexAttributeHandle: public AttributeHandle<ATTR_TYPE,VertContainer>{$/;"	c	class:vcg::tri::TriMesh
PerVertexBasicRadialCrossField	vcglib/vcg/complex/algorithms/update/curvature.h	/^    static void PerVertexBasicRadialCrossField(MeshType &m, float anisotropyRatio = 1.0 )$/;"	f	class:vcg::tri::UpdateCurvature
PerVertexBoolHandle	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::template PerVertexAttributeHandle<bool> PerVertexBoolHandle;$/;"	t	class:vcg::tri::VoronoiProcessing
PerVertexBorderFlag	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerVertexBorderFlag( MeshType &m, Color4b BorderColor=Color4b::Blue, Color4b InternalColor=Color4b::White, Color4b MixColor=Color4b::Cyan)$/;"	f	class:vcg::tri::UpdateColor
PerVertexBrightness	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexBrightness(MeshType &m, float amount, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexBrightnessContrast	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexBrightnessContrast(MeshType &m, float brightness, float contrast, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexClear	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerVertexClear(ComputeMeshType &m, bool ClearAllVertNormal=false)$/;"	f	class:vcg::tri::UpdateNormal
PerVertexColourisation	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexColourisation(MeshType &m, Color4b c, float intensity, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexConstant	vcglib/vcg/complex/algorithms/update/color.h	/^  static int PerVertexConstant(MeshType &m, Color4b vs=Color4b::White,bool selected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexContrast	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexContrast(MeshType &m, float factor, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexDesaturation	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexDesaturation(MeshType &m, int method, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexDijsktraCompute	vcglib/vcg/complex/algorithms/geodesic.h	/^  static void PerVertexDijsktraCompute(MeshType &m, const std::vector<VertexPointer> &seedVec,$/;"	f	class:vcg::tri::Geodesic
PerVertexEqualize	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexEqualize(MeshType &m, unsigned int rgbMask, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexFromCurrentFaceNormal	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerVertexFromCurrentFaceNormal(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerVertexFromFace	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerVertexFromFace( MeshType &m)$/;"	f	class:vcg::tri::UpdateColor
PerVertexGamma	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexGamma(MeshType &m, float gamma, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexInvert	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexInvert(MeshType &m, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexLevels	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexLevels(MeshType &m, float gamma, float in_min, float in_max, float out_min, float out_max, unsigned char rgbMask, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexMatrix	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerVertexMatrix(ComputeMeshType &m, const Matrix44<ScalarType> &mat, bool remove_scaling= true)$/;"	f	class:vcg::tri::UpdateNormal
PerVertexNelsonMaxWeighted	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerVertexNelsonMaxWeighted(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerVertexNormalized	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerVertexNormalized(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerVertexNormalizedPerFace	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerVertexNormalizedPerFace(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerVertexNormalizedPerFaceNormalized	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerVertexNormalizedPerFaceNormalized(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerVertexPerFace	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerVertexPerFace(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateNormal
PerVertexPerlinNoise	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerVertexPerlinNoise(MeshType& m, Point3f period, Point3f offset=Point3f(0,0,0))$/;"	f	class:vcg::tri::UpdateColor
PerVertexPointerHandle	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::template PerVertexAttributeHandle<VertexPointer> PerVertexPointerHandle;$/;"	t	class:vcg::tri::VoronoiProcessing
PerVertexQualityGray	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerVertexQualityGray(MeshType &m,  float minq,  float maxq)$/;"	f	class:vcg::tri::UpdateColor
PerVertexQualityRamp	vcglib/vcg/complex/algorithms/update/color.h	/^  static void PerVertexQualityRamp(MeshType &m, float minq=0, float maxq=0)$/;"	f	class:vcg::tri::UpdateColor
PerVertexThresholding	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexThresholding(MeshType &m, float threshold, Color4b c1 = Color4<unsigned char>::Black, Color4b c2 = Color4<unsigned char>::White, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerVertexWhiteBalance	vcglib/vcg/complex/algorithms/update/color.h	/^static int PerVertexWhiteBalance(MeshType &m, Color4b userColor, const bool ProcessSelected=false)$/;"	f	class:vcg::tri::UpdateColor
PerWedgeCrease	vcglib/vcg/complex/algorithms/update/normal.h	/^static void PerWedgeCrease(ComputeMeshType &m, ScalarType angleRad)$/;"	f	class:vcg::tri::UpdateNormal
PerWedgeMakeUnitaryUV	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^		void PerWedgeMakeUnitaryUV(MeshType &m)$/;"	f	class:vcg::tri::UV_Utils
PerWedgeUVBox	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			static vcg::Box2<ScalarType> PerWedgeUVBox(MeshType &m)$/;"	f	class:vcg::tri::UV_Utils
Percentile	vcglib/vcg/math/histogram.h	/^	ScalarType Percentile(ScalarType perc)$/;"	f	class:vcg::Distribution
Percentile	vcglib/vcg/math/histogram.h	/^ScalarType Histogram<ScalarType>::Percentile(ScalarType frac) const$/;"	f	class:vcg::Histogram
PerfectHashFunction	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		typename HashTable::EntryCoordinate PerfectHashFunction(const typename UniformGrid::CellCoordinate &query)$/;"	f	class:vcg::PerfectSpatialHashing
PerfectSpatialHashing	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		PerfectSpatialHashing() { srand( (unsigned) time(NULL) ); }$/;"	f	class:vcg::PerfectSpatialHashing
PerfectSpatialHashing	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^	class PerfectSpatialHashing : public vcg::SpatialIndex< OBJECT_TYPE, SCALAR_TYPE >$/;"	c	namespace:vcg
PerformCompactConstruction	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		void PerformCompactConstruction(const int number_of_filled_cells, vcg::CallBackPos *callback)$/;"	f	class:vcg::PerfectSpatialHashing
PerformFastConstruction	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		void PerformFastConstruction(const int number_of_filled_cells, vcg::CallBackPos *callback)$/;"	f	class:vcg::PerfectSpatialHashing
Perimeter	vcglib/vcg/complex/algorithms/hole.h	/^            ScalarType Perimeter()$/;"	f	class:vcg::tri::Hole::Info
Perimeter	vcglib/vcg/space/triangle3.h	/^typename TriangleType::ScalarType Perimeter(const TriangleType &t) $/;"	f	namespace:vcg
Perlin	vcglib/vcg/math/perlin_noise.h	/^class Perlin $/;"	c	namespace:vcg::math
Perm	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef PermutationMatrix<Dynamic,Dynamic,Index> Perm;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
PermPermProduct	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	e	enum:Eigen::internal::PermPermProduct_t
PermPermProduct_t	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	g	namespace:Eigen::internal
PermutType	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,ColMajor> PermutType;$/;"	t	class:Eigen::IncompleteLUT
PermutateVertexVector	vcglib/vcg/complex/allocate.h	/^            static void PermutateVertexVector(MeshType &m, PointerUpdater<VertexPointer> &pu)$/;"	f	class:vcg::tri::Allocator
PermutationBase	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^class PermutationBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
PermutationMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(const Transpose<PermutationBase<Other> >& other)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    explicit PermutationMatrix(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    explicit inline PermutationMatrix(const MatrixBase<Other>& indices) : m_indices(indices)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix()$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationMatrix& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(int size) : m_indices(size)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^class PermutationMatrix : public PermutationBase<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	c	namespace:Eigen
PermutationPType	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationPType;$/;"	t	class:Eigen::FullPivLU
PermutationQType	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationQType;$/;"	t	class:Eigen::FullPivLU
PermutationStorage	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^struct PermutationStorage {};$/;"	s	namespace:Eigen
PermutationType	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::LDLT
PermutationType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef Derived PermutationType;$/;"	t	class:Eigen::Transpose
PermutationType	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::PartialPivLU
PermutationType	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::ColPivHouseholderQR
PermutationType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::FullPivHouseholderQR
PermutationWrapper	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationWrapper(const IndicesType& indices)$/;"	f	class:Eigen::PermutationWrapper
PermutationWrapper	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^class PermutationWrapper : public PermutationBase<PermutationWrapper<_IndicesType> >$/;"	c	namespace:Eigen
Perturb	vcglib/vcg/math/gen_normal.h	/^static void Perturb(std::vector<Point3<ScalarType > > &NN)$/;"	f	class:vcg::GenNormal
Pick	vcglib/wrap/gl/picking.h	/^bool Pick(const int & x, const int &y, PointType &pp){$/;"	f	namespace:vcg
Pick	vcglib/wrap/gl/picking.h	/^int Pick(	const int & x, const int &y,$/;"	f	namespace:vcg
PickFace	vcglib/wrap/gl/pick.h	/^	static int PickFace(int x, int y, MESH_TYPE &m, std::vector<FacePointer> &result, int width=4, int height=4,bool sorted=true)$/;"	f	class:vcg::GLPickTri
PickFaceVisible	vcglib/wrap/gl/pick.h	/^	static int PickFaceVisible(int x, int y, MESH_TYPE &m, std::vector<FacePointer> &resultZ, int width=4, int height=4, bool sorted=true)$/;"	f	class:vcg::GLPickTri
PickNearestFace	vcglib/wrap/gl/pick.h	/^	static bool PickNearestFace(int x, int y, MESH_TYPE &m, FacePointer &fi,int width=4, int height=4)$/;"	f	class:vcg::GLPickTri
PickNearestTetra	vcglib/wrap/gl/pick.h	/^static bool PickNearestTetra(int x, int y,TETRA_MESH_TYPE &m, TetraIterator &ti,int width=4, int height=4)$/;"	f	class:vcg::GLPickTetra
PickNearestTetraFace	vcglib/wrap/gl/pick.h	/^static bool PickNearestTetraFace(int x, int y,TETRA_MESH_TYPE &m, TetraIterator &ti,int &face,int width=4, int height=4)$/;"	f	class:vcg::GLPickTetra
PickTetra	vcglib/wrap/gl/pick.h	/^static int PickTetra(int x, int y, TETRA_MESH_TYPE &m, std::vector<TetraPointer> &result, int width=4, int height=4)$/;"	f	class:vcg::GLPickTetra
PickTetraFace	vcglib/wrap/gl/pick.h	/^static int PickTetraFace(int x, int y, TETRA_MESH_TYPE &m, std::vector<std::pair<TetraPointer,int> > &result, int width=4, int height=4)$/;"	f	class:vcg::GLPickTetra
PickVert	vcglib/wrap/gl/pick.h	/^  static int PickVert(int x, int y, MESH_TYPE &m, std::vector<VertexPointer> &result, int width=4, int height=4,bool sorted=true)$/;"	f	class:vcg::GLPickTri
Pin	vcglib/wrap/gui/rubberband.cpp	/^void Rubberband::Pin(QPoint p)$/;"	f	class:Rubberband
Pivot	vcglib/apps/pivoting/pivot.h	/^    Pivot(MESH &_mesh, float _radius, float _mindist = 0.05, float _crease = -0.5): $/;"	f	class:vcg::tri::Pivot
Pivot	vcglib/apps/pivoting/pivot.h	/^class Pivot {$/;"	c	namespace:vcg::tri
Pivoting	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Pivoting            = 0x01, $/;"	e	enum:Eigen::DecompositionOptions
Pix	vcglib/apps/unsupported/shadevis/simplepic.h	/^   PixType &Pix(int x, int y) {return img[sx*y+x];}$/;"	f	class:vcg::SimplePic
PixelPackBufferBindingParams	vcglib/wrap/glw/buffer.h	/^		PixelPackBufferBindingParams(void)$/;"	f	class:glw::PixelPackBufferBindingParams
PixelPackBufferBindingParams	vcglib/wrap/glw/buffer.h	/^class PixelPackBufferBindingParams : public BufferBindingParams$/;"	c	namespace:glw
PixelSizeMm	vcglib/vcg/math/camera.h	/^    Point2<S>	PixelSizeMm;		\/\/\/ Dimension in mm of a single pixel$/;"	m	class:vcg::Camera
PixelUnpackBufferBindingParams	vcglib/wrap/glw/buffer.h	/^		PixelUnpackBufferBindingParams(void)$/;"	f	class:glw::PixelUnpackBufferBindingParams
PixelUnpackBufferBindingParams	vcglib/wrap/glw/buffer.h	/^class PixelUnpackBufferBindingParams : public BufferBindingParams$/;"	c	namespace:glw
Place	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  int Place(FrontEdge &e, typename AdvancingFront<MESH>::ResultIterator &touch)$/;"	f	class:vcg::tri::AdvancingTest
Place	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  int Place(FrontEdge &edge, typename AdvancingFront<MESH>::ResultIterator &touch) {$/;"	f	class:vcg::tri::BallPivoting
PlaceHolderType	vcglib/wrap/io_trimesh/export_vmi.h	/^    template <int N> struct PlaceHolderType{ char A[N];};$/;"	s	namespace:vcg::tri::io
PlainObject	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Array
PlainObject	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^          > PlainObject;$/;"	t	class:Eigen::ArrayBase
PlainObject	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalMatrix<Scalar,DiagonalVectorType::SizeAtCompileTime,DiagonalVectorType::MaxSizeAtCompileTime> PlainObject;$/;"	t	class:Eigen::DiagonalBase
PlainObject	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Matrix
PlainObject	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^          > PlainObject;$/;"	t	class:Eigen::MatrixBase
PlainObject	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::ProductBase
PlainObject	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::ScaledProduct
PlainObject	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::SelfAdjointView
PlainObject	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType PlainObject;$/;"	t	class:Eigen::TriangularView
PlainObject	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::CoeffBasedProduct
PlainObject	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef Quaternion<_Scalar,_Options> PlainObject;$/;"	t	struct:Eigen::internal::traits
PlainObject	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrix<Scalar, Flags&RowMajorBit ? RowMajor : ColMajor> PlainObject;$/;"	t	class:Eigen::SparseMatrixBase
PlainObjectBase	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(Index size, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE explicit PlainObjectBase() : m_storage()$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    PlainObjectBase(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>$/;"	c	namespace:Eigen
PlainPermutationType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^            PlainPermutationType;$/;"	t	class:Eigen::PermutationBase
PlainPermutationType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::PlainPermutationType PlainPermutationType;$/;"	t	class:Eigen::Transpose
PlanData	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef fftw_plan<Scalar> PlanData;$/;"	t	struct:Eigen::internal::fftw_impl
PlanData	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef kiss_cpx_fft<Scalar> PlanData;$/;"	t	struct:Eigen::internal::kissfft_impl
PlanKey	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    int PlanKey(int nfft, bool isinverse) const { return (nfft<<1) | int(isinverse); }$/;"	f	struct:Eigen::internal::kissfft_impl
PlanMap	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef std::map<int64_t,PlanData> PlanMap;$/;"	t	struct:Eigen::internal::fftw_impl
PlanMap	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef std::map<int,PlanData> PlanMap;$/;"	t	struct:Eigen::internal::kissfft_impl
PlanarEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	inline PlanarEdgeFlip()$/;"	f	class:vcg::tri::PlanarEdgeFlip
PlanarEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	inline PlanarEdgeFlip(const PlanarEdgeFlip &par)$/;"	f	class:vcg::tri::PlanarEdgeFlip
PlanarEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  inline PlanarEdgeFlip(PosType pos, int mark,BaseParameterClass *pp)$/;"	f	class:vcg::tri::PlanarEdgeFlip
PlanarEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^class PlanarEdgeFlip :$/;"	c	namespace:vcg::tri
PlanarEdgeFlipParameter	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  PlanarEdgeFlipParameter() {SetDefaultParams();}$/;"	f	class:vcg::tri::PlanarEdgeFlipParameter
PlanarEdgeFlipParameter	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^class PlanarEdgeFlipParameter : public BaseParameterClass$/;"	c	namespace:vcg::tri
Plane	vcglib/vcg/simplex/face/component_ep.h	/^	typename vcg::Plane3<typename T::VertexType::CoordType::ScalarType> &Plane() {$/;"	f	class:vcg::face::EdgePlane
Plane	vcglib/vcg/simplex/face/component_ep.h	/^typename vcg::Plane3<typename T::VertexType::CoordType::ScalarType> &Plane() {assert(0);  static typename vcg::Plane3<typename T::VertexType::CoordType::ScalarType> dum; return dum;}$/;"	f	class:vcg::face::EmptyEdgePlane
Plane3	vcglib/vcg/space/plane3.h	/^  Plane3() {}$/;"	f	class:vcg::Plane3
Plane3	vcglib/vcg/space/plane3.h	/^  Plane3(const ScalarType &dist, const PointType &dir) { Set(dist, dir); }$/;"	f	class:vcg::Plane3
Plane3	vcglib/vcg/space/plane3.h	/^template <class T, bool NORM=true> class Plane3 {$/;"	c	namespace:vcg
Plane3d	vcglib/vcg/space/plane3.h	/^typedef Plane3<double> Plane3d;$/;"	t	namespace:vcg
Plane3f	vcglib/vcg/space/plane3.h	/^typedef Plane3<float>  Plane3f;$/;"	t	namespace:vcg
Plane3x	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef Plane3<ScalarType> Plane3x;$/;"	t	class:vcg::tri::CylinderClipping
PlaneMode	vcglib/wrap/gui/trackmode.h	/^  PlaneMode (Plane3f & pl)$/;"	f	class:vcg::PlaneMode
PlaneMode	vcglib/wrap/gui/trackmode.h	/^  PlaneMode (float a, float b, float c, float d)$/;"	f	class:vcg::PlaneMode
PlaneMode	vcglib/wrap/gui/trackmode.h	/^class PlaneMode:public TrackMode {$/;"	c	namespace:vcg
PlyConv	vcglib/wrap/io_tetramesh/export_ply.h	/^static void PlyConv(int mem_type, void *src, StoType &dest)$/;"	f	class:vcg::tetra::io::ExporterPLY
PlyConv	vcglib/wrap/io_trimesh/export_ply.h	/^static void PlyConv(int mem_type, void *src, StoType &dest)$/;"	f	class:vcg::tri::io::ExporterPLY
PlyElement	vcglib/wrap/ply/plylib.h	/^	inline PlyElement( const char * na, int nu )$/;"	f	class:vcg::ply::PlyElement
PlyElement	vcglib/wrap/ply/plylib.h	/^	inline PlyElement()$/;"	f	class:vcg::ply::PlyElement
PlyElement	vcglib/wrap/ply/plylib.h	/^class PlyElement$/;"	c	namespace:vcg::ply
PlyError	vcglib/wrap/ply/plylib.h	/^enum PlyError {$/;"	g	namespace:vcg::ply
PlyFile	vcglib/wrap/ply/plylib.cpp	/^PlyFile::PlyFile( void )$/;"	f	class:vcg::ply::PlyFile
PlyFile	vcglib/wrap/ply/plylib.h	/^class PlyFile$/;"	c	namespace:vcg::ply
PlyFormat	vcglib/wrap/ply/plylib.h	/^enum PlyFormat {$/;"	g	namespace:vcg::ply
PlyInfo	vcglib/wrap/io_tetramesh/io_ply.h	/^  PlyInfo()$/;"	f	class:vcg::tetra::io::PlyInfo
PlyInfo	vcglib/wrap/io_tetramesh/io_ply.h	/^class PlyInfo$/;"	c	namespace:vcg::tetra::io
PlyInfo	vcglib/wrap/io_trimesh/io_ply.h	/^  PlyInfo()$/;"	f	class:vcg::tri::io::PlyInfo
PlyInfo	vcglib/wrap/io_trimesh/io_ply.h	/^class PlyInfo$/;"	c	namespace:vcg::tri::io
PlyPoint3d	vcglib/wrap/ply/plystuff.h	/^struct PlyPoint3d$/;"	s	namespace:vcg::ply
PlyProperty	vcglib/wrap/ply/plylib.h	/^	inline PlyProperty( const char * na, int ti, int isl, int t2 )$/;"	f	class:vcg::ply::PlyProperty
PlyProperty	vcglib/wrap/ply/plylib.h	/^	inline PlyProperty()$/;"	f	class:vcg::ply::PlyProperty
PlyProperty	vcglib/wrap/ply/plylib.h	/^class PlyProperty$/;"	c	namespace:vcg::ply
PlyType	vcglib/wrap/io_tetramesh/import_ply.h	/^int PlyType ()  { return 0;}$/;"	f	namespace:vcg::tetra::io
PlyType	vcglib/wrap/io_tetramesh/import_ply.h	/^template <> int PlyType <double>()  { return ply::T_DOUBLE; }$/;"	f	namespace:vcg::tetra::io
PlyType	vcglib/wrap/io_tetramesh/import_ply.h	/^template <> int PlyType <float >()  { return ply::T_FLOAT; }$/;"	f	namespace:vcg::tetra::io
PlyType	vcglib/wrap/io_tetramesh/import_ply.h	/^template <> int PlyType <int   >()  { return ply::T_INT; } $/;"	f	namespace:vcg::tetra::io
PlyType	vcglib/wrap/io_tetramesh/import_ply.h	/^template <> int PlyType <short >()  { return ply::T_SHORT; }$/;"	f	namespace:vcg::tetra::io
PlyType	vcglib/wrap/io_tetramesh/import_ply.h	/^template <> int PlyType <unsigned char >()  { return ply::T_UCHAR; }$/;"	f	namespace:vcg::tetra::io
PlyType	vcglib/wrap/io_trimesh/import_ply.h	/^int PlyType ()  { return 0;}$/;"	f	namespace:vcg::tri::io
PlyType	vcglib/wrap/io_trimesh/import_ply.h	/^template <> inline int PlyType <double>()  { return ply::T_DOUBLE; }$/;"	f	namespace:vcg::tri::io
PlyType	vcglib/wrap/io_trimesh/import_ply.h	/^template <> inline int PlyType <float >()  { return ply::T_FLOAT; }$/;"	f	namespace:vcg::tri::io
PlyType	vcglib/wrap/io_trimesh/import_ply.h	/^template <> inline int PlyType <int   >()  { return ply::T_INT; }$/;"	f	namespace:vcg::tri::io
PlyType	vcglib/wrap/io_trimesh/import_ply.h	/^template <> inline int PlyType <short >()  { return ply::T_SHORT; }$/;"	f	namespace:vcg::tri::io
PlyType	vcglib/wrap/io_trimesh/import_ply.h	/^template <> inline int PlyType <unsigned char >()  { return ply::T_UCHAR; }$/;"	f	namespace:vcg::tri::io
PlyTypes	vcglib/wrap/ply/plylib.h	/^enum PlyTypes {$/;"	g	namespace:vcg::ply
PntSum	vcglib/vcg/complex/algorithms/smooth.h	/^    CoordType PntSum;$/;"	m	class:vcg::tri::Smooth::ScaleLaplacianInfo
Point	vcglib/vcg/space/deprecated_point.h	/^  inline Point () { };$/;"	f	class:vcg::ndim::Point
Point	vcglib/vcg/space/deprecated_point.h	/^class Point$/;"	c	namespace:vcg::ndim
Point	vcglib/vcg/space/point.h	/^	inline Point() : Base() {}$/;"	f	class:vcg::ndim::Point
Point	vcglib/vcg/space/point.h	/^	inline Point(const Eigen::MatrixBase<OtherDerived>& other) : Base(other) {}$/;"	f	class:vcg::ndim::Point
Point	vcglib/vcg/space/point.h	/^template <int N, class S> class Point : public Eigen::Matrix<S,N,1>$/;"	c	namespace:vcg::ndim
Point2	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 ( const S a, const S b){$/;"	f	class:vcg::ndim::Point2
Point2	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 ( const S nv[2] ){$/;"	f	class:vcg::ndim::Point2
Point2	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 (){}$/;"	f	class:vcg::ndim::Point2
Point2	vcglib/vcg/space/deprecated_point.h	/^class Point2 : public Point<2,S> {$/;"	c	namespace:vcg::ndim
Point2	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 ( Point2 const & p)$/;"	f	class:vcg::Point2
Point2	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 ( const ScalarType nx, const ScalarType ny )$/;"	f	class:vcg::Point2
Point2	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 () { }$/;"	f	class:vcg::Point2
Point2	vcglib/vcg/space/deprecated_point2.h	/^template <class P2ScalarType> class Point2$/;"	c	namespace:vcg
Point2	vcglib/vcg/space/point2.h	/^	inline Point2 ( const Scalar nx, const Scalar ny ) : Base(nx,ny) {}$/;"	f	class:vcg::Point2
Point2	vcglib/vcg/space/point2.h	/^	inline Point2 () { }$/;"	f	class:vcg::Point2
Point2	vcglib/vcg/space/point2.h	/^	inline Point2(Point2 const & p) : Base(p) {}$/;"	f	class:vcg::Point2
Point2	vcglib/vcg/space/point2.h	/^	inline Point2(const Eigen::MatrixBase<OtherDerived>& other) : Base(other) {}$/;"	f	class:vcg::Point2
Point2	vcglib/vcg/space/point2.h	/^template <class _Scalar> class Point2 : public Eigen::Matrix<_Scalar,2,1>$/;"	c	namespace:vcg
Point2d	vcglib/vcg/space/deprecated_point.h	/^typedef Point2<double> Point2d;$/;"	t	namespace:vcg::ndim
Point2d	vcglib/vcg/space/deprecated_point2.h	/^typedef Point2<double> Point2d;$/;"	t	namespace:vcg
Point2d	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<double,2,1> Point2d;$/;"	t	namespace:vcg::ndim
Point2d	vcglib/vcg/space/point2.h	/^typedef Point2<double> Point2d;$/;"	t	namespace:vcg
Point2f	vcglib/vcg/space/deprecated_point.h	/^typedef Point2<float>  Point2f;$/;"	t	namespace:vcg::ndim
Point2f	vcglib/vcg/space/deprecated_point2.h	/^typedef Point2<float>  Point2f;$/;"	t	namespace:vcg
Point2f	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<float ,2,1> Point2f;$/;"	t	namespace:vcg::ndim
Point2f	vcglib/vcg/space/point2.h	/^typedef Point2<float>  Point2f;$/;"	t	namespace:vcg
Point2i	vcglib/vcg/space/deprecated_point.h	/^typedef Point2<int>	  Point2i;$/;"	t	namespace:vcg::ndim
Point2i	vcglib/vcg/space/deprecated_point2.h	/^typedef Point2<int>	   Point2i;$/;"	t	namespace:vcg
Point2i	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<int   ,2,1> Point2i;$/;"	t	namespace:vcg::ndim
Point2i	vcglib/vcg/space/point2.h	/^typedef Point2<int>	   Point2i;$/;"	t	namespace:vcg
Point2s	vcglib/vcg/space/deprecated_point.h	/^typedef Point2<short>  Point2s;$/;"	t	namespace:vcg::ndim
Point2s	vcglib/vcg/space/deprecated_point2.h	/^typedef Point2<short>  Point2s;$/;"	t	namespace:vcg
Point2s	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<short ,2,1> Point2s;$/;"	t	namespace:vcg::ndim
Point2s	vcglib/vcg/space/point2.h	/^typedef Point2<short>  Point2s;$/;"	t	namespace:vcg
Point2x	vcglib/vcg/space/outline2_packer.h	/^  typedef typename vcg::Point2<SCALAR_TYPE> Point2x;$/;"	t	class:vcg::PolyPacker
Point2x	vcglib/vcg/space/rasterized_outline2_packer.h	/^    typedef typename vcg::Point2<SCALAR_TYPE> Point2x;$/;"	t	class:vcg::RasterizedOutline2Packer
Point2x	vcglib/vcg/space/rect_packer.h	/^  typedef typename vcg::Point2<SCALAR_TYPE> Point2x;$/;"	t	class:vcg::RectPacker
Point3	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 ( const S a, const S b,  const S c){$/;"	f	class:vcg::ndim::Point3
Point3	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 ( const S nv[3] ){$/;"	f	class:vcg::ndim::Point3
Point3	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 ():Point<3,S>(){}$/;"	f	class:vcg::ndim::Point3
Point3	vcglib/vcg/space/deprecated_point.h	/^class Point3 : public Point<3,S> {$/;"	c	namespace:vcg::ndim
Point3	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 ( Point3 const & p )$/;"	f	class:vcg::Point3
Point3	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 ( const P3ScalarType nv[3] )$/;"	f	class:vcg::Point3
Point3	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 ( const P3ScalarType nx, const P3ScalarType ny, const P3ScalarType nz )$/;"	f	class:vcg::Point3
Point3	vcglib/vcg/space/deprecated_point3.h	/^  inline Point3 () { }$/;"	f	class:vcg::Point3
Point3	vcglib/vcg/space/deprecated_point3.h	/^template <class P3ScalarType> class Point3$/;"	c	namespace:vcg
Point3	vcglib/vcg/space/point3.h	/^	inline Point3 ( Point3 const & p ) : Base(p) {}$/;"	f	class:vcg::Point3
Point3	vcglib/vcg/space/point3.h	/^	inline Point3 ( const Scalar nv[3] ) : Base(nv) {}$/;"	f	class:vcg::Point3
Point3	vcglib/vcg/space/point3.h	/^	inline Point3 ( const Scalar nx, const Scalar ny, const Scalar nz ) : Base(nx,ny,nz) {}$/;"	f	class:vcg::Point3
Point3	vcglib/vcg/space/point3.h	/^	inline Point3(const Eigen::MatrixBase<OtherDerived>& other) : Base(other) {}$/;"	f	class:vcg::Point3
Point3	vcglib/vcg/space/point3.h	/^  inline Point3 () {}$/;"	f	class:vcg::Point3
Point3	vcglib/vcg/space/point3.h	/^template <class _Scalar> class Point3 : public Eigen::Matrix<_Scalar,3,1>$/;"	c	namespace:vcg
Point3d	vcglib/vcg/space/deprecated_point.h	/^typedef Point3<double> Point3d;$/;"	t	namespace:vcg::ndim
Point3d	vcglib/vcg/space/deprecated_point3.h	/^typedef Point3<double> Point3d;$/;"	t	namespace:vcg
Point3d	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<double,3,1> Point3d;$/;"	t	namespace:vcg::ndim
Point3d	vcglib/vcg/space/point3.h	/^typedef Point3<double> Point3d;$/;"	t	namespace:vcg
Point3f	vcglib/vcg/space/deprecated_point.h	/^typedef Point3<float>  Point3f;$/;"	t	namespace:vcg::ndim
Point3f	vcglib/vcg/space/deprecated_point3.h	/^typedef Point3<float>  Point3f;$/;"	t	namespace:vcg
Point3f	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<float ,3,1> Point3f;$/;"	t	namespace:vcg::ndim
Point3f	vcglib/vcg/space/point3.h	/^typedef Point3<float>  Point3f;$/;"	t	namespace:vcg
Point3i	vcglib/vcg/space/deprecated_point.h	/^typedef Point3<int>	  Point3i;$/;"	t	namespace:vcg::ndim
Point3i	vcglib/vcg/space/deprecated_point3.h	/^typedef Point3<int>	   Point3i;$/;"	t	namespace:vcg
Point3i	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<int   ,3,1> Point3i;$/;"	t	namespace:vcg::ndim
Point3i	vcglib/vcg/space/point3.h	/^typedef Point3<int>	   Point3i;$/;"	t	namespace:vcg
Point3s	vcglib/vcg/space/deprecated_point.h	/^typedef Point3<short>  Point3s;$/;"	t	namespace:vcg::ndim
Point3s	vcglib/vcg/space/deprecated_point3.h	/^typedef Point3<short>  Point3s;$/;"	t	namespace:vcg
Point3s	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<short ,3,1> Point3s;$/;"	t	namespace:vcg::ndim
Point3s	vcglib/vcg/space/point3.h	/^typedef Point3<short>  Point3s;$/;"	t	namespace:vcg
Point3x	vcglib/apps/metro/sampling.h	/^	typedef Point3<typename MetroMesh::ScalarType> Point3x;$/;"	t	class:vcg::Sampling
Point3x	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^typedef Point3<CMesh::ScalarType> Point3x;$/;"	t	file:
Point3x	vcglib/apps/unsupported/shadevis/visshader.h	/^		typedef Point3<typename MESH_TYPE::ScalarType> Point3x;$/;"	t	class:vcg::VisShader
Point3x	vcglib/vcg/complex/algorithms/clean.h	/^  typedef Point3<ScalarType> Point3x;$/;"	t	class:vcg::tri::Clean
Point3x	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::VertexType::CoordType   Point3x;$/;"	t	class:vcg::tri::AdvancingFront
Point3x	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::VertexType::CoordType   Point3x;$/;"	t	class:vcg::tri::AdvancingTest
Point3x	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  typedef typename MESH::VertexType::CoordType   Point3x;$/;"	t	class:vcg::tri::BallPivoting
Point3x	vcglib/vcg/complex/algorithms/refine.h	/^    typedef Point3<typename MESH_TYPE::ScalarType> Point3x;$/;"	t	struct:vcg::tri::MidPointSphere
Point3x	vcglib/vcg/complex/algorithms/refine.h	/^  typedef Point3<typename MESH_TYPE::ScalarType> Point3x;$/;"	t	class:vcg::tri::QualityEdgePredicate
Point3x	vcglib/vcg/complex/algorithms/refine.h	/^  typedef Point3<typename MESH_TYPE::ScalarType> Point3x;$/;"	t	class:vcg::tri::QualityMidPointFunctor
Point3x	vcglib/vcg/math/gen_normal.h	/^typedef Point3<ScalarType> Point3x;$/;"	t	class:vcg::GenNormal
Point3x	vcglib/wrap/gl/tetramesh.h	/^  typedef typename VertexType::CoordType Point3x;$/;"	t	class:vcg::tetra::GlTetramesh
Point3x	vcglib/wrap/io_tetramesh/export_ts.h	/^	typedef Point3<ScalarType> Point3x;$/;"	t	struct:vcg::tetra::io::ExporterTS
Point3x	vcglib/wrap/io_tetramesh/import_ts.h	/^	typedef Point3<ScalarType> Point3x;$/;"	t	class:vcg::tetra::io::ImporterTS
Point4	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 ( const S a, const S b,  const S c, const S d){$/;"	f	class:vcg::ndim::Point4
Point4	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 ( const S nv[4] ){$/;"	f	class:vcg::ndim::Point4
Point4	vcglib/vcg/space/deprecated_point.h	/^        inline Point4 (){}$/;"	f	class:vcg::ndim::Point4
Point4	vcglib/vcg/space/deprecated_point.h	/^class Point4 : public Point<4,S> {$/;"	c	namespace:vcg::ndim
Point4	vcglib/vcg/space/deprecated_point4.h	/^	inline Point4 ( const Point4 & p )$/;"	f	class:vcg::Point4
Point4	vcglib/vcg/space/deprecated_point4.h	/^	inline Point4 ( const T  p[4] )$/;"	f	class:vcg::Point4
Point4	vcglib/vcg/space/deprecated_point4.h	/^	inline Point4 ( const T nx, const T ny, const T nz , const T nw )$/;"	f	class:vcg::Point4
Point4	vcglib/vcg/space/deprecated_point4.h	/^	inline Point4 () { }$/;"	f	class:vcg::Point4
Point4	vcglib/vcg/space/deprecated_point4.h	/^template <class T> class Point4$/;"	c	namespace:vcg
Point4	vcglib/vcg/space/point4.h	/^	inline Point4( const T nx, const T ny, const T nz , const T nw ) : Base(nx,ny,nz,nw) {}$/;"	f	class:vcg::Point4
Point4	vcglib/vcg/space/point4.h	/^	inline Point4() : Base() {}$/;"	f	class:vcg::Point4
Point4	vcglib/vcg/space/point4.h	/^	inline Point4(const Eigen::MatrixBase<OtherDerived>& other) : Base(other) {}$/;"	f	class:vcg::Point4
Point4	vcglib/vcg/space/point4.h	/^	inline Point4(const Point4& p) : Base(p) {}$/;"	f	class:vcg::Point4
Point4	vcglib/vcg/space/point4.h	/^	inline Point4(const T p[4]) : Base(p) {}$/;"	f	class:vcg::Point4
Point4	vcglib/vcg/space/point4.h	/^template <class T> class Point4 : public Eigen::Matrix<T,4,1>$/;"	c	namespace:vcg
Point4d	vcglib/vcg/space/deprecated_point.h	/^typedef Point4<double> Point4d;$/;"	t	namespace:vcg::ndim
Point4d	vcglib/vcg/space/deprecated_point4.h	/^typedef Point4<double> Point4d;$/;"	t	namespace:vcg
Point4d	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<double,4,1> Point4d;$/;"	t	namespace:vcg::ndim
Point4d	vcglib/vcg/space/point4.h	/^typedef Point4<double> Point4d;$/;"	t	namespace:vcg
Point4f	vcglib/vcg/space/deprecated_point.h	/^typedef Point4<float>  Point4f;$/;"	t	namespace:vcg::ndim
Point4f	vcglib/vcg/space/deprecated_point4.h	/^typedef Point4<float>  Point4f;$/;"	t	namespace:vcg
Point4f	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<float ,4,1> Point4f;$/;"	t	namespace:vcg::ndim
Point4f	vcglib/vcg/space/point4.h	/^typedef Point4<float>  Point4f;$/;"	t	namespace:vcg
Point4i	vcglib/vcg/space/deprecated_point.h	/^typedef Point4<int>	  Point4i;$/;"	t	namespace:vcg::ndim
Point4i	vcglib/vcg/space/deprecated_point4.h	/^typedef Point4<int>	   Point4i;$/;"	t	namespace:vcg
Point4i	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<int   ,4,1> Point4i;$/;"	t	namespace:vcg::ndim
Point4i	vcglib/vcg/space/point4.h	/^typedef Point4<int>	   Point4i;$/;"	t	namespace:vcg
Point4s	vcglib/vcg/space/deprecated_point.h	/^typedef Point4<short>  Point4s;$/;"	t	namespace:vcg::ndim
Point4s	vcglib/vcg/space/deprecated_point4.h	/^typedef Point4<short>  Point4s;$/;"	t	namespace:vcg
Point4s	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<short ,4,1> Point4s;$/;"	t	namespace:vcg::ndim
Point4s	vcglib/vcg/space/point4.h	/^typedef Point4<short>  Point4s;$/;"	t	namespace:vcg
PointBase	vcglib/vcg/space/deprecated_point.h	/^	PointBase()$/;"	f	struct:vcg::ndim::PointBase
PointBase	vcglib/vcg/space/deprecated_point.h	/^struct PointBase : Point<N,S>$/;"	s	namespace:vcg::ndim
PointBoxDistance	vcglib/vcg/space/distance3.h	/^void PointBoxDistance(const Point3<ScalarType> &p,$/;"	f	namespace:vcg
PointCloudNormal	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^class PointCloudNormal {$/;"	c	namespace:vcg::tri
PointDistance	vcglib/vcg/simplex/edge/distance.h	/^	bool PointDistance(	const EdgeType &e, $/;"	f	namespace:vcg::edge
PointDistance	vcglib/vcg/space/triangle2.h	/^void PointDistance(const CoordType & q,$/;"	f	class:vcg::Triangle2
PointDistanceBase	vcglib/vcg/simplex/face/distance.h	/^            bool PointDistanceBase($/;"	f	namespace:vcg::face
PointDistanceBaseFunctor	vcglib/vcg/simplex/face/distance.h	/^    class PointDistanceBaseFunctor {$/;"	c	namespace:vcg::face
PointDistanceEP	vcglib/vcg/simplex/face/distance.h	/^    bool PointDistanceEP(	const FaceType &f,$/;"	f	namespace:vcg::face
PointDistanceEPFunctor	vcglib/vcg/simplex/face/distance.h	/^    class PointDistanceEPFunctor {$/;"	c	namespace:vcg::face
PointDistanceFunctor	vcglib/vcg/simplex/edge/distance.h	/^	class PointDistanceFunctor {$/;"	c	namespace:vcg::edge
PointDistanceFunctor	vcglib/vcg/simplex/vertex/distance.h	/^	class PointDistanceFunctor {$/;"	c	namespace:vcg::vertex
PointFilledBoxDistance	vcglib/vcg/space/distance3.h	/^Scalar PointFilledBoxDistance(const Point3<Scalar> &p, const Box3<Scalar> &bbox)$/;"	f	namespace:vcg
PointInsidePolygon	vcglib/vcg/space/intersection2.h	/^	bool PointInsidePolygon(vcg::Point2<ScalarType> p,$/;"	f	namespace:vcg
PointIsInSegment	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^static bool PointIsInSegment(const Point3<T> &point, const Segment3<T> &seg){$/;"	f	namespace:vcg
PointNormalDistanceFunctor	vcglib/vcg/simplex/face/distance.h	/^    class PointNormalDistanceFunctor {$/;"	c	namespace:vcg::face
PointNormalDistanceFunctor	vcglib/vcg/simplex/vertex/distance.h	/^class PointNormalDistanceFunctor {$/;"	c	namespace:vcg::vertex
PointPointMinimizer	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^  PointPointMinimizer() : calls(0) {}$/;"	f	struct:PointPointMinimizer
PointPointMinimizer	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^struct PointPointMinimizer \/\/how to compute squared distances between points and rectangles$/;"	s	file:
PointScaledDistanceFunctor	vcglib/vcg/simplex/vertex/distance.h	/^class PointScaledDistanceFunctor {$/;"	c	namespace:vcg::vertex
PointType	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    typedef typename SplineTraits<Spline>::PointType PointType;$/;"	t	class:Eigen::Spline
PointType	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef Array<Scalar,Dimension,1> PointType;$/;"	t	struct:Eigen::SplineTraits
PointType	vcglib/vcg/math/eigen_matrix_addons.h	/^typedef Matrix          PointType;$/;"	t
PointType	vcglib/vcg/space/box.h	/^	typedef Point<N,S> PointType;$/;"	t	class:vcg::Box
PointType	vcglib/vcg/space/box2.h	/^  typedef Point2<BoxScalarType> PointType ;$/;"	t	class:vcg::Box2
PointType	vcglib/vcg/space/deprecated_point.h	/^	typedef Point2 PointType;$/;"	t	class:vcg::ndim::Point2
PointType	vcglib/vcg/space/deprecated_point.h	/^	typedef Point3<S>  PointType;$/;"	t	class:vcg::ndim::Point3
PointType	vcglib/vcg/space/deprecated_point.h	/^	typedef Point4<S> PointType;$/;"	t	class:vcg::ndim::Point4
PointType	vcglib/vcg/space/deprecated_point.h	/^	typedef Point<N,S> PointType;$/;"	t	class:vcg::ndim::Point
PointType	vcglib/vcg/space/line2.h	/^	typedef Point2<LineScalarType> PointType;$/;"	t	class:vcg::Line2
PointType	vcglib/vcg/space/line3.h	/^	typedef Point3<LineScalarType> PointType;$/;"	t	class:vcg::Line3
PointType	vcglib/vcg/space/plane3.h	/^	typedef Point3<T> PointType;$/;"	t	class:vcg::Plane3
PointType	vcglib/vcg/space/ray2.h	/^	typedef Point2<RayScalarType> PointType;$/;"	t	class:vcg::Ray2
PointType	vcglib/vcg/space/ray3.h	/^	typedef Point3<RayScalarType> PointType;$/;"	t	class:vcg::Ray3
PointType	vcglib/vcg/space/segment2.h	/^	typedef Point2<SegmentScalarType> PointType;$/;"	t	class:vcg::Segment2
PointType	vcglib/vcg/space/segment3.h	/^	typedef Point3<SegmentScalarType> PointType;$/;"	t	class:vcg::Segment3
PointType	vcglib/vcg/space/space.h	/^	typedef Point<N,S> PointType;$/;"	t	class:vcg::Space
PointType	vcglib/vcg/space/texcoord2.h	/^  typedef Point2<T>  PointType;$/;"	t	class:vcg::TexCoord2
PointType	vcglib/vcg/space/texcoord2.h	/^  typedef Point2<T>  PointType;$/;"	t	class:vcg::TexCoord2Simple
Pointer2begin	vcglib/vcg/container/vector_occ.h	/^	VALUE_TYPE * Pointer2begin(){$/;"	f	class:vcg::vector_occ
PointerArgType	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    typedef PointerType PointerArgType;$/;"	t	class:Eigen::Map
PointerArgType	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    typedef const Scalar* PointerArgType;$/;"	t	class:Eigen::Map
PointerToAttribute	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::PointerToAttribute PointerToAttribute;$/;"	t	class:vcg::tri::Allocator
PointerToAttribute	vcglib/vcg/complex/base.h	/^        typedef vcg::PointerToAttribute PointerToAttribute;$/;"	t	class:vcg::tri::TriMesh
PointerToAttribute	vcglib/vcg/complex/base.h	/^class PointerToAttribute$/;"	c	namespace:vcg
PointerType	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::Map
PointerType	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^                     PointerType;$/;"	t	class:Eigen::MapBase
PointerType	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::MapBase
PointerUpdater	vcglib/vcg/complex/allocate.h	/^                PointerUpdater(void) : newBase(0), oldBase(0), newEnd(0), oldEnd(0), preventUpdateFlag(false) { ; }$/;"	f	class:vcg::tri::Allocator::PointerUpdater
PointerUpdater	vcglib/vcg/complex/allocate.h	/^            class PointerUpdater$/;"	c	class:vcg::tri::Allocator
PointsGridType	vcglib/vcg/complex/algorithms/update/curvature.h	/^  typedef vcg::GridStaticPtr	<VertexType, ScalarType >		PointsGridType;$/;"	t	class:vcg::tri::UpdateCurvature
Poison_setup	vcg_mesh.hpp	/^    Poison_setup() :$/;"	f	struct:vcg::MyAlgorithms::Poison_setup
Poison_setup	vcg_mesh.hpp	/^struct Poison_setup {$/;"	s	namespace:vcg::MyAlgorithms
Poisson	vcglib/vcg/complex/algorithms/point_sampling.h	/^static int Poisson(double lambda)$/;"	f	class:vcg::tri::SurfaceSampling
PoissonDiskParam	vcglib/vcg/complex/algorithms/point_sampling.h	/^  PoissonDiskParam()$/;"	f	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
PoissonDiskParam	vcglib/vcg/complex/algorithms/point_sampling.h	/^struct PoissonDiskParam$/;"	s	class:vcg::tri::SurfaceSampling
PoissonDiskPruning	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void PoissonDiskPruning(VertexSampler &ps, MetroMesh &montecarloMesh,$/;"	f	class:vcg::tri::SurfaceSampling
PoissonPruning	vcglib/vcg/complex/algorithms/point_sampling.h	/^void PoissonPruning(MeshType &m, \/\/ the mesh that has to be pruned$/;"	f	namespace:vcg::tri
PoissonRatioUniforms	vcglib/vcg/complex/algorithms/point_sampling.h	/^static int  PoissonRatioUniforms(double L) {$/;"	f	class:vcg::tri::SurfaceSampling
PoissonSampling	vcglib/vcg/complex/algorithms/point_sampling.h	/^void PoissonSampling(MeshType &m, \/\/ the mesh that has to be sampled$/;"	f	namespace:vcg::tri
PoissonSolver	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    PoissonSolver(MeshType &_mesh):mesh(_mesh)$/;"	f	class:vcg::tri::PoissonSolver
PoissonSolver	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^class PoissonSolver$/;"	c	namespace:vcg::tri
PoissonSolver	vcglib/wrap/miq/core/poisson_solver.h	/^    PoissonSolver(MeshType &_mesh):mesh(_mesh)$/;"	f	class:PoissonSolver
PoissonSolver	vcglib/wrap/miq/core/poisson_solver.h	/^class PoissonSolver$/;"	c
Polar2Cartesian	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 & Polar2Cartesian()$/;"	f	class:vcg::Point2
Polar2Cartesian	vcglib/vcg/space/point2.h	/^	inline Point2 & Polar2Cartesian()$/;"	f	class:vcg::Point2
PolarMode	vcglib/wrap/gui/trackmode.h	/^  PolarMode(): alpha(0), beta(0), enda(0), endb(0) {}$/;"	f	class:vcg::PolarMode
PolarMode	vcglib/wrap/gui/trackmode.h	/^class PolarMode:public TrackMode {$/;"	c	namespace:vcg
PolyCoordType	vcglib/wrap/miq/quadrangulator.h	/^    typedef typename PolyMesh::CoordType PolyCoordType;$/;"	t	class:Quadrangulator
PolyFace	vcglib/apps/sample/polygonmesh_polychord_collapse/polygonmesh_polychord_collapse.cpp	/^class PolyFace : public vcg::Face<$/;"	c	file:
PolyFaceType	vcglib/wrap/miq/quadrangulator.h	/^    typedef typename PolyMesh::FaceType PolyFaceType;$/;"	t	class:Quadrangulator
PolyInfo	vcglib/vcg/simplex/face/component_polygon.h	/^  PolyInfo(){ _ns = -1; }$/;"	f	class:vcg::face::PolyInfo
PolyInfo	vcglib/vcg/simplex/face/component_polygon.h	/^template <class T> class PolyInfo: public T {$/;"	c	namespace:vcg::face
PolyMesh	vcglib/apps/sample/polygonmesh_polychord_collapse/polygonmesh_polychord_collapse.cpp	/^class PolyMesh : public vcg::tri::TriMesh<$/;"	c	file:
PolyPacker	vcglib/vcg/space/outline2_packer.h	/^class PolyPacker$/;"	c	namespace:vcg
PolyPacking	vcglib/vcg/space/rasterized_outline2_packer.h	/^    static bool PolyPacking(std::vector< std::vector< Point2x>  > &outline2Vec,$/;"	f	class:vcg::RasterizedOutline2Packer
PolyScalarType	vcglib/wrap/miq/quadrangulator.h	/^    typedef typename PolyMesh::ScalarType PolyScalarType;$/;"	t	class:Quadrangulator
PolyTable	vcglib/vcg/complex/algorithms/create/emc_lookup_table.h	/^			static int PolyTable(unsigned int cubetype, int u)$/;"	f	class:vcg::tri::EMCLookUpTable
PolyUsedTypes	vcglib/apps/quadrangulator/quadrangulator.cpp	/^struct PolyUsedTypes: public UsedTypes<Use<MyPolyVertex>	::AsVertexType,$/;"	s	file:
PolyUsedTypes	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^struct PolyUsedTypes: public vcg::UsedTypes<vcg::Use<MyPolyVertex>	::AsVertexType,$/;"	s	file:
PolyUsedTypes	vcglib/apps/sample/polygonmesh_polychord_collapse/polygonmesh_polychord_collapse.cpp	/^struct PolyUsedTypes : public vcg::UsedTypes<$/;"	s	file:
PolyUsedTypes	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^struct PolyUsedTypes: public vcg::UsedTypes<$/;"	s	file:
PolyVertex	vcglib/apps/sample/polygonmesh_polychord_collapse/polygonmesh_polychord_collapse.cpp	/^class PolyVertex : public vcg::Vertex<$/;"	c	file:
PolyVertexType	vcglib/wrap/miq/quadrangulator.h	/^    typedef typename PolyMesh::VertexType PolyVertexType;$/;"	t	class:Quadrangulator
PolychordCollapse	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^class PolychordCollapse {$/;"	c	namespace:vcg::tri
PolygonIterator	vcglib/wrap/dae/poly_triangulator.h	/^		typedef typename std::vector<FaceType>::iterator PolygonIterator; $/;"	t	class:vcg::tri::io::PolygonalMesh
PolygonSupport	vcglib/vcg/complex/algorithms/polygon_support.h	/^	struct PolygonSupport{$/;"	s	namespace:vcg::tri
PolygonalMesh	vcglib/wrap/dae/poly_triangulator.h	/^	class PolygonalMesh$/;"	c	namespace:vcg::tri::io
Polynomial	vcglib/vcg/math/legendre.h	/^	double Polynomial(unsigned l, ScalarType x)$/;"	f	class:vcg::math::DynamicLegendre
Polynomial	vcglib/vcg/math/legendre.h	/^	static double Polynomial(unsigned l, ScalarType x)$/;"	f	class:vcg::math::Legendre
PolynomialSolver	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline PolynomialSolver( const OtherPolynomial& poly ){$/;"	f	class:Eigen::PolynomialSolver
PolynomialSolver	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline PolynomialSolver(){}$/;"	f	class:Eigen::PolynomialSolver
PolynomialSolver	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^class PolynomialSolver : public PolynomialSolverBase<_Scalar,_Deg>$/;"	c	namespace:Eigen
PolynomialSolver	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^class PolynomialSolver<_Scalar,1> : public PolynomialSolverBase<_Scalar,1>$/;"	c	namespace:Eigen
PolynomialSolverBase	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline PolynomialSolverBase( const OtherPolynomial& poly ){$/;"	f	class:Eigen::PolynomialSolverBase
PolynomialSolverBase	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline PolynomialSolverBase(){}$/;"	f	class:Eigen::PolynomialSolverBase
PolynomialSolverBase	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^class PolynomialSolverBase$/;"	c	namespace:Eigen
Pos	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^typedef typename BQ::Pos Pos;$/;"	t	class:vcg::tri::BitQuadOptimization
Pos	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  Pos(){ f=NULL; e=0; mode=AROUND;}$/;"	f	class:vcg::tri::BitQuad::Pos
Pos	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  Pos(FaceType* _f, int _e){f=_f; e=_e;}$/;"	f	class:vcg::tri::BitQuad::Pos
Pos	vcglib/vcg/complex/algorithms/bitquad_support.h	/^class Pos{$/;"	c	class:vcg::tri::BitQuad
Pos	vcglib/vcg/complex/algorithms/clustering.h	/^  CoordType    Pos() const { return p\/cnt; }$/;"	f	class:vcg::tri::AverageColorCell
Pos	vcglib/vcg/complex/algorithms/clustering.h	/^  CoordType Pos() const$/;"	f	class:vcg::tri::NearestToCenter
Pos	vcglib/vcg/connectors/halfedge_pos.h	/^            Pos(HEdgePointer hep)$/;"	f	class:vcg::hedge::Pos
Pos	vcglib/vcg/connectors/halfedge_pos.h	/^            Pos(HEdgePointer hep, bool dir)$/;"	f	class:vcg::hedge::Pos
Pos	vcglib/vcg/connectors/halfedge_pos.h	/^        template <class MeshType> class Pos$/;"	c	namespace:vcg::hedge
Pos	vcglib/vcg/simplex/edge/distance.h	/^		static inline const Point3<ScalarType> &  Pos(const QueryType & qt)  {return qt;}$/;"	f	class:vcg::edge::PointDistanceFunctor
Pos	vcglib/vcg/simplex/edge/pos.h	/^	Pos(){}$/;"	f	class:vcg::edge::Pos
Pos	vcglib/vcg/simplex/edge/pos.h	/^  Pos(EDGETYPE  * ep, VertexType  *vp){e=ep;v=vp;}$/;"	f	class:vcg::edge::Pos
Pos	vcglib/vcg/simplex/edge/pos.h	/^  Pos(EDGETYPE  * ep, int zp) {e=ep;v=ep->V(zp);}$/;"	f	class:vcg::edge::Pos
Pos	vcglib/vcg/simplex/edge/pos.h	/^class Pos$/;"	c	namespace:vcg::edge
Pos	vcglib/vcg/simplex/face/distance.h	/^          static inline const Point3<ScalarType> & Pos(const Point3<ScalarType> & qt)  {return qt;}$/;"	f	class:vcg::face::PointDistanceBaseFunctor
Pos	vcglib/vcg/simplex/face/distance.h	/^        static inline const Point3<ScalarType> &  Pos(const QueryType & qt)  {return qt.P();}$/;"	f	class:vcg::face::PointNormalDistanceFunctor
Pos	vcglib/vcg/simplex/face/distance.h	/^        static inline const Point3<ScalarType> &  Pos(const QueryType & qt)  {return qt;}$/;"	f	class:vcg::face::PointDistanceEPFunctor
Pos	vcglib/vcg/simplex/face/pos.h	/^	Pos(){}$/;"	f	class:vcg::face::Pos
Pos	vcglib/vcg/simplex/face/pos.h	/^	Pos(FaceType * const fp, VertexType * const vp)$/;"	f	class:vcg::face::Pos
Pos	vcglib/vcg/simplex/face/pos.h	/^	Pos(FaceType * const fp, int const zp){f=fp; z=zp; v=f->V(zp);}$/;"	f	class:vcg::face::Pos
Pos	vcglib/vcg/simplex/face/pos.h	/^	Pos(FaceType * const fp, int const zp, VertexType * const vp)$/;"	f	class:vcg::face::Pos
Pos	vcglib/vcg/simplex/face/pos.h	/^class Pos$/;"	c	namespace:vcg::face
Pos	vcglib/vcg/simplex/tetrahedron/pos.h	/^	Pos(){SetNull();};$/;"	f	class:vcg::tetra::Pos
Pos	vcglib/vcg/simplex/tetrahedron/pos.h	/^	Pos(TetraType * const tp, char const fap,char const ep,$/;"	f	class:vcg::tetra::Pos
Pos	vcglib/vcg/simplex/tetrahedron/pos.h	/^class Pos$/;"	c	namespace:vcg::tetra
Pos	vcglib/vcg/simplex/vertex/distance.h	/^		static inline const Point3<SCALARTYPE> & Pos(const QueryType & qt)  {return qt;}$/;"	f	class:vcg::vertex::PointDistanceFunctor
Pos	vcglib/vcg/simplex/vertex/distance.h	/^		static inline const Point3<ScalarType> &  Pos(const QueryType & qt)  {return qt;}$/;"	f	class:vcg::vertex::PointScaledDistanceFunctor
Pos	vcglib/vcg/simplex/vertex/distance.h	/^		static inline const Point3<typename VERTYPE::ScalarType> &  Pos(const QueryType & qt)  {return qt.P();}$/;"	f	class:vcg::vertex::PointNormalDistanceFunctor
Pos	vcglib/vcg/simplex/vertex/distance.h	/^    static inline const Point3<ScalarType> &  Pos(const VertexType & qt)  {return qt.P();}$/;"	f	class:vcg::vertex::ApproximateGeodesicDistanceFunctor
PosJump	vcglib/vcg/simplex/tetrahedron/pos.h	/^  PosJump(const TetraType*  tp,const int  fap,const int  ep,$/;"	f	class:vcg::tetra::PosJump
PosJump	vcglib/vcg/simplex/tetrahedron/pos.h	/^class PosJump:public Pos<MTTYPE>$/;"	c	namespace:vcg::tetra
PosLType	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  typedef PosLoop<TetraType> PosLType;$/;"	t	class:vcg::tetra::TetraEdgeCollapse
PosLoop	vcglib/vcg/simplex/tetrahedron/pos.h	/^PosLoop(TetraType*  tp,const int  fap,const int  ep,$/;"	f	class:vcg::tetra::PosLoop
PosLoop	vcglib/vcg/simplex/tetrahedron/pos.h	/^class PosLoop:public Pos<MTTYPE>$/;"	c	namespace:vcg::tetra
PosOnDiag	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static ScalarType PosOnDiag(const FaceType& f, bool counterDiag){$/;"	f	class:vcg::tri::BitQuad
PosType	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef typename face::Pos<FaceType>        PosType;$/;"	t	class:vcg::tri::CylinderClipping
PosType	vcglib/vcg/complex/algorithms/hole.h	/^            typedef typename face::Pos<FaceType>    PosType;$/;"	t	class:vcg::tri::Hole
PosType	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename face::Pos<FaceType>    PosType;$/;"	t	class:vcg::tri::SelfIntersectionEar
PosType	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename face::Pos<FaceType>    PosType;$/;"	t	class:vcg::tri::TrivialEar
PosType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef Pos<MeshType> PosType;$/;"	t	class:vcg::tri::QuadDiagonalCollapse
PosType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef Pos<MeshType> PosType;$/;"	t	class:vcg::tri::QuadDiagonalCollapseBase
PosType	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  typedef Pos<TetraType> PosType;$/;"	t	class:vcg::tetra::TetraEdgeCollapse
PosType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef vcg::face::Pos<FaceType> PosType;$/;"	t	class:vcg::tri::PlanarEdgeFlip
PosType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef vcg::face::Pos<FaceType> PosType;$/;"	t	class:vcg::tri::TopoEdgeFlip
PosType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef vcg::face::Pos<FaceType> PosType;$/;"	t	class:vcg::tri::TriEdgeFlip
PosType	vcglib/vcg/complex/algorithms/refine.h	/^     typedef typename face::Pos<typename MESH_TYPE::FaceType> PosType;$/;"	t	struct:vcg::tri::MidPoint
PosType	vcglib/vcg/complex/algorithms/refine.h	/^  typedef typename face::Pos<typename MeshType::FaceType> PosType;$/;"	t	struct:vcg::tri::BaseInterpolator
PosType	vcglib/vcg/simplex/face/jumping_pos.h	/^			typedef						Pos<FaceType>						PosType;$/;"	t	class:vcg::face::JumpingPos
PosType	vcglib/vcg/simplex/face/pos.h	/^	typedef Pos<FaceType> PosType;$/;"	t	class:vcg::face::Pos
PreImage	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				PreImage(EntryCoordinate &at, std::vector< typename UniformGrid::CellCoordinate > *preimage)$/;"	f	struct:vcg::PerfectSpatialHashing::OffsetTable::PreImage
PreImage	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			struct PreImage$/;"	s	class:vcg::PerfectSpatialHashing::OffsetTable
PreconditionIfMoreColsThanRows	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon436
PreconditionIfMoreRowsThanCols	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon436
Preconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::BiCGSTAB
Preconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::ConjugateGradient
Preconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::Preconditioner Preconditioner;$/;"	t	class:Eigen::IterativeSolverBase
Preconditioner	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::GMRES
Preconditioner	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
PreprocessForVoronoi	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void PreprocessForVoronoi(MeshType &m, float radius, VoronoiProcessingParameter &vpp)$/;"	f	class:vcg::tri::VoronoiProcessing
PreprocessForVoronoi	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void PreprocessForVoronoi(MeshType &m, float radius,$/;"	f	class:vcg::tri::VoronoiProcessing
PreserveBoundary	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      PreserveBoundary;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
PreserveBoundary	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  bool		  PreserveBoundary;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
PreserveTopology	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      PreserveTopology;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
PreserveTopology	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  bool		  PreserveTopology;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
Prev	vcglib/vcg/simplex/face/base.h	/^        inline int Prev(const int & i) const { return (i+(3-1))%3;}$/;"	f	class:vcg::FaceTypeHolder
Prev	vcglib/vcg/simplex/face/component_polygon.h	/^  inline int Prev(const int & i){ return (i+(VN()-1))%VN();}$/;"	f	class:vcg::face::PolyInfo
PrevE	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  Pos PrevE(){return Pos(f, (e+2)%3); }$/;"	f	class:vcg::tri::BitQuad::Pos
PreviousEdge	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            static HEdgeType *  PreviousEdge(HEdgeType * e0){$/;"	f	class:vcg::tri::UpdateHalfEdges
PrincipalDirections	vcglib/vcg/complex/algorithms/update/curvature.h	/^  static void PrincipalDirections(MeshType &m)$/;"	f	class:vcg::tri::UpdateCurvature
PrincipalDirectionsNormalCycle	vcglib/vcg/complex/algorithms/update/curvature.h	/^    static void PrincipalDirectionsNormalCycle(MeshType & m){$/;"	f	class:vcg::tri::UpdateCurvature
PrincipalDirectionsPCA	vcglib/vcg/complex/algorithms/update/curvature.h	/^  static void PrincipalDirectionsPCA(MeshType &m, ScalarType r, bool pointVSfaceInt = true,vcg::CallBackPos * cb = NULL)$/;"	f	class:vcg::tri::UpdateCurvature
PrintMeshInfo	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^void PrintMeshInfo(MeshInfo &mi)$/;"	f
Priority	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            virtual ScalarType Priority() const$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
Priority	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	virtual ScalarType Priority() const {$/;"	f	class:vcg::tetra::TetraEdgeCollapse
Priority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	virtual ScalarType Priority() const {$/;"	f	class:vcg::tri::TriEdgeCollapse
Priority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	virtual ScalarType Priority() const$/;"	f	class:vcg::tri::PlanarEdgeFlip
ProcessCell	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^        void ProcessCell(const vcg::Point3i &min, const vcg::Point3i &max)$/;"	f	class:vcg::tri::ExtendedMarchingCubes
ProcessCell	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            void ProcessCell(const vcg::Point3i &min, const vcg::Point3i &max)$/;"	f	class:vcg::tri::MarchingCubes
ProcessSlice	vcglib/vcg/complex/algorithms/create/resampler.h	/^		void ProcessSlice(EXTRACTOR_TYPE &extractor)$/;"	f	class:vcg::tri::Resampler::Walker
ProdRetType	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename ProductReturnType<DenseMatrixType, OtherPlainObject>::Type ProdRetType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type
Product	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)$/;"	f	class:Product
Product	vcglib/eigenlib/Eigen/src/Core/Product.h	/^class Product : public ProductImpl<Lhs,Rhs,typename internal::promote_storage_type<typename internal::traits<Lhs>::StorageKind,$/;"	c
ProductBase	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    ProductBase(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::ProductBase
ProductBase	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^class ProductBase : public MatrixBase<Derived>$/;"	c	namespace:Eigen
ProductImpl	vcglib/eigenlib/Eigen/src/Core/Product.h	/^class ProductImpl<Lhs,Rhs,Dense> : public internal::dense_xpr_base<Product<Lhs,Rhs> >::type$/;"	c
ProductReturnType	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType$/;"	s	namespace:Eigen
ProductReturnType	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,CoeffBasedProductMode>$/;"	s	namespace:Eigen
ProductReturnType	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen
ProductType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    typedef internal::transform_transform_product_impl<Transform,Transform<Scalar,Dim,OtherMode,OtherOptions> > ProductType;$/;"	t	struct:Eigen::Transform::icc_11_workaround
ProfileCommonTag	vcglib/wrap/dae/colladaformat.h	/^		ProfileCommonTag()$/;"	f	class:Collada::Tags::ProfileCommonTag
ProfileCommonTag	vcglib/wrap/dae/colladaformat.h	/^	class ProfileCommonTag : public XMLTag$/;"	c	namespace:Collada::Tags
ProfileWithCap	vcglib/vcg/complex/algorithms/create/extrude.h	/^static void ProfileWithCap(MeshType &profile, MeshType &fullSurface, const vcg::Similarityf &sim )$/;"	f	class:vcg::tri::Extrude
ProfileWithCap	vcglib/vcg/complex/algorithms/create/extrude.h	/^static void ProfileWithCap(MeshType &profile, MeshType &sideSurf, MeshType &lowCapSurf, MeshType &topCapSurf, const vcg::Similarityf &sim )$/;"	f	class:vcg::tri::Extrude
ProfileWithCap	vcglib/vcg/complex/algorithms/create/extrude.h	/^static void ProfileWithCap(MeshType &profile, MeshType &surface, const Point3f offset)$/;"	f	class:vcg::tri::Extrude
Program	vcglib/wrap/gl/shaders.h	/^	Program(void)$/;"	f	class:Program
Program	vcglib/wrap/gl/shaders.h	/^class Program : public GLObject, public Bindable$/;"	c
Program	vcglib/wrap/glw/program.h	/^		Program(Context * ctx)$/;"	f	class:glw::Program
Program	vcglib/wrap/glw/program.h	/^class Program : public Object$/;"	c	namespace:glw
ProgramArguments	vcglib/wrap/glw/program.h	/^		ProgramArguments(void)$/;"	f	class:glw::ProgramArguments
ProgramArguments	vcglib/wrap/glw/program.h	/^class ProgramArguments : public ObjectArguments$/;"	c	namespace:glw
ProgramBindingParams	vcglib/wrap/glw/program.h	/^		ProgramBindingParams(void)$/;"	f	class:glw::ProgramBindingParams
ProgramBindingParams	vcglib/wrap/glw/program.h	/^class ProgramBindingParams : public ObjectBindingParams$/;"	c	namespace:glw
ProgramHandle	vcglib/wrap/glw/program.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeProgram> ::Type ProgramHandle;$/;"	t	namespace:glw
ProgramPtr	vcglib/wrap/glw/program.h	/^typedef   detail::ObjectSharedPointerTraits  <Program> ::Type ProgramPtr;$/;"	t	namespace:glw
ProgramType	vcglib/wrap/glw/type.h	/^	ProgramType,$/;"	e	enum:glw::Type
ProgramVF	vcglib/wrap/gl/shaders.h	/^	ProgramVF(void) : Bindable()$/;"	f	class:ProgramVF
ProgramVF	vcglib/wrap/gl/shaders.h	/^class ProgramVF : public Bindable$/;"	c
Project	vcglib/vcg/math/camera.h	/^vcg::Point2<S> Camera<S>::Project(const vcg::Point3<S> & p) const$/;"	f	class:vcg::Camera
Project	vcglib/vcg/math/shot.h	/^vcg::Point2<S> Shot<S,RotationType>::Project(const vcg::Point3<S> & p) const$/;"	f	class:vcg::Shot
Project	vcglib/vcg/math/spherical_harmonics.h	/^	static SphericalHarmonics Project(PolarFunctor * fun, unsigned n_samples)$/;"	f	class:vcg::math::SphericalHarmonics
Project	vcglib/wrap/gui/view.h	/^template <class T> Point3<T> View<T>::Project(const Point3<T> &p) const {$/;"	f	class:vcg::View
ProjectLineOnPlane	vcglib/wrap/gui/trackutils.h	/^Line3f ProjectLineOnPlane(const Line3f & ln, const Plane3f & pl)$/;"	f	namespace:vcg::trackutils
Projection	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef METHOD_TYPE Projection;$/;"	t	struct:vcg::tri::EvenPointLoopGeneric
Projection	vcglib/vcg/complex/algorithms/refine_loop.h	/^  typedef METHOD_TYPE Projection;$/;"	t	struct:vcg::tri::OddPointLoopGeneric
Projection	vcglib/vcg/space/line2.h	/^	inline ScalarType Projection( const  PointType &p ) const$/;"	f	class:vcg::Line2
Projection	vcglib/vcg/space/line3.h	/^	inline ScalarType Projection( const  PointType &p ) const$/;"	f	class:vcg::Line3
Projection	vcglib/vcg/space/plane3.h	/^  PointType Projection(const PointType &p) const	{$/;"	f	class:vcg::Plane3
Projection	vcglib/vcg/space/ray2.h	/^	inline ScalarType Projection( const  PointType &p ) const$/;"	f	class:vcg::Ray2
Projection	vcglib/vcg/space/ray3.h	/^	inline ScalarType Projection( const  PointType &p ) const$/;"	f	class:vcg::Ray3
Projective	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Projective    = 0x20$/;"	e	enum:Eigen::TransformTraits
Projective2d	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Projective> Projective2d;$/;"	t	namespace:Eigen
Projective2f	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Projective> Projective2f;$/;"	t	namespace:Eigen
Projective3d	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Projective> Projective3d;$/;"	t	namespace:Eigen
Projective3f	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Projective> Projective3f;$/;"	t	namespace:Eigen
PropDescriptor	vcglib/wrap/io_tetramesh/export_ply.h	/^typedef ::vcg::ply::PropDescriptor PropDescriptor ;$/;"	t	class:vcg::tetra::io::ExporterPLY
PropDescriptor	vcglib/wrap/io_tetramesh/import_ply.h	/^typedef ::vcg::ply::PropDescriptor PropDescriptor ;$/;"	t	class:vcg::tetra::io::ImporterPLY
PropDescriptor	vcglib/wrap/io_tetramesh/io_ply.h	/^  typedef ::vcg::ply::PropDescriptor PropDescriptor ;$/;"	t	class:vcg::tetra::io::PlyInfo
PropDescriptor	vcglib/wrap/io_trimesh/export_ply.h	/^typedef ::vcg::ply::PropDescriptor PropDescriptor ;$/;"	t	class:vcg::tri::io::ExporterPLY
PropDescriptor	vcglib/wrap/io_trimesh/import_ply.h	/^typedef ::vcg::ply::PropDescriptor PropDescriptor ;$/;"	t	class:vcg::tri::io::ImporterPLY
PropDescriptor	vcglib/wrap/io_trimesh/io_ply.h	/^  typedef ::vcg::ply::PropDescriptor PropDescriptor ;$/;"	t	class:vcg::tri::io::PlyInfo
PropDescriptor	vcglib/wrap/ply/plylib.h	/^class PropDescriptor$/;"	c	namespace:vcg::ply
PropLength	vcglib/wrap/miq/core/auxmath.h	/^inline double PropLength( const double l, const double an, const double ad ){$/;"	f
Provider	vcglib/wrap/gcache/provider.h	/^  Provider(): max_tokens(-1), heap_dirty(false) {}$/;"	f	class:vcg::Provider
Provider	vcglib/wrap/gcache/provider.h	/^class Provider: public mt::thread {$/;"	c	namespace:vcg
PruneSeedByRegionArea	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void PruneSeedByRegionArea(std::vector<VertexType *> &seedVec,$/;"	f	class:vcg::tri::VoronoiProcessing
Ptr	vcglib/vcg/complex/algorithms/clustering.h	/^  VertexType * Ptr() const {return 0;}$/;"	f	class:vcg::tri::AverageColorCell
Ptr	vcglib/vcg/complex/algorithms/clustering.h	/^  VertexType * Ptr() const {return orig;}$/;"	f	class:vcg::tri::NearestToCenter
PtrDHeap	vcglib/wrap/gcache/dheap.h	/^class PtrDHeap {$/;"	c
PtrFromObject	vcglib/wrap/glw/context.h	/^		struct PtrFromObject$/;"	s	class:glw::Context
PtrValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^const void * & AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::PtrValue(void) const {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
PtrValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^void * & AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::PtrValue(void) {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
Push_back	vcglib/vcg/container/entries_allocation_table.h	/^virtual void Push_back(const int &){};$/;"	f	class:vcg::EntryCATBase
Push_back	vcglib/vcg/container/entries_allocation_table.h	/^void Push_back(const int & n){ for(int i = 0; i < n ; ++i) data.push_back(ATTR_TYPE());}$/;"	f	struct:vcg::EntryCAT
PutMatrixElt	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void PutMatrixElt(Scalar value, int row, int col, std::ofstream& out)$/;"	f	namespace:Eigen::internal
PutMatrixElt	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void PutMatrixElt(std::complex<Scalar> value, int row, int col, std::ofstream& out)$/;"	f	namespace:Eigen::internal
Q	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^Trackball *Q=&QV;$/;"	v
Q	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  MeshType			*Q;											\/\/ mesh where to find the correspondences$/;"	m	class:vcg::tri::FourPCS
Q	vcglib/vcg/simplex/edge/component.h	/^    QualityType &Q() { static QualityType dummyQuality(0);  assert(0); return dummyQuality; }$/;"	f	class:vcg::edge::EmptyCore
Q	vcglib/vcg/simplex/edge/component.h	/^  QualityType &Q() { return _quality; }$/;"	f	class:vcg::edge::Quality
Q	vcglib/vcg/simplex/face/component.h	/^  QualityType &Q()       { return _quality; }$/;"	f	class:vcg::face::Quality
Q	vcglib/vcg/simplex/face/component.h	/^  QualityType &Q()       { static QualityType dummyQuality(0);  assert(0); return dummyQuality; }$/;"	f	class:vcg::face::EmptyCore
Q	vcglib/vcg/simplex/face/component_ocf.h	/^  QualityType &Q()        {$/;"	f	class:vcg::face::QualityOcf
Q	vcglib/vcg/simplex/vertex/component.h	/^  QualityType &Q()       { assert(0); static QualityType dummyQuality(0); return dummyQuality; }$/;"	f	class:vcg::vertex::EmptyCore
Q	vcglib/vcg/simplex/vertex/component.h	/^  inline       QualityType &Q()       { return _quality; }$/;"	f	class:vcg::vertex::Quality
Q	vcglib/vcg/simplex/vertex/component.h	/^  inline const QualityType &Q() const { return _quality; }$/;"	f	class:vcg::vertex::Quality
Q	vcglib/vcg/simplex/vertex/component_occ.h	/^  QualityType &Q() { return CAT< vector_occ<VertType>,QualityType>::Instance()->Get((VertType*)this);}$/;"	f	class:vcg::vertex::QualityOcc
Q	vcglib/vcg/simplex/vertex/component_ocf.h	/^        QualityType &Q()       { assert((*this).Base().QualityEnabled); return (*this).Base().QV[(*this).Index()]; }$/;"	f	class:vcg::vertex::QualityOcf
Q	vcglib/vcg/simplex/vertex/component_ocf.h	/^  const QualityType &Q() const { assert((*this).Base().QualityEnabled); return (*this).Base().QV[(*this).Index()]; }$/;"	f	class:vcg::vertex::QualityOcf
Q3	vcglib/vcg/simplex/face/component.h	/^  Quality3Type &Q3()       { return _quality; }$/;"	f	class:vcg::face::Quality3
Q3	vcglib/vcg/simplex/face/component.h	/^  Quality3Type &Q3()       { static Quality3Type dummyQuality3(0,0,0);  assert(0); return dummyQuality3; }$/;"	f	class:vcg::face::EmptyCore
QDEBUG	vcglib/wrap/io_trimesh/import_dae.h	/^#define QDEBUG /;"	d
QDoor	vcglib/wrap/gcache/door.h	/^  QDoor(): _open(0), _close(1) {} \/\/this means closed$/;"	f	class:QDoor
QDoor	vcglib/wrap/gcache/door.h	/^  QDoor():key(0) {}$/;"	f	class:QDoor
QDoor	vcglib/wrap/gcache/door.h	/^  QDoor(void) : doorOpen(false), waiting(false) {}$/;"	f	class:QDoor
QDoor	vcglib/wrap/gcache/door.h	/^class QDoor {$/;"	c
QH	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^    typedef HelperType QH;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadric
QH	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef HelperType QH;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadricTex
QInfoStandard	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^		class QInfoStandard$/;"	c	namespace:vcg::tri
QInfoStandard	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^      QInfoStandard(){}$/;"	f	class:vcg::tri::QInfoStandard
QL	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^Trackball QL;$/;"	v
QMessageBox	vcglib/wrap/qt/checkGLError.h	/^  static void QMessageBox(const char* m) {QMessageBox(m,"GL error");}$/;"	f	class:checkGLError
QMessageBox	vcglib/wrap/qt/checkGLError.h	/^  static void QMessageBox(const char* m, const char* title) {$/;"	f	class:checkGLError
QMyWindow	vcglib/apps/pivoting/main.cpp	/^     QMyWindow(QWidget *parent): QMainWindow(parent) {$/;"	f	class:QMyWindow
QMyWindow	vcglib/apps/pivoting/main.cpp	/^class QMyWindow: public QMainWindow {$/;"	c	file:
QParameter	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^    typedef TriEdgeCollapseQuadricParameter QParameter;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadric
QR	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^    QR() : Base() {}$/;"	f	class:Eigen::QR
QR	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^    explicit QR(const T& t) : Base(t) {}$/;"	f	class:Eigen::QR
QR	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^class QR : public HouseholderQR<MatrixType>$/;"	c	namespace:Eigen
QRPreconditioners	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum QRPreconditioners {$/;"	g	namespace:Eigen
QT2VCG	vcglib/apps/pivoting/glarea.cpp	/^Trackball::Button QT2VCG(Qt::MouseButton qtbt,  Qt::KeyboardModifiers modifiers)$/;"	f
QT2VCG	vcglib/wrap/qt/trackball.h	/^inline  vcg::Trackball::Button QT2VCG (Qt::MouseButton qtbt, Qt::KeyboardModifiers modifiers)$/;"	f
QT2VCG_X	vcglib/wrap/qt/trackball.h	/^inline float QT2VCG_X( QWidget *qw, QMouseEvent *e)$/;"	f
QT2VCG_Y	vcglib/wrap/qt/trackball.h	/^inline float QT2VCG_Y( QWidget *qw, QMouseEvent *e)$/;"	f
QTDeviceHeight	vcglib/wrap/qt/device_to_logical.h	/^inline int QTDeviceHeight(QWidget *qw) {return QTLogicalToDevice(qw,qw->height());}$/;"	f
QTDeviceToLogical	vcglib/wrap/qt/device_to_logical.h	/^inline ValueType QTDeviceToLogical( QPainter *qp, const ValueType &value)$/;"	f
QTDeviceWidth	vcglib/wrap/qt/device_to_logical.h	/^inline int QTDeviceWidth(QWidget *qw) {return QTLogicalToDevice(qw,qw->width());}$/;"	f
QTKey2VCG	vcglib/wrap/qt/trackball.h	/^inline vcg::Trackball::Button QTKey2VCG (int key, Qt::KeyboardModifiers modifiers)$/;"	f
QTLogicalToDevice	vcglib/wrap/qt/device_to_logical.h	/^inline ValueType QTLogicalToDevice( QPainter *qp, const ValueType &value)$/;"	f
QTLogicalToDevice	vcglib/wrap/qt/device_to_logical.h	/^inline ValueType QTLogicalToDevice( QWidget *qw, const ValueType &value)$/;"	f
QTLogicalToOpenGL	vcglib/wrap/qt/device_to_logical.h	/^inline vcg::Point2f QTLogicalToOpenGL( QWidget *qw, const QPoint &p)$/;"	f
QTPOLYRASTERIZER_H	vcglib/wrap/qt/outline2_rasterizer.h	/^#define QTPOLYRASTERIZER_H$/;"	d
QTWheel2VCG	vcglib/wrap/qt/trackball.h	/^inline vcg::Trackball::Button QTWheel2VCG (Qt::KeyboardModifiers modifiers)$/;"	f
QT_TRACKBALL_H	vcglib/wrap/qt/trackball.h	/^#define QT_TRACKBALL_H$/;"	d
QUAD_DIAGONAL_COLLAPSE_H	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^#define QUAD_DIAGONAL_COLLAPSE_H$/;"	d
QUATERNION_H	vcglib/vcg/math/quaternion.h	/^#define QUATERNION_H$/;"	d
QV	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^Trackball QV;$/;"	v
QV	vcglib/vcg/simplex/face/component_ocf.h	/^  std::vector<float> QV;$/;"	m	class:vcg::face::vector_ocf
QV	vcglib/vcg/simplex/vertex/component_ocf.h	/^  std::vector<typename VALUE_TYPE::QualityType> QV;$/;"	m	class:vcg::vertex::vector_ocf
Qd	vcglib/apps/tridecimator/tridecimator.cpp	/^  vcg::math::Quadric<double> &Qd() {return q;}$/;"	f	class:MyVertex
Qd	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^      static math::Quadric<double> &Qd(VERTEX_TYPE &v) {return v.Qd();}$/;"	f	class:vcg::tri::QInfoStandard
Qd	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^      static math::Quadric<double> &Qd(VERTEX_TYPE *v) {return v->Qd();}$/;"	f	class:vcg::tri::QInfoStandard
Qd	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    static Quadric5<double> &Qd(VertexType *v,const vcg::TexCoord2f &coord)$/;"	f	class:vcg::tri::QuadricTexHelper
Qd3	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^      static math::Quadric<double> &Qd3(VertexType *v) {return TD3()[*v];}$/;"	f	class:vcg::tri::QuadricTexHelper
Qd3	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    static math::Quadric<double> &Qd3(VertexType &v) {return TD3()[v];}$/;"	f	class:vcg::tri::QuadricTexHelper
Qt2TwMouseButtonId	vcglib/wrap/qt/anttweakbarMapper.cpp	/^TwMouseButtonID Qt2TwMouseButtonId(QMouseEvent *e)$/;"	f
Qt2TwMouseButtonId	vcglib/wrap/qt/anttweakbarMapperNew.cpp	/^TwMouseButtonID Qt2TwMouseButtonId(QMouseEvent *e)$/;"	f
QtOutline2Rasterizer	vcglib/wrap/qt/outline2_rasterizer.h	/^class QtOutline2Rasterizer$/;"	c
QtUtilityFunctions	vcglib/wrap/io_trimesh/export_idtf.h	/^namespace QtUtilityFunctions$/;"	n	namespace:vcg::tri::io
QuadDiagCollapseOp	vcglib/vcg/complex/algorithms/local_optimization.h	/^				QuadDiagCollapseOp, QuadEdgeCollapseOp};$/;"	e	enum:vcg::ModifierType
QuadDiagonalCollapse	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            QuadDiagonalCollapse(){}$/;"	f	class:vcg::tri::QuadDiagonalCollapse
QuadDiagonalCollapse	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            QuadDiagonalCollapse(HEdgePointer he, int mark)$/;"	f	class:vcg::tri::QuadDiagonalCollapse
QuadDiagonalCollapse	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^        class QuadDiagonalCollapse: public QuadDiagonalCollapseBase<MeshType, MYTYPE, TriMeshType, OptimizationType>$/;"	c	namespace:vcg::tri
QuadDiagonalCollapseBase	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            QuadDiagonalCollapseBase(){}$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
QuadDiagonalCollapseBase	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            QuadDiagonalCollapseBase(HEdgePointer he, int mark)$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
QuadDiagonalCollapseBase	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^        class QuadDiagonalCollapseBase: public LocalOptimization<MeshType>::LocModType$/;"	c	namespace:vcg::tri
QuadEdgeCollapseOp	vcglib/vcg/complex/algorithms/local_optimization.h	/^				QuadDiagCollapseOp, QuadEdgeCollapseOp};$/;"	e	enum:vcg::ModifierType
QuadGLDrawIntegerVertices	vcglib/wrap/miq/core/glUtils.h	/^   static void QuadGLDrawIntegerVertices(QuadrangulatorType &Quadr)$/;"	f	class:Miq_Gl_Utils
QuadQualityVariationIfVertexRotated	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static ScalarType QuadQualityVariationIfVertexRotated(const FaceType &f, int w0)$/;"	f	class:vcg::tri::BitQuad
QuadTriangulate	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void QuadTriangulate(std::vector<VertexPointer> &q)$/;"	f	class:vcg::tri::BitQuad
Quadrangulate	vcglib/wrap/miq/quadrangulator.h	/^    void Quadrangulate(TriMesh &Tmesh,$/;"	f	class:Quadrangulator
Quadrangulator	vcglib/wrap/miq/quadrangulator.h	/^class Quadrangulator$/;"	c
Quadric	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    Quadric(double av, double bv, double cv, double dv, double ev)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
Quadric	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^class Quadric$/;"	c	class:vcg::tri::UpdateCurvatureFitting
Quadric	vcglib/vcg/math/quadric.h	/^	inline Quadric() { c = -1; }$/;"	f	class:vcg::math::Quadric
Quadric	vcglib/vcg/math/quadric.h	/^class Quadric$/;"	c	namespace:vcg::math
Quadric5	vcglib/vcg/math/quadric5.h	/^	inline Quadric5() { c = -1;}$/;"	f	class:vcg::Quadric5
Quadric5	vcglib/vcg/math/quadric5.h	/^class Quadric5$/;"	c	namespace:vcg
Quadric5Temp	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef	SimpleTempData<typename MeshType::VertContainer, std::vector<std::pair<vcg::TexCoord2f ,Quadric5<double> > > > Quadric5Temp;$/;"	t	class:vcg::tri::QuadricTexHelper
QuadricEpsilon	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  double    QuadricEpsilon;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
QuadricEpsilon	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  double	  QuadricEpsilon;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
QuadricLocal	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        QuadricLocal ()$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
QuadricLocal	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        QuadricLocal (double av, double bv, double cv, double dv, double ev)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
QuadricLocal	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    class QuadricLocal$/;"	c	class:vcg::tri::UpdateCurvatureFitting
QuadricRelax	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static bool QuadricRelax(MeshType &m, std::vector<VertexType *> &seedVec, std::vector<VertexPointer> &frontierVec,$/;"	f	class:vcg::tri::VoronoiProcessing
QuadricSumDistance	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  QuadricSumDistance() {a=0; c=0; b[0]=0; b[1]=0; b[2]=0;}$/;"	f	struct:vcg::tri::VoronoiProcessing::QuadricSumDistance
QuadricSumDistance	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^struct QuadricSumDistance$/;"	s	class:vcg::tri::VoronoiProcessing
QuadricTemp	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef	SimpleTempData<typename MeshType::VertContainer, math::Quadric<double> > QuadricTemp;$/;"	t	class:vcg::tri::QuadricTexHelper
QuadricTexHelper	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^      QuadricTexHelper(){}$/;"	f	class:vcg::tri::QuadricTexHelper
QuadricTexHelper	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^class QuadricTexHelper$/;"	c	namespace:vcg::tri
QuadricType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^		typedef  math::Quadric< double > QuadricType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadric
Quadricd	vcglib/vcg/math/quadric.h	/^typedef Quadric<double> Quadricd;$/;"	t	namespace:vcg::math
Quadricf	vcglib/vcg/math/quadric.h	/^typedef Quadric<float>  Quadricf;$/;"	t	namespace:vcg::math
Quadrici	vcglib/vcg/math/quadric.h	/^typedef Quadric<int>	  Quadrici;$/;"	t	namespace:vcg::math
Quadrics	vcglib/vcg/math/quadric.h	/^typedef Quadric<short>  Quadrics;$/;"	t	namespace:vcg::math
Quality	vcglib/vcg/simplex/edge/component.h	/^template <class A, class TT> class Quality: public TT {$/;"	c	namespace:vcg::edge
Quality	vcglib/vcg/simplex/face/component.h	/^  Quality():_quality(0) {}$/;"	f	class:vcg::face::Quality
Quality	vcglib/vcg/simplex/face/component.h	/^template <class A, class T> class Quality: public T {$/;"	c	namespace:vcg::face
Quality	vcglib/vcg/simplex/vertex/component.h	/^  Quality():_quality(0) {}$/;"	f	class:vcg::vertex::Quality
Quality	vcglib/vcg/simplex/vertex/component.h	/^template <class A, class TT> class Quality: public TT {$/;"	c	namespace:vcg::vertex
Quality	vcglib/vcg/space/triangle3.h	/^P3ScalarType Quality( Point3<P3ScalarType> const &p0, Point3<P3ScalarType> const & p1,  Point3<P3ScalarType> const & p2)$/;"	f	namespace:vcg
Quality3	vcglib/vcg/simplex/face/component.h	/^template <class A, class T> class Quality3: public T {$/;"	c	namespace:vcg::face
Quality3Type	vcglib/vcg/simplex/face/component.h	/^  typedef Point3f Quality3Type;$/;"	t	class:vcg::face::EmptyCore
Quality3Type	vcglib/vcg/simplex/face/component.h	/^  typedef vcg::Point3<A> Quality3Type;$/;"	t	class:vcg::face::Quality3
Quality3d	vcglib/vcg/simplex/face/component.h	/^template <class T> class Quality3d: public Quality3<double, T> {$/;"	c	namespace:vcg::face
Quality3f	vcglib/vcg/simplex/face/component.h	/^template <class T> class Quality3f: public Quality3<float, T> {$/;"	c	namespace:vcg::face
Quality3s	vcglib/vcg/simplex/face/component.h	/^template <class T> class Quality3s: public Quality3<short, T> {$/;"	c	namespace:vcg::face
QualityCheck	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      QualityCheck;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
QualityEdgePredicate	vcglib/vcg/complex/algorithms/refine.h	/^  QualityEdgePredicate(const ScalarType &thr):thr(thr) {}$/;"	f	class:vcg::tri::QualityEdgePredicate
QualityEdgePredicate	vcglib/vcg/complex/algorithms/refine.h	/^class QualityEdgePredicate$/;"	c	namespace:vcg::tri
QualityEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  bool QualityEnabled;$/;"	m	class:vcg::face::vector_ocf
QualityEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  bool QualityEnabled;$/;"	m	class:vcg::vertex::vector_ocf
QualityFace	vcglib/vcg/space/triangle3.h	/^typename TriangleType::ScalarType QualityFace(const TriangleType &t)$/;"	f	namespace:vcg
QualityMeanRatio	vcglib/vcg/space/triangle3.h	/^P3ScalarType QualityMeanRatio(Point3<P3ScalarType> const &p0,$/;"	f	namespace:vcg
QualityMidPointFunctor	vcglib/vcg/complex/algorithms/refine.h	/^  QualityMidPointFunctor(ScalarType _thr):thr(_thr){}$/;"	f	class:vcg::tri::QualityMidPointFunctor
QualityMidPointFunctor	vcglib/vcg/complex/algorithms/refine.h	/^class QualityMidPointFunctor : public std::unary_function<face::Pos<typename MESH_TYPE::FaceType> , typename MESH_TYPE::CoordType>$/;"	c	namespace:vcg::tri
QualityOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class A, class T> class QualityOcc: public T {$/;"	c	namespace:vcg::vertex
QualityOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class A, class T> class QualityOcf: public T {$/;"	c	namespace:vcg::face
QualityOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class A, class T> class QualityOcf: public T {$/;"	c	namespace:vcg::vertex
QualityQuadric	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      QualityQuadric; \/\/ During the initialization manage all the edges as border edges adding a set of additional quadrics that are useful mostly for keeping face aspect ratio good.$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
QualityQuadric	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  bool	    QualityQuadric;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
QualityRadii	vcglib/vcg/space/triangle3.h	/^P3ScalarType QualityRadii(Point3<P3ScalarType> const &p0,$/;"	f	namespace:vcg
QualitySmoothInfo	vcglib/vcg/complex/algorithms/smooth.h	/^class QualitySmoothInfo$/;"	c	class:vcg::tri::Smooth
QualityThr	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  double    QualityThr; \/\/ all$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
QualityThr	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  double	  QualityThr;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
QualityType	vcglib/vcg/simplex/edge/component.h	/^    typedef float QualityType;$/;"	t	class:vcg::edge::EmptyCore
QualityType	vcglib/vcg/simplex/edge/component.h	/^  typedef A QualityType;$/;"	t	class:vcg::edge::Quality
QualityType	vcglib/vcg/simplex/face/component.h	/^  typedef A QualityType;$/;"	t	class:vcg::face::Quality
QualityType	vcglib/vcg/simplex/face/component.h	/^  typedef float QualityType;$/;"	t	class:vcg::face::EmptyCore
QualityType	vcglib/vcg/simplex/face/component_ocf.h	/^  typedef A QualityType;$/;"	t	class:vcg::face::QualityOcf
QualityType	vcglib/vcg/simplex/vertex/component.h	/^  typedef A QualityType;$/;"	t	class:vcg::vertex::Quality
QualityType	vcglib/vcg/simplex/vertex/component.h	/^  typedef float QualityType;$/;"	t	class:vcg::vertex::EmptyCore
QualityType	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef A QualityType;$/;"	t	class:vcg::vertex::QualityOcc
QualityType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef A QualityType;$/;"	t	class:vcg::vertex::QualityOcf
QualityWeight	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      QualityWeight;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
Qualityd	vcglib/vcg/simplex/edge/component.h	/^template <class TT> class Qualityd: public Quality<double, TT> {$/;"	c	namespace:vcg::edge
Qualityd	vcglib/vcg/simplex/face/component.h	/^template <class T> class Qualityd: public Quality<double, T> {$/;"	c	namespace:vcg::face
Qualityd	vcglib/vcg/simplex/vertex/component.h	/^template <class TT> class Qualityd: public Quality<double, TT> {$/;"	c	namespace:vcg::vertex
QualitydOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class QualitydOcc: public QualityOcc<double, T> {};$/;"	c	namespace:vcg::vertex
Qualityf	vcglib/vcg/simplex/edge/component.h	/^template <class TT> class Qualityf: public Quality<float, TT> {$/;"	c	namespace:vcg::edge
Qualityf	vcglib/vcg/simplex/face/component.h	/^template <class T> class Qualityf: public Quality<float, T> {$/;"	c	namespace:vcg::face
Qualityf	vcglib/vcg/simplex/vertex/component.h	/^template <class TT> class Qualityf: public Quality<float, TT> {$/;"	c	namespace:vcg::vertex
QualityfOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class QualityfOcc: public QualityOcc<float, T> {};$/;"	c	namespace:vcg::vertex
QualityfOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class QualityfOcf: public QualityOcf<float, T> {};$/;"	c	namespace:vcg::face
QualityfOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class QualityfOcf: public QualityOcf<float, T> {$/;"	c	namespace:vcg::vertex
Qualitys	vcglib/vcg/simplex/edge/component.h	/^template <class TT> class Qualitys: public Quality<short, TT> {$/;"	c	namespace:vcg::edge
Qualitys	vcglib/vcg/simplex/face/component.h	/^template <class T> class Qualitys: public Quality<short, T> {$/;"	c	namespace:vcg::face
Qualitys	vcglib/vcg/simplex/vertex/component.h	/^template <class TT> class Qualitys: public Quality<short, TT> {$/;"	c	namespace:vcg::vertex
QualitysOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class QualitysOcc: public QualityOcc<short, T> {};$/;"	c	namespace:vcg::vertex
Quaternion	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Quaternion /;"	d
Quaternion	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Quaternion$/;"	d
Quaternion	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(Scalar w, Scalar x, Scalar y, Scalar z)$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(const Quaternion& other) { m_coeffs = other.m_coeffs; }$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline explicit Quaternion(const Quaternion<OtherScalarType>& other)$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^class Quaternion : public RotationBase<Quaternion<_Scalar>,3>$/;"	c	namespace:Eigen
Quaternion	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const Quaternion<OtherScalar, OtherOptions>& other)$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion(Scalar w, Scalar x, Scalar y, Scalar z) : m_coeffs(x, y, z, w){}$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion(const Scalar* data) : m_coeffs(data) {}$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_STRONG_INLINE Quaternion(const QuaternionBase<Derived>& other) { this->Base::operator=(other); }$/;"	f	class:Eigen::Quaternion
Quaternion	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^class Quaternion : public QuaternionBase<Quaternion<_Scalar,_Options> >$/;"	c	namespace:Eigen
Quaternion	vcglib/vcg/math/quaternion.h	/^	Quaternion() {}$/;"	f	class:vcg::Quaternion
Quaternion	vcglib/vcg/math/quaternion.h	/^	Quaternion(const Point4<S> p) : Point4<S>(p)	{}$/;"	f	class:vcg::Quaternion
Quaternion	vcglib/vcg/math/quaternion.h	/^	Quaternion(const S v0, const S v1, const S v2, const S v3): Point4<S>(v0,v1,v2,v3){}	$/;"	f	class:vcg::Quaternion
Quaternion	vcglib/vcg/math/quaternion.h	/^template <class S> Quaternion<S>::Quaternion(const S phi, const Point3<S> &a) {$/;"	f	class:vcg::Quaternion
Quaternion	vcglib/vcg/math/quaternion.h	/^template<class S> class Quaternion: public Point4<S> {$/;"	c	namespace:vcg
QuaternionBase	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^class QuaternionBase : public RotationBase<Derived, 3>$/;"	c	namespace:Eigen
QuaternionMapAlignedd	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, Aligned>  QuaternionMapAlignedd;$/;"	t	namespace:Eigen
QuaternionMapAlignedf	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, Aligned>   QuaternionMapAlignedf;$/;"	t	namespace:Eigen
QuaternionMapd	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, 0>        QuaternionMapd;$/;"	t	namespace:Eigen
QuaternionMapf	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, 0>         QuaternionMapf;$/;"	t	namespace:Eigen
QuaternionToMatrix	vcglib/vcg/math/quaternion.h	/^template<class S, class M> void QuaternionToMatrix(const Quaternion<S> &q, M &m) {$/;"	f	namespace:vcg
QuaternionType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis
QuaternionType	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis
Quaterniond	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Quaterniond /;"	d
Quaterniond	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Quaterniond$/;"	d
Quaterniond	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Quaterniond	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Quaterniond	vcglib/vcg/math/quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:vcg
Quaternionf	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Quaternionf /;"	d
Quaternionf	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Quaternionf$/;"	d
Quaternionf	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Quaternionf	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Quaternionf	vcglib/vcg/math/quaternion.h	/^typedef Quaternion<float>  Quaternionf;$/;"	t	namespace:vcg
QueryNode	vcglib/vcg/space/index/kdtree/kdtree.h	/^			QueryNode() {}$/;"	f	struct:KdTree::QueryNode
QueryNode	vcglib/vcg/space/index/kdtree/kdtree.h	/^			QueryNode(unsigned int id) : nodeId(id) {}$/;"	f	struct:KdTree::QueryNode
QueryNode	vcglib/vcg/space/index/kdtree/kdtree.h	/^	struct QueryNode$/;"	s	class:KdTree
QueryType	vcglib/vcg/simplex/edge/distance.h	/^		typedef Point3<ScalarType> QueryType;$/;"	t	class:vcg::edge::PointDistanceFunctor
QueryType	vcglib/vcg/simplex/face/distance.h	/^            typedef Point3<ScalarType> QueryType;$/;"	t	class:vcg::face::PointDistanceBaseFunctor
QueryType	vcglib/vcg/simplex/face/distance.h	/^        typedef Point3<ScalarType> QueryType;$/;"	t	class:vcg::face::PointDistanceEPFunctor
QueryType	vcglib/vcg/simplex/face/distance.h	/^        typedef S QueryType;$/;"	t	class:vcg::face::PointNormalDistanceFunctor
QueryType	vcglib/vcg/simplex/vertex/distance.h	/^		typedef Point3<SCALARTYPE> QueryType;$/;"	t	class:vcg::vertex::PointDistanceFunctor
QueryType	vcglib/vcg/simplex/vertex/distance.h	/^		typedef Point3<ScalarType> QueryType;$/;"	t	class:vcg::vertex::PointScaledDistanceFunctor
QueryType	vcglib/vcg/simplex/vertex/distance.h	/^		typedef VERTYPE QueryType; $/;"	t	class:vcg::vertex::PointNormalDistanceFunctor
QuickSplit	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^int IncompleteLUT<Scalar>::QuickSplit(VectorV &row, VectorI &ind, int ncut)$/;"	f	class:Eigen::IncompleteLUT
R	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    UpperTriangularType R;$/;"	m	class:Eigen::HybridNonLinearSolver
R	vcglib/vcg/math/histogram.h	/^  std::vector <ScalarType> R; 	\/\/! Range for bins.$/;"	m	class:vcg::Histogram
R	vcglib/vcg/simplex/vertex/component.h	/^          RadiusType &R()       { return _radius; }$/;"	f	class:vcg::vertex::Radius
R	vcglib/vcg/simplex/vertex/component.h	/^    const RadiusType &R() const { return _radius; }$/;"	f	class:vcg::vertex::Radius
R	vcglib/vcg/simplex/vertex/component.h	/^  RadiusType &R()       { static ScalarType v = 0.0; assert(0 && "the radius component is not available"); return v; }$/;"	f	class:vcg::vertex::EmptyCore
R	vcglib/vcg/simplex/vertex/component_occ.h	/^  RadiusType  &R(){  return CAT< vector_occ<VertType>,RadiusType>::Instance()->Get((VertType*)this);}$/;"	f	class:vcg::vertex::RadiusOcc
R	vcglib/vcg/simplex/vertex/component_ocf.h	/^        RadiusType &R()       { assert((*this).Base().RadiusEnabled); return (*this).Base().RadiusV[(*this).Index()];}$/;"	f	class:vcg::vertex::RadiusOcf
R	vcglib/vcg/simplex/vertex/component_ocf.h	/^  const RadiusType &R() const { assert((*this).Base().RadiusEnabled); return (*this).Base().RadiusV[(*this).Index()];}$/;"	f	class:vcg::vertex::RadiusOcf
R	vcglib/wrap/opensg/vertex_component.h	/^	ScalarType R()$/;"	f	class:vcg::vert::OSGColorCore
R1	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  std::vector<Couple > R1\/*,R2*\/;$/;"	m	class:vcg::tri::FourPCS
RAWError	vcglib/wrap/io_trimesh/import_asc.h	/^enum RAWError {$/;"	g	class:vcg::tri::io::ImporterASC
RAWError	vcglib/wrap/io_trimesh/import_raw.h	/^enum RAWError {$/;"	g	class:vcg::tri::io::ImporterRAW
RAW_MAX_TOKEN_LINE_DESCRIPTOR	vcglib/wrap/io_trimesh/import_raw.h	/^#define RAW_MAX_TOKEN_LINE_DESCRIPTOR /;"	d
READY	vcglib/wrap/gcache/token.h	/^    enum Status { LOCKED = 1, READY = 0, CACHE = -1, REMOVE = -2, OUTSIDE = -3 };$/;"	e	enum:vcg::Token::Status
REC	vcglib/wrap/gui/trackrecorder.h	/^	enum { PLAY,REC,OFF } mode;$/;"	e	enum:vcg::TrackRecorder::__anon521
RED_CHANNEL	vcglib/vcg/complex/algorithms/update/color.h	/^enum rgbChMask {ALL_CHANNELS = 7, RED_CHANNEL = 4, GREEN_CHANNEL = 2, BLUE_CHANNEL = 1, NO_CHANNELS = 0 };$/;"	e	enum:vcg::tri::UpdateColor::rgbChMask
RELEASE_LOCK	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define RELEASE_LOCK(/;"	d	file:
RELEASE_MALLOC_GLOBAL_LOCK	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define RELEASE_MALLOC_GLOBAL_LOCK(/;"	d	file:
REMOVE	vcglib/wrap/gcache/token.h	/^    enum Status { LOCKED = 1, READY = 0, CACHE = -1, REMOVE = -2, OUTSIDE = -3 };$/;"	e	enum:vcg::Token::Status
REQUIRE_ORDER	vcglib/wrap/system/getopt.cpp	/^  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER$/;"	e	enum:__anon528	file:
RETURN_IN_ORDER	vcglib/wrap/system/getopt.cpp	/^  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER$/;"	e	enum:__anon528	file:
RGB	vcglib/img/img_attributes.h	/^    RGB,$/;"	e	enum:img::COLORSPACE
RGB2XYZ	vcglib/vcg/space/colorspace.h	/^	static double RGB2XYZ(int index)$/;"	f	class:vcg::ColorSpace
RGBSpaces	vcglib/vcg/space/colorspace.h	/^	enum RGBSpaces$/;"	g	class:vcg::ColorSpace
RGBtoHSL	vcglib/vcg/space/colorspace.h	/^	static Color4<T> RGBtoHSL(const Color4<T> & color)$/;"	f	class:vcg::ColorSpace
RGBtoHSL	vcglib/vcg/space/colorspace.h	/^	static void RGBtoHSL(double R, double G, double B, double &H, double &S, double &L)$/;"	f	class:vcg::ColorSpace
RGBtoHSV	vcglib/vcg/space/colorspace.h	/^	static Color4<T> RGBtoHSV(const Color4<T> & color)$/;"	f	class:vcg::ColorSpace
RGBtoHSV	vcglib/vcg/space/colorspace.h	/^	static void RGBtoHSV(double R, double G, double B, double &H, double &S, double &V)$/;"	f	class:vcg::ColorSpace
RGBtoRGB	vcglib/vcg/space/colorspace.h	/^	static Color4<T> RGBtoRGB(const Color4<T> & color, RGBSpaces rgbsrc, RGBSpaces rgbdest, $/;"	f	class:vcg::ColorSpace
RGBtoRGB	vcglib/vcg/space/colorspace.h	/^	static void RGBtoRGB(double Ri, double Gi, double Bi, RGBSpaces rgbsrc,$/;"	f	class:vcg::ColorSpace
RGBtoXYZ	vcglib/vcg/space/colorspace.h	/^	static Color4<T> RGBtoXYZ(const Color4<T> & color, RGBSpaces space, $/;"	f	class:vcg::ColorSpace
RGBtoXYZ	vcglib/vcg/space/colorspace.h	/^	static void RGBtoXYZ(double R, double G, double B, RGBSpaces space, $/;"	f	class:vcg::ColorSpace
RINGWALKER_H	vcglib/vcg/complex/algorithms/nring.h	/^#define RINGWALKER_H$/;"	d
RING_H	vcglib/apps/pivoting/ring.h	/^#define RING_H$/;"	d
RMS	vcglib/vcg/math/histogram.h	/^	ScalarType RMS(){ DirtyCheck(); return rms;}$/;"	f	class:vcg::Distribution
RMS	vcglib/vcg/math/histogram.h	/^	ScalarType RMS(){ return sqrt(rms\/double(cnt));}$/;"	f	class:vcg::Histogram
RMS_dist	vcglib/apps/metro/sampling.h	/^    double          RMS_dist;$/;"	m	class:vcg::Sampling
RRParam	vcglib/vcg/complex/algorithms/point_sampling.h	/^class RRParam$/;"	c	class:vcg::tri::SurfaceSampling
RTCHECK	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define RTCHECK(/;"	d	file:
RTEdge	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^class RTEdge : public vcg::Edge< RTUsedTypes> {};$/;"	c	file:
RTFace	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^class RTFace    : public vcg::Face< RTUsedTypes,$/;"	c	file:
RTMap	vcglib/wrap/gl/fbo.h	/^	typedef std::map<GLenum, RenderTarget *> RTMap;$/;"	t	class:FrameBuffer
RTMap_ci	vcglib/wrap/gl/fbo.h	/^	typedef RTMap::const_iterator RTMap_ci;$/;"	t	class:FrameBuffer
RTMap_i	vcglib/wrap/gl/fbo.h	/^	typedef RTMap::iterator RTMap_i;$/;"	t	class:FrameBuffer
RTMesh	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^class RTMesh    : public vcg::tri::TriMesh<std::vector<RTVertex>, std::vector<RTFace> > {};$/;"	c	file:
RTStorageType	vcglib/wrap/gl/fbo.h	/^	} RTStorageType;$/;"	t	class:RenderTarget	typeref:enum:RenderTarget::__anon516
RTUsedTypes	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^struct RTUsedTypes: public vcg::UsedTypes<vcg::Use<RTVertex>::AsVertexType,vcg::Use<RTEdge>::AsEdgeType,vcg::Use<RTFace>::AsFaceType>{};$/;"	s	file:
RTVertex	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^class RTVertex  : public vcg::Vertex< RTUsedTypes,$/;"	c	file:
RUBBERBAND_H	vcglib/wrap/gui/rubberband.h	/^#define RUBBERBAND_H$/;"	d
RUBBER_BEGIN	vcglib/wrap/gui/rubberband.h	/^  typedef enum { RUBBER_BEGIN = 0,$/;"	e	enum:vcg::Rubberband::__anon520
RUBBER_DRAGGED	vcglib/wrap/gui/rubberband.h	/^                 RUBBER_DRAGGED = 2,$/;"	e	enum:vcg::Rubberband::__anon520
RUBBER_DRAGGING	vcglib/wrap/gui/rubberband.h	/^                 RUBBER_DRAGGING = 1,$/;"	e	enum:vcg::Rubberband::__anon520
Radius	vcglib/vcg/simplex/vertex/component.h	/^  template <class A, class TT> class Radius: public TT {$/;"	c	namespace:vcg::vertex
Radius	vcglib/vcg/space/sphere3.h	/^  T &Radius() { return _radius; }$/;"	f	class:vcg::Sphere3
Radius	vcglib/vcg/space/sphere3.h	/^  const T &Radius() const { return _radius; }$/;"	f	class:vcg::Sphere3
RadiusEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  bool RadiusEnabled;$/;"	m	class:vcg::vertex::vector_ocf
RadiusInterval	vcglib/vcg/complex/algorithms/symmetry.h	/^    ScalarType RadiusInterval;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
RadiusOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class A, class TT> class RadiusOcc: public TT {$/;"	c	namespace:vcg::vertex
RadiusOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class A, class TT> class RadiusOcf: public TT {$/;"	c	namespace:vcg::vertex
RadiusType	vcglib/vcg/simplex/vertex/component.h	/^    typedef A RadiusType;$/;"	t	class:vcg::vertex::Radius
RadiusType	vcglib/vcg/simplex/vertex/component.h	/^  typedef ScalarType RadiusType;$/;"	t	class:vcg::vertex::EmptyCore
RadiusType	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef A RadiusType;$/;"	t	class:vcg::vertex::RadiusOcc
RadiusType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef A RadiusType;$/;"	t	class:vcg::vertex::RadiusOcf
RadiusV	vcglib/vcg/simplex/vertex/component_ocf.h	/^  std::vector<typename VALUE_TYPE::RadiusType> RadiusV;$/;"	m	class:vcg::vertex::vector_ocf
RadiusdOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class RadiusdOcc: public RadiusOcc<double, T> {$/;"	c	namespace:vcg::vertex
RadiusdOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class RadiusdOcf: public RadiusOcf<double, T> {};$/;"	c	namespace:vcg::vertex
Radiusf	vcglib/vcg/simplex/vertex/component.h	/^template <class TT> class Radiusf: public Radius<float, TT> {$/;"	c	namespace:vcg::vertex
RadiusfOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class RadiusfOcc: public RadiusOcc<float, T> {$/;"	c	namespace:vcg::vertex
RadiusfOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class RadiusfOcf: public RadiusOcf<float, T> {};$/;"	c	namespace:vcg::vertex
Random	vcglib/eigenlib/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random()$/;"	f	class:Eigen::DenseBase
Random	vcglib/eigenlib/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
Random	vcglib/eigenlib/Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index size)$/;"	f	class:Eigen::DenseBase
Random	vcglib/vcg/math/gen_normal.h	/^static void  Random(int vn, std::vector<Point3<ScalarType > > &NN)$/;"	f	class:vcg::GenNormal
RandomAccessLinSpacedReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,true>,Derived> RandomAccessLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase
RandomAccessPattern	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^const int RandomAccessPattern       = 0x8 | OuterRandomAccessPattern | InnerRandomAccessPattern;$/;"	m	namespace:Eigen
RandomBarycentric	vcglib/vcg/complex/algorithms/point_sampling.h	/^static CoordType RandomBarycentric()$/;"	f	class:vcg::tri::SurfaceSampling
RandomCpx	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^std::complex<T> RandomCpx() { return std::complex<T>( (T)(rand()\/(T)RAND_MAX - .5), (T)(rand()\/(T)RAND_MAX - .5) ); }$/;"	f
RandomDouble01	vcglib/vcg/complex/algorithms/point_sampling.h	/^static double RandomDouble01()$/;"	f	class:vcg::tri::SurfaceSampling
RandomFill	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^void RandomFill(std::vector<T> & vec)$/;"	f
RandomFill	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^void RandomFill(std::vector<std::complex<T> > & vec)$/;"	f
RandomGenerator	vcglib/vcg/math/random_generator.h	/^	RandomGenerator(){}$/;"	f	class:vcg::math::RandomGenerator
RandomGenerator	vcglib/vcg/math/random_generator.h	/^class RandomGenerator$/;"	c	namespace:vcg::math
RandomInt	vcglib/vcg/complex/algorithms/point_sampling.h	/^static unsigned int RandomInt(unsigned int i)$/;"	f	class:vcg::tri::SurfaceSampling
RandomPointInTriangle	vcglib/vcg/complex/algorithms/point_sampling.h	/^static CoordType RandomPointInTriangle(const FaceType &f)$/;"	f	class:vcg::tri::SurfaceSampling
RandomRotation	vcglib/vcg/math/matrix33.h	/^ Matrix33<S> RandomRotation(){$/;"	f	namespace:vcg
RandomRotation	vcglib/vcg/math/old_matrix33.h	/^ Matrix33<S> RandomRotation(){$/;"	f	namespace:vcg
RandomSeg	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^void RandomSeg(vcg::Point2<MyScalarType> &P0,$/;"	f
RandomSetter	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    inline RandomSetter(SparseMatrixType& target)$/;"	f	class:Eigen::RandomSetter
RandomSetter	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^class RandomSetter$/;"	c	namespace:Eigen
RangeCount	vcglib/vcg/math/histogram.h	/^ScalarType Histogram<ScalarType>::RangeCount(ScalarType rangeMin, ScalarType rangeMax)$/;"	f	class:vcg::Histogram
RangeDesc	vcglib/wrap/io_trimesh/import_ply.h	/^static const  PropDescriptor &RangeDesc(int i)$/;"	f	class:vcg::tri::io::ImporterPLY
RasterizedOutline2	vcglib/vcg/space/rasterized_outline2_packer.h	/^    RasterizedOutline2() { }$/;"	f	class:vcg::RasterizedOutline2
RasterizedOutline2	vcglib/vcg/space/rasterized_outline2_packer.h	/^class RasterizedOutline2$/;"	c	namespace:vcg
RasterizedOutline2Packer	vcglib/vcg/space/rasterized_outline2_packer.h	/^class RasterizedOutline2Packer$/;"	c	namespace:vcg
RasterizerExecution	vcglib/wrap/glw/program.h	/^		enum RasterizerExecution$/;"	g	class:glw::RasterizerSettings
RasterizerSettings	vcglib/wrap/glw/program.h	/^		RasterizerSettings(void)$/;"	f	class:glw::RasterizerSettings
RasterizerSettings	vcglib/wrap/glw/program.h	/^class RasterizerSettings$/;"	c	namespace:glw
RawVolumeImporter	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^class RawVolumeImporter$/;"	c	namespace:vcg
Ray	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^	static inline ObjPtr Ray(TreeType & tree, OBJRAYISECTFUNCT & rayIntersection, const Ray3<ScalarType> & ray, const ScalarType & maxDist, ScalarType & t) {$/;"	f	class:vcg::AABBBinaryTreeRay
Ray2	vcglib/vcg/space/ray2.h	/^	Ray2() {};$/;"	f	class:vcg::Ray2
Ray2	vcglib/vcg/space/ray2.h	/^	Ray2(const PointType &ori, const PointType &dir) {SetOrigin(ori); SetDirection(dir);};$/;"	f	class:vcg::Ray2
Ray2	vcglib/vcg/space/ray2.h	/^	Ray2(const Ray2<ScalarType,!NORM > &r) $/;"	f	class:vcg::Ray2
Ray2	vcglib/vcg/space/ray2.h	/^class Ray2$/;"	c	namespace:vcg
Ray2d	vcglib/vcg/space/ray2.h	/^typedef Ray2<double> Ray2d;$/;"	t	namespace:vcg
Ray2dN	vcglib/vcg/space/ray2.h	/^typedef Ray2<double,true> Ray2dN;$/;"	t	namespace:vcg
Ray2f	vcglib/vcg/space/ray2.h	/^typedef Ray2<float>  Ray2f;$/;"	t	namespace:vcg
Ray2fN	vcglib/vcg/space/ray2.h	/^typedef Ray2<float ,true> Ray2fN;$/;"	t	namespace:vcg
Ray2i	vcglib/vcg/space/ray2.h	/^typedef Ray2<int>    Ray2i;$/;"	t	namespace:vcg
Ray2iN	vcglib/vcg/space/ray2.h	/^typedef Ray2<int   ,true> Ray2iN;$/;"	t	namespace:vcg
Ray2s	vcglib/vcg/space/ray2.h	/^typedef Ray2<short>  Ray2s;$/;"	t	namespace:vcg
Ray2sN	vcglib/vcg/space/ray2.h	/^typedef Ray2<short ,true> Ray2sN;$/;"	t	namespace:vcg
Ray3	vcglib/vcg/space/ray3.h	/^	Ray3() {};$/;"	f	class:vcg::Ray3
Ray3	vcglib/vcg/space/ray3.h	/^	Ray3(const PointType &ori, const PointType &dir) {SetOrigin(ori); SetDirection(dir);};$/;"	f	class:vcg::Ray3
Ray3	vcglib/vcg/space/ray3.h	/^	Ray3(const Ray3<ScalarType,!NORM > &r) $/;"	f	class:vcg::Ray3
Ray3	vcglib/vcg/space/ray3.h	/^class Ray3$/;"	c	namespace:vcg
Ray3Ex	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^	class Ray3Ex {$/;"	c	class:vcg::AABBBinaryTreeRay
Ray3d	vcglib/vcg/space/ray3.h	/^typedef Ray3<double> Ray3d;$/;"	t	namespace:vcg
Ray3dN	vcglib/vcg/space/ray3.h	/^typedef Ray3<double,true> Ray3dN;$/;"	t	namespace:vcg
Ray3f	vcglib/vcg/space/ray3.h	/^typedef Ray3<float>  Ray3f;$/;"	t	namespace:vcg
Ray3fN	vcglib/vcg/space/ray3.h	/^typedef Ray3<float ,true> Ray3fN;$/;"	t	namespace:vcg
Ray3i	vcglib/vcg/space/ray3.h	/^typedef Ray3<int>    Ray3i;$/;"	t	namespace:vcg
Ray3iN	vcglib/vcg/space/ray3.h	/^typedef Ray3<int   ,true> Ray3iN;$/;"	t	namespace:vcg
Ray3s	vcglib/vcg/space/ray3.h	/^typedef Ray3<short>  Ray3s;$/;"	t	namespace:vcg
Ray3sN	vcglib/vcg/space/ray3.h	/^typedef Ray3<short ,true> Ray3sN;$/;"	t	namespace:vcg
RayBaseType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef vcg::RayIterator<GRID,FintFunct, FaceTmark<MESH> > RayBaseType;$/;"	t	class:vcg::tri::TriRayIterator
RayIterator	vcglib/vcg/space/index/space_iterators.h	/^		RayIterator(Spatial_Idexing &_Si,$/;"	f	class:vcg::RayIterator
RayIterator	vcglib/vcg/space/index/space_iterators.h	/^	class RayIterator$/;"	c	namespace:vcg
RayLineDistance	vcglib/wrap/gui/trackutils.h	/^std::pair< float, bool > RayLineDistance(const Ray3f & R,const Line3f & Q,Point3f & R_s, Point3f & Q_t){$/;"	f	namespace:vcg::trackutils
RayLineIntersection	vcglib/vcg/space/intersection2.h	/^	inline bool RayLineIntersection(const vcg::Line2<SCALAR_TYPE> & l,$/;"	f	namespace:vcg
RaySegmentIntersection	vcglib/vcg/space/intersection2.h	/^	inline bool RaySegmentIntersection(const vcg::Ray2<SCALAR_TYPE> & r,$/;"	f	namespace:vcg
RaySpherical	vcglib/vcg/complex/algorithms/closest.h	/^			void RaySpherical(MESH & mesh,GRID & gr, const Ray3<typename GRID::ScalarType> & _ray,$/;"	f	namespace:vcg::tri
RayTriangleIntersectionFunctor	vcglib/vcg/space/intersection3.h	/^class RayTriangleIntersectionFunctor {$/;"	c	namespace:vcg
RayType	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename vcg::Ray3<ScalarType> RayType;$/;"	t	class:vcg::RayIterator
RayType	vcglib/vcg/space/ray2.h	/^	typedef Ray2<RayScalarType,NORM> RayType;$/;"	t	class:vcg::Ray2
RayType	vcglib/vcg/space/ray3.h	/^	typedef Ray3<RayScalarType,NORM> RayType;$/;"	t	class:vcg::Ray3
Read	vcglib/wrap/io_trimesh/import_vmi.h	/^        static int Read( void * dst,  size_t size, size_t count){$/;"	f	class:vcg::tri::io::ImporterVMI
Read	vcglib/wrap/ply/plylib.cpp	/^int PlyFile::Read( void * mem )$/;"	f	class:vcg::ply::PlyFile
ReadAscii	vcglib/wrap/ply/plylib.cpp	/^int ReadAscii( XFILE * fp, const PlyProperty * pr, void * mem, int \/*fmt*\/ )$/;"	f	namespace:vcg::ply
ReadBin	vcglib/wrap/ply/plylib.cpp	/^int ReadBin  ( XFILE * fp, const PlyProperty * pr, void * mem, int fmt )$/;"	f	namespace:vcg::ply
ReadCB	vcglib/wrap/ply/plylib.h	/^	int (* ReadCB)( GZFILE fp, const PlyProperty * r, void * mem, int fmt );$/;"	m	class:vcg::ply::PlyFile
ReadCharA	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadCharA( XFILE * fp, char * c )$/;"	f	namespace:vcg::ply
ReadCharB	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadCharB( XFILE * fp, char * c, int \/*format*\/ )$/;"	f	namespace:vcg::ply
ReadCost	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon185
ReadCost	vcglib/vcg/math/eigen.h	/^		ReadCost = 0,$/;"	e	enum:Eigen::NumTraits::__anon488
ReadCost	vcglib/vcg/math/eigen.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::NumTraits::__anon486
ReadCost	vcglib/vcg/math/eigen.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::NumTraits::__anon487
ReadCost	vcglib/vcg/space/point3.h	/^    ReadCost = 3,$/;"	e	enum:Eigen::NumTraits::__anon511
ReadDouble	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadDouble( XFILE * fp, double & d )$/;"	f	namespace:vcg::ply
ReadDoubleA	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadDoubleA( XFILE * fp, double * d )$/;"	f	namespace:vcg::ply
ReadDoubleB	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadDoubleB( XFILE * fp, double * d, int format )$/;"	f	namespace:vcg::ply
ReadDrawFramebufferBindingParams	vcglib/wrap/glw/framebuffer.h	/^		ReadDrawFramebufferBindingParams(void)$/;"	f	class:glw::ReadDrawFramebufferBindingParams
ReadDrawFramebufferBindingParams	vcglib/wrap/glw/framebuffer.h	/^class ReadDrawFramebufferBindingParams : public FramebufferBindingParams$/;"	c	namespace:glw
ReadFloat	vcglib/wrap/io_trimesh/import_vmi.h	/^        static void ReadFloat( float & v){ Read(&v,1,sizeof(float));}$/;"	f	class:vcg::tri::io::ImporterVMI
ReadFloat	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadFloat( XFILE * fp, float & f )$/;"	f	namespace:vcg::ply
ReadFloatA	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadFloatA( XFILE * fp, float * f )$/;"	f	namespace:vcg::ply
ReadFloatB	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadFloatB( XFILE * fp, float * f, int format )$/;"	f	namespace:vcg::ply
ReadFramebufferBindingParams	vcglib/wrap/glw/framebuffer.h	/^		ReadFramebufferBindingParams(void)$/;"	f	class:glw::ReadFramebufferBindingParams
ReadFramebufferBindingParams	vcglib/wrap/glw/framebuffer.h	/^class ReadFramebufferBindingParams : public FramebufferBindingParams$/;"	c	namespace:glw
ReadFromMem	vcglib/wrap/io_trimesh/import_vmi.h	/^        static int ReadFromMem(  OpenMeshType &m, int & mask,char * ptr){$/;"	f	class:vcg::tri::io::ImporterVMI
ReadHeader	vcglib/wrap/io_trimesh/import_nvm.h	/^static bool ReadHeader(FILE *fp,unsigned int &num_cams){$/;"	f	class:vcg::tri::io::ImporterNVM
ReadHeader	vcglib/wrap/io_trimesh/import_nvm.h	/^static bool ReadHeader(const char * filename,unsigned int &\/*num_cams*\/, unsigned int &\/*num_points*\/){$/;"	f	class:vcg::tri::io::ImporterNVM
ReadHeader	vcglib/wrap/io_trimesh/import_out.h	/^static bool ReadHeader(FILE *fp,unsigned int &num_cams, unsigned int &num_points){$/;"	f	class:vcg::tri::io::ImporterOUT
ReadHeader	vcglib/wrap/io_trimesh/import_out.h	/^static bool ReadHeader(const char * filename,unsigned int &\/*num_cams*\/, unsigned int &\/*num_points*\/){$/;"	f	class:vcg::tri::io::ImporterOUT
ReadImagesFilenames	vcglib/wrap/io_trimesh/import_nvm.h	/^static bool ReadImagesFilenames(const char *  filename,std::vector<std::string> &image_filenames)$/;"	f	class:vcg::tri::io::ImporterNVM
ReadImagesFilenames	vcglib/wrap/io_trimesh/import_out.h	/^static bool ReadImagesFilenames(const char *  filename,std::vector<std::string> &image_filenames)$/;"	f	class:vcg::tri::io::ImporterOUT
ReadInt	vcglib/wrap/io_trimesh/import_vmi.h	/^        static void ReadInt( unsigned int & i){ Read(&i,1,4);}$/;"	f	class:vcg::tri::io::ImporterVMI
ReadInt	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadInt( XFILE * fp, int & t )$/;"	f	namespace:vcg::ply
ReadIntA	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadIntA( XFILE * fp, int * i )$/;"	f	namespace:vcg::ply
ReadIntB	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadIntB( XFILE * fp, int * i, int format )$/;"	f	namespace:vcg::ply
ReadOnlyAccessors	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  ReadOnlyAccessors, $/;"	e	enum:Eigen::AccessorLevels
ReadPolyVec	vcglib/vcg/space/outline2_packer.h	/^static bool ReadPolyVec(std::vector< std::vector<Point2x> > &polyVec, const char *filename)$/;"	f	class:vcg::PolyPacker
ReadPos	vcglib/wrap/io_tetramesh/import_ts.h	/^	inline static void  ReadPos( Point3<float> &p){$/;"	f	class:vcg::tetra::io::ImporterTS
ReadPos	vcglib/wrap/io_tetramesh/import_ts.h	/^	inline static void  ReadPos( Point4<ScalarType> &p){$/;"	f	class:vcg::tetra::io::ImporterTS
ReadPos	vcglib/wrap/io_tetramesh/import_ts.h	/^	inline static void ReadPos( Point3<double> &p){$/;"	f	class:vcg::tetra::io::ImporterTS
ReadScalarA	vcglib/wrap/ply/plylib.cpp	/^static int ReadScalarA( XFILE * fp, void * mem, const int tf, const int tm )$/;"	f	namespace:vcg::ply
ReadScalarB	vcglib/wrap/ply/plylib.cpp	/^static int ReadScalarB( XFILE * fp, void * mem, const int tf, const int tm, int fmt )$/;"	f	namespace:vcg::ply
ReadShortA	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadShortA( XFILE * fp, short * s )$/;"	f	namespace:vcg::ply
ReadShortB	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadShortB( XFILE * fp, short * s, int format )$/;"	f	namespace:vcg::ply
ReadShotFromOLDXML	vcglib/wrap/qt/shot_qt.h	/^  bool ReadShotFromOLDXML( ShotType &shot, const QDomNode &node)$/;"	f
ReadShotFromQDomNode	vcglib/wrap/qt/shot_qt.h	/^    bool ReadShotFromQDomNode($/;"	f
ReadString	vcglib/wrap/io_trimesh/import_vmi.h	/^        static void ReadString(std::string & out){$/;"	f	class:vcg::tri::io::ImporterVMI
ReadUCharA	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadUCharA( XFILE * fp, uchar * uc )$/;"	f	namespace:vcg::ply
ReadUCharB	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadUCharB( XFILE * fp, uchar * uc, int \/*format*\/ )$/;"	f	namespace:vcg::ply
ReadUInt	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadUInt( XFILE * fp, unsigned int & t )$/;"	f	namespace:vcg::ply
ReadUIntA	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadUIntA( XFILE * fp, uint * ui )$/;"	f	namespace:vcg::ply
ReadUIntB	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadUIntB( XFILE * fp, uint * ui, int format )$/;"	f	namespace:vcg::ply
ReadUShortA	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadUShortA( XFILE * fp, ushort * us )$/;"	f	namespace:vcg::ply
ReadUShortB	vcglib/wrap/ply/plylib.cpp	/^static inline int ReadUShortB( XFILE * fp, ushort * us, int format )$/;"	f	namespace:vcg::ply
ReadVisibility	vcglib/apps/unsupported/shadevis/visshader.h	/^	 virtual bool ReadVisibility(const char * \/*filename*\/){assert( 0); return false;}$/;"	f	class:vcg::VisShader
Read_mem	vcglib/wrap/io_trimesh/import_vmi.h	/^        static int Read_mem( void *dst , size_t size, size_t count ){ memcpy(dst,&In_mem()[pos()],size*count); pos() += size * count;return size * count; }$/;"	f	class:vcg::tri::io::ImporterVMI
Read_sim	vcglib/wrap/io_trimesh/import_vmi.h	/^        static int Read_sim(const void * , size_t size, size_t count ){ pos() += size * count;return size * count; }$/;"	f	class:vcg::tri::io::ImporterVMI
Real	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^  typedef T Real;$/;"	t	struct:Eigen::GenericNumTraits
Real	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    typedef typename NumTraits<Scalar>::Real Real;$/;"	t	class:Eigen::AutoDiffScalar
Real	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef AutoDiffScalar<Matrix<typename NumTraits<typename DerType::Scalar>::Real,DerType::RowsAtCompileTime,DerType::ColsAtCompileTime> > Real;$/;"	t	struct:Eigen::NumTraits
Real	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef typename NumTraits<Scalar>::Real Real;$/;"	t	struct:Eigen::internal::auto_diff_special_op
Real	vcglib/vcg/math/eigen.h	/^	typedef wrong_type Real;$/;"	t	struct:Eigen::NumTraits
Real	vcglib/vcg/math/eigen.h	/^  typedef short int Real;$/;"	t	struct:Eigen::NumTraits
Real	vcglib/vcg/math/eigen.h	/^  typedef unsigned char Real;$/;"	t	struct:Eigen::NumTraits
Real	vcglib/vcg/math/spherical_harmonics.h	/^	static ScalarType Real(unsigned l, int m, ScalarType theta, ScalarType phi)$/;"	f	class:vcg::math::SphericalHarmonics
RealPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RealScalar>::type RealPacket;$/;"	t	class:Eigen::internal::gebp_traits
RealPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacketSize  = Vectorizable ? packet_traits<RealScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon200
RealReturnType	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type RealReturnType;$/;"	t
RealRowVectorType	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, RealScalar>::type RealRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
RealScalar	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LDLT
RealScalar	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LLT
RealScalar	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::llt_inplace
RealScalar	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::CholmodBase
RealScalar	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ArrayBase
RealScalar	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseBase
RealScalar	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseCoeffsBase
RealScalar	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::RealScalar RealScalar;$/;"	t	class:Eigen::DiagonalBase
RealScalar	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::lpNorm_selector
RealScalar	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::significant_decimals_default_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MapBase
RealScalar	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef bool RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::hypot_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_ref_default_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::norm1_default_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_ref_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_default_impl
RealScalar	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixBase
RealScalar	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::PlainObjectBase
RealScalar	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointView
RealScalar	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::RealScalar RealScalar;$/;"	t	class:Eigen::VectorwiseOp
RealScalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::AlignedBox
RealScalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane
RealScalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine
RealScalar	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LU
RealScalar	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::SVD
RealScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexEigenSolver
RealScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexSchur
RealScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::EigenSolver
RealScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::HessenbergDecomposition
RealScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver
RealScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Tridiagonalization
RealScalar	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
RealScalar	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::Real               RealScalar;$/;"	t	class:Eigen::AlignedBox
RealScalar	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane
RealScalar	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
RealScalar	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine
RealScalar	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::QuaternionBase
RealScalar	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::BiCGSTAB
RealScalar	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ConjugateGradient
RealScalar	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::IncompleteLUT
RealScalar	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::IterativeSolverBase
RealScalar	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiRotation
RealScalar	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::FullPivLU
RealScalar	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::PartialPivLU
RealScalar	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::partial_lu_impl
RealScalar	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::PastixBase
RealScalar	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pastix_traits
RealScalar	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLDLT
RealScalar	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLLT
RealScalar	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLU
RealScalar	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoImpl
RealScalar	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pardiso_traits
RealScalar	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ColPivHouseholderQR
RealScalar	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::FullPivHouseholderQR
RealScalar	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::HouseholderQR
RealScalar	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiSVD
RealScalar	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
RealScalar	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization
RealScalar	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholesky
RealScalar	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholeskyBase
RealScalar	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLDLT
RealScalar	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLLT
RealScalar	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector
RealScalar	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator
RealScalar	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::CompressedStorage
RealScalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SparseMatrixBase
RealScalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename ResultType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
RealScalar	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperILU
RealScalar	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLU
RealScalar	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLUBase
RealScalar	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::UmfPackLU
RealScalar	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::GMRES
RealScalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixExponential
RealScalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixFunction
RealScalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixFunctionAtomic
RealScalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixLogarithmAtomic
RealScalar	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef typename NumTraits<Scalar>::Real       RealScalar;$/;"	t	class:Eigen::internal::companion
RealScalar	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef typename NumTraits<Scalar>::Real    RealScalar;$/;"	t	class:Eigen::PolynomialSolverBase
RealScalar	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::SkylineInplaceLU
RealScalar	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SkylineMatrixBase
RealScalar	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SkylineStorage
RealSchur	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::RealSchur
RealSchur	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::RealSchur
RealSchur	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^template<typename _MatrixType> class RealSchur$/;"	c	namespace:Eigen
RealVectorType	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type RealVectorType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
RecordTrackball	vcglib/wrap/gui/trackrecorder.h	/^	void  RecordTrackball(Trackball & t){$/;"	f	struct:vcg::TrackRecorder
RectPacker	vcglib/vcg/space/rect_packer.h	/^class RectPacker$/;"	c	namespace:vcg
Red	vcglib/vcg/space/color4.h	/^	  Red     = 0xff0000ff,$/;"	e	enum:vcg::Color4::ColorConstant
ReduxReturnType	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    template<typename BinaryOp> struct ReduxReturnType$/;"	s	class:Eigen::VectorwiseOp
Ref	vcglib/vcg/space/index/octree.h	/^        static				TYPE& Ref(TYPE &t)				{ return ( t);	}$/;"	f	struct:vcg::Dereferencer
Ref	vcglib/vcg/space/index/octree.h	/^        static				TYPE& Ref(TYPE* &t)				{ return (*t);	}$/;"	f	struct:vcg::Dereferencer
Ref	vcglib/vcg/space/index/octree.h	/^        static const	TYPE& Ref(const TYPE &t)	{ return ( t);	}$/;"	f	struct:vcg::Dereferencer
Ref	vcglib/vcg/space/index/octree.h	/^        static const	TYPE& Ref(const TYPE* &t) { return (*t);	}$/;"	f	struct:vcg::Dereferencer
RefCountedBindingHandleFromBinding	vcglib/wrap/glw/context.h	/^		struct RefCountedBindingHandleFromBinding$/;"	s	class:glw::Context
RefCountedBindingHandleFromObject	vcglib/wrap/glw/context.h	/^		struct RefCountedBindingHandleFromObject$/;"	s	class:glw::Context
RefCountedBindingPtrMap	vcglib/wrap/glw/context.h	/^		typedef std::map<BindingTarget, RefCountedBindingType *>       RefCountedBindingPtrMap;$/;"	t	class:glw::Context
RefCountedBindingPtrMapConstIterator	vcglib/wrap/glw/context.h	/^		typedef RefCountedBindingPtrMap::const_iterator                RefCountedBindingPtrMapConstIterator;$/;"	t	class:glw::Context
RefCountedBindingPtrMapIterator	vcglib/wrap/glw/context.h	/^		typedef RefCountedBindingPtrMap::iterator                      RefCountedBindingPtrMapIterator;$/;"	t	class:glw::Context
RefCountedBindingPtrMapValue	vcglib/wrap/glw/context.h	/^		typedef RefCountedBindingPtrMap::value_type                    RefCountedBindingPtrMapValue;$/;"	t	class:glw::Context
RefCountedBindingType	vcglib/wrap/glw/context.h	/^		typedef BoundObjectHandle::RefCountedObjectType                RefCountedBindingType;$/;"	t	class:glw::Context
RefCountedObject	vcglib/wrap/glw/bookkeeping.h	/^		RefCountedObject(ObjectType * object, const DeleterType & deleter)$/;"	f	class:glw::detail::RefCountedObject
RefCountedObject	vcglib/wrap/glw/bookkeeping.h	/^class RefCountedObject : public RefCountedObject<TBaseObject, TDeleter, typename BaseOf<TBaseObject>::Type>$/;"	c	namespace:glw::detail
RefCountedObject	vcglib/wrap/glw/bookkeeping.h	/^class RefCountedObject<TObject, TDeleter, NoType>$/;"	c	namespace:glw::detail
RefCountedObjectTraits	vcglib/wrap/glw/bookkeeping.h	/^template <typename T> struct RefCountedObjectTraits { typedef RefCountedObject<T, typename DeleterOf<T>::Type, typename BaseOf<T>::Type> Type; };$/;"	s	namespace:glw::detail
RefCountedObjectType	vcglib/wrap/glw/bookkeeping.h	/^		typedef RefCountedObject<ObjectType, DeleterType, BaseObjectType>                       RefCountedObjectType;$/;"	t	class:glw::detail::ObjectSharedPointer
RefCountedObjectType	vcglib/wrap/glw/bookkeeping.h	/^		typedef RefCountedObject<ObjectType, DeleterType, NoType> RefCountedObjectType;$/;"	t	class:glw::detail::ObjectSharedPointer
RefCountedPtrFromObject	vcglib/wrap/glw/context.h	/^		struct RefCountedPtrFromObject$/;"	s	class:glw::Context
RefCountedPtrPtrMap	vcglib/wrap/glw/context.h	/^		typedef std::map<Object *, RefCountedPtrType *>                RefCountedPtrPtrMap;$/;"	t	class:glw::Context
RefCountedPtrPtrMapConstIterator	vcglib/wrap/glw/context.h	/^		typedef RefCountedPtrPtrMap::const_iterator                    RefCountedPtrPtrMapConstIterator;$/;"	t	class:glw::Context
RefCountedPtrPtrMapIterator	vcglib/wrap/glw/context.h	/^		typedef RefCountedPtrPtrMap::iterator                          RefCountedPtrPtrMapIterator;$/;"	t	class:glw::Context
RefCountedPtrPtrMapValue	vcglib/wrap/glw/context.h	/^		typedef RefCountedPtrPtrMap::value_type                        RefCountedPtrPtrMapValue;$/;"	t	class:glw::Context
RefCountedPtrType	vcglib/wrap/glw/context.h	/^		typedef RefCountedPtrFromObject<ObjectType>::Type              RefCountedPtrType;$/;"	t	class:glw::Context
RefCountedSafeHandleFromObject	vcglib/wrap/glw/context.h	/^		struct RefCountedSafeHandleFromObject$/;"	s	class:glw::Context
Reference	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			static				TYPE& Reference(TYPE				 &t)	{	return  t;	}$/;"	f	struct:vcg::PerfectSpatialHashing::Dereferencer
Reference	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			static				TYPE& Reference(TYPE*			 &t)	{ return *t;  }$/;"	f	struct:vcg::PerfectSpatialHashing::Dereferencer
Reference	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			static const	TYPE& Reference(const TYPE* &t)	{ return *t;	}$/;"	f	struct:vcg::PerfectSpatialHashing::Dereferencer
Reference	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			static const  TYPE& Reference(const TYPE	 &t)	{ return  t;	}$/;"	f	struct:vcg::PerfectSpatialHashing::Dereferencer
ReferenceFrame	vcglib/vcg/math/shot.h	/^  class ReferenceFrame {$/;"	c	class:vcg::Shot
ReferenceType	vcglib/vcg/space/index/octree.h	/^    class ReferenceType$/;"	c	namespace:vcg
ReferenceType	vcglib/vcg/space/index/octree.h	/^    class ReferenceType<T *>$/;"	c	namespace:vcg
ReferenceType	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		struct ReferenceType { typedef TYPE Type; };$/;"	s	class:vcg::PerfectSpatialHashing
ReferenceType	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		struct ReferenceType< TYPE * > { typedef typename ReferenceType<TYPE>::Type Type; };$/;"	s	class:vcg::PerfectSpatialHashing
Refine	vcglib/vcg/complex/algorithms/refine.h	/^bool Refine(MESH_TYPE &m, MIDPOINT mid, typename MESH_TYPE::ScalarType thr=0,bool RefineSelected=false, CallBackPos *cb = 0)$/;"	f	namespace:vcg::tri
RefineE	vcglib/vcg/complex/algorithms/refine.h	/^bool RefineE(MESH_TYPE &m, MIDPOINT &mid, EDGEPRED &ep,bool RefineSelected=false, CallBackPos *cb = 0)$/;"	f	namespace:vcg::tri
RefineOddEven	vcglib/vcg/complex/algorithms/refine_loop.h	/^bool RefineOddEven(MESH_TYPE &m, ODD_VERT odd, EVEN_VERT even,float length,$/;"	f	namespace:vcg::tri
RefineOddEvenE	vcglib/vcg/complex/algorithms/refine_loop.h	/^bool RefineOddEvenE(MESH_TYPE &m, ODD_VERT odd, EVEN_VERT even, PREDICATE edgePred,$/;"	f	namespace:vcg::tri
RefinedFaceData	vcglib/vcg/complex/algorithms/refine.h	/^        RefinedFaceData(){$/;"	f	class:vcg::tri::RefinedFaceData
RefinedFaceData	vcglib/vcg/complex/algorithms/refine.h	/^class RefinedFaceData$/;"	c	namespace:vcg::tri
ReflectiveTag	vcglib/wrap/dae/colladaformat.h	/^		ReflectiveTag()$/;"	f	class:Collada::Tags::ReflectiveTag
ReflectiveTag	vcglib/wrap/dae/colladaformat.h	/^	class ReflectiveTag : public XMLTag$/;"	c	namespace:Collada::Tags
ReflectivityTag	vcglib/wrap/dae/colladaformat.h	/^		ReflectivityTag()$/;"	f	class:Collada::Tags::ReflectivityTag
ReflectivityTag	vcglib/wrap/dae/colladaformat.h	/^	class ReflectivityTag : public XMLTag$/;"	c	namespace:Collada::Tags
Refresh	vcglib/vcg/space/index/space_iterators.h	/^		bool Refresh()$/;"	f	class:vcg::ClosestIterator
Refresh	vcglib/vcg/space/index/space_iterators.h	/^		bool Refresh()$/;"	f	class:vcg::RayIterator
RegionArea	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^    RegionArea=3$/;"	e	enum:vcg::tri::VoronoiProcessingParameter::__anon483
Regular	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool Regular,Semiregular;$/;"	m	struct:MeshInfo	file:
RegularLoopWeight	vcglib/vcg/complex/algorithms/refine_loop.h	/^struct RegularLoopWeight {$/;"	s	namespace:vcg::tri
RegularRecursiveOffset	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void RegularRecursiveOffset(MetroMesh & m, std::vector<Point3f> &pvec, ScalarType offset, float minDiag)$/;"	f	class:vcg::tri::SurfaceSampling
RegularizeTexArea	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^ static void RegularizeTexArea(VoroMesh &m)$/;"	f	class:vcg::tri::VoronoiAtlas
RelativeErrorAndReductionTooSmall	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        RelativeErrorAndReductionTooSmall = 3,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
RelativeErrorTooSmall	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        RelativeErrorTooSmall = 1,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
RelativeErrorTooSmall	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        RelativeErrorTooSmall = 2,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
RelativeReductionTooSmall	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        RelativeReductionTooSmall = 1,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
RelaxRefineTriangulationLaplacian	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void RelaxRefineTriangulationLaplacian(MeshType &m, MeshType &delaMesh, int refineStep=3, int relaxStep=10 )$/;"	f	class:vcg::tri::VoronoiProcessing
RelaxRefineTriangulationSpring	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void RelaxRefineTriangulationSpring(MeshType &m, MeshType &delaMesh, int refineStep=3, int relaxStep=10 )$/;"	f	class:vcg::tri::VoronoiProcessing
Remap	vcglib/vcg/complex/append.h	/^ struct Remap{$/;"	s	class:vcg::tri::Append
Remoteness	vcglib/wrap/gui/frustum.h	/^template <class T> T Frustum<T>::Remoteness(Point3<T> &point, T radius) {$/;"	f	class:vcg::Frustum
Remove	vcglib/vcg/container/container_allocation_table.h	/^Remove( const STL_CONT & c )$/;"	f	class:vcg::CATEntry
Remove	vcglib/vcg/container/container_allocation_table.h	/^Remove(ValueType  *	pt)$/;"	f	class:vcg::CATEntry
Remove	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void Remove( ObjType* s)$/;"	f	class:vcg::SpatialHashTable2D
Remove	vcglib/vcg/space/index/spatial_hashing.h	/^        void Remove( ObjType* s)$/;"	f	class:vcg::SpatialHashTable
RemoveCell	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        bool RemoveCell(ObjType* s)$/;"	f	class:vcg::SpatialHashTable2D
RemoveCell	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void RemoveCell(const Point3i &\/*cell*\/)$/;"	f	class:vcg::SpatialHashTable2D
RemoveCell	vcglib/vcg/space/index/spatial_hashing.h	/^        bool RemoveCell(ObjType* s)$/;"	f	class:vcg::SpatialHashTable
RemoveCell	vcglib/vcg/space/index/spatial_hashing.h	/^    void RemoveCell(const Point3i &\/*cell*\/)$/;"	f	class:vcg::SpatialHashTable
RemoveDegenerateEdge	vcglib/vcg/complex/algorithms/clean.h	/^      static int RemoveDegenerateEdge(MeshType& m)$/;"	f	class:vcg::tri::Clean
RemoveDegenerateFace	vcglib/vcg/complex/algorithms/clean.h	/^      static int RemoveDegenerateFace(MeshType& m)$/;"	f	class:vcg::tri::Clean
RemoveDegenerateVertex	vcglib/vcg/complex/algorithms/clean.h	/^      static int RemoveDegenerateVertex(MeshType& m)$/;"	f	class:vcg::tri::Clean
RemoveDoublet	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void RemoveDoublet(FaceType &f, int wedge, MeshType& m, Pos* affected=NULL){$/;"	f	class:vcg::tri::BitQuad
RemoveDoubletOrSinglet	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool RemoveDoubletOrSinglet(FaceType& f, int wedge, MeshType& m, Pos* affected=NULL){$/;"	f	class:vcg::tri::BitQuad
RemoveDoublets	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static int RemoveDoublets(MeshType &m, Pos *p=NULL)$/;"	f	class:vcg::tri::BitQuadOptimization
RemoveDuplicateEdge	vcglib/vcg/complex/algorithms/clean.h	/^            static int RemoveDuplicateEdge( MeshType & m)    \/\/ V1.0$/;"	f	class:vcg::tri::Clean
RemoveDuplicateFace	vcglib/vcg/complex/algorithms/clean.h	/^            static int RemoveDuplicateFace( MeshType & m)    \/\/ V1.0$/;"	f	class:vcg::tri::Clean
RemoveDuplicateVert_Compare	vcglib/vcg/complex/algorithms/clean.h	/^  class RemoveDuplicateVert_Compare{$/;"	c	class:vcg::tri::Clean
RemoveDuplicateVertex	vcglib/vcg/complex/algorithms/clean.h	/^            static int RemoveDuplicateVertex( MeshType & m, bool RemoveDegenerateFlag=true)    \/\/ V1.0$/;"	f	class:vcg::tri::Clean
RemoveFaceFoldByFlip	vcglib/vcg/complex/algorithms/clean.h	/^      static int RemoveFaceFoldByFlip(MeshType &m, float normalThresholdDeg=175, bool repeat=true)$/;"	f	class:vcg::tri::Clean
RemoveFaceOutOfRangeArea	vcglib/vcg/complex/algorithms/clean.h	/^      static int RemoveFaceOutOfRangeArea(MeshType& m, ScalarType MinAreaThr=0, ScalarType MaxAreaThr=(std::numeric_limits<ScalarType>::max)())$/;"	f	class:vcg::tri::Clean
RemoveFaceOutOfRangeAreaSel	vcglib/vcg/complex/algorithms/clean.h	/^          static int RemoveFaceOutOfRangeAreaSel(MeshType& m, ScalarType MinAreaThr=0, ScalarType MaxAreaThr=(std::numeric_limits<ScalarType>::max)())$/;"	f	class:vcg::tri::Clean
RemoveHEdge	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            static void RemoveHEdge(MeshType &m, HEdgeType * e){$/;"	f	class:vcg::tri::UpdateHalfEdges
RemoveHugeConnectedComponentsDiameter	vcglib/vcg/complex/algorithms/clean.h	/^static std::pair<int,int> RemoveHugeConnectedComponentsDiameter(MeshType &m, ScalarType minDiameter)$/;"	f	class:vcg::tri::Clean
RemoveIfEmpty	vcglib/vcg/container/container_allocation_table.h	/^RemoveIfEmpty( const STL_CONT & c )$/;"	f	class:vcg::CATEntry
RemoveInSphere	vcglib/vcg/space/index/spatial_hashing.h	/^        int RemoveInSphere(const Point3<ScalarType> &p, const ScalarType radius)$/;"	f	class:vcg::SpatialHashTable
RemoveInSphereNormal	vcglib/vcg/space/index/spatial_hashing.h	/^        int RemoveInSphereNormal(const Point3<ScalarType> &p, const Point3<ScalarType> &n, DistanceFunctor &DF, const ScalarType radius)$/;"	f	class:vcg::SpatialHashTable
RemoveNonManifoldFace	vcglib/vcg/complex/algorithms/clean.h	/^      static int RemoveNonManifoldFace(MeshType& m)$/;"	f	class:vcg::tri::Clean
RemoveNonManifoldVertex	vcglib/vcg/complex/algorithms/clean.h	/^            static int RemoveNonManifoldVertex(MeshType& m)$/;"	f	class:vcg::tri::Clean
RemoveObject	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        bool RemoveObject(ObjType* s, const Point2i &cell)$/;"	f	class:vcg::SpatialHashTable2D
RemoveObject	vcglib/vcg/space/index/spatial_hashing.h	/^    bool RemoveObject(ObjType* s, const Point3i &cell)$/;"	f	class:vcg::SpatialHashTable
RemovePunctual	vcglib/vcg/space/index/spatial_hashing.h	/^        void RemovePunctual( ObjType *s)$/;"	f	class:vcg::SpatialHashTable
RemoveRT	vcglib/wrap/gl/fbo.h	/^	bool RemoveRT(RenderTarget * rt)$/;"	f	class:FrameBuffer
RemoveSinglet	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void RemoveSinglet(FaceType &f, int wedge, MeshType& m, Pos* affected=NULL){$/;"	f	class:vcg::tri::BitQuad
RemoveSinglets	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^static int RemoveSinglets(MeshType &m, Pos *p=NULL)$/;"	f	class:vcg::tri::BitQuadOptimization
RemoveSmallConnectedComponentsDiameter	vcglib/vcg/complex/algorithms/clean.h	/^static std::pair<int,int> RemoveSmallConnectedComponentsDiameter(MeshType &m, ScalarType maxDiameter)$/;"	f	class:vcg::tri::Clean
RemoveSmallConnectedComponentsSize	vcglib/vcg/complex/algorithms/clean.h	/^static std::pair<int,int>  RemoveSmallConnectedComponentsSize(MeshType &m, int maxCCSize)$/;"	f	class:vcg::tri::Clean
RemoveTVertexByCollapse	vcglib/vcg/complex/algorithms/clean.h	/^    static int RemoveTVertexByCollapse(MeshType &m, float threshold=40, bool repeat=true)$/;"	f	class:vcg::tri::Clean
RemoveTVertexByFlip	vcglib/vcg/complex/algorithms/clean.h	/^    static int RemoveTVertexByFlip(MeshType &m, float threshold=40, bool repeat=true)$/;"	f	class:vcg::tri::Clean
RemoveUnreferencedVertex	vcglib/vcg/complex/algorithms/clean.h	/^            static int RemoveUnreferencedVertex( MeshType& m, bool DeleteVertexFlag=true)   \/\/ V1.0$/;"	f	class:vcg::tri::Clean
RemoveZeroAreaFace	vcglib/vcg/complex/algorithms/clean.h	/^      static int RemoveZeroAreaFace(MeshType& m) { return RemoveFaceOutOfRangeArea(m);}$/;"	f	class:vcg::tri::Clean
RemovedBits	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    RemovedBits = ~(EvalToRowMajor ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon424
RemovedBits	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        RemovedBits = ~((EvalToRowMajor ? 0 : RowMajorBit) | (ResultIsSkyline ? 0 : SkylineBit)),$/;"	e	enum:Eigen::internal::traits::__anon452
Render	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>::Render($/;"	f	class:SplatRenderer
Render	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>::Render(std::vector<MeshType*> & meshes,  vcg::GLW::ColorMode cm,  vcg::GLW::TextureMode tm )$/;"	f	class:SplatRenderer
Render	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::Render(QGLWidget* glw)$/;"	f	class:ActiveCoordinateFrame
Render	vcglib/wrap/gui/coordinateframe.cpp	/^void CoordinateFrame::Render(QGLWidget* glw,QPainter* p)$/;"	f	class:CoordinateFrame
Render	vcglib/wrap/gui/coordinateframe.cpp	/^void MovableCoordinateFrame::Render(QGLWidget* gla)$/;"	f	class:MovableCoordinateFrame
Render	vcglib/wrap/gui/rubberband.cpp	/^void Rubberband::Render(QGLWidget* gla)$/;"	f	class:Rubberband
RenderFloor	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^void RenderFloor(){$/;"	f
RenderTarget	vcglib/wrap/gl/fbo.h	/^	RenderTarget(void) : GLObject(), Bindable(), FrameBufferSemantic()$/;"	f	class:RenderTarget
RenderTarget	vcglib/wrap/gl/fbo.h	/^class RenderTarget : public GLObject, public Bindable, public FrameBufferSemantic$/;"	c
RenderTarget	vcglib/wrap/glw/framebuffer.h	/^		RenderTarget(RenderableHandle & rTarget)$/;"	f	class:glw::RenderTarget
RenderTarget	vcglib/wrap/glw/framebuffer.h	/^		RenderTarget(RenderableHandle & rTarget, GLint rLevel, GLint rLayer, GLenum rFace)$/;"	f	class:glw::RenderTarget
RenderTarget	vcglib/wrap/glw/framebuffer.h	/^		RenderTarget(void)$/;"	f	class:glw::RenderTarget
RenderTarget	vcglib/wrap/glw/framebuffer.h	/^class RenderTarget$/;"	c	namespace:glw
RenderTargetBinding	vcglib/wrap/glw/framebuffer.h	/^		RenderTargetBinding(void)$/;"	f	class:glw::RenderTargetBinding
RenderTargetBinding	vcglib/wrap/glw/framebuffer.h	/^class RenderTargetBinding$/;"	c	namespace:glw
RenderTargetMapping	vcglib/wrap/glw/framebuffer.h	/^		RenderTargetMapping(void)$/;"	f	class:glw::RenderTargetMapping
RenderTargetMapping	vcglib/wrap/glw/framebuffer.h	/^class RenderTargetMapping$/;"	c	namespace:glw
RenderTargetVector	vcglib/wrap/glw/framebuffer.h	/^typedef std::vector<RenderTarget> RenderTargetVector;$/;"	t	namespace:glw
Renderable	vcglib/wrap/glw/renderable.h	/^		Renderable(Context * ctx)$/;"	f	class:glw::Renderable
Renderable	vcglib/wrap/glw/renderable.h	/^class Renderable : public Object$/;"	c	namespace:glw
RenderableArguments	vcglib/wrap/glw/renderable.h	/^		RenderableArguments(GLenum aFormat)$/;"	f	class:glw::RenderableArguments
RenderableArguments	vcglib/wrap/glw/renderable.h	/^		RenderableArguments(void)$/;"	f	class:glw::RenderableArguments
RenderableArguments	vcglib/wrap/glw/renderable.h	/^class RenderableArguments : public ObjectArguments$/;"	c	namespace:glw
RenderableBindingParams	vcglib/wrap/glw/renderable.h	/^		RenderableBindingParams(GLenum aTarget, GLenum aUnit)$/;"	f	class:glw::RenderableBindingParams
RenderableBindingParams	vcglib/wrap/glw/renderable.h	/^		RenderableBindingParams(void)$/;"	f	class:glw::RenderableBindingParams
RenderableBindingParams	vcglib/wrap/glw/renderable.h	/^class RenderableBindingParams : public ObjectBindingParams$/;"	c	namespace:glw
RenderableHandle	vcglib/wrap/glw/renderable.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeRenderable> ::Type RenderableHandle;$/;"	t	namespace:glw
RenderablePtr	vcglib/wrap/glw/renderable.h	/^typedef   detail::ObjectSharedPointerTraits  <Renderable> ::Type RenderablePtr;$/;"	t	namespace:glw
Renderbuffer	vcglib/wrap/glw/renderbuffer.h	/^		Renderbuffer(Context * ctx)$/;"	f	class:glw::Renderbuffer
Renderbuffer	vcglib/wrap/glw/renderbuffer.h	/^class Renderbuffer : public Renderable$/;"	c	namespace:glw
RenderbufferArguments	vcglib/wrap/glw/renderbuffer.h	/^		RenderbufferArguments(GLenum aFormat, GLsizei aWidth, GLsizei aHeight)$/;"	f	class:glw::RenderbufferArguments
RenderbufferArguments	vcglib/wrap/glw/renderbuffer.h	/^		RenderbufferArguments(void)$/;"	f	class:glw::RenderbufferArguments
RenderbufferArguments	vcglib/wrap/glw/renderbuffer.h	/^class RenderbufferArguments : public RenderableArguments$/;"	c	namespace:glw
RenderbufferBindingParams	vcglib/wrap/glw/renderbuffer.h	/^		RenderbufferBindingParams(void)$/;"	f	class:glw::RenderbufferBindingParams
RenderbufferBindingParams	vcglib/wrap/glw/renderbuffer.h	/^class RenderbufferBindingParams : public RenderableBindingParams$/;"	c	namespace:glw
RenderbufferHandle	vcglib/wrap/glw/renderbuffer.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeRenderbuffer> ::Type RenderbufferHandle;$/;"	t	namespace:glw
RenderbufferPtr	vcglib/wrap/glw/renderbuffer.h	/^typedef   detail::ObjectSharedPointerTraits  <Renderbuffer> ::Type RenderbufferPtr;$/;"	t	namespace:glw
RenderbufferType	vcglib/wrap/glw/type.h	/^	RenderbufferType,$/;"	e	enum:glw::Type
Reorder	vcglib/vcg/complex/base.h	/^    void Reorder(std::vector<size_t> & newVertIndex){((SimpleTempDataBase *)_handle)->Reorder(newVertIndex);}$/;"	f	class:vcg::PointerToAttribute
Reorder	vcglib/vcg/container/simple_temporary_data.h	/^    void Reorder(std::vector<size_t> &  ){assert(0);}$/;"	f	class:vcg::Attribute
Reorder	vcglib/vcg/container/simple_temporary_data.h	/^    void Reorder(std::vector<size_t> & newVertIndex){$/;"	f	class:vcg::SimpleTempData
ReorderAttribute	vcglib/vcg/complex/allocate.h	/^void ReorderAttribute(ATTR_CONT &c,std::vector<size_t> & newVertIndex, MeshType & \/* m *\/){$/;"	f	namespace:vcg::tri
ReorderFace	vcglib/vcg/simplex/face/component_ocf.h	/^  void ReorderFace( std::vector<size_t>  &newFaceIndex, face::vector_ocf< FaceType > &faceVec)$/;"	f	namespace:vcg::tri
ReorderFace	vcglib/vcg/simplex/face/component_ocf.h	/^void ReorderFace(std::vector<size_t> &newFaceIndex )$/;"	f	class:vcg::face::vector_ocf
Replicate	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    inline Replicate(const OriginalMatrixType& matrix, Index rowFactor, Index colFactor)$/;"	f	class:Eigen::Replicate
Replicate	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    inline explicit Replicate(const OriginalMatrixType& matrix)$/;"	f	class:Eigen::Replicate
Replicate	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^template<typename MatrixType,int RowFactor,int ColFactor> class Replicate$/;"	c	namespace:Eigen
ReplicateReturnType	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    typedef Replicate<ExpressionType,Direction==Vertical?Dynamic:1,Direction==Horizontal?Dynamic:1> ReplicateReturnType;$/;"	t	class:Eigen::VectorwiseOp
Require	vcglib/wrap/glw/utility.h	/^			Require$/;"	e	enum:glw::ShaderHeaderBuilder::ExtensionMode
RequireCompactness	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequireCompactness    (MeshType &m) {$/;"	f	namespace:vcg::tri
RequireEEAdjacency	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequireEEAdjacency    (MeshType &m) { if(!tri::HasEEAdjacency   (m)) throw vcg::MissingComponentException("EEAdjacency"); }$/;"	f	namespace:vcg::tri
RequireFEAdjacency	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequireFEAdjacency    (MeshType &m) { if(!tri::HasFEAdjacency   (m)) throw vcg::MissingComponentException("FEAdjacency"); }$/;"	f	namespace:vcg::tri
RequireFFAdjacency	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequireFFAdjacency    (MeshType &m) { if(!tri::HasFFAdjacency   (m)) throw vcg::MissingComponentException("FFAdjacency"); }$/;"	f	namespace:vcg::tri
RequireFHAdjacency	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequireFHAdjacency    (MeshType &m) { if(!tri::HasFHAdjacency   (m)) throw vcg::MissingComponentException("FHAdjacency"); }$/;"	f	namespace:vcg::tri
RequireInitialization	vcglib/eigenlib/Eigen/src/Core/NumTraits.h	/^    RequireInitialization = internal::is_arithmetic<T>::value ? 0 : 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon185
RequireInitialization	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    RequireInitialization = 1$/;"	e	enum:Eigen::NumTraits::__anon445
RequirePerEdgeAttribute	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerEdgeAttribute(MeshType &m, const char *name)   { if(!HasPerEdgeAttribute(m,name))   throw vcg::MissingComponentException("PerEdge attribute"); }$/;"	f	namespace:vcg::tri
RequirePerEdgeColor	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerEdgeColor   (MeshType &m) { if(!tri::HasPerEdgeColor   (m)) throw vcg::MissingComponentException("PerEdgeColor   "); }$/;"	f	namespace:vcg::tri
RequirePerEdgeFlags	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerEdgeFlags   (MeshType &m) { if(!tri::HasPerEdgeFlags   (m)) throw vcg::MissingComponentException("PerEdgeFlags   "); }$/;"	f	namespace:vcg::tri
RequirePerEdgeMark	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerEdgeMark    (MeshType &m) { if(!tri::HasPerEdgeMark    (m)) throw vcg::MissingComponentException("PerEdgeMark    "); }$/;"	f	namespace:vcg::tri
RequirePerEdgeNormal	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerEdgeNormal  (MeshType &m) { if(!tri::HasPerEdgeNormal  (m)) throw vcg::MissingComponentException("PerEdgeNormal  "); }$/;"	f	namespace:vcg::tri
RequirePerEdgeQuality	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerEdgeQuality (MeshType &m) { if(!tri::HasPerEdgeQuality (m)) throw vcg::MissingComponentException("PerEdgeQuality "); }$/;"	f	namespace:vcg::tri
RequirePerFaceAttribute	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerFaceAttribute(MeshType &m, const char *name)   { if(!HasPerFaceAttribute(m,name))   throw vcg::MissingComponentException("PerFace attribute"); }$/;"	f	namespace:vcg::tri
RequirePerFaceColor	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerFaceColor       (MeshType &m) { if(!tri::HasPerFaceColor       (m)) throw vcg::MissingComponentException("PerFaceColor       "); }$/;"	f	namespace:vcg::tri
RequirePerFaceCurvatureDir	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerFaceCurvatureDir(MeshType &m) { if(!tri::HasPerFaceCurvatureDir(m)) throw vcg::MissingComponentException("PerFaceCurvatureDir"); }$/;"	f	namespace:vcg::tri
RequirePerFaceFlags	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerFaceFlags       (MeshType &m) { if(!tri::HasPerFaceFlags       (m)) throw vcg::MissingComponentException("PerFaceFlags       "); }$/;"	f	namespace:vcg::tri
RequirePerFaceMark	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerFaceMark        (MeshType &m) { if(!tri::HasPerFaceMark        (m)) throw vcg::MissingComponentException("PerFaceMark        "); }$/;"	f	namespace:vcg::tri
RequirePerFaceNormal	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerFaceNormal      (MeshType &m) { if(!tri::HasPerFaceNormal      (m)) throw vcg::MissingComponentException("PerFaceNormal      "); }$/;"	f	namespace:vcg::tri
RequirePerFaceQuality	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerFaceQuality     (MeshType &m) { if(!tri::HasPerFaceQuality     (m)) throw vcg::MissingComponentException("PerFaceQuality     "); }$/;"	f	namespace:vcg::tri
RequirePerFaceWedgeColor	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerFaceWedgeColor   (MeshType &m) { if(!tri::HasPerWedgeColor   (m)) throw vcg::MissingComponentException("PerFaceWedgeColor   "); }$/;"	f	namespace:vcg::tri
RequirePerFaceWedgeNormal	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerFaceWedgeNormal  (MeshType &m) { if(!tri::HasPerWedgeNormal  (m)) throw vcg::MissingComponentException("PerFaceWedgeNormal  "); }$/;"	f	namespace:vcg::tri
RequirePerFaceWedgeTexCoord	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerFaceWedgeTexCoord(MeshType &m) { if(!tri::HasPerWedgeTexCoord(m)) throw vcg::MissingComponentException("PerFaceWedgeTexCoord"); }$/;"	f	namespace:vcg::tri
RequirePerMeshAttribute	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerMeshAttribute(MeshType &m, const char *name)   { if(!HasPerMeshAttribute(m,name))   throw vcg::MissingComponentException("PerMesh attribute"); }$/;"	f	namespace:vcg::tri
RequirePerVertexAttribute	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerVertexAttribute(MeshType &m, const char *name) { if(!HasPerVertexAttribute(m,name)) throw vcg::MissingComponentException("PerVertex attribute"); }$/;"	f	namespace:vcg::tri
RequirePerVertexColor	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerVertexColor       (MeshType &m) { if(!tri::HasPerVertexColor       (m)) throw vcg::MissingComponentException("PerVertexColor       "); }$/;"	f	namespace:vcg::tri
RequirePerVertexCurvature	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerVertexCurvature   (MeshType &m) { if(!tri::HasPerVertexCurvature   (m)) throw vcg::MissingComponentException("PerVertexCurvature   "); }$/;"	f	namespace:vcg::tri
RequirePerVertexCurvatureDir	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerVertexCurvatureDir(MeshType &m) { if(!tri::HasPerVertexCurvatureDir(m)) throw vcg::MissingComponentException("PerVertexCurvatureDir"); }$/;"	f	namespace:vcg::tri
RequirePerVertexFlags	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerVertexFlags       (MeshType &m) { if(!tri::HasPerVertexFlags       (m)) throw vcg::MissingComponentException("PerVertexFlags       "); }$/;"	f	namespace:vcg::tri
RequirePerVertexMark	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerVertexMark        (MeshType &m) { if(!tri::HasPerVertexMark        (m)) throw vcg::MissingComponentException("PerVertexMark        "); }$/;"	f	namespace:vcg::tri
RequirePerVertexNormal	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerVertexNormal      (MeshType &m) { if(!tri::HasPerVertexNormal      (m)) throw vcg::MissingComponentException("PerVertexNormal      "); }$/;"	f	namespace:vcg::tri
RequirePerVertexQuality	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerVertexQuality     (MeshType &m) { if(!tri::HasPerVertexQuality     (m)) throw vcg::MissingComponentException("PerVertexQuality     "); }$/;"	f	namespace:vcg::tri
RequirePerVertexRadius	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerVertexRadius      (MeshType &m) { if(!tri::HasPerVertexRadius      (m)) throw vcg::MissingComponentException("PerVertexRadius      "); }$/;"	f	namespace:vcg::tri
RequirePerVertexTexCoord	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequirePerVertexTexCoord    (MeshType &m) { if(!tri::HasPerVertexTexCoord    (m)) throw vcg::MissingComponentException("PerVertexTexCoord    "); }$/;"	f	namespace:vcg::tri
RequireTriangularMesh	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequireTriangularMesh (MeshType & ) { if(typename MeshType::FaceType::HasPolyInfo()) throw vcg::MissingTriangularRequirementException("");}$/;"	f	namespace:vcg::tri
RequireVEAdjacency	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequireVEAdjacency    (MeshType &m) { if(!tri::HasVEAdjacency   (m)) throw vcg::MissingComponentException("VEAdjacency"); }$/;"	f	namespace:vcg::tri
RequireVFAdjacency	vcglib/vcg/complex/base.h	/^template <class MeshType> void RequireVFAdjacency    (MeshType &m) { if(!tri::HasVFAdjacency   (m)) throw vcg::MissingComponentException("VFAdjacency"); }$/;"	f	namespace:vcg::tri
Res	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseResType>::type Res;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
ResPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResPacket ResPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
ResPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
ResPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
ResPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
ResPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize   = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon200
ResPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Traits::ResPacketSize$/;"	e	enum:Eigen::internal::gebp_kernel::__anon202
ResPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
ResPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
ResPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
ResPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon210
ResPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon211
ResScalar	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^  typedef typename scalar_product_traits<typename traits<T>::Scalar,typename traits<U>::Scalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::dot_nocheck
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::gebp_kernel
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef           Scalar      ResScalar;$/;"	t	class:Eigen::GeneralProduct
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::tribb_kernel
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_triangular_product
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
ResScalar	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::triangular_matrix_vector_product
Resample	vcglib/vcg/complex/algorithms/create/resampler.h	/^static void Resample(Old_Mesh &old_mesh,New_Mesh &new_mesh,  Box3f volumeBox, vcg::Point3<int> accuracy,float max_dist, float thr=0, bool DiscretizeFlag=false, bool MultiSampleFlag=false, bool AbsDistFlag=false, vcg::CallBackPos *cb=0 )$/;"	f	class:vcg::tri::Resampler
Resampler	vcglib/vcg/complex/algorithms/create/resampler.h	/^	class Resampler : public BasicGrid<FLT>$/;"	c	namespace:vcg::tri
RescalingWorld	vcglib/vcg/math/shot.h	/^void Shot<S, RotationType>::RescalingWorld(S scalefactor, bool adjustIntrinsics)$/;"	f	class:vcg::Shot
Reserve	vcglib/vcg/container/entries_allocation_table.h	/^virtual void Reserve(const int & s){data.reserve(s);};$/;"	f	struct:vcg::EntryCAT
Reserve	vcglib/vcg/container/entries_allocation_table.h	/^virtual void Reserve(const int & s){};$/;"	f	class:vcg::EntryCATBase
Reset	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    inline void Reset() {$/;"	f	struct:vcg::tri::PolychordCollapse::PC_Chord
Reset	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    void Reset(const PolyMeshType &mesh) {$/;"	f	class:vcg::tri::PolychordCollapse::PC_Chords
Reset	vcglib/vcg/simplex/tetrahedron/pos.h	/^  void Reset()$/;"	f	class:vcg::tetra::PosLoop
Reset	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::Reset(bool reset_position,bool reset_alignment)$/;"	f	class:ActiveCoordinateFrame
Reset	vcglib/wrap/gui/coordinateframe.cpp	/^void MovableCoordinateFrame::Reset(bool reset_position,bool reset_alignment)$/;"	f	class:MovableCoordinateFrame
Reset	vcglib/wrap/gui/rubberband.cpp	/^void Rubberband::Reset()$/;"	f	class:Rubberband
Reset	vcglib/wrap/gui/trackball.cpp	/^void Trackball::Reset() {$/;"	f	class:Trackball
Reset	vcglib/wrap/gui/trackmode.cpp	/^void AreaMode::Reset()$/;"	f	class:AreaMode
Reset	vcglib/wrap/gui/trackmode.cpp	/^void NavigatorWasdMode::Reset() {$/;"	f	class:NavigatorWasdMode
Reset	vcglib/wrap/gui/trackmode.cpp	/^void PathMode::Reset()$/;"	f	class:PathMode
Reset	vcglib/wrap/gui/trackmode.cpp	/^void PolarMode::Reset() {$/;"	f	class:PolarMode
Reset	vcglib/wrap/gui/trackmode.cpp	/^void TrackMode::Reset (){}$/;"	f	class:TrackMode
ResetMarks	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    void ResetMarks() {$/;"	f	class:vcg::tri::PolychordCollapse::PC_Chords
Reshape	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void Reshape(int _width,int _height){$/;"	f
Resize	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    inline void Resize(const size_t size) {$/;"	f	class:vcg::tri::PolychordCollapse::LinkConditions
Resize	vcglib/vcg/complex/base.h	/^    void Resize(const int & sz){((SimpleTempDataBase *)_handle)->Resize(sz);}$/;"	f	class:vcg::PointerToAttribute
Resize	vcglib/vcg/container/container_allocation_table.h	/^Resize(typename STL_CONT::value_type * pt,int n)$/;"	f	class:vcg::CATEntry
Resize	vcglib/vcg/container/entries_allocation_table.h	/^virtual void Resize(const int & s){data.resize(s);};$/;"	f	struct:vcg::EntryCAT
Resize	vcglib/vcg/container/entries_allocation_table.h	/^virtual void Resize(const int & s){};$/;"	f	class:vcg::EntryCATBase
Resize	vcglib/vcg/container/simple_temporary_data.h	/^    void Resize(const int &  ) {assert(0);}$/;"	f	class:vcg::Attribute
Resize	vcglib/vcg/container/simple_temporary_data.h	/^    void Resize(const int & sz){$/;"	f	class:vcg::SimpleTempData
Resize	vcglib/vcg/math/old_deprecated_matrix.h	/^			void Resize(const unsigned int m, const unsigned int n)$/;"	f	class:vcg::ndim::Matrix
Resize	vcglib/vcg/math/old_matrix.h	/^	void Resize(const unsigned int m, const unsigned int n)$/;"	f	class:vcg::ndim::Matrix
ResizeAttribute	vcglib/vcg/complex/allocate.h	/^void ResizeAttribute(ATTR_CONT &c,const int &   sz  , MeshType &\/*m*\/){$/;"	f	namespace:vcg::tri
Resolution	vcglib/wrap/gui/frustum.h	/^template <class T> T Frustum<T>::Resolution(float dist) {$/;"	f	class:vcg::Frustum
Resort	vcglib/vcg/container/container_allocation_table.h	/^Resort(ValueType* old_start,ValueType* new_start)$/;"	f	class:vcg::CATEntry
RestoreGL	vcglib/apps/unsupported/shadevis/visshader.h	/^	void RestoreGL()$/;"	f	class:vcg::VisShader
ResultAlignment	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment     = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon385
ResultAlignment	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon386
ResultIsSkyline	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        ResultIsSkyline = ProductMode == SkylineTimeSkylineProduct,$/;"	e	enum:Eigen::internal::traits::__anon452
ResultIterator	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef std::pair< ListID,std::list<FrontEdge>::iterator > ResultIterator;$/;"	t	class:vcg::tri::AdvancingFront
ResultMode	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  enum { ResultMode = transform_product_result<LhsMode,RhsMode>::Mode };$/;"	e	enum:Eigen::internal::transform_transform_product_impl::__anon378
ResultScalar	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    ResultScalar;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type
ResultType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl
ResultType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl
ResultType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename ProductReturnType<MatrixType,Other>::Type ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl
ResultType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    typedef typename ProductType::ResultType ResultType;$/;"	t	struct:Eigen::Transform::icc_11_workaround
ResultType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
ResultType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,ResultMode,LhsOptions> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
ResultType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Projective,Options> ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
ResultType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
ResultType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef typename MatrixType::PlainObject ResultType;$/;"	t	struct:Eigen::internal::transform_right_product_impl
ResultType	vcglib/vcg/math/old_matrix44.h	/^	typedef Eigen::Matrix<Scalar,3,1> ResultType;$/;"	t	struct:vcg::ei_matrix44_product_impl
ResultType	vcglib/vcg/math/old_matrix44.h	/^	typedef typename Eigen::ProductReturnType<typename Matrix44<Scalar>::Base,Other>::Type ResultType;$/;"	t	struct:vcg::ei_matrix44_product_impl
Retract	vcglib/wrap/miq/core/seams_initializer.h	/^    void Retract(){$/;"	f	class:SeamsInitializer
RetrieveContainedObjects	vcglib/vcg/space/index/octree.h	/^        inline int RetrieveContainedObjects$/;"	f	class:vcg::Octree
ReturnByValue	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^template<typename Derived> class ReturnByValue$/;"	c	namespace:Eigen
ReturnOpposite	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^        ReturnOpposite = (Options&SelfAdjoint) && (((Index)>0 && Supers==0) || ((Index)<0 && Subs==0)),$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon47
ReturnType	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::traits<Derived>::ReturnType ReturnType;$/;"	t	class:Eigen::ReturnByValue
ReturnType	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename internal::plain_matrix_type_column_major<Rhs>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^                      typename Scalar=typename internal::traits<ExpressionType>::Scalar> struct ReturnType$/;"	s	class:Eigen::VectorwiseOp
ReturnType	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^  typedef T ReturnType;$/;"	t	struct:Eigen::scalar_product_traits
ReturnType	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^  typedef std::complex<T> ReturnType;$/;"	t	struct:Eigen::scalar_product_traits
ReturnType	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^  typedef MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^                 MatrixTypeCleaned::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^                 Rhs::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,1> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,Dim> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^  typedef Transform<Scalar,Dim,Affine> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^        SparseMatrix<Scalar,int(SrcStorageOrder)==RowMajor?ColMajor:RowMajor,Index> >::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  typedef SparseMatrix<typename Rhs::Scalar, Rhs::Options, typename Rhs::Index> ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^   typedef Matrix<A_Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols> ReturnType;$/;"	t	struct:Eigen::internal::scalar_product_traits
ReturnType	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^ typedef AutoDiffScalar<DerType> ReturnType;$/;"	t	struct:Eigen::internal::scalar_product_traits
ReturnType	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^  typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^  typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^    typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^  typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
Reverse	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline Reverse(const MatrixType& matrix) : m_matrix(matrix) { }$/;"	f	class:Eigen::Reverse
Reverse	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^template<typename MatrixType, int Direction> class Reverse$/;"	c	namespace:Eigen
ReverseCol	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^      ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon237
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    ReverseInnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^        inline ReverseInnerIterator(const SparseInnerVectorSet& xpr, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator: public MatrixType::ReverseInnerIterator$/;"	c	class:Eigen::SparseInnerVectorSet
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    ReverseInnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseMatrix
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const TransposeImpl& xpr, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::TransposeImpl
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::ReverseInnerIterator : public MatrixTypeNestedCleaned::ReverseInnerIterator$/;"	c	class:Eigen::SparseTriangularView
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
ReverseInnerIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseVector
ReverseInnerIterator	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    ReverseInnerIterator(const DynamicSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
ReverseInnerIterator	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^class DynamicSparseMatrix<Scalar,_Options,_Index>::ReverseInnerIterator : public SparseVector<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::DynamicSparseMatrix
ReverseOutline2	vcglib/vcg/complex/algorithms/outline_support.h	/^  static void ReverseOutline2(std::vector< Point2<ScalarType> > &outline2)$/;"	f	class:vcg::tri::OutlineUtil
ReversePacket	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^      ReversePacket = (Direction == BothDirections)$/;"	e	enum:Eigen::Reverse::__anon237
ReverseReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef Reverse<Derived, BothDirections> ReverseReturnType;$/;"	t	class:Eigen::DenseBase
ReverseRow	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^      ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon237
Rhs	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^  typedef typename remove_all<_Rhs>::type Rhs;$/;"	t	struct:Eigen::internal::traits
Rhs	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,RhsMode,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseRhsType>::type Rhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
RhsBlasTraits	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef internal::blas_traits<_RhsNested> RhsBlasTraits;$/;"	t	class:Eigen::ProductBase
RhsCleaned	vcglib/eigenlib/Eigen/src/Core/Product.h	/^  typedef typename remove_all<Rhs>::type RhsCleaned;$/;"	t	struct:internal::traits
RhsCoeffReadCost	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon54
RhsCoeffReadCost	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon194
RhsCoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    RhsCoeffReadCost = traits<_RhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon413
RhsCoeffReadCost	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon424
RhsCoeffReadCost	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon452
RhsFlags	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon54
RhsFlags	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon194
RhsFlags	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon424
RhsFlags	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon452
RhsIsSelfAdjoint	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsSelfAdjoint = (RhsMode&SelfAdjoint)==SelfAdjoint$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon213
RhsIsUpper	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsUpper = (RhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon213
RhsIsVectorAtCompileTime	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^      RhsIsVectorAtCompileTime = (Side==OnTheLeft ? Rhs::ColsAtCompileTime : Rhs::RowsAtCompileTime)==1$/;"	e	enum:Eigen::internal::trsolve_traits::__anon244
RhsIterator	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _RhsNested::InnerIterator RhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
RhsMode	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      RhsMode = internal::is_diagonal<_RhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon416
RhsNested	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Rhs>::type RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
RhsNested	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Rhs, Lhs::RowsAtCompileTime, typename internal::plain_matrix_type<Rhs>::type >::type RhsNested;$/;"	t	struct:Eigen::ProductReturnType
RhsNested	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Product
RhsNested	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::ProductBase
RhsNested	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNested;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl
RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::RhsNested RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::RhsNested RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct
RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct
RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    typename internal::nested<Rhs,Lhs::RowsAtCompileTime>::type>::type RhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType
RhsNested	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef const typename internal::nested<Rhs, Lhs::RowsAtCompileTime>::type RhsNested;$/;"	t	struct:Eigen::SkylineProductReturnType
RhsNestedCleaned	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;$/;"	t	class:Product
RhsNestedCleaned	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::triangular_solve_retval
RhsNestedCleaned	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::solve_retval_base
RhsNestedCleaned	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base
RhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::RhsPacket RhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
RhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
RhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
RhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
RhsPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
RhsPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
RhsPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
RhsPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon210
RhsPacketSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon211
RhsProgress	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress   = Traits::RhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon202
RhsProgress	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = ResPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
RhsProgress	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
RhsProgress	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
RhsProgress	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = Vectorizable ? 2*ResPacketSize : 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon200
RhsRowMajor	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsRowMajor = RhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon194
RhsRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    RhsRowMajor = internal::traits<Rhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon423
RhsScalar	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    typedef typename Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct
RhsScalar	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::traits<Rhs>::Scalar RhsScalar;$/;"	t	class:Eigen::ProductBase
RhsScalar	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar RhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
RhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::level3_blocking
RhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct
RhsScalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_LhsScalar,_RhsScalar>::type RhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space
RhsUpLo	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^    RhsUpLo = RhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon215
RhsVectors	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^      RhsVectors  = RhsIsVectorAtCompileTime ? 1 : Dynamic$/;"	e	enum:Eigen::internal::trsolve_traits::__anon245
RightColumn	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef Matrix<Scalar, Deg, 1>                 RightColumn;$/;"	t	class:Eigen::internal::companion
RightScaling	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    VectorXd& RightScaling()$/;"	f	class:Scaling
RingWalker	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    typedef vcg::tri::Nring<MeshType> RingWalker;$/;"	t	class:vcg::tri::Fitmaps
Root	vcglib/vcg/space/index/octree_template.h	/^        inline 				NodePointer Root()					const	{ return nodes[0];					}$/;"	f	class:vcg::OctreeTemplate
RootOf	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct RootOf                    { typedef typename RootOfType<T, typename BaseOf<T>::Type>::Type   Type;  };$/;"	s	namespace:glw::detail
RootOfType	vcglib/wrap/glw/bookkeeping.h	/^template <typename T, typename B> struct RootOfType                { typedef typename RootOfType<B,  typename BaseOf<B>::Type>::Type  Type;  };$/;"	s	namespace:glw::detail
RootOfType	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct RootOfType<T, NoType>     { typedef T                                                        Type;  };$/;"	s	namespace:glw::detail
RootType	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef std::complex<RealScalar>            RootType;$/;"	t	class:Eigen::PolynomialSolverBase
RootsType	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef Matrix<RootType,_Deg,1>             RootsType;$/;"	t	class:Eigen::PolynomialSolverBase
Rot	vcglib/vcg/math/shot.h	/^      RotoType Rot() const  { return rot;}$/;"	f	class:vcg::Shot::ReferenceFrame
Rot	vcglib/wrap/gui/coordinateframe.cpp	/^void MovableCoordinateFrame::Rot(float angle_deg,const Point3f axis)$/;"	f	class:MovableCoordinateFrame
Rotate	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static CoordType Rotate(const FaceType &f0,const FaceType &f1,const CoordType &dir3D)$/;"	f	class:vcg::tri::CrossField
Rotate	vcglib/vcg/math/quaternion.h	/^template <class S> Point3<S> Quaternion<S>::Rotate(const Point3<S> p) const {$/;"	f	class:vcg::Quaternion
Rotate	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 & Rotate( const ScalarType rad ){$/;"	f	class:vcg::ndim::Point2
Rotate	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 & Rotate( const ScalarType rad )$/;"	f	class:vcg::Point2
Rotate	vcglib/vcg/space/point2.h	/^	inline Point2 & Rotate( const Scalar rad )$/;"	f	class:vcg::Point2
Rotate	vcglib/wrap/miq/core/poisson_solver.h	/^    vcg::Point2i Rotate(vcg::Point2i p,int interval)$/;"	f	class:PoissonSolver
RotateEdge	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool RotateEdge(FaceType& f, int w0a, MeshType &m, Pos *affected=NULL){$/;"	f	class:vcg::tri::BitQuad
RotateTag	vcglib/wrap/dae/colladaformat.h	/^		RotateTag(const QString& sid,const vcg::Point4f& p)$/;"	f	class:Collada::Tags::RotateTag
RotateTag	vcglib/wrap/dae/colladaformat.h	/^	class RotateTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
RotateToAlign	vcglib/wrap/gui/coordinateframe.cpp	/^void MovableCoordinateFrame::RotateToAlign(const Point3f source, const Point3f dest)$/;"	f	class:MovableCoordinateFrame
RotateVertex	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool RotateVertex(FaceType &f, int w0, MeshType &\/*m*\/, Pos *affected=NULL)$/;"	f	class:vcg::tri::BitQuad
Rotation2D	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Rotation2D /;"	d
Rotation2D	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Rotation2D$/;"	d
Rotation2D	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D(Scalar a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D
Rotation2D	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D
Rotation2D	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen
Rotation2D	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D(Scalar a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D
Rotation2D	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D
Rotation2D	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen
Rotation2Dd	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Rotation2Dd /;"	d
Rotation2Dd	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Rotation2Dd$/;"	d
Rotation2Dd	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Rotation2Dd	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Rotation2Df	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Rotation2Df /;"	d
Rotation2Df	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Rotation2Df$/;"	d
Rotation2Df	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
Rotation2Df	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
RotationBase	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define RotationBase /;"	d
RotationBase	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef RotationBase$/;"	d
RotationBase	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
RotationBase	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
RotationMatrix	vcglib/vcg/math/matrix33.h	/^Matrix33<S> RotationMatrix(const vcg::Point3<S> &axis,$/;"	f	namespace:vcg
RotationMatrix	vcglib/vcg/math/matrix33.h	/^Matrix33<S> RotationMatrix(vcg::Point3<S> v0,vcg::Point3<S> v1,bool normalized=true)$/;"	f	namespace:vcg
RotationMatrix	vcglib/vcg/math/old_matrix33.h	/^Matrix33<S> RotationMatrix(const vcg::Point3<S> &axis,$/;"	f	namespace:vcg
RotationMatrix	vcglib/vcg/math/old_matrix33.h	/^Matrix33<S> RotationMatrix(vcg::Point3<S> v0,vcg::Point3<S> v1,bool normalized=true)$/;"	f	namespace:vcg
RotationMatrixType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase
RotationMatrixType	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase
RotationalPartByPolarDecomposition	vcglib/vcg/math/polar_decomposition.h	/^void RotationalPartByPolarDecomposition( const vcg::Matrix33<S> & m, vcg::Matrix33<S> &r ){$/;"	f	namespace:vcg
RowMajor	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  RowMajor = 0x1,  \/\/ it is only a coincidence that this is equal to RowMajorBit -- don't rely on that$/;"	e	enum:Eigen::__anon263
RowMajorBit	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^const unsigned int RowMajorBit = 0x1;$/;"	m	namespace:Eigen
RowType	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowType;$/;"	t	class:Eigen::JacobiSVD
RowVector	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, 1> RowVector;$/;"	t	class:Eigen::SVD
RowVectorType	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::LU
RowVectorType	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
RowVectorType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
RowVectorType	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::HouseholderQR
RowVectorType	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, 1, ColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
RowXpr	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::RowXpr RowXpr;$/;"	t	class:Eigen::MatrixBase
RowXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowXpr;$/;"	t
Rows	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    Rows  = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon142
Rows	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    Rows = int(Mode)==(AffineCompact) ? Dim : HDim$/;"	e	enum:Eigen::Transform::__anon373
Rows	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    static const int Rows = Traits::RowsAtCompileTime;$/;"	m	class:Eigen::MatrixFunction
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon4
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon5
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon45
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon48
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon49
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    RowsAtCompileTime = MatrixRows == 0 ? 0 : BlockRows,$/;"	e	enum:Eigen::internal::traits::__anon50
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon53
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon58
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    RowsAtCompileTime = (int(DiagIndex) == Dynamic || int(MatrixType::SizeAtCompileTime) == Dynamic) ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon64
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^      RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon65
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon67
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon68
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon175
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon181
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon186
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon188
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    RowsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon187
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    RowsAtCompileTime = LhsCleaned::RowsAtCompileTime,$/;"	e	enum:internal::traits::__anon192
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    RowsAtCompileTime = traits<Lhs>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon193
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    RowsAtCompileTime = RowFactor==Dynamic || int(MatrixType::RowsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon234
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon236
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    RowsAtCompileTime = ConditionMatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon238
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    RowsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon248
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon251
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    RowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon321
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      RowsAtCompileTime = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon194
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    RowsAtCompileTime = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon348
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon350
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon351
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon352
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon354
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    RowsAtCompileTime = Direction==Vertical  ?  RowsPlusOne : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon359
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^      RowsAtCompileTime = internal::traits<HouseholderSequence>::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon383
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    RowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon382
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon387
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon390
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon396
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon397
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon398
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon442
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon438
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon439
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon440
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon441
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon443
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    RowsAtCompileTime = IsRowMajor ? Size : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon408
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    RowsAtCompileTime    = Tr ? int(traits<Rhs>::RowsAtCompileTime)     : int(traits<Lhs>::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon413
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    RowsAtCompileTime = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon414
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon417
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon418
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    RowsAtCompileTime    = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon424
RowsAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    RowsAtCompileTime = IsColVector ? Dynamic : 1,$/;"	e	enum:Eigen::internal::traits::__anon430
RowsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    static const int RowsAtCompileTime = Traits::RowsAtCompileTime;$/;"	m	class:Eigen::MatrixFunction
RowsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^        RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon450
RowsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon451
RowsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^        RowsAtCompileTime = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon452
RowsAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon456
RowsBlockXpr	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowsBlockXpr;$/;"	t
RowsNumber	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline unsigned int RowsNumber() const { return rows(); };$/;"	f
RowsNumber	vcglib/vcg/math/matrix33.h	/^    inline unsigned int RowsNumber() const$/;"	f	class:vcg::Matrix33
RowsNumber	vcglib/vcg/math/old_deprecated_matrix.h	/^			inline unsigned int RowsNumber() const $/;"	f	class:vcg::ndim::Matrix
RowsPlusOne	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    RowsPlusOne = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon359
RowwiseReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;$/;"	t	class:Eigen::DenseBase
RubberPhase	vcglib/wrap/gui/rubberband.h	/^               } RubberPhase;$/;"	t	class:vcg::Rubberband	typeref:enum:vcg::Rubberband::__anon520
Rubberband	vcglib/wrap/gui/rubberband.cpp	/^Rubberband::Rubberband(Color4b c)$/;"	f	class:Rubberband
Rubberband	vcglib/wrap/gui/rubberband.h	/^class Rubberband$/;"	c	namespace:vcg
Run	vcglib/wrap/minpack/minpack.h	/^void LMDiff::Run( int m_dat,int n_par, double* par, lm_evaluate_type *evaluate,$/;"	f	class:LMDiff
Running	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Running = -1,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
Running	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Running = -1,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
S	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^    S = IsLower ? 0     : I+1$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon246
S	vcglib/wrap/gl/camera.h	/^	typedef typename CameraType::ScalarType S;$/;"	t	struct:GlCamera
S	vcglib/wrap/gl/pos.h	/^			typedef typename PosType::ScalarType S;$/;"	t	struct:vcg::GlPos
S	vcglib/wrap/gl/pos.h	/^			typedef typename VfIteType::ScalarType S;$/;"	t	struct:vcg::GlVfIterator
S	vcglib/wrap/miq/core/poisson_solver.h	/^	SparseSystemData S;$/;"	m	class:PoissonSolver
S1	vcglib/apps/metro/sampling.h	/^    MetroMesh       &S1;$/;"	m	class:vcg::Sampling
S2	vcglib/apps/metro/sampling.h	/^    MetroMesh       &S2;$/;"	m	class:vcg::Sampling
SAVE_ERROR	vcglib/apps/metro/sampling.h	/^						SAVE_ERROR                      = 0x0100,$/;"	e	enum:vcg::SamplingFlags::__anon1
SDL2VCG	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^vcg::Trackball::Button SDL2VCG(int code){$/;"	f
SDL_TIMER	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^#define SDL_TIMER /;"	d	file:
SDP_IsDiagonal	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon415
SDP_IsSparseColMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon415
SDP_IsSparseRowMajor	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon415
SELECTED	vcglib/vcg/connectors/hedge.h	/^		SELECTED   = 0x0020,		\/\/ This bit can be used to select $/;"	e	enum:vcg::HEdgeArityMax::__anon484
SELECTED	vcglib/vcg/simplex/edge/base.h	/^		SELECTED   = 0x0020,		\/\/ This bit can be used to select $/;"	e	enum:vcg::EdgeArityMax::__anon496
SELECTED	vcglib/vcg/simplex/face/base.h	/^		SELECTED    = 0x00000020,		\/\/ Face is selected. Algorithms should try to work only on selected face (if explicitly requested)$/;"	e	enum:vcg::FaceArityMax::__anon497
SELECTED	vcglib/vcg/simplex/tetrahedron/base.h	/^		SELECTED    = 0x00000020,		\/\/ Face is selected. Algorithms should try to work only on selected face (if explicitly requested)$/;"	e	enum:vcg::TetraArityMax::__anon498
SELECTED	vcglib/vcg/simplex/vertex/base.h	/^		SELECTED   = 0x0020,		\/\/ This bit can be used to select $/;"	e	enum:vcg::VertexArityMax::__anon499
SET	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define SET(/;"	d
SET	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef SET$/;"	d
SH	vcglib/vcg/simplex/vertex/component_sph.h	/^	SphType &SH() { return _harmonics; }$/;"	f	class:vcg::vertex::Sph
SHORT	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  SHORT=2,$/;"	e	enum:vcg::RawVolumeImporter::DataType
SHOT_QT_H	vcglib/wrap/qt/shot_qt.h	/^#define SHOT_QT_H$/;"	d
SIMILARITY_H	vcglib/vcg/math/similarity.h	/^#define SIMILARITY_H$/;"	d
SIMILAR_SAMPLING	vcglib/apps/metro/sampling.h	/^						SIMILAR_SAMPLING			          = 0x0040,$/;"	e	enum:vcg::SamplingFlags::__anon1
SIX_SIZE_T_SIZES	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SIX_SIZE_T_SIZES /;"	d	file:
SIZE_T_BITSIZE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SIZE_T_BITSIZE /;"	d	file:
SIZE_T_FOUR	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SIZE_T_FOUR /;"	d	file:
SIZE_T_ONE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SIZE_T_ONE /;"	d	file:
SIZE_T_SIZE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SIZE_T_SIZE /;"	d	file:
SIZE_T_TWO	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SIZE_T_TWO /;"	d	file:
SIZE_T_ZERO	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SIZE_T_ZERO /;"	d	file:
SKIP_MAX_BUF	vcglib/wrap/ply/plylib.cpp	/^const int SKIP_MAX_BUF = 512;$/;"	m	namespace:vcg::ply	file:
SLOTS_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		SLOTS_NODE=				1; $/;"	v
SLOT_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		SLOT_NODE=					2; $/;"	v
SMALLBIN_SHIFT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SMALLBIN_SHIFT /;"	d	file:
SMALLBIN_WIDTH	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SMALLBIN_WIDTH /;"	d	file:
SMFError	vcglib/wrap/io_trimesh/import_smf.h	/^		enum SMFError {$/;"	g	class:vcg::tri::io::ImporterSMF
SMFFacet	vcglib/wrap/io_trimesh/import_smf.h	/^		class SMFFacet$/;"	c	class:vcg::tri::io::ImporterSMF
SMF_LABEL_SIZE	vcglib/wrap/io_trimesh/import_smf.h	/^		enum {SMF_LABEL_SIZE=80};$/;"	e	enum:vcg::tri::io::ImporterSMF::__anon522
SMOOTH	vcglib/apps/sample/trimesh_QT/glarea.h	/^  enum DrawMode{SMOOTH=0,POINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:GLArea::DrawMode
SMOOTH	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^enum DrawMode{SMOOTH=0,PERPOINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:DrawMode	file:
SMPTE_C	vcglib/vcg/space/colorspace.h	/^		SMPTE_C = 13,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
SORT	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define SORT(/;"	d
SORT	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef SORT /;"	d
SORT2	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define SORT2(/;"	d
SORT2	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef SORT2 /;"	d
SOURCES	Makefile	/^SOURCES    = vcg_mesh.cpp \\$/;"	m
SOURCE_DIRTY	vcglib/wrap/gl/shaders.h	/^		SOURCE_DIRTY$/;"	e	enum:Shader::__anon518
SPD	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^  SPD = 0x100,$/;"	e	enum:Eigen::__anon458
SPINS_PER_YIELD	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SPINS_PER_YIELD /;"	d	file:
SPIN_LOCKS_AVAILABLE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SPIN_LOCKS_AVAILABLE /;"	d	file:
SPLATRENDERER_H	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^#define SPLATRENDERER_H$/;"	d
SQR	vcglib/eigenlib/unsupported/test/BVH.cpp	/^inline double SQR(double x) { return x * x; }$/;"	f
SQR	vcglib/vcg/complex/algorithms/inertia.h	/^	inline ScalarType SQR(ScalarType &x) const { return x*x;}$/;"	f	class:vcg::tri::Inertia
SQRT2_2	vcglib/wrap/miq/core/auxmath.h	/^const double SQRT2_2 = 0.7071067811865; \/\/ sqrt(2)\/2 = 1\/sqrt(2)$/;"	v
SQRT_TWO	vcglib/vcg/math/base.h	/^#define SQRT_TWO /;"	d
SRGB	vcglib/img/img_attributes.h	/^    SRGB,$/;"	e	enum:img::COLORSPACE
SRGB	vcglib/vcg/space/colorspace.h	/^		SRGB = 14,$/;"	e	enum:vcg::ColorSpace::RGBSpaces
SRGB_compress_adjust_range_and_save_PGM	vcglib/wrap/qt/img_qt_io.h	/^inline bool SRGB_compress_adjust_range_and_save_PGM(const Image<1,ScalarType,Safe> &linear_image, const QString filename)$/;"	f	namespace:img
SRGB_compress_adjust_range_and_save_RGB	vcglib/wrap/qt/img_qt_io.h	/^inline bool SRGB_compress_adjust_range_and_save_RGB(const Image<3,ScalarType,Safe> &linear_image,const QString filename)$/;"	f	namespace:img
SRGB_compress_adjust_range_and_save_Y	vcglib/wrap/qt/img_qt_io.h	/^inline bool SRGB_compress_adjust_range_and_save_Y(const Image<1,ScalarType,Safe> &linear_image,const QString filename)$/;"	f	namespace:img
SSE	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^    SSE = 0x1,$/;"	e	enum:Eigen::Architecture::Type
STATIC_ASSERT	vcglib/img/img_base.h	/^#define STATIC_ASSERT(/;"	d
STATIC_FLOAT_OR_DOUBLE_TYPECHECK	vcglib/img/img_base.h	/^#define STATIC_FLOAT_OR_DOUBLE_TYPECHECK(/;"	d
STDBf	vcglib/wrap/io_trimesh/export_vmi.h	/^    typedef SimpleTempDataBase STDBf;$/;"	t	class:vcg::tri::io::ExporterVMI
STDBv	vcglib/wrap/io_trimesh/export_vmi.h	/^    typedef SimpleTempDataBase STDBv;$/;"	t	class:vcg::tri::io::ExporterVMI
STDEXT	vcglib/vcg/complex/algorithms/clip.h	/^  #define STDEXT /;"	d
STDEXT	vcglib/vcg/complex/algorithms/clip.h	/^ #define STDEXT /;"	d
STDEXT	vcglib/vcg/complex/algorithms/clustering.h	/^  #define STDEXT /;"	d
STDEXT	vcglib/vcg/complex/algorithms/clustering.h	/^ #define STDEXT /;"	d
STDEXT	vcglib/vcg/complex/algorithms/clustering.h	/^}} namespace STDEXT {$/;"	n
STDEXT	vcglib/vcg/math/disjoint_set.h	/^  #define STDEXT /;"	d
STDEXT	vcglib/vcg/math/disjoint_set.h	/^ #define STDEXT /;"	d
STDEXT	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^#define STDEXT /;"	d
STDEXT	vcglib/vcg/space/index/spatial_hashing.h	/^  #define STDEXT /;"	d
STDEXT	vcglib/vcg/space/index/spatial_hashing.h	/^ #define STDEXT /;"	d
STENCIL	vcglib/wrap/gl/fbo.h	/^		STENCIL$/;"	e	enum:FrameBufferSemantic::__anon515
STLError	vcglib/wrap/io_trimesh/import_stl.h	/^enum STLError {$/;"	g	class:vcg::tri::io::ImporterSTL
STLFacet	vcglib/wrap/io_trimesh/import_stl.h	/^class STLFacet$/;"	c	class:vcg::tri::io::ImporterSTL
STL_LABEL_SIZE	vcglib/wrap/io_trimesh/import_stl.h	/^enum {STL_LABEL_SIZE=80};$/;"	e	enum:vcg::tri::io::ImporterSTL::__anon523
STRIP	vcglib/wrap/bmt/strip_mesh.h	/^  enum Signature { NORMAL = 1, COLOR = 2, STRIP = 4 };$/;"	e	enum:vcg::StripMesh::Signature
STRUCT_MALLINFO_DECLARED	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define STRUCT_MALLINFO_DECLARED /;"	d	file:
STRUCT_MALLINFO_DECLARED	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define STRUCT_MALLINFO_DECLARED /;"	d
STR_HIST_FILENAME_DEFAULT	vcglib/apps/trimeshinfo/defs.h	/^#define STR_HIST_FILENAME_DEFAULT /;"	d
STR_HIST_FILENAME_DEFAULT	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define STR_HIST_FILENAME_DEFAULT /;"	d
STR_NEW_MESH_FILENAME_DEFAULT	vcglib/apps/trimeshinfo/defs.h	/^#define STR_NEW_MESH_FILENAME_DEFAULT /;"	d
STR_NEW_MESH_FILENAME_DEFAULT	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define STR_NEW_MESH_FILENAME_DEFAULT /;"	d
STR_NEW_MESH_FILENAME_DEFAULT_2	vcglib/apps/trimeshinfo/defs.h	/^#define STR_NEW_MESH_FILENAME_DEFAULT_2 /;"	d
STR_NEW_MESH_FILENAME_DEFAULT_2	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define STR_NEW_MESH_FILENAME_DEFAULT_2 /;"	d
SUB	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define SUB(/;"	d
SUB	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef SUB$/;"	d
SUBDIVISION_SAMPLING	vcglib/apps/metro/sampling.h	/^						SUBDIVISION_SAMPLING						= 0x0020,$/;"	e	enum:vcg::SamplingFlags::__anon1
SVD	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    SVD() {} \/\/ a user who relied on compiler-generated default compiler reported problems with MSVC in 2.0.7$/;"	f	class:Eigen::SVD
SVD	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    SVD(const MatrixType& matrix)$/;"	f	class:Eigen::SVD
SVD	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^template<typename MatrixType> class SVD$/;"	c	namespace:Eigen
SVD	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<MatrixType, QRPreconditioner> SVD;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
SVGProperties	vcglib/wrap/io_edgemesh/export_svg.h	/^		SVGProperties() 	$/;"	f	class:vcg::tri::io::SVGProperties
SVGProperties	vcglib/wrap/io_edgemesh/export_svg.h	/^class SVGProperties$/;"	c	namespace:vcg::tri::io
SWITCH	vcglib/wrap/system/qgetopt.h	/^    enum Type { SWITCH, OPTION, ARGUMENT, OPTIONAL };$/;"	e	enum:GetOpt::Option::Type
SYS_ALLOC_PADDING	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define SYS_ALLOC_PADDING /;"	d	file:
SafeBuffer	vcglib/wrap/glw/buffer.h	/^		SafeBuffer(const BufferPtr & buffer)$/;"	f	class:glw::SafeBuffer
SafeBuffer	vcglib/wrap/glw/buffer.h	/^		SafeBuffer(void)$/;"	f	class:glw::SafeBuffer
SafeBuffer	vcglib/wrap/glw/buffer.h	/^class SafeBuffer : public SafeObject$/;"	c	namespace:glw
SafeFragmentShader	vcglib/wrap/glw/fragmentshader.h	/^		SafeFragmentShader(const FragmentShaderPtr & fragmentShader)$/;"	f	class:glw::SafeFragmentShader
SafeFragmentShader	vcglib/wrap/glw/fragmentshader.h	/^class SafeFragmentShader : public SafeShader$/;"	c	namespace:glw
SafeFramebuffer	vcglib/wrap/glw/framebuffer.h	/^		SafeFramebuffer(const FramebufferPtr & program)$/;"	f	class:glw::SafeFramebuffer
SafeFramebuffer	vcglib/wrap/glw/framebuffer.h	/^class SafeFramebuffer : public SafeObject$/;"	c	namespace:glw
SafeGeometryShader	vcglib/wrap/glw/geometryshader.h	/^		SafeGeometryShader(const GeometryShaderPtr & geometryShader)$/;"	f	class:glw::SafeGeometryShader
SafeGeometryShader	vcglib/wrap/glw/geometryshader.h	/^class SafeGeometryShader : public SafeShader$/;"	c	namespace:glw
SafeHandleFromBinding	vcglib/wrap/glw/context.h	/^		struct SafeHandleFromBinding$/;"	s	class:glw::Context
SafeHandleFromObject	vcglib/wrap/glw/context.h	/^		struct SafeHandleFromObject$/;"	s	class:glw::Context
SafeHeapUpdate	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      SafeHeapUpdate;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
SafeHeapUpdate	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  bool    SafeHeapUpdate;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
SafeObject	vcglib/wrap/glw/object.h	/^		SafeObject(const ObjectPtr & object)$/;"	f	class:glw::SafeObject
SafeObject	vcglib/wrap/glw/object.h	/^		SafeObject(void)$/;"	f	class:glw::SafeObject
SafeObject	vcglib/wrap/glw/object.h	/^class SafeObject : public detail::NonCopyable$/;"	c	namespace:glw
SafeProgram	vcglib/wrap/glw/program.h	/^		SafeProgram(const ProgramPtr & program)$/;"	f	class:glw::SafeProgram
SafeProgram	vcglib/wrap/glw/program.h	/^class SafeProgram : public SafeObject$/;"	c	namespace:glw
SafeRenderable	vcglib/wrap/glw/renderable.h	/^		SafeRenderable(const RenderablePtr & renderable)$/;"	f	class:glw::SafeRenderable
SafeRenderable	vcglib/wrap/glw/renderable.h	/^		SafeRenderable(void)$/;"	f	class:glw::SafeRenderable
SafeRenderable	vcglib/wrap/glw/renderable.h	/^class SafeRenderable : public SafeObject$/;"	c	namespace:glw
SafeRenderbuffer	vcglib/wrap/glw/renderbuffer.h	/^		SafeRenderbuffer(const RenderbufferPtr & renderbuffer)$/;"	f	class:glw::SafeRenderbuffer
SafeRenderbuffer	vcglib/wrap/glw/renderbuffer.h	/^		SafeRenderbuffer(void)$/;"	f	class:glw::SafeRenderbuffer
SafeRenderbuffer	vcglib/wrap/glw/renderbuffer.h	/^class SafeRenderbuffer : public SafeRenderable$/;"	c	namespace:glw
SafeShader	vcglib/wrap/glw/shader.h	/^		SafeShader(const ShaderPtr & shader)$/;"	f	class:glw::SafeShader
SafeShader	vcglib/wrap/glw/shader.h	/^		SafeShader(void)$/;"	f	class:glw::SafeShader
SafeShader	vcglib/wrap/glw/shader.h	/^class SafeShader : public SafeObject$/;"	c	namespace:glw
SafeTexture	vcglib/wrap/glw/texture.h	/^		SafeTexture(const TexturePtr & texture)$/;"	f	class:glw::SafeTexture
SafeTexture	vcglib/wrap/glw/texture.h	/^		SafeTexture(void)$/;"	f	class:glw::SafeTexture
SafeTexture	vcglib/wrap/glw/texture.h	/^class SafeTexture : public SafeRenderable$/;"	c	namespace:glw
SafeTexture2D	vcglib/wrap/glw/texture2d.h	/^		SafeTexture2D(const Texture2DPtr & texture2D)$/;"	f	class:glw::SafeTexture2D
SafeTexture2D	vcglib/wrap/glw/texture2d.h	/^		SafeTexture2D(void)$/;"	f	class:glw::SafeTexture2D
SafeTexture2D	vcglib/wrap/glw/texture2d.h	/^class SafeTexture2D : public SafeTexture$/;"	c	namespace:glw
SafeTextureCube	vcglib/wrap/glw/texturecube.h	/^		SafeTextureCube(const TextureCubePtr & texture2D)$/;"	f	class:glw::SafeTextureCube
SafeTextureCube	vcglib/wrap/glw/texturecube.h	/^		SafeTextureCube(void)$/;"	f	class:glw::SafeTextureCube
SafeTextureCube	vcglib/wrap/glw/texturecube.h	/^class SafeTextureCube : public SafeTexture$/;"	c	namespace:glw
SafeVertexShader	vcglib/wrap/glw/vertexshader.h	/^		SafeVertexShader(const VertexShaderPtr & vertexShader)$/;"	f	class:glw::SafeVertexShader
SafeVertexShader	vcglib/wrap/glw/vertexshader.h	/^class SafeVertexShader : public SafeShader$/;"	c	namespace:glw
SameType	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon54
SameType	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon194
SampleEdge	vcglib/apps/metro/sampling.h	/^inline void Sampling<MetroMesh>::SampleEdge(const Point3x & v0, const Point3x & v1, int n_samples_per_edge)$/;"	f	class:vcg::Sampling
SampleNum	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^int SampleNum=64;$/;"	v
SampleSHT	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename vcg::SpatialHashTable<VertexType, ScalarType> SampleSHT;$/;"	t	class:vcg::tri::SurfaceSampling
SampleSHTIterator	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename vcg::SpatialHashTable<VertexType, ScalarType>::CellIterator SampleSHTIterator;$/;"	t	class:vcg::tri::SurfaceSampling
SampleVertNormalEqualized	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    bool SampleVertNormalEqualized(vector<typename MESH_TYPE::VertexPointer>& vert, int SampleNum)$/;"	f	class:OverlapEstimation
SampleVertUniform	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    void SampleVertUniform(MESH_TYPE& m, vector<typename MESH_TYPE::VertexPointer>& vert, int sampleNum)$/;"	f	class:OverlapEstimation
Sampler2DTag	vcglib/wrap/dae/colladaformat.h	/^		Sampler2DTag()$/;"	f	class:Collada::Tags::Sampler2DTag
Sampler2DTag	vcglib/wrap/dae/colladaformat.h	/^	class Sampler2DTag : public XMLTag$/;"	c	namespace:Collada::Tags
SamplesPerAreaUnit	vcglib/apps/metro/metro.cpp	/^bool SamplesPerAreaUnit             = false;$/;"	v
Sampling	vcglib/apps/metro/sampling.h	/^Sampling<MetroMesh>::Sampling(MetroMesh &_s1, MetroMesh &_s2):S1(_s1),S2(_s2)$/;"	f	class:vcg::Sampling
Sampling	vcglib/apps/metro/sampling.h	/^class Sampling$/;"	c	namespace:vcg
SamplingFlags	vcglib/apps/metro/sampling.h	/^struct SamplingFlags{$/;"	s	namespace:vcg
SamplingRandomGenerator	vcglib/vcg/complex/algorithms/point_sampling.h	/^static math::MarsenneTwisterRNG &SamplingRandomGenerator()$/;"	f	class:vcg::tri::SurfaceSampling
Save	vcglib/wrap/bmt/bmt.cpp	/^bool BmtBuilder::Save(const std::string &filename) {  $/;"	f	class:BmtBuilder
Save	vcglib/wrap/io_edgemesh/export_dxf.h	/^	static bool Save(EdgeMeshType  *mp, const char * filename)$/;"	f	class:vcg::edg::io::ExporterDXF
Save	vcglib/wrap/io_edgemesh/export_dxf.h	/^	static void Save(EdgeMeshType *mp, FILE* o )$/;"	f	class:vcg::edg::io::ExporterDXF
Save	vcglib/wrap/io_edgemesh/export_svg.h	/^	static bool Save(EdgeMeshType &m, const char *filename, SVGProperties & pro)$/;"	f	class:vcg::tri::io::ExporterSVG
Save	vcglib/wrap/io_edgemesh/export_svg.h	/^	static bool Save(std::vector<EdgeMeshType*> &meshVec, const char *filename, SVGProperties & pro)$/;"	f	class:vcg::tri::io::ExporterSVG
Save	vcglib/wrap/io_tetramesh/export_ply.h	/^static bool Save(SaveMeshType &m,  const char * filename, bool binary, PlyInfo &pi )	\/\/ V1.0$/;"	f	class:vcg::tetra::io::ExporterPLY
Save	vcglib/wrap/io_tetramesh/export_ply.h	/^static bool Save(SaveMeshType &m,  const char * filename, int savemask )$/;"	f	class:vcg::tetra::io::ExporterPLY
Save	vcglib/wrap/io_tetramesh/export_ply.h	/^static bool Save(SaveMeshType &m, const char * filename, bool binary=true)$/;"	f	class:vcg::tetra::io::ExporterPLY
Save	vcglib/wrap/io_tetramesh/export_ts.h	/^static int Save( MESHTYPE & m, const char * filename )$/;"	f	struct:vcg::tetra::io::ExporterTS
Save	vcglib/wrap/io_trimesh/export.h	/^static int Save(OpenMeshType &m, const char *filename, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::Exporter
Save	vcglib/wrap/io_trimesh/export.h	/^static int Save(OpenMeshType &m, const char *filename, const int mask, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::Exporter
Save	vcglib/wrap/io_trimesh/export_3ds.h	/^		static int Save(SaveMeshType &m, const char * filename, const int &mask, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::Exporter3DS
Save	vcglib/wrap/io_trimesh/export_ctm.h	/^                static int Save(SaveMeshType &m, const char * filename, int mask=0, bool lossLessFlag=false, float relativePrecision=0.0001)$/;"	f	class:vcg::tri::io::ExporterCTM
Save	vcglib/wrap/io_trimesh/export_dae.h	/^		static int Save(const MESHMODEL& model,const char* filename,const int mask,const QDomDocument* doc = NULL)$/;"	f	class:vcg::tri::io::ExporterDAE
Save	vcglib/wrap/io_trimesh/export_dxf.h	/^  static int Save(SaveMeshType &m, const char * filename)$/;"	f	class:vcg::tri::io::ExporterDXF
Save	vcglib/wrap/io_trimesh/export_fbx.h	/^	static int Save(SaveMeshType &m, const char * filename,const bool binary,const bool embed,const int mask)$/;"	f	class:ExporterFBX
Save	vcglib/wrap/io_trimesh/export_gts.h	/^				static int Save(SaveMeshType &m, const char * filename, int mask=0 )$/;"	f	class:vcg::tri::io::ExporterGTS
Save	vcglib/wrap/io_trimesh/export_idtf.h	/^	static int Save(SaveMeshType& m,const char* file,const int mask)$/;"	f	class:vcg::tri::io::ExporterIDTF
Save	vcglib/wrap/io_trimesh/export_obj.h	/^  static int Save(SaveMeshType &m, const char * filename, int mask, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ExporterOBJ
Save	vcglib/wrap/io_trimesh/export_off.h	/^				static int Save(SaveMeshType &m, const char * filename, int mask=0 )$/;"	f	class:vcg::tri::io::ExporterOFF
Save	vcglib/wrap/io_trimesh/export_ply.h	/^static int Save(SaveMeshType &m,  const char * filename, bool binary, PlyInfo &pi, CallBackPos *cb=0)	\/\/ V1.0$/;"	f	class:vcg::tri::io::ExporterPLY
Save	vcglib/wrap/io_trimesh/export_ply.h	/^static int Save(SaveMeshType &m,  const char * filename, int savemask, bool binary = true, CallBackPos *cb=0 )$/;"	f	class:vcg::tri::io::ExporterPLY
Save	vcglib/wrap/io_trimesh/export_ply.h	/^static int Save(SaveMeshType &m, const char * filename, bool binary=true)$/;"	f	class:vcg::tri::io::ExporterPLY
Save	vcglib/wrap/io_trimesh/export_smf.h	/^		static int Save(SaveMeshType &m, const char * filename, const int &mask, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ExporterSMF
Save	vcglib/wrap/io_trimesh/export_stl.h	/^static int Save(SaveMeshType &m, const char * filename , bool binary =true, int mask=0, const char *objectname=0, bool magicsMode=0)$/;"	f	class:vcg::tri::io::ExporterSTL
Save	vcglib/wrap/io_trimesh/export_stl.h	/^static int Save(SaveMeshType &m, const char * filename, const int &mask, CallBackPos *)$/;"	f	class:vcg::tri::io::ExporterSTL
Save	vcglib/wrap/io_trimesh/export_u3d.h	/^	static int Save(SaveMeshType& m,const char* output_file,const char* conv_loc,const u3dparametersclasses::Movie15Parameters& mov_par,const int mask)$/;"	f	class:vcg::tri::io::ExporterU3D
Save	vcglib/wrap/io_trimesh/export_vmi.h	/^        static int Save(const SaveMeshType &m,const char * filename){$/;"	f	class:vcg::tri::io::ExporterVMI
Save	vcglib/wrap/io_trimesh/export_vrml.h	/^				static int Save(SaveMeshType &m, const char * filename, const int &mask, CallBackPos *\/*cb=0*\/)$/;"	f	class:vcg::tri::io::ExporterWRL
Save4ROSY	vcglib/wrap/io_trimesh/export_field.h	/^    static void Save4ROSY(MeshType &mesh,$/;"	f	class:vcg::tri::io::ExporterFIELD
Save4ROSYFace	vcglib/wrap/io_trimesh/export_field.h	/^    static void Save4ROSYFace(MeshType &mesh,$/;"	f	class:vcg::tri::io::ExporterFIELD
SaveBBoxCache	vcglib/wrap/ply/plystuff.h	/^static bool SaveBBoxCache( const char * fname, const Box3<ScalarType> & boxOut )$/;"	f	namespace:vcg::ply
SaveBinary	vcglib/wrap/io_trimesh/export_3ds.h	/^		static int SaveBinary(SaveMeshType &m, const char * filename, const int &mask, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::Exporter3DS
SaveEdge	vcglib/wrap/io_trimesh/export_dxf.h	/^  static bool SaveEdge(SaveMeshType  &mp, const char * filename)$/;"	f	class:vcg::tri::io::ExporterDXF
SaveError	vcglib/wrap/io_trimesh/export_3ds.h	/^		enum SaveError$/;"	g	class:vcg::tri::io::Exporter3DS
SaveError	vcglib/wrap/io_trimesh/export_obj.h	/^  enum SaveError$/;"	g	class:vcg::tri::io::ExporterOBJ
SaveFaceOcf	vcglib/wrap/io_trimesh/export_vmi.h	/^            SaveFaceOcf(  const CONT & \/*face*\/, bool only_header){$/;"	f	struct:vcg::tri::io::ExporterVMI::SaveFaceOcf
SaveFaceOcf	vcglib/wrap/io_trimesh/export_vmi.h	/^            SaveFaceOcf( const face::vector_ocf<FaceType> & face, bool only_header){$/;"	f	struct:vcg::tri::io::ExporterVMI::SaveFaceOcf
SaveFaceOcf	vcglib/wrap/io_trimesh/export_vmi.h	/^        struct SaveFaceOcf<  MeshType, face::vector_ocf<typename MeshType::FaceType> >{$/;"	s	class:vcg::tri::io::ExporterVMI
SaveFaceOcf	vcglib/wrap/io_trimesh/export_vmi.h	/^        struct SaveFaceOcf{$/;"	s	class:vcg::tri::io::ExporterVMI
SaveFileName	vcglib/apps/metro/metro.cpp	/^std::string SaveFileName(const std::string &filename)$/;"	f
SaveHtmlInfo	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^void SaveHtmlInfo(MeshInfo &mi)$/;"	f
SaveLatex	vcglib/wrap/io_trimesh/export_u3d.h	/^	static void SaveLatex(SaveMeshType& \/*m*\/,const QString& file,const u3dparametersclasses::Movie15Parameters& mov_par)$/;"	f	class:vcg::tri::io::ExporterU3D
SaveMeshInfoHtmlTable	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^void SaveMeshInfoHtmlTable(fstream &fout, MeshInfo &mi)$/;"	f
SavePPM	vcglib/apps/unsupported/shadevis/simplepic.h	/^	bool SavePPM( const char * filename )$/;"	f	class:vcg::SimplePic
SaveVertexOcf	vcglib/wrap/io_trimesh/export_vmi.h	/^            SaveVertexOcf(  const CONT & \/*vert*\/, bool only_header){$/;"	f	struct:vcg::tri::io::ExporterVMI::SaveVertexOcf
SaveVertexOcf	vcglib/wrap/io_trimesh/export_vmi.h	/^            SaveVertexOcf(  const vertex::vector_ocf<VertexType> & vert, bool only_header){$/;"	f	struct:vcg::tri::io::ExporterVMI::SaveVertexOcf
SaveVertexOcf	vcglib/wrap/io_trimesh/export_vmi.h	/^        struct SaveVertexOcf<MeshType, vertex::vector_ocf<typename MeshType::VertexType> >{$/;"	s	class:vcg::tri::io::ExporterVMI
SaveVertexOcf	vcglib/wrap/io_trimesh/export_vmi.h	/^        struct SaveVertexOcf{$/;"	s	class:vcg::tri::io::ExporterVMI
SaveXMLInfo	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^void SaveXMLInfo(MeshInfo &mi)$/;"	f
Save_Iv	vcglib/wrap/io_trimesh/export_iv.h	/^void Save_Iv(const char * filename) $/;"	f
Scalar	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LDLT
Scalar	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LLT
Scalar	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::CholmodBase
Scalar	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::ArrayBase
Scalar	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::vml_assign_impl
Scalar	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrix
Scalar	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixWrapper
Scalar	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixBase
Scalar	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::CommaInitializer
Scalar	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseBase
Scalar	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseCoeffsBase
Scalar	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalMatrix
Scalar	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	class:Eigen::DiagonalBase
Scalar	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^  typedef typename scalar_product_traits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/Map.h	/^  typedef typename PlainObjectType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::MapBase
Scalar	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MapBase
Scalar	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^      typedef typename internal::scalar_product_traits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type
Scalar	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MatrixBase
Scalar	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::NoAlias
Scalar	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PermutationBase
Scalar	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::Transpose
Scalar	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::PlainObjectBase
Scalar	vcglib/eigenlib/Eigen/src/Core/Product.h	/^  typedef typename scalar_product_traits<typename traits<LhsCleaned>::Scalar, typename traits<RhsCleaned>::Scalar>::ReturnType Scalar;$/;"	t	struct:internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::ScaledProduct
Scalar	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^  typedef typename scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_impl
Scalar	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_novec_unroller
Scalar	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller
Scalar	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar; $/;"	t	class:Eigen::SelfAdjointView
Scalar	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
Scalar	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::TriangularBase
Scalar	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Scalar Scalar;$/;"	t	class:Eigen::TriangularView
Scalar	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_assignment_selector
Scalar	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::VectorwiseOp
Scalar	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::result_type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::coeff_visitor
Scalar	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::max_coeff_visitor
Scalar	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::min_coeff_visitor
Scalar	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename scalar_product_traits<typename _LhsNested::Scalar, typename _RhsNested::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  Scalar;$/;"	t	class:Eigen::internal::gebp_traits
Scalar	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef std::complex<RealScalar> Scalar;$/;"	t	struct:Eigen::internal::conj_helper
Scalar	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename NestedXpr::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits
Scalar	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^    typedef typename internal::traits<ExpressionType>::Scalar Scalar;$/;"	t	class:Eigen::Cwise
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AlignedBox
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_quaternion_assign_impl
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    typedef typename ei_traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Scaling
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_transform_product_impl
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LU
Scalar	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SVD
Scalar	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexEigenSolver
Scalar	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexSchur
Scalar	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::EigenSolver
Scalar	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HessenbergDecomposition
Scalar	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealSchur
Scalar	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Scalar	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::Scalar Scalar;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
Scalar	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::Tridiagonalization
Scalar	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
Scalar	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  typedef _Scalar                                   Scalar;$/;"	t	class:Eigen::AlignedBox
Scalar	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis
Scalar	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane
Scalar	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename traits<Derived>::Scalar Scalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
Scalar	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::Map
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::QuaternionBase
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::UniformScaling
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform
Scalar	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation
Scalar	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename internal::traits<HouseholderSequence>::Scalar Scalar;$/;"	t	class:Eigen::HouseholderSequence
Scalar	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalPreconditioner
Scalar	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::BiCGSTAB
Scalar	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ConjugateGradient
Scalar	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::IncompleteLUT
Scalar	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::IterativeSolverBase
Scalar	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivLU
Scalar	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PartialPivLU
Scalar	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PastixBase
Scalar	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pastix_traits
Scalar	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLDLT
Scalar	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLLT
Scalar	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLU
Scalar	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PardisoImpl
Scalar	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pardiso_traits
Scalar	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ColPivHouseholderQR
Scalar	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivHouseholderQR
Scalar	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HouseholderQR
Scalar	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::JacobiSVD
Scalar	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
Scalar	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
Scalar	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Scalar	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholesky
Scalar	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholeskyBase
Scalar	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLDLT
Scalar	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLLT
Scalar	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                             Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                         Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::CompressedStorage
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename LhsCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    typedef typename Derived::Scalar Scalar;$/;"	t	class:Eigen::DenseBase::InnerIterator
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef typename traits<MatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename CwiseBinaryXpr::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^                                            typename traits<Rhs>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename _Lhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SparseMatrixBase
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename _LhsNested::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename internal::traits<Lhs>::Scalar Scalar;$/;"	t	struct:Eigen::SparseSparseProductReturnType
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSelfAdjointView
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector
Scalar	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
Scalar	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperILU
Scalar	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperLU
Scalar	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SuperLUBase
Scalar	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::UmfPackLU
Scalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef typename JacobianType::Scalar Scalar;$/;"	t	class:Eigen::AutoDiffJacobian
Scalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    typedef typename internal::traits<DerType>::Scalar Scalar;$/;"	t	class:Eigen::AutoDiffScalar
Scalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  typedef typename traits<DerType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::auto_diff_special_op
Scalar	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    typedef ActiveScalar Scalar;$/;"	t	class:Eigen::AutoDiffVector
Scalar	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  typedef typename Minimizer::Scalar Scalar;$/;"	t	struct:Eigen::internal::minimizer_helper1
Scalar	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  typedef typename Minimizer::Scalar Scalar;$/;"	t	struct:Eigen::internal::minimizer_helper2
Scalar	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::KdBVH
Scalar	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::fftw_impl
Scalar	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::kiss_cpx_fft
Scalar	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::kissfft_impl
Scalar	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::GMRES
Scalar	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::IncompleteLU
Scalar	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Scaling
Scalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    typedef typename internal::traits<MatrixType>::Scalar Scalar;$/;"	t	class:Eigen::MatrixExponential
Scalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename Derived::Scalar Scalar;$/;"	t	class:Eigen::MatrixFunctionReturnValue
Scalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::MatrixFunction
Scalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::MatrixFunction
Scalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::MatrixFunctionAtomic
Scalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	class:Eigen::MatrixLogarithmReturnValue
Scalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::MatrixLogarithmAtomic
Scalar	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::MatrixSquareRootQuasiTriangular
Scalar	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    typedef typename Functor::Scalar Scalar;$/;"	t	class:Eigen::NumericalDiff
Scalar	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    typedef _Scalar                                Scalar;$/;"	t	class:Eigen::internal::companion
Scalar	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    typedef _Scalar                             Scalar;$/;"	t	class:Eigen::PolynomialSolverBase
Scalar	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SkylineInplaceLU
Scalar	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SkylineMatrixBase
Scalar	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename _LhsNested::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::skyline_product_selector
Scalar	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    typedef typename SparseMatrixType::Scalar Scalar;$/;"	t	class:Eigen::RandomSetter
Scalar	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    typedef _Scalar Scalar; \/*!< The spline curve's scalar type. *\/$/;"	t	class:Eigen::Spline
Scalar	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^      typedef _Scalar Scalar; \/*!< The spline curve's scalar type. *\/$/;"	t	struct:Eigen::SplineTraits
Scalar	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^  typedef double Scalar;$/;"	t	struct:PointPointMinimizer	file:
Scalar	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  typedef double Scalar;$/;"	t	struct:BallPointStuff	file:
Scalar	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^  typedef _Scalar Scalar;$/;"	t	struct:Functor	file:
Scalar	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^  typedef _Scalar Scalar;$/;"	t	struct:Functor	file:
Scalar	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  typedef _Scalar Scalar;$/;"	t	struct:TestFunc1	file:
Scalar	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  typedef _Scalar Scalar;$/;"	t	struct:TestFunc1	file:
Scalar	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef typename MESH_TYPE::ScalarType Scalar;$/;"	t	struct:vcg::tri::Centroid
Scalar	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef typename MESH_TYPE::ScalarType Scalar;$/;"	t	struct:vcg::tri::LS3Projection
Scalar	vcglib/vcg/math/old_matrix44.h	/^	typedef typename Other::Scalar Scalar;$/;"	t	struct:vcg::ei_matrix44_product_impl
Scalar	vcglib/vcg/space/index/kdtree/kdtree.h	/^	typedef _Scalar Scalar;$/;"	t	class:KdTree
ScalarAddReturnType	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^    typedef CwiseUnaryOp<internal::scalar_add_op<Scalar>, ExpressionType> ScalarAddReturnType;$/;"	t	class:Eigen::Cwise
ScalarAddReturnType	vcglib/vcg/math/eigen_matrixbase_addons.h	/^typedef CwiseUnaryOp<ei_scalar_add_op<Scalar>, Derived> ScalarAddReturnType;$/;"	t
ScalarCoeffImpl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^                                   _LhsNested, _RhsNested, Scalar> ScalarCoeffImpl;$/;"	t	class:Eigen::CoeffBasedProduct
ScalarIsComplex	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^      ScalarIsComplex = NumTraits<Scalar>::IsComplex$/;"	e	enum:Eigen::PardisoImpl::__anon391
ScalarLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::ScalarType			ScalarLeft;$/;"	t	class:vcg::tri::Append
ScalarMultipleReturnType	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_multiple_op<Scalar>, const Derived> ScalarMultipleReturnType;$/;"	t
ScalarPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type     ScalarPacket;$/;"	t	class:Eigen::internal::gebp_traits
ScalarQuotient1ReturnType	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_quotient1_op<Scalar>, const Derived> ScalarQuotient1ReturnType;$/;"	t
ScalarRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::ScalarType			ScalarRight;$/;"	t	class:vcg::tri::Append
ScalarTraits	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  typedef NumTraits<Scalar>                         ScalarTraits;$/;"	t	class:Eigen::AlignedBox
ScalarType	vcglib/apps/metro/sampling.h	/^    typedef typename MetroMesh::ScalarType			ScalarType;$/;"	t	class:vcg::Sampling
ScalarType	vcglib/apps/sample/trimesh_isosurface/trimesh_isosurface.cpp	/^typedef float ScalarType;$/;"	t	file:
ScalarType	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^typedef CMesh::ScalarType ScalarType;$/;"	t	file:
ScalarType	vcglib/apps/unsupported/extractors/extractor/Definitions.h	/^typedef float ScalarType;$/;"	t
ScalarType	vcglib/apps/unsupported/shadevis/visshader.h	/^    typedef typename MESH_TYPE::ScalarType ScalarType;$/;"	t	class:vcg::VisShader
ScalarType	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::FourPCS
ScalarType	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::BitQuadCreation
ScalarType	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::BitQuadOptimization
ScalarType	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  typedef typename VertexType::ScalarType ScalarType;$/;"	t	class:vcg::tri::GeometricInterpolator
ScalarType	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::BitQuad
ScalarType	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::ScalarType     ScalarType;$/;"	t	class:vcg::tri::ConnectedComponentIterator
ScalarType	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::Clean
ScalarType	vcglib/vcg/complex/algorithms/clip.h	/^	typedef typename CoordType::ScalarType ScalarType;$/;"	t	class:vcg::tri::TriMeshClipper
ScalarType	vcglib/vcg/complex/algorithms/clip.h	/^    typedef typename CoordType::ScalarType ScalarType;$/;"	t	class:vcg::tri::GenericVertexInterpolator
ScalarType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef typename MESH::ScalarType ScalarType;$/;"	t	class:vcg::tri::ClosestFaceEPIterator
ScalarType	vcglib/vcg/complex/algorithms/closest.h	/^			typedef typename MESH::ScalarType ScalarType;$/;"	t	class:vcg::tri::TriRayIterator
ScalarType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::ScalarType  ScalarType;$/;"	t	class:vcg::tri::Clustering
ScalarType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::NearestToCenter
ScalarType	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::ScalarType     ScalarType;$/;"	t	class:vcg::tri::AdvancingFront
ScalarType	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::ScalarType     ScalarType;$/;"	t	class:vcg::tri::AdvancingTest
ScalarType	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  typedef typename MESH::ScalarType     ScalarType;$/;"	t	class:vcg::tri::BallPivoting
ScalarType	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef typename TRIMESH_TYPE::ScalarType			ScalarType;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
ScalarType	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef typename TRIMESH_TYPE::ScalarType			ScalarType;$/;"	t	class:vcg::tri::MarchingCubes
ScalarType	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::TrivialWalker
ScalarType	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef typename MeshType::ScalarType          ScalarType;$/;"	t	class:vcg::tri::CylinderClipping
ScalarType	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  typedef	typename TriMeshType::VertexType::ScalarType ScalarType;$/;"	t	class:vcg::tri::EdgeCollapser
ScalarType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::ScalarType  ScalarType;$/;"	t	class:vcg::tri::AnisotropicDistance
ScalarType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::ScalarType  ScalarType;$/;"	t	class:vcg::tri::Geodesic
ScalarType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::ScalarType  ScalarType;$/;"	t	class:vcg::tri::IsotropicDistance
ScalarType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::ScalarType  ScalarType;$/;"	t	struct:vcg::tri::EuclideanDistance
ScalarType	vcglib/vcg/complex/algorithms/harmonic.h	/^	typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::Harmonic
ScalarType	vcglib/vcg/complex/algorithms/hole.h	/^            typedef	typename MESH::ScalarType				ScalarType;$/;"	t	class:vcg::tri::Hole
ScalarType	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename MESH::ScalarType ScalarType;$/;"	t	class:vcg::tri::SelfIntersectionEar
ScalarType	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename MESH::ScalarType ScalarType;$/;"	t	class:vcg::tri::TrivialEar
ScalarType	vcglib/vcg/complex/algorithms/inertia.h	/^	typedef	typename MeshType::ScalarType			ScalarType;$/;"	t	class:vcg::tri::Inertia
ScalarType	vcglib/vcg/complex/algorithms/inside.h	/^			typedef typename FaceSpatialIndexing::ScalarType ScalarType;$/;"	t	class:vcg::tri::Inside
ScalarType	vcglib/vcg/complex/algorithms/local_optimization.h	/^	typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::LocalOptimization
ScalarType	vcglib/vcg/complex/algorithms/local_optimization.h	/^        typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::LocalModification
ScalarType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::QuadDiagonalCollapse
ScalarType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::QuadDiagonalCollapseBase
ScalarType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::FitmapsCollapse
ScalarType	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  typedef	typename TETRA_MESH_TYPE::VertexType::ScalarType ScalarType;$/;"	t	class:vcg::tetra::TetraEdgeCollapse
ScalarType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  typedef	typename TriMeshType::VertexType::ScalarType ScalarType;$/;"	t	class:vcg::tri::TriEdgeCollapse
ScalarType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^		typedef typename TriMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadric
ScalarType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef typename TriMeshType::CoordType::ScalarType ScalarType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadricTex
ScalarType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::ScalarType ScalarType;$/;"	t	class:vcg::tri::PlanarEdgeFlip
ScalarType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::ScalarType ScalarType;$/;"	t	class:vcg::tri::TopoEdgeFlip
ScalarType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::ScalarType ScalarType;$/;"	t	class:vcg::tri::TriEdgeFlip
ScalarType	vcglib/vcg/complex/algorithms/nring.h	/^    typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::Nring
ScalarType	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:OverlapEstimation
ScalarType	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::Distortion
ScalarType	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::PoissonSolver
ScalarType	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::CrossField
ScalarType	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::UV_Utils
ScalarType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MetroMesh::ScalarType      ScalarType;$/;"	t	class:vcg::tri::SurfaceSampling
ScalarType	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^  typedef typename MeshType::ScalarType			ScalarType;$/;"	t	class:vcg::tri::PointCloudNormal
ScalarType	vcglib/vcg/complex/algorithms/refine.h	/^  typedef typename MESH_TYPE::ScalarType ScalarType;$/;"	t	class:vcg::tri::QualityEdgePredicate
ScalarType	vcglib/vcg/complex/algorithms/refine.h	/^  typedef typename MESH_TYPE::ScalarType ScalarType;$/;"	t	class:vcg::tri::QualityMidPointFunctor
ScalarType	vcglib/vcg/complex/algorithms/smooth.h	/^            typedef	typename MeshType::ScalarType			ScalarType;$/;"	t	class:vcg::tri::Smooth
ScalarType	vcglib/vcg/complex/algorithms/stat.h	/^  typedef typename MeshType::ScalarType			ScalarType;$/;"	t	class:vcg::tri::Stat
ScalarType	vcglib/vcg/complex/algorithms/symmetry.h	/^    typedef typename TriMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::ExtrinsicPlaneSymmetry
ScalarType	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef typename MESH_TYPE::ScalarType ScalarType;$/;"	t	class:vcg::tri::AreaPreservingTextureOptimizer
ScalarType	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef typename MESH_TYPE::ScalarType ScalarType;$/;"	t	class:vcg::tri::TextureOptimizer
ScalarType	vcglib/vcg/complex/algorithms/update/color.h	/^  typedef typename MeshType::ScalarType     ScalarType;$/;"	t	class:vcg::tri::UpdateColor
ScalarType	vcglib/vcg/complex/algorithms/update/component_ep.h	/^	  typedef typename MeshType::FaceType::CoordType::ScalarType     ScalarType;$/;"	t	class:vcg::tri::UpdateComponentEP
ScalarType	vcglib/vcg/complex/algorithms/update/curvature.h	/^    typedef typename CoordType::ScalarType ScalarType;$/;"	t	class:vcg::tri::UpdateCurvature
ScalarType	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^	typedef typename CoordType::ScalarType ScalarType;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
ScalarType	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::Fitmaps
ScalarType	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef typename MeshType::ScalarType     ScalarType;$/;"	t	class:vcg::tri::UpdateFlags
ScalarType	vcglib/vcg/complex/algorithms/update/normal.h	/^typedef typename VertexType::ScalarType ScalarType;$/;"	t	class:vcg::tri::UpdateNormal
ScalarType	vcglib/vcg/complex/algorithms/update/position.h	/^typedef typename MeshType::ScalarType     ScalarType;$/;"	t	class:vcg::tri::UpdatePosition
ScalarType	vcglib/vcg/complex/algorithms/update/quality.h	/^  typedef typename MeshType::ScalarType     ScalarType;$/;"	t	class:vcg::tri::UpdateQuality
ScalarType	vcglib/vcg/complex/algorithms/update/selection.h	/^typedef	typename MeshType::ScalarType			ScalarType;$/;"	t	class:vcg::tri::UpdateSelection
ScalarType	vcglib/vcg/complex/algorithms/update/texture.h	/^typedef typename MeshType::ScalarType     ScalarType;$/;"	t	class:vcg::tri::UpdateTexture
ScalarType	vcglib/vcg/complex/algorithms/update/topology.h	/^typedef typename MeshType::ScalarType     ScalarType;$/;"	t	class:vcg::tri::UpdateTopology
ScalarType	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::ScalarType				ScalarType;$/;"	t	class:vcg::tri::VoronoiProcessing
ScalarType	vcglib/vcg/complex/base.h	/^                                typedef typename VertexType::ScalarType ScalarType;$/;"	t	struct:vcg::tri::MeshTypeHolder
ScalarType	vcglib/vcg/complex/base.h	/^                typedef bool ScalarType;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
ScalarType	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::ScalarType		ScalarType;$/;"	t	class:vcg::tri::TriMesh
ScalarType	vcglib/vcg/complex/used_types.h	/^        typedef char ScalarType;$/;"	t	struct:vcg::DummyTypes
ScalarType	vcglib/vcg/math/camera.h	/^    typedef S ScalarType;$/;"	t	class:vcg::Camera
ScalarType	vcglib/vcg/math/eigen_matrixbase_addons.h	/^typedef Scalar ScalarType;$/;"	t
ScalarType	vcglib/vcg/math/linear.h	/^		typedef T ScalarType;$/;"	t	class:vcg::Linear
ScalarType	vcglib/vcg/math/matrix33.h	/^    typedef S ScalarType;$/;"	t	class:vcg::Matrix33
ScalarType	vcglib/vcg/math/matrix44.h	/^	typedef T ScalarType;$/;"	t	class:vcg::Matrix44
ScalarType	vcglib/vcg/math/old_deprecated_matrix.h	/^			typedef TYPE ScalarType;$/;"	t	class:vcg::ndim::Matrix
ScalarType	vcglib/vcg/math/old_matrix.h	/^	typedef _Scalar ScalarType;$/;"	t	class:vcg::ndim::Matrix
ScalarType	vcglib/vcg/math/old_matrix33.h	/^	typedef _Scalar ScalarType;$/;"	t	class:vcg::Matrix33
ScalarType	vcglib/vcg/math/old_matrix44.h	/^	typedef _Scalar ScalarType;$/;"	t	class:vcg::Matrix44
ScalarType	vcglib/vcg/math/quadric.h	/^        typedef Scalar ScalarType;$/;"	t	class:vcg::math::Quadric
ScalarType	vcglib/vcg/math/quadric5.h	/^    typedef Scalar ScalarType;$/;"	t	class:vcg::Quadric5
ScalarType	vcglib/vcg/math/quadric5.h	/^  typedef double ScalarType;$/;"	t	namespace:vcg::math
ScalarType	vcglib/vcg/math/shot.h	/^  typedef S ScalarType;$/;"	t	class:vcg::Shot
ScalarType	vcglib/vcg/simplex/edge/distance.h	/^		typedef S ScalarType;$/;"	t	class:vcg::edge::PointDistanceFunctor
ScalarType	vcglib/vcg/simplex/edge/pos.h	/^	typedef typename VertexType::ScalarType ScalarType;$/;"	t	class:vcg::edge::VEIterator
ScalarType	vcglib/vcg/simplex/face/base.h	/^	typedef typename  FaceArityMax::ScalarType ScalarType;$/;"	t	class:vcg::FaceArityMax
ScalarType	vcglib/vcg/simplex/face/component.h	/^        typedef  S   ScalarType;$/;"	t	struct:vcg::face::CurvatureDirBaseType
ScalarType	vcglib/vcg/simplex/face/component.h	/^  typedef typename CurvatureDirType::ScalarType ScalarType;$/;"	t	class:vcg::face::CurvatureDir
ScalarType	vcglib/vcg/simplex/face/component.h	/^  typedef typename T::VertexType::ScalarType ScalarType;$/;"	t	class:vcg::face::VertexRef
ScalarType	vcglib/vcg/simplex/face/component_ocf.h	/^        typedef  S   ScalarType;$/;"	t	struct:vcg::face::CurvatureDirOcfBaseType
ScalarType	vcglib/vcg/simplex/face/component_ocf.h	/^  typedef typename CurvatureDirType::ScalarType ScalarType;$/;"	t	class:vcg::face::CurvatureDirOcf
ScalarType	vcglib/vcg/simplex/face/component_polygon.h	/^  typedef typename  T::VertexType::ScalarType ScalarType;$/;"	t	class:vcg::face::PFVAdj
ScalarType	vcglib/vcg/simplex/face/distance.h	/^            typedef S ScalarType;$/;"	t	class:vcg::face::PointDistanceBaseFunctor
ScalarType	vcglib/vcg/simplex/face/distance.h	/^        typedef S ScalarType;$/;"	t	class:vcg::face::PointDistanceEPFunctor
ScalarType	vcglib/vcg/simplex/face/distance.h	/^        typedef typename S::ScalarType ScalarType;$/;"	t	class:vcg::face::PointNormalDistanceFunctor
ScalarType	vcglib/vcg/simplex/face/jumping_pos.h	/^			typedef typename	VertexType::ScalarType	ScalarType;$/;"	t	class:vcg::face::JumpingPos
ScalarType	vcglib/vcg/simplex/face/pos.h	/^	typedef typename VertexType::ScalarType ScalarType;$/;"	t	class:vcg::face::Pos
ScalarType	vcglib/vcg/simplex/face/pos.h	/^	typedef typename VertexType::ScalarType ScalarType;$/;"	t	class:vcg::face::VFIterator
ScalarType	vcglib/vcg/simplex/tetrahedron/base.h	/^  typedef typename VertexType::ScalarType ScalarType;$/;"	t	class:vcg::TetraTypeHolder
ScalarType	vcglib/vcg/simplex/vertex/component.h	/^          typedef  S   ScalarType;$/;"	t	struct:vcg::vertex::CurvatureDirBaseType
ScalarType	vcglib/vcg/simplex/vertex/component.h	/^    typedef typename CurvatureDirType::ScalarType ScalarType;$/;"	t	class:vcg::vertex::CurvatureDir
ScalarType	vcglib/vcg/simplex/vertex/component.h	/^    typedef typename CurvatureType::ScalarType ScalarType;$/;"	t	class:vcg::vertex::Curvature
ScalarType	vcglib/vcg/simplex/vertex/component.h	/^  typedef CoordType::ScalarType      ScalarType;$/;"	t	class:vcg::vertex::EmptyCore
ScalarType	vcglib/vcg/simplex/vertex/component.h	/^  typedef typename A::ScalarType      ScalarType;$/;"	t	class:vcg::vertex::Coord
ScalarType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef  S   ScalarType;$/;"	t	struct:vcg::vertex::CurvatureDirTypeOcc
ScalarType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename CurvatureDirTypeOcc::ScalarType ScalarType;$/;"	t	class:vcg::vertex::CurvatureDirOcc
ScalarType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename CurvatureTypeOcc::ScalarType ScalarType;$/;"	t	class:vcg::vertex::CurvatureOcc
ScalarType	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef A ScalarType;$/;"	t	class:vcg::vertex::RadiusOcc
ScalarType	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef typename CoordType::ScalarType      ScalarType;$/;"	t	class:vcg::vertex::CoordOcc
ScalarType	vcglib/vcg/simplex/vertex/component_ocf.h	/^	typedef  S   ScalarType;$/;"	t	struct:vcg::vertex::CurvatureDirTypeOcf
ScalarType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef RadiusType ScalarType;$/;"	t	class:vcg::vertex::RadiusOcf
ScalarType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef typename CurvatureDirType::ScalarType ScalarType;$/;"	t	class:vcg::vertex::CurvatureDirOcf
ScalarType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef typename CurvatureType::ScalarType ScalarType;$/;"	t	class:vcg::vertex::CurvatureOcf
ScalarType	vcglib/vcg/simplex/vertex/distance.h	/^		typedef typename VERTEXYPE::ScalarType ScalarType;$/;"	t	class:vcg::vertex::PointScaledDistanceFunctor
ScalarType	vcglib/vcg/simplex/vertex/distance.h	/^		typedef typename VERTYPE::ScalarType ScalarType;$/;"	t	class:vcg::vertex::PointNormalDistanceFunctor
ScalarType	vcglib/vcg/simplex/vertex/distance.h	/^    typedef typename VertexType::ScalarType ScalarType;$/;"	t	class:vcg::vertex::ApproximateGeodesicDistanceFunctor
ScalarType	vcglib/vcg/space/box.h	/^	typedef S          ScalarType;$/;"	t	class:vcg::Box
ScalarType	vcglib/vcg/space/box2.h	/^	typedef BoxScalarType ScalarType;$/;"	t	class:vcg::Box2
ScalarType	vcglib/vcg/space/box3.h	/^    typedef BoxScalarType ScalarType;$/;"	t	class:vcg::Box3
ScalarType	vcglib/vcg/space/deprecated_point.h	/^	typedef S          ScalarType;$/;"	t	class:vcg::ndim::Point
ScalarType	vcglib/vcg/space/deprecated_point.h	/^	typedef S ScalarType;$/;"	t	class:vcg::ndim::Point2
ScalarType	vcglib/vcg/space/deprecated_point.h	/^	typedef S ScalarType;$/;"	t	class:vcg::ndim::Point3
ScalarType	vcglib/vcg/space/deprecated_point.h	/^	typedef S ScalarType;$/;"	t	class:vcg::ndim::Point4
ScalarType	vcglib/vcg/space/deprecated_point2.h	/^	typedef P2ScalarType ScalarType;$/;"	t	class:vcg::Point2
ScalarType	vcglib/vcg/space/deprecated_point3.h	/^    typedef P3ScalarType ScalarType;$/;"	t	class:vcg::Point3
ScalarType	vcglib/vcg/space/deprecated_point4.h	/^	typedef T ScalarType;$/;"	t	class:vcg::Point4
ScalarType	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	typedef SCALARTYPE ScalarType;$/;"	t	class:vcg::AABBBinaryTreeIndex
ScalarType	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		typedef SCALARTYPE ScalarType;$/;"	t	class:vcg::AABBBinaryTree
ScalarType	vcglib/vcg/space/index/aabb_binary_tree/closest.h	/^	typedef typename TreeType::ScalarType ScalarType;$/;"	t	class:vcg::AABBBinaryTreeClosest
ScalarType	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	typedef typename TreeType::ScalarType ScalarType;$/;"	t	class:vcg::AABBBinaryTreeFrustumCull
ScalarType	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^	typedef typename TreeType::ScalarType ScalarType;$/;"	t	class:vcg::AABBBinaryTreeKClosest
ScalarType	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^	typedef typename TreeType::ScalarType ScalarType;$/;"	t	class:vcg::AABBBinaryTreeRay
ScalarType	vcglib/vcg/space/index/base.h	/^	typedef SCALARTYPE ScalarType;$/;"	t	class:vcg::SpatialIndex
ScalarType	vcglib/vcg/space/index/grid_static_ptr.h	/^		typedef typename ObjType::ScalarType ScalarType;$/;"	t	class:vcg::GridStaticPtr
ScalarType	vcglib/vcg/space/index/grid_util.h	/^	typedef SCALARTYPE ScalarType;$/;"	t	class:vcg::BasicGrid
ScalarType	vcglib/vcg/space/index/index2D/base_2d.h	/^	typedef SCALARTYPE ScalarType;$/;"	t	class:vcg::SpatialIndex2D
ScalarType	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		typedef SCALARTYPE ScalarType;$/;"	t	class:vcg::BasicGrid2D
ScalarType	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        typedef typename ObjType::ScalarType ScalarType;$/;"	t	class:vcg::SpatialHashTable2D
ScalarType	vcglib/vcg/space/index/octree.h	/^        typedef						SCALAR_TYPE													ScalarType;$/;"	t	class:vcg::Octree
ScalarType	vcglib/vcg/space/index/octree_template.h	/^	typedef SCALAR_TYPE								ScalarType;$/;"	t	class:vcg::OctreeTemplate
ScalarType	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		typedef						SCALAR_TYPE													ScalarType;$/;"	t	class:vcg::PerfectSpatialHashing
ScalarType	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename Spatial_Idexing::ScalarType ScalarType;$/;"	t	class:vcg::ClosestIterator
ScalarType	vcglib/vcg/space/index/space_iterators.h	/^		typedef typename Spatial_Idexing::ScalarType ScalarType;$/;"	t	class:vcg::RayIterator
ScalarType	vcglib/vcg/space/index/spatial_hashing.h	/^	typedef typename ObjType::ScalarType ScalarType;$/;"	t	class:vcg::SpatialHashTable
ScalarType	vcglib/vcg/space/line2.h	/^	typedef LineScalarType ScalarType;$/;"	t	class:vcg::Line2
ScalarType	vcglib/vcg/space/line3.h	/^	typedef LineScalarType ScalarType;$/;"	t	class:vcg::Line3
ScalarType	vcglib/vcg/space/plane3.h	/^  typedef T ScalarType;$/;"	t	class:vcg::Plane3
ScalarType	vcglib/vcg/space/point4.h	/^	typedef Scalar ScalarType;$/;"	t	class:vcg::Point4
ScalarType	vcglib/vcg/space/ray2.h	/^	typedef RayScalarType ScalarType;$/;"	t	class:vcg::Ray2
ScalarType	vcglib/vcg/space/ray3.h	/^	typedef RayScalarType ScalarType;$/;"	t	class:vcg::Ray3
ScalarType	vcglib/vcg/space/segment2.h	/^	typedef SegmentScalarType ScalarType;$/;"	t	class:vcg::Segment2
ScalarType	vcglib/vcg/space/segment3.h	/^	typedef SegmentScalarType ScalarType;$/;"	t	class:vcg::Segment3
ScalarType	vcglib/vcg/space/space.h	/^	typedef S          ScalarType;$/;"	t	class:vcg::Space
ScalarType	vcglib/vcg/space/sphere3.h	/^	typedef T ScalarType;$/;"	t	class:vcg::Sphere3
ScalarType	vcglib/vcg/space/texcoord2.h	/^  typedef T ScalarType;$/;"	t	class:vcg::TexCoord2
ScalarType	vcglib/vcg/space/texcoord2.h	/^  typedef T ScalarType;$/;"	t	class:vcg::TexCoord2Simple
ScalarType	vcglib/vcg/space/triangle2.h	/^  typedef SCALAR_TYPE ScalarType;$/;"	t	class:vcg::Triangle2
ScalarType	vcglib/vcg/space/triangle3.h	/^  typedef ScalarTriangleType ScalarType;$/;"	t	class:vcg::Triangle3
ScalarType	vcglib/wrap/gl/camera.h	/^	typedef typename CameraType::ScalarType ScalarType;$/;"	t	struct:GlCamera
ScalarType	vcglib/wrap/gl/gl_field.h	/^	typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::GLField
ScalarType	vcglib/wrap/gl/shot.h	/^	typedef typename ShotType::ScalarType ScalarType;$/;"	t	struct:GlShot
ScalarType	vcglib/wrap/gl/tetramesh.h	/^  typedef typename VertexType::ScalarType ScalarType;$/;"	t	class:vcg::tetra::GlTetramesh
ScalarType	vcglib/wrap/io_tetramesh/export_ply.h	/^typedef typename SaveMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tetra::io::ExporterPLY
ScalarType	vcglib/wrap/io_tetramesh/export_ts.h	/^	typedef typename MESHTYPE::ScalarType ScalarType;$/;"	t	struct:vcg::tetra::io::ExporterTS
ScalarType	vcglib/wrap/io_tetramesh/import_ply.h	/^typedef typename OpenMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tetra::io::ImporterPLY
ScalarType	vcglib/wrap/io_tetramesh/import_ts.h	/^	typedef typename Tetramesh::ScalarType ScalarType;$/;"	t	class:vcg::tetra::io::ImporterTS
ScalarType	vcglib/wrap/io_trimesh/export_fbx.h	/^	typedef typename SaveMeshType::ScalarType ScalarType;$/;"	t	class:ExporterFBX
ScalarType	vcglib/wrap/io_trimesh/export_field.h	/^    typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ExporterFIELD
ScalarType	vcglib/wrap/io_trimesh/export_gts.h	/^				typedef typename SaveMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ExporterGTS
ScalarType	vcglib/wrap/io_trimesh/export_idtf.h	/^typedef typename SaveMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ExporterIDTF
ScalarType	vcglib/wrap/io_trimesh/export_obj.h	/^  typedef typename SaveMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ExporterOBJ
ScalarType	vcglib/wrap/io_trimesh/export_off.h	/^				typedef typename SaveMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ExporterOFF
ScalarType	vcglib/wrap/io_trimesh/export_ply.h	/^typedef typename SaveMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ExporterPLY
ScalarType	vcglib/wrap/io_trimesh/export_smf.h	/^		typedef typename SaveMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ExporterSMF
ScalarType	vcglib/wrap/io_trimesh/export_vrml.h	/^				typedef typename SaveMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ExporterWRL
ScalarType	vcglib/wrap/io_trimesh/import_asc.h	/^typedef typename MESH_TYPE::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterASC
ScalarType	vcglib/wrap/io_trimesh/import_ctm.h	/^typedef typename OpenMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterCTM
ScalarType	vcglib/wrap/io_trimesh/import_fbx.h	/^	typedef typename OpenMeshType::ScalarType ScalarType;$/;"	t	class:ImporterFBX
ScalarType	vcglib/wrap/io_trimesh/import_field.h	/^    typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterFIELD
ScalarType	vcglib/wrap/io_trimesh/import_gts.h	/^				typedef typename MESH_TYPE::ScalarType			ScalarType;$/;"	t	class:vcg::tri::io::ImporterGTS
ScalarType	vcglib/wrap/io_trimesh/import_nvm.h	/^typedef typename OpenMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterNVM
ScalarType	vcglib/wrap/io_trimesh/import_obj.h	/^                typedef typename OpenMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterOBJ
ScalarType	vcglib/wrap/io_trimesh/import_off.h	/^  typedef typename MESH_TYPE::ScalarType			ScalarType;$/;"	t	class:vcg::tri::io::ImporterOFF
ScalarType	vcglib/wrap/io_trimesh/import_out.h	/^typedef typename OpenMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterOUT
ScalarType	vcglib/wrap/io_trimesh/import_ply.h	/^typedef typename OpenMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterPLY
ScalarType	vcglib/wrap/io_trimesh/import_ptx.h	/^		typedef typename OpenMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterPTX
ScalarType	vcglib/wrap/io_trimesh/import_raw.h	/^typedef typename MESH_TYPE::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterRAW
ScalarType	vcglib/wrap/io_trimesh/import_smf.h	/^		typedef typename OpenMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterSMF
ScalarType	vcglib/wrap/io_trimesh/import_stl.h	/^typedef typename OpenMeshType::ScalarType ScalarType;$/;"	t	class:vcg::tri::io::ImporterSTL
ScalarType	vcglib/wrap/miq/core/poisson_solver.h	/^    typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:PoissonSolver
ScalarType	vcglib/wrap/miq/core/seams_initializer.h	/^    typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:SeamsInitializer
ScalarType	vcglib/wrap/miq/core/stiffening.h	/^    typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:StiffeningInitializer
ScalarType	vcglib/wrap/miq/core/vertex_indexing.h	/^    typedef typename MeshType::ScalarType ScalarType;$/;"	t	class:VertexIndexing
ScalarType	vcglib/wrap/miq/quadrangulator.h	/^        typedef typename MESH_TYPE::ScalarType ScalarType;$/;"	t	class:Quadrangulator::EdgePredicate
ScalarType	vcglib/wrap/miq/quadrangulator.h	/^    typedef typename TriMesh::ScalarType ScalarType;$/;"	t	class:Quadrangulator
ScalarType	vcglib/wrap/opensg/vertex_component.h	/^	typedef OSG::Real32 ScalarType;$/;"	t	class:vcg::vert::EmptyOSGColor
ScalarType	vcglib/wrap/opensg/vertex_component.h	/^	typedef OSG::Real32 ScalarType;$/;"	t	class:vcg::vert::EmptyOSGCoord
ScalarType	vcglib/wrap/opensg/vertex_component.h	/^	typedef OSG::Real32 ScalarType;$/;"	t	class:vcg::vert::EmptyOSGNormal
ScalarType	vcglib/wrap/opensg/vertex_component.h	/^	typedef typename ColorType::ValueType ScalarType;				\/\/\/ Can be a OSG basic type as : OSG::UInt8, OSG::Real32 etc...$/;"	t	class:vcg::vert::OSGColor
ScalarType	vcglib/wrap/opensg/vertex_component.h	/^	typedef typename ColorType::ValueType ScalarType;$/;"	t	class:vcg::vert::OSGColorCore
ScalarType	vcglib/wrap/opensg/vertex_component.h	/^	typedef typename CoordType::ValueType ScalarType;				\/\/\/ Can be a OSG basic type as : OSG::Int16, OSG::Real32, OSG::Real64 etc...$/;"	t	class:vcg::vert::OSGCoord
ScalarType	vcglib/wrap/opensg/vertex_component.h	/^	typedef typename CoordType::ValueType ScalarType;$/;"	t	class:vcg::vert::OSGCoordCore
ScalarType	vcglib/wrap/opensg/vertex_component.h	/^	typedef typename NormalType::ValueType ScalarType;			\/\/\/ Can be a OSG basic type as : OSG::Int16, OSG::Real32, OSG::Real64 etc...$/;"	t	class:vcg::vert::OSGNormal
ScalarType	vcglib/wrap/opensg/vertex_component.h	/^	typedef typename NormalType::ValueType ScalarType;$/;"	t	class:vcg::vert::OSGNormalCore
ScalarValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^const typename AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::ScalarType & AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::ScalarValue(void) const {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
ScalarValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^typename AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::ScalarType & AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::ScalarValue(void) {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
ScalarWithConstIfNotLvalue	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::ArrayWrapper
ScalarWithConstIfNotLvalue	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MatrixWrapper
ScalarWithConstIfNotLvalue	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::Diagonal
ScalarWithConstIfNotLvalue	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^                  >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MapBase
ScalarWithConstIfNotLvalue	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::SwapWrapper
ScalarWithConstIfNotLvalue	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::TransposeImpl
ScalarWrapper	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^      ScalarWrapper() : value(0) {}$/;"	f	struct:Eigen::RandomSetter::ScalarWrapper
ScalarWrapper	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    struct ScalarWrapper$/;"	s	class:Eigen::RandomSetter
Scale	vcglib/vcg/complex/algorithms/update/position.h	/^static void Scale(ComputeMeshType &m, const Point3<ScalarType> &s)$/;"	f	class:vcg::tri::UpdatePosition
Scale	vcglib/vcg/complex/algorithms/update/position.h	/^static void Scale(ComputeMeshType &m, const ScalarType s)$/;"	f	class:vcg::tri::UpdatePosition
Scale	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Derived& Scale(const MatrixBase<OtherDerived>& other)$/;"	f
Scale	vcglib/vcg/math/eigen_matrixbase_addons.h	/^Scale(const MatrixBase<OtherDerived>& other) const$/;"	f
Scale	vcglib/vcg/math/quadric5.h	/^	void Scale(ScalarType val)	$/;"	f	class:vcg::Quadric5
Scale	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & Scale( const PointType & p ) {$/;"	f	class:vcg::ndim::Point2
Scale	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & Scale( const PointType & p ) {$/;"	f	class:vcg::ndim::Point3
Scale	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & Scale( const PointType & p ) {$/;"	f	class:vcg::ndim::Point4
Scale	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 & Scale( const ScalarType sx, const ScalarType sy )$/;"	f	class:vcg::Point2
Scale	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 & Scale( const P3ScalarType sx, const P3ScalarType sy, const P3ScalarType sz )$/;"	f	class:vcg::Point3
Scale	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 & Scale( const Point3 & p )$/;"	f	class:vcg::Point3
Scale	vcglib/wrap/gui/trackball.cpp	/^void Trackball::Scale(const float s)$/;"	f	class:Trackball
ScaleFactor	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  double    ScaleFactor;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
ScaleFactor	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  double	  ScaleFactor;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
ScaleIndependent	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      ScaleIndependent;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
ScaleIndependent	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  bool	    ScaleIndependent;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
ScaleLaplacianInfo	vcglib/vcg/complex/algorithms/smooth.h	/^class ScaleLaplacianInfo$/;"	c	class:vcg::tri::Smooth
ScaleMode	vcglib/wrap/gui/trackmode.h	/^class ScaleMode:public TrackMode {$/;"	c	namespace:vcg
ScaledProduct	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    ScaledProduct(const NestedProduct& prod, Scalar x)$/;"	f	class:Eigen::ScaledProduct
ScaledProduct	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^class ScaledProduct$/;"	c	namespace:Eigen
Scaling	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Scaling /;"	d
Scaling	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Scaling$/;"	d
Scaling	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  Scaling() {}$/;"	f	class:Eigen::Scaling
Scaling	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const Scalar& s) { m_coeffs.setConstant(s); }$/;"	f	class:Eigen::Scaling
Scaling	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const VectorType& coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Scaling
Scaling	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Scaling
Scaling	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Scaling
Scaling	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline explicit Scaling(const Scaling<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Scaling
Scaling	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^class Scaling$/;"	c	namespace:Eigen
Scaling	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,2> Scaling(Scalar sx, Scalar sy)$/;"	f	namespace:Eigen
Scaling	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,3> Scaling(Scalar sx, Scalar sy, Scalar sz)$/;"	f	namespace:Eigen
Scaling	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<double> Scaling(double s) { return UniformScaling<double>(s); }$/;"	f	namespace:Eigen
Scaling	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<float> Scaling(float s) { return UniformScaling<float>(s); }$/;"	f	namespace:Eigen
Scaling	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<std::complex<RealScalar> > Scaling(const std::complex<RealScalar>& s)$/;"	f	namespace:Eigen
Scaling	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^static inline const DiagonalWrapper<const Derived> Scaling(const MatrixBase<Derived>& coeffs)$/;"	f	namespace:Eigen
Scaling	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    Scaling() { init(); }$/;"	f	class:Scaling
Scaling	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    Scaling(const MatrixType& matrix)$/;"	f	class:Scaling
Scaling	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^class Scaling$/;"	c
Scaling2d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Scaling2d /;"	d
Scaling2d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Scaling2d$/;"	d
Scaling2d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,2> Scaling2d;$/;"	t	namespace:Eigen
Scaling2f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Scaling2f /;"	d
Scaling2f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Scaling2f$/;"	d
Scaling2f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 2> Scaling2f;$/;"	t	namespace:Eigen
Scaling3d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Scaling3d /;"	d
Scaling3d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Scaling3d$/;"	d
Scaling3d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,3> Scaling3d;$/;"	t	namespace:Eigen
Scaling3f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Scaling3f /;"	d
Scaling3f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Scaling3f$/;"	d
Scaling3f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 3> Scaling3f;$/;"	t	namespace:Eigen
ScalingFactor	vcglib/vcg/math/spherical_harmonics.h	/^	ScalingFactor()$/;"	f	class:vcg::math::ScalingFactor
ScalingFactor	vcglib/vcg/math/spherical_harmonics.h	/^class ScalingFactor$/;"	c	namespace:vcg::math
ScalingType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Transform
ScalingType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Translation
ScanBBox	vcglib/wrap/ply/plystuff.h	/^bool ScanBBox( const char * fname, Box3<ScalarType> & box, bool use_cache=true )$/;"	f	namespace:vcg::ply
ScanBBox	vcglib/wrap/ply/plystuff.h	/^bool ScanBBox( const char * fname, Box3<ScalarType> & box, const Matrix44<ScalarType> & m, bool use_cache, const char *matrixfname)$/;"	f	namespace:vcg::ply
Scatter	vcglib/vcg/space/color4.h	/^inline static Color4 Scatter(int range, int value,float Sat=.3f,float Val=.9f)$/;"	f	class:vcg::Color4
SceneTag	vcglib/wrap/dae/colladaformat.h	/^		SceneTag()$/;"	f	class:Collada::Tags::SceneTag
SceneTag	vcglib/wrap/dae/colladaformat.h	/^	class SceneTag : public XMLTag$/;"	c	namespace:Collada::Tags
ScrUsedTypes	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^struct ScrUsedTypes : public UsedTypes<	Use<SrcVertex>::AsVertexType,$/;"	s	file:
ScreenH	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		int ScreenH,ScreenW,pic_x,pic_y,keypress;$/;"	m	class:GLWidget
ScreenH	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^int ScreenH,ScreenW;$/;"	v
ScreenW	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		int ScreenH,ScreenW,pic_x,pic_y,keypress;$/;"	m	class:GLWidget
ScreenW	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^int ScreenH,ScreenW;$/;"	v
SeamInfo	vcglib/wrap/miq/core/vertex_indexing.h	/^    SeamInfo(const SeamInfo &S1)$/;"	f	struct:SeamInfo
SeamInfo	vcglib/wrap/miq/core/vertex_indexing.h	/^    SeamInfo(int _v0,$/;"	f	struct:SeamInfo
SeamInfo	vcglib/wrap/miq/core/vertex_indexing.h	/^struct SeamInfo$/;"	s
SeamsInitializer	vcglib/wrap/miq/core/seams_initializer.h	/^    SeamsInitializer(){mesh=NULL;}$/;"	f	class:SeamsInitializer
SeamsInitializer	vcglib/wrap/miq/core/seams_initializer.h	/^class SeamsInitializer$/;"	c
Seed	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  bool Seed(int &v0, int &v1, int &v2) {$/;"	f	class:vcg::tri::AdvancingTest
Seed	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  bool Seed(int &v0, int &v1, int &v2) {               $/;"	f	class:vcg::tri::BallPivoting
SeedFace	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  bool SeedFace() {$/;"	f	class:vcg::tri::AdvancingFront
SeedToVertexConversion	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void SeedToVertexConversion(MeshType &m,std::vector<CoordType> &seedPVec,std::vector<VertexType *> &seedVVec, bool compactFlag = true)$/;"	f	class:vcg::tri::VoronoiProcessing
Segment2	vcglib/vcg/space/segment2.h	/^    Segment2() {};$/;"	f	class:vcg::Segment2
Segment2	vcglib/vcg/space/segment2.h	/^    Segment2(const PointType &a, const PointType &b) { _p0=a; _p1=b; };$/;"	f	class:vcg::Segment2
Segment2	vcglib/vcg/space/segment2.h	/^class Segment2$/;"	c	namespace:vcg
Segment2DSegment2DDistance	vcglib/vcg/space/distance2.h	/^	ScalarType Segment2DSegment2DDistance(const vcg::Segment2<ScalarType> &S0,$/;"	f	namespace:vcg
Segment2d	vcglib/vcg/space/segment2.h	/^typedef Segment2<double> Segment2d;$/;"	t	namespace:vcg
Segment2f	vcglib/vcg/space/segment2.h	/^typedef Segment2<float>  Segment2f;$/;"	t	namespace:vcg
Segment2i	vcglib/vcg/space/segment2.h	/^typedef Segment2<int>	 Segment2i;$/;"	t	namespace:vcg
Segment2s	vcglib/vcg/space/segment2.h	/^typedef Segment2<short>  Segment2s;$/;"	t	namespace:vcg
Segment3	vcglib/vcg/space/segment3.h	/^	Segment3() {};$/;"	f	class:vcg::Segment3
Segment3	vcglib/vcg/space/segment3.h	/^	Segment3(const PointType &a, const PointType &b) { _p0=a; _p1=b; };$/;"	f	class:vcg::Segment3
Segment3	vcglib/vcg/space/segment3.h	/^class Segment3$/;"	c	namespace:vcg
Segment3d	vcglib/vcg/space/segment3.h	/^typedef Segment3<double> Segment3d;$/;"	t	namespace:vcg
Segment3f	vcglib/vcg/space/segment3.h	/^typedef Segment3<float>  Segment3f;$/;"	t	namespace:vcg
Segment3i	vcglib/vcg/space/segment3.h	/^typedef Segment3<int>	   Segment3i;$/;"	t	namespace:vcg
Segment3s	vcglib/vcg/space/segment3.h	/^typedef Segment3<short>  Segment3s;$/;"	t	namespace:vcg
Segment3x	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef Segment3<ScalarType> Segment3x;$/;"	t	class:vcg::tri::CylinderClipping
SegmentPointDistance	vcglib/vcg/space/distance3.h	/^void SegmentPointDistance( Segment3<ScalarType> s, $/;"	f	namespace:vcg
SegmentPointSquaredDistance	vcglib/vcg/space/distance3.h	/^void SegmentPointSquaredDistance( const Segment3<ScalarType> &s,$/;"	f	namespace:vcg
SegmentReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef VectorBlock<Derived> SegmentReturnType;$/;"	t	class:Eigen::DenseBase
SegmentSegmentDistance	vcglib/vcg/space/distance3.h	/^void SegmentSegmentDistance(const vcg::Segment3<ScalarType> &s0,$/;"	f	namespace:vcg
SegmentSegmentIntersection	vcglib/vcg/space/intersection2.h	/^	inline bool SegmentSegmentIntersection(const vcg::Segment2<SCALAR_TYPE> &seg0,$/;"	f	namespace:vcg
SegmentType	vcglib/vcg/space/segment2.h	/^	typedef Segment2<SegmentScalarType> SegmentType;$/;"	t	class:vcg::Segment2
SegmentType	vcglib/vcg/space/segment3.h	/^	typedef Segment3<SegmentScalarType> SegmentType;$/;"	t	class:vcg::Segment3
Select	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    Select(const ConditionMatrixType& conditionMatrix,$/;"	f	class:Eigen::Select
Select	vcglib/eigenlib/Eigen/src/Core/Select.h	/^class Select : internal::no_assignment_operator,$/;"	c	namespace:Eigen
SelectCoplanarBase	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^FourPCS<MeshType>::SelectCoplanarBase(){$/;"	f	class:vcg::tri::FourPCS
SelectFlippedFaces	vcglib/wrap/miq/core/param_stats.h	/^void SelectFlippedFaces(MeshType &Tmesh)$/;"	f
SelectPointSet	vcglib/vcg/complex/algorithms/clustering.h	/^  void SelectPointSet(MeshType &m)$/;"	f	class:vcg::tri::Clustering
SelectSingularByCross	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^            static void SelectSingularByCross(MeshType &mesh)$/;"	f	class:vcg::tri::CrossField
SelectSingularityByMM	vcglib/wrap/miq/core/seams_initializer.h	/^    void SelectSingularityByMM()$/;"	f	class:SeamsInitializer
Selected	vcglib/vcg/complex/append.h	/^static void Selected(MeshLeft& ml, ConstMeshRight& mr)$/;"	f	class:vcg::tri::Append
SelectionStack	vcglib/vcg/complex/algorithms/update/selection.h	/^  SelectionStack(ComputeMeshType &m)$/;"	f	class:vcg::tri::SelectionStack
SelectionStack	vcglib/vcg/complex/algorithms/update/selection.h	/^class SelectionStack$/;"	c	namespace:vcg::tri
SelfAdjoint	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  SelfAdjoint=0x10,$/;"	e	enum:Eigen::__anon258
SelfAdjointBit	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int SelfAdjointBit = SelfAdjoint;$/;"	m	namespace:Eigen
SelfAdjointEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver()$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, int options = ComputeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename _MatrixType> class SelfAdjointEigenSolver$/;"	c	namespace:Eigen
SelfAdjointView	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    inline SelfAdjointView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SelfAdjointView
SelfAdjointView	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SelfAdjointView$/;"	c	namespace:Eigen
SelfAdjointViewReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase
SelfCwiseBinaryOp	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}$/;"	f	class:Eigen::SelfCwiseBinaryOp
SelfCwiseBinaryOp	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^template<typename BinaryOp, typename Lhs, typename Rhs> class SelfCwiseBinaryOp$/;"	c	namespace:Eigen
SelfIntersect	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool SelfIntersect;$/;"	m	struct:MeshInfo	file:
SelfIntersectionEar	vcglib/vcg/complex/algorithms/hole.h	/^  SelfIntersectionEar(){}$/;"	f	class:vcg::tri::SelfIntersectionEar
SelfIntersectionEar	vcglib/vcg/complex/algorithms/hole.h	/^  SelfIntersectionEar(const PosType & ep):MinimumWeightEar<MESH>(ep){}$/;"	f	class:vcg::tri::SelfIntersectionEar
SelfIntersectionEar	vcglib/vcg/complex/algorithms/hole.h	/^template<class MESH> class SelfIntersectionEar : public MinimumWeightEar<MESH>$/;"	c	namespace:vcg::tri
SelfIntersections	vcglib/vcg/complex/algorithms/clean.h	/^    static bool SelfIntersections(MeshType &m, std::vector<FaceType*> &ret)$/;"	f	class:vcg::tri::Clean
SelfadjointProductMatrix	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix
SelfadjointProductMatrix	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false>$/;"	s	namespace:Eigen
SelfadjointProductMatrix	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix
SelfadjointProductMatrix	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false>$/;"	s	namespace:Eigen
SelfadjointProductMatrix	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true>$/;"	s	namespace:Eigen
Semantic	vcglib/wrap/gl/fbo.h	/^	FrameBufferSemantic::FBSType Semantic(void) const$/;"	f	class:ColorRenderTarget
Semantic	vcglib/wrap/gl/fbo.h	/^	FrameBufferSemantic::FBSType Semantic(void) const$/;"	f	class:ColorTexture
Semantic	vcglib/wrap/gl/fbo.h	/^	FrameBufferSemantic::FBSType Semantic(void) const$/;"	f	class:DepthRenderTarget
Semantic	vcglib/wrap/gl/fbo.h	/^	FrameBufferSemantic::FBSType Semantic(void) const$/;"	f	class:DepthTexture
Semantic	vcglib/wrap/gl/fbo.h	/^	FrameBufferSemantic::FBSType Semantic(void) const$/;"	f	class:StencilRenderTarget
Semantic	vcglib/wrap/gl/fbo.h	/^	FrameBufferSemantic::FBSType Semantic(void) const$/;"	f	class:StencilTexture
Semiregular	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool Regular,Semiregular;$/;"	m	struct:MeshInfo	file:
Sequential	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	e	enum:Eigen::Sequential_t
SequentialLinSpacedReturnType	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,false>,Derived> SequentialLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase
Sequential_t	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	g	namespace:Eigen
Serialize	vcglib/wrap/io_trimesh/export_vmi.h	/^        static int Serialize(const SaveMeshType &m){$/;"	f	class:vcg::tri::io::ExporterVMI
Set	vcglib/vcg/complex/algorithms/update/component_ep.h	/^		static void Set(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateComponentEP
Set	vcglib/vcg/complex/algorithms/update/flag.h	/^    void Set( const FacePointer pf, const int nz )$/;"	f	class:vcg::tri::UpdateFlags::EdgeSorter
Set	vcglib/vcg/complex/algorithms/update/topology.h	/^  void Set( FacePointer  pf, const int nz )$/;"	f	class:vcg::tri::UpdateTopology::PEdge
Set	vcglib/vcg/complex/algorithms/update/topology.h	/^  void Set( FacePointer  pf, const int nz )$/;"	f	class:vcg::tri::UpdateTopology::PEdgeTex
Set	vcglib/vcg/simplex/edge/pos.h	/^  void Set(EDGETYPE  * const ep, VertexType  * const vp)$/;"	f	class:vcg::edge::Pos
Set	vcglib/vcg/simplex/face/pos.h	/^	void Set(FaceType  * const pFace, VertexType  * const pVertex)$/;"	f	class:vcg::face::Pos
Set	vcglib/vcg/simplex/face/pos.h	/^    void Set(FaceType  * const fp, int const zp,  VertexType  * const vp)$/;"	f	class:vcg::face::Pos
Set	vcglib/vcg/space/box.h	/^	void Set( const PointType & p )$/;"	f	class:vcg::Box
Set	vcglib/vcg/space/box2.h	/^	inline void Set( ScalarType minx, ScalarType miny, ScalarType maxx, ScalarType maxy )$/;"	f	class:vcg::Box2
Set	vcglib/vcg/space/box2.h	/^	void Set( const PointType & p )$/;"	f	class:vcg::Box2
Set	vcglib/vcg/space/box3.h	/^    void Set( const Point3<BoxScalarType> & p )$/;"	f	class:vcg::Box3
Set	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	inline bool Set(const OBJITERATOR & _oBegin, const OBJITERATOR & _oEnd, OBJITERATORPTRFUNCT & _objPtr, OBJBOXFUNCT & _objBox, OBJBARYCENTERFUNCT & _objBarycenter, const unsigned int _maxElemsPerLeaf = 1, const ScalarType & _leafBoxMaxVolume = ((ScalarType)0), const bool _useVariance = true) {$/;"	f	class:vcg::AABBBinaryTreeIndex
Set	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	inline void Set(const OBJITER & _oBegin, const OBJITER & _oEnd) {$/;"	f	class:vcg::AABBBinaryTreeIndex
Set	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^bool AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::Set(const OBJITERATOR & oBegin, const OBJITERATOR & oEnd, OBJITERATORPTRFUNCT & objPtr, OBJBOXFUNCT & objBox, OBJBARYCENTERFUNCT & objBarycenter, const unsigned int maxElemsPerLeaf, const ScalarType & leafBoxMaxVolume, const bool useVariance) {$/;"	f	class:vcg::AABBBinaryTree
Set	vcglib/vcg/space/index/base.h	/^	void Set(const OBJITER & _oBegin, const OBJITER & _oEnd) {$/;"	f	class:vcg::SpatialIndex
Set	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline void Set(const OBJITER & _oBegin, const OBJITER & _oEnd, const Box3x &_bbox, int _size=0)$/;"	f	class:vcg::GridStaticPtr
Set	vcglib/vcg/space/index/grid_static_ptr.h	/^		inline void Set(const OBJITER & _oBegin, const OBJITER & _oEnd, int _size=0)$/;"	f	class:vcg::GridStaticPtr
Set	vcglib/vcg/space/index/grid_static_ptr.h	/^    inline void Set(const OBJITER & _oBegin, const OBJITER & _oEnd, const Box3x &_bbox, Point3i _siz)$/;"	f	class:vcg::GridStaticPtr
Set	vcglib/vcg/space/index/index2D/base_2d.h	/^	void Set(const OBJITER & _oBegin, const OBJITER & _oEnd) {$/;"	f	class:vcg::SpatialIndex2D
Set	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void Set(const OBJITER & _oBegin, const OBJITER & _oEnd,$/;"	f	class:vcg::SpatialHashTable2D
Set	vcglib/vcg/space/index/octree.h	/^        void Set(const OBJECT_ITERATOR & bObj, const OBJECT_ITERATOR & eObj \/*, vcg::CallBackPos *callback=NULL*\/)$/;"	f	class:vcg::Octree
Set	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		void Set(const OBJECT_ITERATOR & bObj, const OBJECT_ITERATOR & eObj) $/;"	f	class:vcg::PerfectSpatialHashing
Set	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		void Set(const OBJECT_ITERATOR & bObj, const OBJECT_ITERATOR & eObj, const ConstructionApproach approach) $/;"	f	class:vcg::PerfectSpatialHashing
Set	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		void Set(const OBJECT_ITERATOR & bObj, const OBJECT_ITERATOR & eObj, const ConstructionApproach approach, vcg::CallBackPos *callback)$/;"	f	class:vcg::PerfectSpatialHashing
Set	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		void Set(const OBJECT_ITERATOR & bObj, const OBJECT_ITERATOR & eObj, vcg::CallBackPos *callback) $/;"	f	class:vcg::PerfectSpatialHashing
Set	vcglib/vcg/space/index/spatial_hashing.h	/^			void Set(const OBJITER & _oBegin, const OBJITER & _oEnd, const Box3x &_bbox=Box3x() )$/;"	f	class:vcg::SpatialHashTable
Set	vcglib/vcg/space/line2.h	/^	inline void Set( const PointType & ori, const PointType & dir )$/;"	f	class:vcg::Line2
Set	vcglib/vcg/space/line3.h	/^	inline void Set( const PointType & ori, const PointType & dir )$/;"	f	class:vcg::Line3
Set	vcglib/vcg/space/plane3.h	/^	void Set( const ScalarType & off, const PointType & dir ) {$/;"	f	class:vcg::Plane3
Set	vcglib/vcg/space/plane3.h	/^  void Set( const PointType & dir, const ScalarType & off) {Set(off,dir);}$/;"	f	class:vcg::Plane3
Set	vcglib/vcg/space/ray2.h	/^	inline void Set( const PointType & ori, const PointType & dir )$/;"	f	class:vcg::Ray2
Set	vcglib/vcg/space/ray3.h	/^	inline void Set( const PointType & ori, const PointType & dir )$/;"	f	class:vcg::Ray3
Set	vcglib/vcg/space/segment2.h	/^    void Set( const PointType &a, const PointType &b)$/;"	f	class:vcg::Segment2
Set	vcglib/vcg/space/segment3.h	/^	void Set( const PointType &a, const PointType &b)$/;"	f	class:vcg::Segment3
Set	vcglib/wrap/gl/fbo.h	/^	bool Set(GLenum format, GLsizei width, GLsizei height)$/;"	f	class:BufferRenderTarget
Set	vcglib/wrap/gl/fbo.h	/^	bool Set(GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels)$/;"	f	class:Texture1D
Set	vcglib/wrap/gl/fbo.h	/^	bool Set(GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels)$/;"	f	class:Texture2D
Set	vcglib/wrap/gl/fbo.h	/^	bool Set(GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels)$/;"	f	class:Texture3D
Set	vcglib/wrap/gl/fbo.h	/^	bool Set(Texture2D * tex)$/;"	f	class:TextureRenderTarget
SetAction	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
SetAction	vcglib/wrap/gui/trackmode.cpp	/^void AreaMode::SetAction ()$/;"	f	class:AreaMode
SetAction	vcglib/wrap/gui/trackmode.cpp	/^void NavigatorWasdMode::SetAction() {$/;"	f	class:NavigatorWasdMode
SetAction	vcglib/wrap/gui/trackmode.cpp	/^void PathMode::SetAction (){$/;"	f	class:PathMode
SetAction	vcglib/wrap/gui/trackmode.cpp	/^void PolarMode::SetAction() {$/;"	f	class:PolarMode
SetAction	vcglib/wrap/gui/trackmode.cpp	/^void TrackMode::SetAction (){}$/;"	f	class:TrackMode
SetAttachment	vcglib/wrap/gl/fbo.h	/^	void SetAttachment(GLenum attachment)$/;"	f	class:ColorRenderTarget
SetB	vcglib/vcg/connectors/hedge.h	/^	void SetB()		{this->Flags() |=BORDER;}$/;"	f	class:vcg::HEdgeArityMax
SetB	vcglib/vcg/simplex/edge/base.h	/^	void SetB()		{this->Flags() |=BORDER;}$/;"	f	class:vcg::EdgeArityMax
SetB	vcglib/vcg/simplex/face/base.h	/^  void SetB(int i)		{this->Flags() |=(BORDER0<<i);}$/;"	f	class:vcg::FaceArityMax
SetB	vcglib/vcg/simplex/tetrahedron/base.h	/^  void SetB(int i)		{this->Flags() |=(BORDER0<<i);}$/;"	f	class:vcg::TetraArityMax
SetB	vcglib/vcg/simplex/vertex/base.h	/^	void SetB()		{this->Flags() |=BORDER;}$/;"	f	class:vcg::VertexArityMax
SetBBox	vcglib/vcg/space/index/grid_static_ptr.h	/^			void SetBBox( const Box3Type & b )$/;"	f	class:vcg::GridStaticPtr
SetBorderAsFixed	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void SetBorderAsFixed()$/;"	f	class:vcg::tri::PoissonSolver
SetBorderAsFixed	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  void SetBorderAsFixed(){$/;"	f	class:vcg::tri::TextureOptimizer
SetByPointers	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void SetByPointers(const OBJITER & _oBegin, const OBJITER & _oEnd,$/;"	f	class:vcg::SpatialHashTable2D
SetCavalieri	vcglib/vcg/math/camera.h	/^void Camera<S>::SetCavalieri(S sx, S dx, S bt, S tp, S Focal, vcg::Point2<int> Viewport)$/;"	f	class:vcg::Camera
SetColorRamp	vcglib/vcg/space/color4.h	/^    inline void SetColorRamp(const float &minf,const float  &maxf ,float v )$/;"	f	class:vcg::Color4
SetColumn	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void SetColumn(unsigned int j, Scalar* v)$/;"	f
SetColumn	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void SetColumn(unsigned int j, const MatrixBase<OtherDerived>& other)$/;"	f
SetColumn	vcglib/vcg/math/matrix33.h	/^    void SetColumn(const int n, S* v){$/;"	f	class:vcg::Matrix33
SetColumn	vcglib/vcg/math/matrix33.h	/^    void SetColumn(const int n, const Point3<S> v){$/;"	f	class:vcg::Matrix33
SetColumn	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetColumn(const unsigned int ii,const Point3<T> &t) {$/;"	f	class:vcg::Matrix44
SetColumn	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetColumn(const unsigned int ii,const Point4<T> &t) {$/;"	f	class:vcg::Matrix44
SetColumn	vcglib/vcg/math/old_deprecated_matrix.h	/^			void SetColumn(const unsigned int j, TYPE* v)$/;"	f	class:vcg::ndim::Matrix
SetCrease	vcglib/vcg/simplex/face/base.h	/^	void SetCrease(int i){this->Flags() |=(CREASE0<<i);}$/;"	f	class:vcg::FaceArityMax
SetCrossVector	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static void SetCrossVector(FaceType &f,$/;"	f	class:vcg::tri::CrossField
SetCurElement	vcglib/wrap/ply/plylib.h	/^	inline void SetCurElement( int i )$/;"	f	class:vcg::ply::PlyFile
SetCurrentAction	vcglib/wrap/gui/trackball.cpp	/^void Trackball::SetCurrentAction ()$/;"	f	class:Trackball
SetD	vcglib/vcg/connectors/hedge.h	/^	void SetD() {this->Flags() |=DELETED;}\/\/\/  deletes the edge from the mesh$/;"	f	class:vcg::HEdgeArityMax
SetD	vcglib/vcg/simplex/edge/base.h	/^	void SetD() {this->Flags() |=DELETED;}\/\/\/  deletes the edge from the mesh$/;"	f	class:vcg::EdgeArityMax
SetD	vcglib/vcg/simplex/face/base.h	/^	void SetD() {this->Flags() |=DELETED;}$/;"	f	class:vcg::FaceArityMax
SetD	vcglib/vcg/simplex/tetrahedron/base.h	/^	void SetD() {this->Flags() |=DELETED;}$/;"	f	class:vcg::TetraArityMax
SetD	vcglib/vcg/simplex/vertex/base.h	/^	void SetD() {this->Flags() |=DELETED;}\/\/\/  deletes the vertex from the mesh$/;"	f	class:vcg::VertexArityMax
SetD	vcglib/wrap/gl/tetramesh.h	/^			void SetD(Point3x d)$/;"	f	class:vcg::tetra::GlTetramesh::ClipPlane
SetDefaultParams	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  void SetDefaultParams()$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricParameter
SetDefaultParams	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  void SetDefaultParams()$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
SetDefaultParams	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  void SetDefaultParams()$/;"	f	class:vcg::tri::PlanarEdgeFlipParameter
SetDiag	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon216
SetDiag	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon217
SetDiagonal	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void SetDiagonal(ScalarType val[3][3])$/;"	f	class:vcg::tri::PoissonSolver
SetDiagonal	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void SetDiagonal(Scalar *v)$/;"	f
SetDiagonal	vcglib/vcg/math/matrix33.h	/^    Matrix33 & SetDiagonal(S *v)$/;"	f	class:vcg::Matrix33
SetDiagonal	vcglib/vcg/math/matrix44.h	/^template <class T> void Matrix44<T>::SetDiagonal(const T k) {$/;"	f	class:vcg::Matrix44
SetDiagonal	vcglib/vcg/math/old_deprecated_matrix.h	/^			void SetDiagonal(TYPE *v)$/;"	f	class:vcg::ndim::Matrix
SetDiagonal	vcglib/vcg/math/old_matrix44.h	/^template <class T> void Matrix44<T>::SetDiagonal(const Scalar k) {$/;"	f	class:vcg::Matrix44
SetDiagonal	vcglib/wrap/miq/core/poisson_solver.h	/^	void SetDiagonal(ScalarType val[3][3])$/;"	f	class:PoissonSolver
SetDirection	vcglib/vcg/space/line2.h	/^	inline void SetDirection( const PointType & dir)$/;"	f	class:vcg::Line2
SetDirection	vcglib/vcg/space/line3.h	/^	inline void SetDirection( const PointType & dir)$/;"	f	class:vcg::Line3
SetDirection	vcglib/vcg/space/plane3.h	/^	void SetDirection( const PointType & dir)	{	$/;"	f	class:vcg::Plane3
SetDirection	vcglib/vcg/space/ray2.h	/^	inline void SetDirection( const PointType & dir)$/;"	f	class:vcg::Ray2
SetDirection	vcglib/vcg/space/ray3.h	/^	inline void SetDirection( const PointType & dir)$/;"	f	class:vcg::Ray3
SetEntry	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void SetEntry(const EntryCoordinate &at, std::vector< ObjectPointer > *data)$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
SetF	vcglib/vcg/simplex/face/base.h	/^	void SetF(int i)		{this->Flags() |=(FAUX0<<i);}$/;"	f	class:vcg::FaceArityMax
SetFaceCrossVectorFromVert	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static void SetFaceCrossVectorFromVert(FaceType &f)$/;"	f	class:vcg::tri::CrossField
SetFaceCrossVectorFromVert	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static void SetFaceCrossVectorFromVert(MeshType &mesh)$/;"	f	class:vcg::tri::CrossField
SetFaceQualityByDistortion	vcglib/wrap/miq/core/param_stats.h	/^void SetFaceQualityByDistortion(MeshType &Tmesh,$/;"	f
SetFix	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    void SetFix(MeshType& m){ mFix = &m; }$/;"	f	class:OverlapEstimation
SetFixedTimesteps	vcglib/wrap/gui/trackball.h	/^	void SetFixedTimesteps(bool mode){$/;"	f	class:vcg::Trackball
SetFlag	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 inline void  SetFlag(const typename UniformGrid::CellCoordinate &at)						{ m_Mask[at.X()][at.Y()][at.Z()] = true; }$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
SetFlags	vcglib/apps/metro/sampling.h	/^    void            SetFlags(int flags)         {Flags = flags;}$/;"	f	class:vcg::Sampling
SetFlags	vcglib/vcg/connectors/hedge.h	/^	void SetFlags(int flagp) {this->Flags()=flagp;}$/;"	f	class:vcg::HEdgeArityMax
SetFlags	vcglib/vcg/simplex/edge/base.h	/^	void SetFlags(int flagp) {this->Flags()=flagp;}$/;"	f	class:vcg::EdgeArityMax
SetFlags	vcglib/vcg/simplex/face/base.h	/^	void SetFlags(int flagp) {this->Flags()=flagp;}$/;"	f	class:vcg::FaceArityMax
SetFlags	vcglib/vcg/simplex/tetrahedron/base.h	/^	void SetFlags(int flagp) {this->Flags()=flagp;}$/;"	f	class:vcg::TetraArityMax
SetFlags	vcglib/vcg/simplex/vertex/base.h	/^	void SetFlags(int flagp) {this->Flags()=flagp;}$/;"	f	class:vcg::VertexArityMax
SetFlat	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 inline void  SetFlat(const int i, const int j, const int k)						{ m_Mask[i][j][k] = true; }$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
SetFromAscii	vcglib/wrap/gui/trackball.cpp	/^bool Trackball::SetFromAscii(const char * st){$/;"	f	class:Trackball
SetFrustum	vcglib/vcg/math/camera.h	/^void Camera<S>::SetFrustum(	S sx, S dx, S bt, S tp, S Focal, vcg::Point2<int> Viewport)$/;"	f	class:vcg::Camera
SetFullyVisible	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	static inline void SetFullyVisible(NodeType * node) {$/;"	f	class:vcg::AABBBinaryTreeFrustumCull
SetGLCavalieriProj	vcglib/wrap/gl/camera.h	/^static void SetGLCavalieriProj(float x1, float x2, float y1, float y2, float z1, float z2)$/;"	f	struct:GlCamera
SetGLIsometricProj	vcglib/wrap/gl/camera.h	/^static void SetGLIsometricProj(float x1, float x2, float y1, float y2, float z1, float z2)$/;"	f	struct:GlCamera
SetGLParameters	vcglib/wrap/gl/addons.h	/^		static void SetGLParameters(DrawMode DM)$/;"	f	class:vcg::Add_Ons
SetGrayShade	vcglib/vcg/space/color4.h	/^inline void SetGrayShade(float f)$/;"	f	class:vcg::Color4
SetHSVColor	vcglib/vcg/space/color4.h	/^    void SetHSVColor( float h, float s, float v)$/;"	f	class:vcg::Color4
SetHint	vcglib/wrap/gl/tetramesh.h	/^		void SetHint(Hint h, double value){$/;"	f	class:vcg::tetra::GlTetramesh
SetHint	vcglib/wrap/gl/trimesh.h	/^    void SetHint(Hint hn)$/;"	f	class:vcg::GlTrimesh
SetHintParamf	vcglib/wrap/gl/trimesh.h	/^    void SetHintParamf(const HintParamf hip, const float value)$/;"	f	class:vcg::GlTrimesh
SetHintParami	vcglib/wrap/gl/trimesh.h	/^    void SetHintParami(const HintParami hip, const int value)$/;"	f	class:vcg::GlTrimesh
SetIdentity	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void SetIdentity() { setIdentity(); };$/;"	f
SetIdentity	vcglib/vcg/math/matrix33.h	/^    Matrix33 & SetIdentity()	{$/;"	f	class:vcg::Matrix33
SetIdentity	vcglib/vcg/math/matrix44.h	/^template <class T> void Matrix44<T>::SetIdentity() {$/;"	f	class:vcg::Matrix44
SetIdentity	vcglib/vcg/math/old_deprecated_matrix.h	/^			void SetIdentity()$/;"	f	class:vcg::ndim::Matrix
SetIdentity	vcglib/vcg/math/quaternion.h	/^void Quaternion<S>::SetIdentity(){$/;"	f	class:vcg::Quaternion
SetIdentity	vcglib/vcg/math/shot.h	/^      void SetIdentity(){ rot.SetIdentity(); tra = Point3<S>(0.0,0.0,0.0);}$/;"	f	class:vcg::Shot::ReferenceFrame
SetIdentity	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Similarity<S,RotationType> &Similarity<S,RotationType>::SetIdentity() {$/;"	f	class:vcg::Similarity
SetIdentity	vcglib/wrap/gui/trackball.cpp	/^void Trackball::SetIdentity() {$/;"	f	class:Trackball
SetIndex	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^static void SetIndex(void) {$/;"	f	file:
SetIndexStructure	vcglib/vcg/space/index/space_iterators.h	/^		void SetIndexStructure(Spatial_Idexing &_Si)$/;"	f	class:vcg::ClosestIterator
SetIndexStructure	vcglib/vcg/space/index/space_iterators.h	/^		void SetIndexStructure(Spatial_Idexing &_Si)$/;"	f	class:vcg::RayIterator
SetIntersection	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    static void SetIntersection (const LCVertexStar &set1, const LCVertexStar &set2, LCVertexStar &result) {$/;"	f	class:vcg::tri::PolychordCollapse::LinkConditions
SetInvalid	vcglib/vcg/math/quadric.h	/^	void SetInvalid() { c = -1.0; }$/;"	f	class:vcg::math::Quadric
SetInvalid	vcglib/vcg/math/quadric5.h	/^	void SetInvalid() { c = -1.0; }$/;"	f	class:vcg::Quadric5
SetInvisible	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	static inline void SetInvisible(NodeType * node) {$/;"	f	class:vcg::AABBBinaryTreeFrustumCull
SetIsometric	vcglib/vcg/math/camera.h	/^void Camera<S>::SetIsometric(S sx, S dx, S bt, S tp, S Focal, vcg::Point2<int> Viewport)$/;"	f	class:vcg::Camera
SetLevel	vcglib/wrap/gl/fbo.h	/^	void SetLevel(GLint level)$/;"	f	class:TextureRenderTarget
SetLight	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void SetLight()$/;"	f
SetMarker	vcglib/vcg/space/index/space_iterators.h	/^		void SetMarker(TMARKER  _tm)$/;"	f	class:vcg::RayIterator
SetMarker	vcglib/vcg/space/index/space_iterators.h	/^		void SetMarker(TMARKER _tm)$/;"	f	class:vcg::ClosestIterator
SetMesh	vcglib/vcg/complex/algorithms/closest.h	/^			inline void SetMesh(void * \/*m=0*\/) const {}$/;"	f	class:vcg::tri::VertTmark
SetMesh	vcglib/vcg/complex/algorithms/closest.h	/^			void SetMesh(MESH_TYPE *_m)$/;"	f	class:vcg::tri::Tmark
SetMesh	vcglib/vcg/complex/algorithms/closest.h	/^			void SetMesh(MeshType *m)$/;"	f	class:vcg::tri::ClosestVertexIterator
SetMesh	vcglib/vcg/complex/algorithms/closest.h	/^			void SetMesh(MeshType *m)$/;"	f	class:vcg::tri::TriRayIterator
SetMesh	vcglib/vcg/complex/algorithms/closest.h	/^      void SetMesh(MeshType *m)$/;"	f	class:vcg::tri::ClosestFaceEPIterator
SetMove	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    void SetMove(MeshType& m){ mMov = &m; }$/;"	f	class:OverlapEstimation
SetName	vcglib/wrap/ply/plylib.h	/^	inline void SetName( const char * na )$/;"	f	class:vcg::ply::PlyElement
SetNothingAsFixed	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  void SetNothingAsFixed(){$/;"	f	class:vcg::tri::TextureOptimizer
SetNull	vcglib/vcg/complex/algorithms/hole.h	/^  void SetNull(){e0.SetNull();e1.SetNull();}$/;"	f	class:vcg::tri::TrivialEar
SetNull	vcglib/vcg/simplex/edge/pos.h	/^	void SetNull(){$/;"	f	class:vcg::edge::Pos
SetNull	vcglib/vcg/simplex/face/pos.h	/^	void SetNull(){$/;"	f	class:vcg::face::Pos
SetNull	vcglib/vcg/simplex/tetrahedron/pos.h	/^	void SetNull(){$/;"	f	class:vcg::tetra::Pos
SetNull	vcglib/vcg/space/box.h	/^	void SetNull()$/;"	f	class:vcg::Box
SetNull	vcglib/vcg/space/box2.h	/^	void SetNull()$/;"	f	class:vcg::Box2
SetNull	vcglib/vcg/space/box3.h	/^    void SetNull()$/;"	f	class:vcg::Box3
SetNumbert	vcglib/wrap/ply/plylib.h	/^	inline void SetNumbert( int nu )$/;"	f	class:vcg::ply::PlyElement
SetOffset	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void SetOffset(const typename UniformGrid::CellCoordinate &coord, const Offset &offset)$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
SetOffset	vcglib/vcg/space/plane3.h	/^	void SetOffset( const ScalarType &o ) {	_offset=o; }$/;"	f	class:vcg::Plane3
SetOrigin	vcglib/vcg/space/line2.h	/^	inline void SetOrigin( const PointType & ori )$/;"	f	class:vcg::Line2
SetOrigin	vcglib/vcg/space/line3.h	/^	inline void SetOrigin( const PointType & ori )$/;"	f	class:vcg::Line3
SetOrigin	vcglib/vcg/space/ray2.h	/^	inline void SetOrigin( const PointType & ori )$/;"	f	class:vcg::Ray2
SetOrigin	vcglib/vcg/space/ray3.h	/^	inline void SetOrigin( const PointType & ori )$/;"	f	class:vcg::Ray3
SetOrtho	vcglib/vcg/math/camera.h	/^    void SetOrtho( S l,S r, S b, S t,  vcg::Point2<int> viewport)$/;"	f	class:vcg::Camera
SetP	vcglib/wrap/gl/tetramesh.h	/^			void SetP(Point3x p)$/;"	f	class:vcg::tetra::GlTetramesh::ClipPlane
SetParam	vcglib/apps/metro/sampling.h	/^    void            SetParam(double _n_samp)    {n_samples_target = _n_samp;}$/;"	f	class:vcg::Sampling
SetPerspective	vcglib/vcg/math/camera.h	/^void Camera<S>::SetPerspective(	S AngleDeg, S AspectRatio, S Focal, vcg::Point2<int> Viewport)$/;"	f	class:vcg::Camera
SetPosition	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::SetPosition(const Point3f newpos)$/;"	f	class:ActiveCoordinateFrame
SetPosition	vcglib/wrap/gui/coordinateframe.cpp	/^void MovableCoordinateFrame::SetPosition(const Point3f newpos)$/;"	f	class:MovableCoordinateFrame
SetPosition	vcglib/wrap/gui/trackball.cpp	/^void Trackball::SetPosition(const Point3f &c, int \/* millisec *\/) {$/;"	f	class:Trackball
SetQasDistorsion	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^            static void SetQasDistorsion(MeshType &m,$/;"	f	class:vcg::tri::Distortion
SetR	vcglib/vcg/connectors/hedge.h	/^	void SetR() {this->Flags() &=(~NOTREAD);}\/\/\/  marks the edge as readable$/;"	f	class:vcg::HEdgeArityMax
SetR	vcglib/vcg/simplex/edge/base.h	/^	void SetR() {this->Flags() &=(~NOTREAD);}\/\/\/  marks the edge as readable$/;"	f	class:vcg::EdgeArityMax
SetR	vcglib/vcg/simplex/face/base.h	/^	void SetR() {this->Flags() &=(~NOTREAD);}$/;"	f	class:vcg::FaceArityMax
SetR	vcglib/vcg/simplex/tetrahedron/base.h	/^	void SetR() {this->Flags() &=(~NOTREAD);}$/;"	f	class:vcg::TetraArityMax
SetR	vcglib/vcg/simplex/vertex/base.h	/^	void SetR() {this->Flags() &=(~NOTREAD);}\/\/\/  marks the vertex as readable$/;"	f	class:vcg::VertexArityMax
SetRange	vcglib/vcg/math/histogram.h	/^void Histogram<ScalarType>::SetRange(ScalarType _minv, ScalarType _maxv, int _n, ScalarType gamma)$/;"	f	class:vcg::Histogram
SetRange	vcglib/vcg/space/index/octree.h	/^        void SetRange(const int begin, const int end)$/;"	f	struct:vcg::Voxel
SetRelationsLoopFace	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            static void SetRelationsLoopFace(HEdgeType * e0, FaceType * f){$/;"	f	class:vcg::tri::UpdateHalfEdges
SetRot	vcglib/vcg/math/shot.h	/^      void SetRot(const  RotoType & rt) {rot = rt;}$/;"	f	class:vcg::Shot::ReferenceFrame
SetRotate	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Similarity<S,RotationType> &Similarity<S,RotationType>::SetRotate(S angle, const Point3<S> &axis) {$/;"	f	class:vcg::Similarity
SetRotate	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Similarity<S,RotationType> &Similarity<S,RotationType>::SetRotate(const RotationType &q) {$/;"	f	class:vcg::Similarity
SetRotateDeg	vcglib/vcg/math/matrix33.h	/^    Matrix33 & SetRotateDeg(S angle, const Point3<S> & axis ){$/;"	f	class:vcg::Matrix33
SetRotateDeg	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetRotateDeg(T AngleDeg, const Point3<T> & axis) {$/;"	f	class:vcg::Matrix44
SetRotateDeg	vcglib/vcg/math/old_matrix33.h	/^	Matrix33 & SetRotateDeg(Scalar angle, const Point3<Scalar> & axis ){$/;"	f	class:vcg::Matrix33
SetRotateDeg	vcglib/vcg/math/old_matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetRotateDeg(Scalar AngleDeg, const Point3<Scalar> & axis) {$/;"	f	class:vcg::Matrix44
SetRotateRad	vcglib/vcg/math/matrix33.h	/^    Matrix33 & SetRotateRad(S angle, const Point3<S> & axis )$/;"	f	class:vcg::Matrix33
SetRotateRad	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetRotateRad(T AngleRad, const Point3<T> & axis) {$/;"	f	class:vcg::Matrix44
SetRotateRad	vcglib/vcg/math/old_matrix33.h	/^	Matrix33 & SetRotateRad(Scalar angle, const Point3<Scalar> & axis )$/;"	f	class:vcg::Matrix33
SetRotateRad	vcglib/vcg/math/old_matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetRotateRad(Scalar AngleRad, const Point3<Scalar> & axis) {$/;"	f	class:vcg::Matrix44
SetRotation	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::SetRotation(const Quaternionf newrot)$/;"	f	class:ActiveCoordinateFrame
SetRotation	vcglib/wrap/gui/coordinateframe.cpp	/^void MovableCoordinateFrame::SetRotation(const Quaternionf newrot)$/;"	f	class:MovableCoordinateFrame
SetRow	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void SetRow(unsigned int i, Scalar* v)$/;"	f
SetRow	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void SetRow(unsigned int j, const MatrixBase<OtherDerived>& other)$/;"	f
SetRow	vcglib/vcg/math/matrix33.h	/^    void SetRow(const int n, S* v){$/;"	f	class:vcg::Matrix33
SetRow	vcglib/vcg/math/matrix33.h	/^    void SetRow(const int n, const Point3<S> v){$/;"	f	class:vcg::Matrix33
SetRow	vcglib/vcg/math/old_deprecated_matrix.h	/^			void SetRow(const unsigned int i, TYPE* v)$/;"	f	class:vcg::ndim::Matrix
SetS	vcglib/vcg/connectors/hedge.h	/^	void SetS()		{this->Flags() |=SELECTED;}\/\/\/  select the edge$/;"	f	class:vcg::HEdgeArityMax
SetS	vcglib/vcg/simplex/edge/base.h	/^	void SetS()		{this->Flags() |=SELECTED;}\/\/\/  select the edge$/;"	f	class:vcg::EdgeArityMax
SetS	vcglib/vcg/simplex/face/base.h	/^	void SetS()		{this->Flags() |=SELECTED;}$/;"	f	class:vcg::FaceArityMax
SetS	vcglib/vcg/simplex/tetrahedron/base.h	/^	void SetS()		{this->Flags() |=SELECTED;}$/;"	f	class:vcg::TetraArityMax
SetS	vcglib/vcg/simplex/vertex/base.h	/^	void SetS()		{this->Flags() |=SELECTED;}\/\/\/  select the vertex$/;"	f	class:vcg::VertexArityMax
SetSVGDimInMm	vcglib/wrap/qt/Outline2ToQImage.h	/^      void SetSVGDimInMm(float widthMM,float heightMM,float _dpi=72)$/;"	f	class:Outline2Dumper::Param
SetSVGPenInMM	vcglib/wrap/qt/Outline2ToQImage.h	/^      void SetSVGPenInMM(float widthMM)$/;"	f	class:Outline2Dumper::Param
SetSamplesPerAreaUnit	vcglib/apps/metro/sampling.h	/^void Sampling<MetroMesh>::SetSamplesPerAreaUnit(double _n_samp)$/;"	f	class:vcg::Sampling
SetSamplesTarget	vcglib/apps/metro/sampling.h	/^void Sampling<MetroMesh>::SetSamplesTarget(unsigned long _n_samp)$/;"	f	class:vcg::Sampling
SetScale	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetScale(const Point3<T> &t) {$/;"	f	class:vcg::Matrix44
SetScale	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetScale(const T sx, const T sy, const T sz) {$/;"	f	class:vcg::Matrix44
SetScale	vcglib/vcg/math/old_matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetScale(const Point3<Scalar> &t) {$/;"	f	class:vcg::Matrix44
SetScale	vcglib/vcg/math/old_matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetScale(const Scalar sx, const Scalar sy, const Scalar sz) {$/;"	f	class:vcg::Matrix44
SetScale	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Similarity<S,RotationType> &Similarity<S,RotationType>::SetScale(const S s) {$/;"	f	class:vcg::Similarity
SetScale	vcglib/wrap/gui/trackball.h	/^  void SetScale(const float s) {radius=s;};$/;"	f	class:vcg::Trackball
SetSelectedAsFixed	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void SetSelectedAsFixed()$/;"	f	class:vcg::tri::PoissonSolver
SetShearXY	vcglib/vcg/math/old_matrix44.h	/^	template <class T> Matrix44<T> & Matrix44<T>::SetShearXY( const Scalar sh)	{\/\/ shear the X coordinate as the Y coordinate change$/;"	f	class:vcg::Matrix44
SetShearXZ	vcglib/vcg/math/old_matrix44.h	/^	template <class T> Matrix44<T> & Matrix44<T>::SetShearXZ( const Scalar sh)	{\/\/ shear the X coordinate as the Z coordinate change$/;"	f	class:vcg::Matrix44
SetShearYZ	vcglib/vcg/math/old_matrix44.h	/^	template <class T> Matrix44<T> &Matrix44<T>::SetShearYZ( const Scalar sh)	{\/\/ shear the Y coordinate as the Z coordinate change$/;"	f	class:vcg::Matrix44
SetSnap	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::SetSnap(float rot_deg)$/;"	f	class:ActiveCoordinateFrame
SetSource	vcglib/wrap/gl/shaders.h	/^	void SetSource(const char * src)$/;"	f	class:Shader
SetSources	vcglib/wrap/gl/shaders.h	/^	void SetSources(const char * vsrc, const char * fsrc)$/;"	f	class:ProgramVF
SetSpeed	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  void SetSpeed(ScalarType _speed){$/;"	f	class:vcg::tri::AreaPreservingTextureOptimizer
SetSpinnable	vcglib/wrap/gui/trackball.cpp	/^void Trackball::SetSpinnable(bool \/* on*\/ ){}$/;"	f	class:Trackball
SetSpinning	vcglib/wrap/gui/trackball.cpp	/^void Trackball::SetSpinning(Quaternionf &\/* spin*\/){}$/;"	f	class:Trackball
SetStartNear	vcglib/wrap/gui/trackmode.cpp	/^Point3f AreaMode::SetStartNear(Point3f point)$/;"	f	class:AreaMode
SetStartNear	vcglib/wrap/gui/trackmode.cpp	/^Point3f PathMode::SetStartNear(Point3f point)$/;"	f	class:PathMode
SetStepOnWalk	vcglib/wrap/gui/trackmode.cpp	/^void NavigatorWasdMode::SetStepOnWalk(float width, float height){$/;"	f	class:NavigatorWasdMode
SetSubView	vcglib/wrap/gl/camera.h	/^static void SetSubView(vcg::Camera<S> & camera,vcg::Point2<S> p0,S nearDist, S farDist,vcg::Point2<S> p1){$/;"	f	struct:GlCamera
SetSubView	vcglib/wrap/gl/shot.h	/^static void SetSubView(vcg::Shot<ScalarType> & shot,$/;"	f	struct:GlShot
SetTargetMetric	vcglib/vcg/complex/algorithms/local_optimization.h	/^	void SetTargetMetric	(ScalarType tm	){targetMetric		= tm;	SetTerminationFlag(LOMetric);		} $/;"	f	class:vcg::LocalOptimization
SetTargetOperations	vcglib/vcg/complex/algorithms/local_optimization.h	/^	void SetTargetOperations(int to			){nTargetOps		= to;	SetTerminationFlag(LOnOps);			} $/;"	f	class:vcg::LocalOptimization
SetTargetSimplices	vcglib/vcg/complex/algorithms/local_optimization.h	/^	void SetTargetSimplices	(int ts			){nTargetSimplices	= ts;	SetTerminationFlag(LOnSimplices);	}	 	$/;"	f	class:vcg::LocalOptimization
SetTargetVertices	vcglib/vcg/complex/algorithms/local_optimization.h	/^	void SetTargetVertices	(int tv			){nTargetVertices	= tv;	SetTerminationFlag(LOnVertices);	} $/;"	f	class:vcg::LocalOptimization
SetTerminationFlag	vcglib/vcg/complex/algorithms/local_optimization.h	/^	void SetTerminationFlag		(int v){tf |= v;}$/;"	f	class:vcg::LocalOptimization
SetTheta	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  void SetTheta(int _theta){$/;"	f	class:vcg::tri::AreaPreservingTextureOptimizer
SetTimeBudget	vcglib/vcg/complex/algorithms/local_optimization.h	/^	void SetTimeBudget		(float tb		){timeBudget		= tb;	SetTerminationFlag(LOTime);			} $/;"	f	class:vcg::LocalOptimization
SetTopSpeedsAndAcc	vcglib/wrap/gui/trackmode.cpp	/^void NavigatorWasdMode::SetTopSpeedsAndAcc(float hspeed, float vspeed, float acc){$/;"	f	class:NavigatorWasdMode
SetTra	vcglib/vcg/math/shot.h	/^      void SetTra(const Point3<S> & tr) {tra = tr;}$/;"	f	class:vcg::Shot::ReferenceFrame
SetTrackball	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^void SetTrackball(int mode){$/;"	f
SetTranslate	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetTranslate(const Point3<T> &t) {$/;"	f	class:vcg::Matrix44
SetTranslate	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetTranslate(const T tx, const T ty, const T tz) {$/;"	f	class:vcg::Matrix44
SetTranslate	vcglib/vcg/math/old_matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetTranslate(const Point3<Scalar> &t) {$/;"	f	class:vcg::Matrix44
SetTranslate	vcglib/vcg/math/old_matrix44.h	/^template <class T> Matrix44<T> &Matrix44<T>::SetTranslate(const Scalar tx, const Scalar ty, const Scalar tz) {$/;"	f	class:vcg::Matrix44
SetTranslate	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Similarity<S,RotationType> &Similarity<S,RotationType>::SetTranslate(const Point3<S> &t) {$/;"	f	class:vcg::Similarity
SetUserBit	vcglib/vcg/connectors/hedge.h	/^	void SetUserBit(int userBit){this->Flags() |=userBit;}$/;"	f	class:vcg::HEdgeArityMax
SetUserBit	vcglib/vcg/simplex/edge/base.h	/^	void SetUserBit(int userBit){this->Flags() |=userBit;}$/;"	f	class:vcg::EdgeArityMax
SetUserBit	vcglib/vcg/simplex/face/base.h	/^	void SetUserBit(int userBit){this->Flags() |=userBit;}$/;"	f	class:vcg::FaceArityMax
SetUserBit	vcglib/vcg/simplex/tetrahedron/base.h	/^	void SetUserBit(int userBit){this->Flags() |=userBit;}$/;"	f	class:vcg::TetraArityMax
SetUserBit	vcglib/vcg/simplex/vertex/base.h	/^	void SetUserBit(int userBit){this->Flags() |=userBit;}$/;"	f	class:vcg::VertexArityMax
SetV	vcglib/vcg/connectors/hedge.h	/^	void SetV()		{this->Flags() |=VISITED;}$/;"	f	class:vcg::HEdgeArityMax
SetV	vcglib/vcg/simplex/edge/base.h	/^	void SetV()		{this->Flags() |=VISITED;}$/;"	f	class:vcg::EdgeArityMax
SetV	vcglib/vcg/simplex/face/base.h	/^	void SetV()		{this->Flags() |=VISITED;}$/;"	f	class:vcg::FaceArityMax
SetV	vcglib/vcg/simplex/tetrahedron/base.h	/^	void SetV()		{this->Flags() |=VISITED;}$/;"	f	class:vcg::TetraArityMax
SetV	vcglib/vcg/simplex/vertex/base.h	/^	void SetV()		{this->Flags() |=VISITED;}$/;"	f	class:vcg::VertexArityMax
SetValA	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void SetValA(int Xindex,int Yindex,ScalarType val)$/;"	f	class:vcg::tri::PoissonSolver
SetValB	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void SetValB(int Xindex,$/;"	f	class:vcg::tri::PoissonSolver
SetValency	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void SetValency(VertexType *v, int n){$/;"	f	class:vcg::tri::BitQuad
SetVertCrossFromCurvature	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static void SetVertCrossFromCurvature(MeshType &mesh)$/;"	f	class:vcg::tri::CrossField
SetVertCrossVectorFromFace	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static void SetVertCrossVectorFromFace(MeshType &mesh)$/;"	f	class:vcg::tri::CrossField
SetVertCrossVectorFromFace	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static void SetVertCrossVectorFromFace(VertexType &v)$/;"	f	class:vcg::tri::CrossField
SetView	vcglib/wrap/gl/shot.h	/^static void SetView(vcg::Shot<ScalarType> & shot, ScalarType nearDist, ScalarType farDist)$/;"	f	struct:GlShot
SetView	vcglib/wrap/gui/frustum.h	/^template <class T> void Frustum<T>::SetView(const float *_proj = NULL,$/;"	f	class:vcg::Frustum
SetView	vcglib/wrap/gui/view.h	/^template <class T> void View<T>::SetView(const float *_proj,$/;"	f	class:vcg::View
SetViewPoint	vcglib/vcg/math/shot.h	/^void Shot<S,RotationType>::SetViewPoint(const vcg::Point3<S> & viewpoint)$/;"	f	class:vcg::Shot
SetW	vcglib/vcg/connectors/hedge.h	/^	void SetW() {this->Flags() &=(~NOTWRITE);}\/\/\/  marks the edge as not writable$/;"	f	class:vcg::HEdgeArityMax
SetW	vcglib/vcg/simplex/edge/base.h	/^	void SetW() {this->Flags() &=(~NOTWRITE);}\/\/\/  marks the edge as not writable$/;"	f	class:vcg::EdgeArityMax
SetW	vcglib/vcg/simplex/face/base.h	/^	void SetW() {this->Flags() &=(~NOTWRITE);}$/;"	f	class:vcg::FaceArityMax
SetW	vcglib/vcg/simplex/tetrahedron/base.h	/^	void SetW() {this->Flags() &=(~NOTWRITE);}$/;"	f	class:vcg::TetraArityMax
SetW	vcglib/vcg/simplex/vertex/base.h	/^	void SetW() {this->Flags() &=(~NOTWRITE);}\/\/\/  marks the vertex as not writable$/;"	f	class:vcg::VertexArityMax
SetWithRadius	vcglib/vcg/space/index/grid_static_ptr.h	/^				inline void SetWithRadius(const OBJITER & _oBegin, const OBJITER & _oEnd, FLT _cellRadius)$/;"	f	class:vcg::GridStaticPtr
SetZero	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void SetZero() { setZero(); };$/;"	f
SetZero	vcglib/vcg/math/matrix33.h	/^    Matrix33 & SetZero()	{$/;"	f	class:vcg::Matrix33
SetZero	vcglib/vcg/math/matrix44.h	/^template <class T> void Matrix44<T>::SetZero() {$/;"	f	class:vcg::Matrix44
SetZero	vcglib/vcg/math/old_deprecated_matrix.h	/^			void SetZero()$/;"	f	class:vcg::ndim::Matrix
SetZero	vcglib/vcg/math/quadric.h	/^	void SetZero()																\/\/ Azzera la quadrica$/;"	f	class:vcg::math::Quadric
SetZero	vcglib/vcg/space/deprecated_point.h	/^	inline void SetZero()$/;"	f	class:vcg::ndim::Point
SetZero	vcglib/vcg/space/deprecated_point2.h	/^	inline void SetZero()$/;"	f	class:vcg::Point2
SetZero	vcglib/vcg/space/deprecated_point3.h	/^    inline void SetZero()$/;"	f	class:vcg::Point3
SetZero	vcglib/vcg/space/deprecated_point4.h	/^	inline void SetZero()$/;"	f	class:vcg::Point4
SetterRowMajor	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^      SetterRowMajor = SwapStorage ? 1-TargetRowMajor : TargetRowMajor$/;"	e	enum:Eigen::RandomSetter::__anon463
SetupGrid	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    inline void SetupGrid()$/;"	f	class:OverlapEstimation
SetupOrthoViewMatrix	vcglib/apps/unsupported/shadevis/visshader.h	/^void SetupOrthoViewMatrix(Point3x &ViewDir, int subx, int suby,int LocSplit)$/;"	f	class:vcg::VisShader
Shader	vcglib/wrap/gl/shaders.h	/^	Shader(void) : GLObject(), Bindable()$/;"	f	class:Shader
Shader	vcglib/wrap/gl/shaders.h	/^class Shader : public GLObject, public Bindable$/;"	c
Shader	vcglib/wrap/glw/shader.h	/^		Shader(Context * ctx)$/;"	f	class:glw::Shader
Shader	vcglib/wrap/glw/shader.h	/^class Shader : public Object$/;"	c	namespace:glw
ShaderArguments	vcglib/wrap/glw/shader.h	/^		ShaderArguments(void)$/;"	f	class:glw::ShaderArguments
ShaderArguments	vcglib/wrap/glw/shader.h	/^class ShaderArguments : public ObjectArguments$/;"	c	namespace:glw
ShaderBindingParams	vcglib/wrap/glw/shader.h	/^		ShaderBindingParams(GLenum aTarget, GLenum aUnit)$/;"	f	class:glw::ShaderBindingParams
ShaderBindingParams	vcglib/wrap/glw/shader.h	/^		ShaderBindingParams(void)$/;"	f	class:glw::ShaderBindingParams
ShaderBindingParams	vcglib/wrap/glw/shader.h	/^class ShaderBindingParams : public ObjectBindingParams$/;"	c	namespace:glw
ShaderHandle	vcglib/wrap/glw/shader.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeShader> ::Type ShaderHandle;$/;"	t	namespace:glw
ShaderHandleVector	vcglib/wrap/glw/program.h	/^typedef std::vector<ShaderHandle> ShaderHandleVector;$/;"	t	namespace:glw
ShaderHeaderBuilder	vcglib/wrap/glw/utility.h	/^class ShaderHeaderBuilder$/;"	c	namespace:glw
ShaderPtr	vcglib/wrap/glw/shader.h	/^typedef   detail::ObjectSharedPointerTraits  <Shader> ::Type ShaderPtr;$/;"	t	namespace:glw
ShaderType	vcglib/wrap/gl/shaders.h	/^	} ShaderType;$/;"	t	class:Shader	typeref:enum:Shader::__anon517
ShareEdgeFF	vcglib/vcg/simplex/face/topology.h	/^bool ShareEdgeFF(FaceType *f0,FaceType *f1, int *i0=0, int *i1=0)$/;"	f	namespace:vcg::face
SharedDataUnion	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^				union SharedDataUnion {$/;"	u	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
Shift	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		typename HashTable::EntryCoordinate Shift(const vcg::Point3i &entry, const typename OffsetTable::Offset &offset)$/;"	f	class:vcg::PerfectSpatialHashing
ShininessTag	vcglib/wrap/dae/colladaformat.h	/^		ShininessTag()$/;"	f	class:Collada::Tags::ShininessTag
ShininessTag	vcglib/wrap/dae/colladaformat.h	/^	class ShininessTag : public XMLTag$/;"	c	namespace:Collada::Tags
Shot	vcglib/vcg/math/shot.h	/^  Shot()$/;"	f	class:vcg::Shot
Shot	vcglib/vcg/math/shot.h	/^  Shot(Camera<S> c)$/;"	f	class:vcg::Shot
Shot	vcglib/vcg/math/shot.h	/^class Shot {$/;"	c	namespace:vcg
Shot2Tsai	vcglib/wrap/tsai/tsaimethods.cpp	/^void TsaiMethods::Shot2Tsai(vcg::Shot<double>* shot){$/;"	f	class:TsaiMethods
Shotd	vcglib/vcg/math/shot.h	/^typedef  Shot<double> Shotd;$/;"	t	namespace:vcg
Shotf	vcglib/vcg/math/shot.h	/^typedef  Shot<float> Shotf;$/;"	t	namespace:vcg
ShowDirFlag	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^bool ShowDirFlag=false;$/;"	v
Si	vcglib/vcg/space/index/space_iterators.h	/^		Spatial_Idexing &Si;		  \/\/reference to spatial index algorithm$/;"	m	class:vcg::ClosestIterator
Si	vcglib/vcg/space/index/space_iterators.h	/^		Spatial_Idexing &Si;	  \/\/reference to spatial index algorithm$/;"	m	class:vcg::RayIterator
Side	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };$/;"	e	enum:Eigen::GeneralProduct::__anon167
Sign	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static ScalarType Sign(ScalarType a){return (ScalarType)((a>0)?+1:-1);}$/;"	f	class:vcg::tri::CrossField
Signature	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^        Signature(){}$/;"	f	struct:vcg::tri::Zonohedron::Signature
Signature	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^        Signature(int n){ v.resize(n,false); }$/;"	f	struct:vcg::tri::Zonohedron::Signature
Signature	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    struct Signature {$/;"	s	class:vcg::tri::Zonohedron
Signature	vcglib/wrap/bmt/strip_mesh.h	/^  enum Signature { NORMAL = 1, COLOR = 2, STRIP = 4 };$/;"	g	class:vcg::StripMesh
SignedDistancePlanePoint	vcglib/vcg/space/plane3.h	/^template<class T> T SignedDistancePlanePoint(const Plane3<T,true> & plane, const Point3<T> & point)$/;"	f	namespace:vcg
SignedDistancePointPlane	vcglib/vcg/space/plane3.h	/^template<class T> T SignedDistancePointPlane(const Point3<T> & point, const Plane3<T,true> & plane)$/;"	f	namespace:vcg
SimilarFaceSampling	vcglib/apps/metro/sampling.h	/^void Sampling<MetroMesh>::SimilarFaceSampling()$/;"	f	class:vcg::Sampling
SimilarTriangles	vcglib/apps/metro/sampling.h	/^void Sampling<MetroMesh>::SimilarTriangles(const Point3x & v0, const Point3x & v1, const Point3x & v2, int n_samples_per_edge)$/;"	f	class:vcg::Sampling
Similarity	vcglib/vcg/math/similarity.h	/^	Similarity(S alpha, S beta, S gamma)$/;"	f	class:vcg::Similarity
Similarity	vcglib/vcg/math/similarity.h	/^  Similarity() {}$/;"	f	class:vcg::Similarity
Similarity	vcglib/vcg/math/similarity.h	/^  Similarity(S s) { SetScale(s); }$/;"	f	class:vcg::Similarity
Similarity	vcglib/vcg/math/similarity.h	/^  Similarity(const Point3<S> &p) { SetTranslate(p); }$/;"	f	class:vcg::Similarity
Similarity	vcglib/vcg/math/similarity.h	/^  Similarity(const RotationType &q) { SetRotate(q); }$/;"	f	class:vcg::Similarity
Similarity	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType = Quaternion<S> > class Similarity {$/;"	c	namespace:vcg
Similarity2	vcglib/vcg/math/similarity2.h	/^  Similarity2():rotRad(0),tra(0,0),sca(1)  {}$/;"	f	class:vcg::Similarity2
Similarity2	vcglib/vcg/math/similarity2.h	/^class Similarity2$/;"	c	namespace:vcg
Similarity2d	vcglib/vcg/math/similarity2.h	/^typedef Similarity2<double> Similarity2d;$/;"	t	namespace:vcg
Similarity2f	vcglib/vcg/math/similarity2.h	/^typedef Similarity2<float> Similarity2f;$/;"	t	namespace:vcg
Similarity2x	vcglib/vcg/space/outline2_packer.h	/^  typedef typename vcg::Similarity2<SCALAR_TYPE> Similarity2x;$/;"	t	class:vcg::PolyPacker
Similarity2x	vcglib/vcg/space/rasterized_outline2_packer.h	/^    typedef typename vcg::Similarity2<SCALAR_TYPE> Similarity2x;$/;"	t	class:vcg::RasterizedOutline2Packer
Similarity2x	vcglib/vcg/space/rect_packer.h	/^  typedef typename vcg::Similarity2<SCALAR_TYPE> Similarity2x;$/;"	t	class:vcg::RectPacker
Similarityd	vcglib/vcg/math/similarity.h	/^class Similarityd:public Similarity<double>{};$/;"	c	namespace:vcg
Similarityf	vcglib/vcg/math/similarity.h	/^class Similarityf:public Similarity<float>{};$/;"	c	namespace:vcg
SimpTempDataType	vcglib/vcg/container/simple_temporary_data.h	/^    typedef SimpleTempData<STL_CONT,ATTR_TYPE> SimpTempDataType;$/;"	t	class:vcg::SimpleTempData
SimpleObjHashFunc	vcglib/vcg/math/disjoint_set.h	/^		struct SimpleObjHashFunc{$/;"	s	class:vcg::DisjointSet
SimplePic	vcglib/apps/unsupported/shadevis/simplepic.h	/^  class SimplePic$/;"	c	namespace:vcg
SimpleTempData	vcglib/vcg/container/simple_temporary_data.h	/^    SimpleTempData(STL_CONT  &_c):c(_c),padding(0){data.reserve(c.capacity());data.resize(c.size());};$/;"	f	class:vcg::SimpleTempData
SimpleTempData	vcglib/vcg/container/simple_temporary_data.h	/^    SimpleTempData(STL_CONT  &_c, const ATTR_TYPE &val):c(_c){$/;"	f	class:vcg::SimpleTempData
SimpleTempData	vcglib/vcg/container/simple_temporary_data.h	/^class SimpleTempData:public SimpleTempDataBase{$/;"	c	namespace:vcg
SimpleTempDataBase	vcglib/vcg/container/simple_temporary_data.h	/^  SimpleTempDataBase() {}$/;"	f	class:vcg::SimpleTempDataBase
SimpleTempDataBase	vcglib/vcg/container/simple_temporary_data.h	/^class SimpleTempDataBase{$/;"	c	namespace:vcg
SimpleTri	vcglib/vcg/complex/algorithms/clustering.h	/^    class SimpleTri$/;"	c	class:vcg::tri::Clustering
SimpleTriHashFunc	vcglib/vcg/complex/algorithms/clustering.h	/^  struct SimpleTriHashFunc{$/;"	s	class:vcg::tri::Clustering
SimpleVolume	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^class SimpleVolume$/;"	c	namespace:vcg
SimpleVolume	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^class SimpleVolume$/;"	c	namespace:vcg
SimpleVoxel	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^class SimpleVoxel$/;"	c	namespace:vcg
SimpleVoxel	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^class SimpleVoxel$/;"	c	namespace:vcg
SimpleVoxelWithNormal	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^class SimpleVoxelWithNormal$/;"	c	namespace:vcg
SimplexNumber	vcglib/vcg/complex/base.h	/^int & SimplexNumber(){ return fn;}$/;"	f	class:vcg::tri::TriMesh
SimplicialCholesky	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky() : Base(), m_LDLT(true) {}$/;"	f	class:Eigen::SimplicialCholesky
SimplicialCholesky	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky
SimplicialCholesky	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialCholesky : public SimplicialCholeskyBase<SimplicialCholesky<_MatrixType,_UpLo> >$/;"	c	namespace:Eigen
SimplicialCholeskyBase	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase
SimplicialCholeskyBase	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase
SimplicialCholeskyBase	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^class SimplicialCholeskyBase : internal::noncopyable$/;"	c	namespace:Eigen
SimplicialCholeskyLDLT	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLDLT$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyLLT	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLLT,$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyMode	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^enum SimplicialCholeskyMode {$/;"	g	namespace:Eigen
SimplicialLDLT	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT() : Base() {}$/;"	f	class:Eigen::SimplicialLDLT
SimplicialLDLT	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT
SimplicialLDLT	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLDLT : public SimplicialCholeskyBase<SimplicialLDLT<_MatrixType,_UpLo> >$/;"	c	namespace:Eigen
SimplicialLLT	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT() : Base() {}$/;"	f	class:Eigen::SimplicialLLT
SimplicialLLT	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT
SimplicialLLT	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLLT : public SimplicialCholeskyBase<SimplicialLLT<_MatrixType,_UpLo> >$/;"	c	namespace:Eigen
Sin	vcglib/vcg/math/base.h	/^  inline double Sin(const double v)   { return sin(v); }$/;"	f	namespace:vcg::math
Sin	vcglib/vcg/math/base.h	/^  inline float Sin(const float v)   { return sinf(v); }$/;"	f	namespace:vcg::math
SingleFaceRaster	vcglib/vcg/complex/algorithms/point_sampling.h	/^    static void SingleFaceRaster(typename MetroMesh::FaceType &f,  VertexSampler &ps,$/;"	f	class:vcg::tri::SurfaceSampling
SingleFaceSimilar	vcglib/vcg/complex/algorithms/point_sampling.h	/^static int SingleFaceSimilar(FacePointer fp, VertexSampler &ps, int n_samples_per_edge)$/;"	f	class:vcg::tri::SurfaceSampling
SingleFaceSimilarDual	vcglib/vcg/complex/algorithms/point_sampling.h	/^static int SingleFaceSimilarDual(FacePointer fp, VertexSampler &ps, int n_samples_per_edge, bool randomFlag)$/;"	f	class:vcg::tri::SurfaceSampling
SingleFaceSubdivision	vcglib/vcg/complex/algorithms/point_sampling.h	/^static int SingleFaceSubdivision(int sampleNum, const CoordType & v0, const CoordType & v1, const CoordType & v2, VertexSampler &ps, FacePointer fp, bool randSample)$/;"	f	class:vcg::tri::SurfaceSampling
SingleFaceSubdivisionOld	vcglib/vcg/complex/algorithms/point_sampling.h	/^static int SingleFaceSubdivisionOld(int sampleNum, const CoordType & v0, const CoordType & v1, const CoordType & v2, VertexSampler &ps, FacePointer fp, bool randSample)$/;"	f	class:vcg::tri::SurfaceSampling
SingletonVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^        SingletonVector(Index i, Index v)$/;"	f	class:Eigen::SparseMatrix::SingletonVector
SingletonVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    class SingletonVector$/;"	c	class:Eigen::SparseMatrix
SingularValueBacksubstitution	vcglib/vcg/math/old_lin_algebra.h	/^		static void SingularValueBacksubstitution(const MATRIX_TYPE												&U,$/;"	f	namespace:vcg
SingularValueDecomposition	vcglib/vcg/math/old_lin_algebra.h	/^		static bool SingularValueDecomposition(MATRIX_TYPE &A, typename MATRIX_TYPE::ScalarType *W, MATRIX_TYPE &V, const SortingStrategy sorting=LeaveUnsorted, const int max_iters=30)$/;"	f	namespace:vcg
SingularValuesType	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MinSize, 1> SingularValuesType;$/;"	t	class:Eigen::SVD
SingularValuesType	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_diag_type<MatrixType, RealScalar>::type SingularValuesType;$/;"	t	class:Eigen::JacobiSVD
Size	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    Size = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_impl::__anon232
Size	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon353
Size	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon355
Size	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon356
Size	vcglib/vcg/space/box.h	/^	PointType Size() const$/;"	f	class:vcg::Box
Size	vcglib/wrap/gl/fbo.h	/^	GLsizei Size(const unsigned int i) const$/;"	f	class:Texture1D
Size	vcglib/wrap/gl/fbo.h	/^	GLsizei Size(const unsigned int i) const$/;"	f	class:Texture2D
Size	vcglib/wrap/gl/fbo.h	/^	GLsizei Size(const unsigned int i) const$/;"	f	class:Texture3D
Size	vcglib/wrap/math/sparse_matrix.h	/^virtual int Size(){return _dimension;}$/;"	f	class:SparseMatrix
Size	vcglib/wrap/math/system_interface_ldl.h	/^int Size(){return (_dimension);}$/;"	f	class:SystemLDL
SizeA	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeA = ActualRows * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon206
SizeAtCompileTime	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      SizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime)$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon46
SizeAtCompileTime	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon58
SizeAtCompileTime	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^      SizeAtCompileTime = Base::SizeAtCompileTime$/;"	e	enum:Eigen::MapBase::__anon175
SizeAtCompileTime	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
SizeAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^        SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SkylineMatrixBase::__anon451
SizeB	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeB = ActualCols * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon206
SizeMinusOne	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^      SizeMinusOne = SizeAtCompileTime==Dynamic ? Dynamic : SizeAtCompileTime-1$/;"	e	enum:Eigen::MatrixBase::__anon184
SizeMinusOne	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : Size - 1,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon353
SizeMinusOne	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : (Size > 1 ? Size - 1 : 1),$/;"	e	enum:Eigen::Tridiagonalization::__anon356
SizeNeigh	vcglib/vcg/simplex/face/component_ocf.h	/^  unsigned int SizeNeigh(){return 3;}$/;"	f	class:vcg::face::FFAdjOcf
SizeNeigh	vcglib/vcg/simplex/face/component_polygon.h	/^  unsigned int SizeNeigh(){ return this->VN();}$/;"	f	class:vcg::face::PVFAdj
SizeOf	vcglib/vcg/container/simple_temporary_data.h	/^    int SizeOf() const {return sizeof(ATTR_TYPE);}$/;"	f	class:vcg::SimpleTempData
SizeOf	vcglib/vcg/container/simple_temporary_data.h	/^    int SizeOf()const {return sizeof(ATTR_TYPE);}$/;"	f	class:vcg::Attribute
SizeW	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeW = MaxDepth * Traits::WorkSpaceFactor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon206
SizeX	vcglib/vcg/space/box.h	/^	inline S SizeX() const { return _max.X()-_min.X();}$/;"	f	class:vcg::Box
SizeY	vcglib/vcg/space/box.h	/^	inline S SizeY() const { return _max.Y()-_min.Y();}$/;"	f	class:vcg::Box
SizeZ	vcglib/vcg/space/box.h	/^	inline S SizeZ() const { static_assert(N>2); return _max.Z()-_min.Z();}$/;"	f	class:vcg::Box
SkipFirst	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    enum { SkipFirst = ((Mode&Lower) && !(MatrixType::Flags&RowMajorBit))$/;"	e	enum:Eigen::SparseTriangularView::__anon425
SkipLast	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^           SkipLast = !SkipFirst,$/;"	e	enum:Eigen::SparseTriangularView::__anon425
SkipScalarA	vcglib/wrap/ply/plylib.cpp	/^static inline int SkipScalarA( XFILE * fp, const int tf )$/;"	f	namespace:vcg::ply
SkipScalarB	vcglib/wrap/ply/plylib.cpp	/^static inline int SkipScalarB( XFILE * fp, const int tf)$/;"	f	namespace:vcg::ply
Skipline	vcglib/wrap/io_trimesh/import_raw.h	/^static void Skipline(FILE *fp)$/;"	f	class:vcg::tri::io::ImporterRAW
SkylineBit	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^const unsigned int SkylineBit = 0x1200;$/;"	m	namespace:Eigen
SkylineInplaceLU	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    SkylineInplaceLU(MatrixType& matrix, int flags = 0)$/;"	f	class:Eigen::SkylineInplaceLU
SkylineInplaceLU	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^class SkylineInplaceLU {$/;"	c	namespace:Eigen
SkylineMatrix	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline SkylineMatrix()$/;"	f	class:Eigen::SkylineMatrix
SkylineMatrix	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline SkylineMatrix(const SkylineMatrix & other)$/;"	f	class:Eigen::SkylineMatrix
SkylineMatrix	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline SkylineMatrix(const SkylineMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SkylineMatrix
SkylineMatrix	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline SkylineMatrix(size_t rows, size_t cols)$/;"	f	class:Eigen::SkylineMatrix
SkylineMatrix	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^class SkylineMatrix$/;"	c	namespace:Eigen
SkylineMatrixBase	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    SkylineMatrixBase() : m_isRValue(false) {$/;"	f	class:Eigen::SkylineMatrixBase
SkylineMatrixBase	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^template<typename Derived> class SkylineMatrixBase : public EigenBase<Derived> {$/;"	c	namespace:Eigen
SkylineProduct	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    EIGEN_STRONG_INLINE SkylineProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::internal::SkylineProduct
SkylineProduct	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^class SkylineProduct : no_assignment_operator,$/;"	c	namespace:Eigen::internal
SkylineProductReturnType	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^struct SkylineProductReturnType {$/;"	s	namespace:Eigen
SkylineStorage	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    SkylineStorage()$/;"	f	class:Eigen::SkylineStorage
SkylineStorage	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    SkylineStorage(const SkylineStorage& other)$/;"	f	class:Eigen::SkylineStorage
SkylineStorage	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^class SkylineStorage {$/;"	c	namespace:Eigen
SkylineTimeDenseProduct	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^enum AdditionalProductEvaluationMode {SkylineTimeDenseProduct, SkylineTimeSkylineProduct, DenseTimeSkylineProduct};$/;"	e	enum:Eigen::AdditionalProductEvaluationMode
SkylineTimeSkylineProduct	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^enum AdditionalProductEvaluationMode {SkylineTimeDenseProduct, SkylineTimeSkylineProduct, DenseTimeSkylineProduct};$/;"	e	enum:Eigen::AdditionalProductEvaluationMode
SliceSize	vcglib/vcg/complex/algorithms/create/resampler.h	/^		int SliceSize;$/;"	m	class:vcg::tri::Resampler::Walker
SliceVectorizedTraversal	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  SliceVectorizedTraversal,$/;"	e	enum:Eigen::__anon260
SlotNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^	SlotNode(void){node_type = SLOT_NODE;};$/;"	f	class:SlotNode
SlotNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^class SlotNode: public Node$/;"	c
SlotsNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^	SlotsNode(void){node_type = SLOTS_NODE;};$/;"	f	class:SlotsNode
SlotsNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^class SlotsNode: public Node$/;"	c
SluMatrix	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix()$/;"	f	struct:Eigen::SluMatrix
SluMatrix	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix
SluMatrix	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrix : SuperMatrix$/;"	s	namespace:Eigen
SluMatrixMapHelper	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<Matrix<Scalar,Rows,Cols,Options,MRows,MCols> >$/;"	s	namespace:Eigen
SluMatrixMapHelper	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<SparseMatrixBase<Derived> >$/;"	s	namespace:Eigen
Small	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  Small = 3$/;"	e	enum:Eigen::__anon140
SmallPanelWidth	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = 2 * EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon216
SmallPanelWidth	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon217
SmallestEnclosing	vcglib/vcg/space/smallest_enclosing.h	/^struct SmallestEnclosing {$/;"	s	namespace:vcg
Smooth	vcglib/vcg/complex/algorithms/smooth.h	/^class Smooth$/;"	c	namespace:vcg::tri
SmoothTextureCoords	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^void SmoothTextureCoords(MESH_TYPE &m){$/;"	f	namespace:vcg::tri
SmoothVisibility	vcglib/apps/unsupported/shadevis/visshader.h	/^void SmoothVisibility(bool Enhance=false)$/;"	f	class:vcg::VertexVisShader
SolidAngle	vcglib/vcg/space/tetra3.h	/^double SolidAngle(int vind)$/;"	f	class:vcg::Tetra3
Solve	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    bool Solve()$/;"	f	class:vcg::tri::PoissonSolver
Solve	vcglib/wrap/math/system_interface_ldl.h	/^void Solve()$/;"	f	class:SystemLDL
SolvePoisson	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    bool SolvePoisson(bool _write_messages=false,$/;"	f	class:vcg::tri::PoissonSolver
SolvePoisson	vcglib/wrap/miq/core/poisson_solver.h	/^    void SolvePoisson(ScalarType vector_field_scale=0.1f,$/;"	f	class:PoissonSolver
Son	vcglib/vcg/space/index/octree_template.h	/^		inline NodePointer &Son(int \/*sonIndex*\/)$/;"	f	struct:vcg::OctreeTemplate::Leaf
Son	vcglib/vcg/space/index/octree_template.h	/^		inline NodePointer &Son(int sonIndex)$/;"	f	struct:vcg::OctreeTemplate::InnerNode
Son	vcglib/vcg/space/index/octree_template.h	/^	inline NodePointer&	Son(NodePointer n, int i)		const	{ return n->Son(i);					}$/;"	f	class:vcg::OctreeTemplate
Sons	vcglib/apps/trimeshinfo/Node.h	/^	list<Node *> Sons;$/;"	m	class:NodeGroup
Sort	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  void Sort() {if(V(0)<V(0)) std::swap(V(0),V(0)); }$/;"	f	class:vcg::tri::BasicVertexPair
Sort	vcglib/vcg/math/base.h	/^	template<class T> inline void Sort(T &a, T &b){$/;"	f	namespace:vcg::math
Sort	vcglib/vcg/math/base.h	/^	template<class T> inline void Sort(T &a, T &b, T &c){$/;"	f	namespace:vcg::math
Sort	vcglib/vcg/math/old_lin_algebra.h	/^	void Sort(MATRIX_TYPE &U, typename MATRIX_TYPE::ScalarType W[], MATRIX_TYPE &V, const SortingStrategy sorting)$/;"	f	namespace:vcg
SortAscending	vcglib/vcg/math/old_lin_algebra.h	/^	enum SortingStrategy {LeaveUnsorted=0, SortAscending=1, SortDescending=2};$/;"	e	enum:vcg::SortingStrategy
SortDescending	vcglib/vcg/math/old_lin_algebra.h	/^	enum SortingStrategy {LeaveUnsorted=0, SortAscending=1, SortDescending=2};$/;"	e	enum:vcg::SortingStrategy
SortEigenvaluesAndEigenvectors	vcglib/vcg/math/old_lin_algebra.h	/^	void SortEigenvaluesAndEigenvectors(POINT_TYPE &eigenvalues, MATRIX_TYPE &eigenvectors, bool absComparison = false)$/;"	f	namespace:vcg
SortedPair	vcglib/vcg/complex/algorithms/clean.h	/^                       SortedPair(unsigned int v0, unsigned int v1, EdgePointer _fp)$/;"	f	class:vcg::tri::Clean::SortedPair
SortedPair	vcglib/vcg/complex/algorithms/clean.h	/^                   SortedPair() {}$/;"	f	class:vcg::tri::Clean::SortedPair
SortedPair	vcglib/vcg/complex/algorithms/clean.h	/^            class SortedPair$/;"	c	class:vcg::tri::Clean
SortedPlanes	vcglib/vcg/complex/algorithms/symmetry.h	/^    std::vector<std::pair<ScalarType,int> > SortedPlanes;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
SortedTriple	vcglib/vcg/complex/algorithms/clean.h	/^                 SortedTriple(unsigned int v0, unsigned int v1, unsigned int v2,FacePointer _fp)$/;"	f	class:vcg::tri::Clean::SortedTriple
SortedTriple	vcglib/vcg/complex/algorithms/clean.h	/^             SortedTriple() {}$/;"	f	class:vcg::tri::Clean::SortedTriple
SortedTriple	vcglib/vcg/complex/algorithms/clean.h	/^      class SortedTriple$/;"	c	class:vcg::tri::Clean
SortingStrategy	vcglib/vcg/math/old_lin_algebra.h	/^	enum SortingStrategy {LeaveUnsorted=0, SortAscending=1, SortDescending=2};$/;"	g	namespace:vcg
SourceTag	vcglib/wrap/dae/colladaformat.h	/^		SourceTag(const QString& id,const QString& name)$/;"	f	class:Collada::Tags::SourceTag
SourceTag	vcglib/wrap/dae/colladaformat.h	/^		SourceTag(const QString& source)$/;"	f	class:Collada::Tags::SourceTag
SourceTag	vcglib/wrap/dae/colladaformat.h	/^	class SourceTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
Space	vcglib/vcg/space/space.h	/^class Space {$/;"	c	namespace:vcg
Span	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^  DenseIndex Spline<_Scalar, _Dim, _Degree>::Span($/;"	f	class:Eigen::Spline
SparseBase	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    typedef SparseMatrixBase<SparseVector> SparseBase;$/;"	t	class:Eigen::SparseVector
SparseDenseOuterProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDenseOuterProduct
SparseDenseOuterProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Rhs& rhs, const Lhs& lhs)$/;"	f	class:Eigen::SparseDenseOuterProduct
SparseDenseOuterProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct$/;"	c	namespace:Eigen
SparseDenseProductReturnType	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct SparseDenseProductReturnType$/;"	s	namespace:Eigen
SparseDenseProductReturnType	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct SparseDenseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
SparseDiagonalProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE SparseDiagonalProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDiagonalProduct
SparseDiagonalProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^class SparseDiagonalProduct$/;"	c	namespace:Eigen
SparseFlags	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    SparseFlags = is_diagonal<_Lhs>::ret ? int(_Rhs::Flags) : int(_Lhs::Flags),$/;"	e	enum:Eigen::internal::traits::__anon414
SparseInnerVectorSet	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet(const MatrixType& matrix, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet
SparseInnerVectorSet	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet(const MatrixType& matrix, Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseInnerVectorSet
SparseInnerVectorSet	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^class SparseInnerVectorSet : internal::no_assignment_operator,$/;"	c	namespace:Eigen
SparseInnerVectorSet	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^class SparseInnerVectorSet<SparseMatrix<_Scalar, _Options, _Index>, Size>$/;"	c	namespace:Eigen
SparseInnerVectorSet	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    inline SparseInnerVectorSet(const MatrixType& matrix, Index outer)$/;"	f	class:Eigen::SparseInnerVectorSet
SparseInnerVectorSet	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    inline SparseInnerVectorSet(const MatrixType& matrix, Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseInnerVectorSet
SparseInnerVectorSet	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^class SparseInnerVectorSet<DynamicSparseMatrix<_Scalar, _Options, _Index>, Size>$/;"	c	namespace:Eigen
SparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    SparseMatrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix()$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix$/;"	c	namespace:Eigen
SparseMatrix	vcglib/wrap/math/sparse_matrix.h	/^class SparseMatrix{$/;"	c
SparseMatrixBase	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseMatrixBase() : m_isRValue(false) { \/* TODO check flags *\/ }$/;"	f	class:Eigen::SparseMatrixBase
SparseMatrixBase	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^template<typename Derived> class SparseMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
SparseMatrixData	vcglib/wrap/miq/core/sparsesystemdata.h	/^  SparseMatrixData(): m_nrows(0), m_ncols(0), m_nentries(0), m_reserved_entries(0), m_rowind(0), m_colind(0), m_vals(0),$/;"	f	class:SparseMatrixData
SparseMatrixData	vcglib/wrap/miq/core/sparsesystemdata.h	/^class SparseMatrixData{ $/;"	c
SparseMatrixType	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef SparseMatrix<Scalar,RowMajor,Index> SparseMatrixType;$/;"	t	class:Eigen::PardisoImpl
SparseSelfAdjointTimeDenseProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct
SparseSelfAdjointTimeDenseProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class SparseSelfAdjointTimeDenseProduct$/;"	c	namespace:Eigen
SparseSelfAdjointView	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline SparseSelfAdjointView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SparseSelfAdjointView
SparseSelfAdjointView	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SparseSelfAdjointView$/;"	c	namespace:Eigen
SparseSparseProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseSparseProduct
SparseSparseProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs, RealScalar tolerance)$/;"	f	class:Eigen::SparseSparseProduct
SparseSparseProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^class SparseSparseProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen
SparseSparseProductReturnType	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^struct SparseSparseProductReturnType$/;"	s	namespace:Eigen
SparseSymmetricPermutationProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct(const MatrixType& mat, const Perm& perm)$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
SparseSymmetricPermutationProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class SparseSymmetricPermutationProduct$/;"	c	namespace:Eigen
SparseSystemData	vcglib/wrap/miq/core/sparsesystemdata.h	/^  SparseSystemData(): m_A(), m_b(NULL), m_x(NULL){ }$/;"	f	class:SparseSystemData
SparseSystemData	vcglib/wrap/miq/core/sparsesystemdata.h	/^class SparseSystemData { $/;"	c
SparseTimeDenseProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    SparseTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseTimeDenseProduct
SparseTimeDenseProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseTimeDenseProduct$/;"	c	namespace:Eigen
SparseTriangularView	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline SparseTriangularView(const MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::SparseTriangularView
SparseTriangularView	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^template<typename MatrixType, int Mode> class SparseTriangularView$/;"	c	namespace:Eigen
SparseVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector() : m_size(0) { resize(0); }$/;"	f	class:Eigen::SparseVector
SparseVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(Index rows, Index cols) : m_size(0) { resize(rows,cols); }$/;"	f	class:Eigen::SparseVector
SparseVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(Index size) : m_size(0) { resize(size); }$/;"	f	class:Eigen::SparseVector
SparseVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector
SparseVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseVector& other)$/;"	f	class:Eigen::SparseVector
SparseVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^class SparseVector$/;"	c	namespace:Eigen
SparseView	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  SparseView(const MatrixType& mat, const Scalar& m_reference = Scalar(0),$/;"	f	class:Eigen::SparseView
SparseView	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^class SparseView : public SparseMatrixBase<SparseView<MatrixType> >$/;"	c	namespace:Eigen
SpatialHashTable	vcglib/vcg/space/index/spatial_hashing.h	/^	class SpatialHashTable:public BasicGrid<FLT>, public SpatialIndex<ObjType,FLT>$/;"	c	namespace:vcg
SpatialHashTable2D	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^    class SpatialHashTable2D:public BasicGrid2D<FLT>, public SpatialIndex2D<ObjType,FLT>$/;"	c	namespace:vcg
SpatialHashType	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        typedef SpatialHashTable2D SpatialHashType;$/;"	t	class:vcg::SpatialHashTable2D
SpatialHashType	vcglib/vcg/space/index/spatial_hashing.h	/^	typedef SpatialHashTable SpatialHashType;$/;"	t	class:vcg::SpatialHashTable
SpatialIndex	vcglib/vcg/space/index/base.h	/^class SpatialIndex {$/;"	c	namespace:vcg
SpatialIndex2D	vcglib/vcg/space/index/index2D/base_2d.h	/^class SpatialIndex2D {$/;"	c	namespace:vcg
Specialized	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Specialized,$/;"	e	enum:Eigen::__anon262
SpecularTag	vcglib/wrap/dae/colladaformat.h	/^		SpecularTag()$/;"	f	class:Collada::Tags::SpecularTag
SpecularTag	vcglib/wrap/dae/colladaformat.h	/^	class SpecularTag : public XMLTag$/;"	c	namespace:Collada::Tags
Sph	vcglib/vcg/simplex/vertex/component_sph.h	/^template <class A, class T> class Sph: public T$/;"	c	namespace:vcg::vertex
Sph16d	vcglib/vcg/simplex/vertex/component_sph.h	/^template <class T> class Sph16d: public Sph<vcg::math::SphericalHarmonics<double, 4>, T> {$/;"	c	namespace:vcg::vertex
Sph16f	vcglib/vcg/simplex/vertex/component_sph.h	/^template <class T> class Sph16f: public Sph<vcg::math::SphericalHarmonics<float, 4>, T> {$/;"	c	namespace:vcg::vertex
Sph25d	vcglib/vcg/simplex/vertex/component_sph.h	/^template <class T> class Sph25d: public Sph<vcg::math::SphericalHarmonics<double, 5>, T> {$/;"	c	namespace:vcg::vertex
Sph25f	vcglib/vcg/simplex/vertex/component_sph.h	/^template <class T> class Sph25f: public Sph<vcg::math::SphericalHarmonics<float, 5>, T> {$/;"	c	namespace:vcg::vertex
Sph36d	vcglib/vcg/simplex/vertex/component_sph.h	/^template <class T> class Sph36d: public Sph<vcg::math::SphericalHarmonics<double, 6>, T> {$/;"	c	namespace:vcg::vertex
Sph36f	vcglib/vcg/simplex/vertex/component_sph.h	/^template <class T> class Sph36f: public Sph<vcg::math::SphericalHarmonics<float, 6>, T> {$/;"	c	namespace:vcg::vertex
Sph49f	vcglib/vcg/simplex/vertex/component_sph.h	/^template <class T> class Sph49f: public Sph<vcg::math::SphericalHarmonics<float, 7>, T> {$/;"	c	namespace:vcg::vertex
Sph9d	vcglib/vcg/simplex/vertex/component_sph.h	/^template <class T> class Sph9d: public Sph<vcg::math::SphericalHarmonics<double, 3>, T> {$/;"	c	namespace:vcg::vertex
Sph9f	vcglib/vcg/simplex/vertex/component_sph.h	/^template <class T> class Sph9f: public Sph<vcg::math::SphericalHarmonics<float, 3>, T> {$/;"	c	namespace:vcg::vertex
SphType	vcglib/vcg/simplex/vertex/component_sph.h	/^	typedef A SphType;$/;"	t	class:vcg::vertex::Sph
Sphere	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Sphere(MeshType &in, const int subdiv = 3 )$/;"	f	namespace:vcg::tri
Sphere3	vcglib/vcg/space/sphere3.h	/^  Sphere3(): _radius(-1) {}$/;"	f	class:vcg::Sphere3
Sphere3	vcglib/vcg/space/sphere3.h	/^  Sphere3(const Point3<T> &center, T radius): _center(center), _radius(radius) {}$/;"	f	class:vcg::Sphere3
Sphere3	vcglib/vcg/space/sphere3.h	/^template <class T> class Sphere3 {$/;"	c	namespace:vcg
Sphere3d	vcglib/vcg/space/sphere3.h	/^typedef Sphere3<double> Sphere3d;$/;"	t	namespace:vcg
Sphere3f	vcglib/vcg/space/sphere3.h	/^typedef Sphere3<float> Sphere3f;$/;"	t	namespace:vcg
SphereDifference	vcglib/apps/unsupported/extractors/extractor/SphereDifference.h	/^	SphereDifference( const SphereDifference &sphere_difference)$/;"	f	class:SphereDifference
SphereDifference	vcglib/apps/unsupported/extractors/extractor/SphereDifference.h	/^	SphereDifference( const SphereUnion &sphere_union,  const ImplicitSphere &sphere)$/;"	f	class:SphereDifference
SphereDifference	vcglib/apps/unsupported/extractors/extractor/SphereDifference.h	/^	SphereDifference() $/;"	f	class:SphereDifference
SphereDifference	vcglib/apps/unsupported/extractors/extractor/SphereDifference.h	/^class SphereDifference$/;"	c
SphereMode	vcglib/wrap/gui/trackmode.h	/^class SphereMode:public TrackMode {$/;"	c	namespace:vcg
SphereOfSpheres	vcglib/vcg/space/smallest_enclosing.h	/^SphereOfSpheres(  const   SphereType  & s0, const  SphereType  & s1)$/;"	f	class:vcg::SmallestEnclosing
SphereOfSpheres	vcglib/vcg/space/smallest_enclosing.h	/^SphereOfSpheres(  const SphereContType & spheres)$/;"	f	class:vcg::SmallestEnclosing
SphereOfTetra	vcglib/vcg/space/smallest_enclosing.h	/^SmallestEnclosing::SphereOfTetra(const TetraType & t){$/;"	f	class:vcg::SmallestEnclosing
SphereOfTriangle	vcglib/vcg/space/smallest_enclosing.h	/^SmallestEnclosing::SphereOfTriangle(const TriangleType & t){$/;"	f	class:vcg::SmallestEnclosing
SpherePointDistance	vcglib/vcg/space/distance3.h	/^void SpherePointDistance(const Sphere3<ScalarType> &sphere, $/;"	f	namespace:vcg
SphereSphereDistance	vcglib/vcg/space/distance3.h	/^void SphereSphereDistance(const Sphere3<ScalarType> &sphere0, $/;"	f	namespace:vcg
SphereUnion	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^	SphereUnion()$/;"	f	class:SphereUnion
SphereUnion	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^	SphereUnion(const ImplicitSphere &sphere1, const ImplicitSphere &sphere2)$/;"	f	class:SphereUnion
SphereUnion	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^	SphereUnion(const SphereUnion &sphere_union)$/;"	f	class:SphereUnion
SphereUnion	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^class SphereUnion$/;"	c
SphericalHarmonics	vcglib/vcg/math/spherical_harmonics.h	/^class SphericalHarmonics{$/;"	c	namespace:vcg::math
SplatRenderer	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^class SplatRenderer $/;"	c
Spline	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    Spline(const OtherVectorType& knots, const OtherArrayType& ctrls) : m_knots(knots), m_ctrls(ctrls) {}$/;"	f	class:Eigen::Spline
Spline	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    Spline(const Spline<Scalar, Dimension, OtherDegree>& spline) : $/;"	f	class:Eigen::Spline
Spline	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^  class Spline$/;"	c	namespace:Eigen
Spline2d	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^    typedef Spline<double,2> Spline2d;$/;"	t	namespace:Eigen
Spline2f	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^    typedef Spline<float,2> Spline2f;$/;"	t	namespace:Eigen
Spline3d	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^    typedef Spline<double,3> Spline3d;$/;"	t	namespace:Eigen
Spline3f	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^    typedef Spline<float,3> Spline3f;$/;"	t	namespace:Eigen
SplineFitting	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFitting.h	/^  struct SplineFitting$/;"	s	namespace:Eigen
SplineTraits	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^    struct SplineTraits< Spline<_Scalar, _Dim, _Degree>, Dynamic >$/;"	s	namespace:Eigen
SplineTraits	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^    struct SplineTraits< Spline<_Scalar, _Dim, _Degree>, _DerivativeOrder > : public SplineTraits< Spline<_Scalar, _Dim, _Degree> >$/;"	s	namespace:Eigen
SplineTraits	vcglib/eigenlib/unsupported/Eigen/src/Splines/SplineFwd.h	/^    template < typename SplineType, int DerivativeOrder = Dynamic > struct SplineTraits {};$/;"	s	namespace:Eigen
Split	vcglib/vcg/complex/algorithms/refine.h	/^class Split {$/;"	c	namespace:vcg::tri
SplitMesh	vcglib/apps/sample/trimesh_edge/trimesh_edge.cpp	/^bool SplitMesh(MyMesh &m,             \/\/\/ The mesh that has to be splitted. It is NOT changed$/;"	f
SplitMidPoint	vcglib/wrap/miq/quadrangulator.h	/^        SplitMidPoint(){alpha=-1;}$/;"	f	struct:Quadrangulator::SplitMidPoint
SplitMidPoint	vcglib/wrap/miq/quadrangulator.h	/^    struct SplitMidPoint : public   std::unary_function<vcg::face::Pos<typename MESH_TYPE::FaceType> ,  typename MESH_TYPE::CoordType >$/;"	s	class:Quadrangulator
SplitNonFlatQuads	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static int SplitNonFlatQuads(MeshType &m, ScalarType deg=0){$/;"	f	class:vcg::tri::BitQuadCreation
SplitNonManifoldVertex	vcglib/vcg/complex/algorithms/clean.h	/^      static int SplitNonManifoldVertex(MeshType& m, ScalarType moveThreshold)$/;"	f	class:vcg::tri::Clean
SplitNum	vcglib/apps/unsupported/shadevis/visshader.h	/^	 int SplitNum;$/;"	m	class:vcg::VisShader
SplitPolychord	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  static void SplitPolychord (PolyMeshType &mesh, const vcg::face::Pos<FaceType> &pos, const size_t n,$/;"	f	class:vcg::tri::PolychordCollapse
SplitTab	vcglib/vcg/complex/algorithms/refine.h	/^const Split SplitTab[8]={$/;"	m	namespace:vcg::tri
SplitToken	vcglib/wrap/io_trimesh/import_obj.h	/^                inline static void SplitToken(const std::string & token, int & vId, int & nId, int & tId, int mask)$/;"	f	class:vcg::tri::io::ImporterOBJ
SplitTris	vcglib/wrap/miq/quadrangulator.h	/^    void SplitTris(TriMesh &to_split,$/;"	f	class:Quadrangulator
SplitVertex	vcglib/vcg/complex/algorithms/attribute_seam.h	/^        static inline bool SplitVertex(const src_trimesh_t & src, dst_trimesh_t & dst, extract_wedge_attribs_t & v_extract, compare_vertex_attribs_t & v_compare, copy_vertex_t & v_copy)$/;"	f	class:vcg::tri::AttributeSeam
SplitVertex	vcglib/vcg/complex/algorithms/attribute_seam.h	/^        static inline bool SplitVertex(src_trimesh_t & src, extract_wedge_attribs_t v_extract, compare_vertex_attribs_t & v_compare)$/;"	f	class:vcg::tri::AttributeSeam
SplittedRendering	vcglib/apps/unsupported/shadevis/visshader.h	/^int SplittedRendering(Point3x &ViewDir, std::vector<int> &PixSeen, CallBack *cb=DummyCallBack)$/;"	f	class:vcg::VisShader
Sqr	vcglib/vcg/math/base.h	/^    template <typename T> inline static T Sqr(T a) { return a*a; }$/;"	f	namespace:vcg::math
Sqrt	vcglib/vcg/math/base.h	/^  inline double Sqrt(const double v)   { return sqrt(v); }$/;"	f	namespace:vcg::math
Sqrt	vcglib/vcg/math/base.h	/^  inline float Sqrt(const float v)   { return sqrtf(v); }$/;"	f	namespace:vcg::math
Sqrt	vcglib/vcg/math/base.h	/^  inline float Sqrt(const int v)   { return sqrtf((float)v); }$/;"	f	namespace:vcg::math
Sqrt	vcglib/vcg/math/base.h	/^  inline float Sqrt(const short v)   { return sqrtf(v); }$/;"	f	namespace:vcg::math
Square	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Square(MeshType &in)$/;"	f	namespace:vcg::tri
SquareMatrixType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::MatrixBase
SquareMatrixType	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::SparseMatrixBase
SquareMatrixType	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^                           EIGEN_SIZE_MAX(RowsAtCompileTime, ColsAtCompileTime) > SquareMatrixType;$/;"	t	class:Eigen::SkylineMatrixBase
SquaredDiag	vcglib/vcg/space/box.h	/^	S SquaredDiag() const$/;"	f	class:vcg::Box
SquaredDiag	vcglib/vcg/space/box3.h	/^    BoxScalarType SquaredDiag() const$/;"	f	class:vcg::Box3
SquaredDistance	vcglib/vcg/math/eigen.h	/^SquaredDistance(const Eigen::MatrixBase<Derived1>& p1, const Eigen::MatrixBase<Derived2> & p2)$/;"	f	namespace:vcg
SquaredDistance	vcglib/vcg/space/deprecated_point.h	/^inline S SquaredDistance( Point<N,S> const & p1,Point<N,S> const & p2 )$/;"	f	namespace:vcg::ndim
SquaredDistance	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType SquaredDistance( Point2 const & p ) const$/;"	f	class:vcg::Point2
SquaredDistance	vcglib/vcg/space/deprecated_point2.h	/^inline T SquaredDistance( Point2<T> const & p1,Point2<T> const & p2 ){$/;"	f	namespace:vcg
SquaredDistance	vcglib/vcg/space/deprecated_point3.h	/^inline P3ScalarType SquaredDistance( Point3<P3ScalarType> const & p1,Point3<P3ScalarType> const & p2 )$/;"	f	namespace:vcg
SquaredDistance	vcglib/vcg/space/deprecated_point4.h	/^inline T SquaredDistance( const Point4<T> & p1, const Point4<T> & p2 )$/;"	f	namespace:vcg
SquaredLength	vcglib/vcg/space/segment2.h	/^	ScalarType SquaredLength()$/;"	f	class:vcg::Segment2
SquaredLength	vcglib/vcg/space/segment3.h	/^	ScalarType SquaredLength() const$/;"	f	class:vcg::Segment3
SquaredNorm	vcglib/vcg/math/eigen.h	/^inline typename Eigen::ei_traits<Derived1>::Scalar SquaredNorm( const Eigen::MatrixBase<Derived1>& p)$/;"	f	namespace:vcg
SquaredNorm	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar SquaredNorm() const { return squaredNorm(); };$/;"	f
SquaredNorm	vcglib/vcg/space/deprecated_point.h	/^	inline S SquaredNorm() const {$/;"	f	class:vcg::ndim::Point2
SquaredNorm	vcglib/vcg/space/deprecated_point.h	/^	inline S SquaredNorm() const {$/;"	f	class:vcg::ndim::Point3
SquaredNorm	vcglib/vcg/space/deprecated_point.h	/^	inline S SquaredNorm() const {$/;"	f	class:vcg::ndim::Point4
SquaredNorm	vcglib/vcg/space/deprecated_point.h	/^	template <class PT> static S SquaredNorm(const PT &p ) {$/;"	f	class:vcg::ndim::Point2
SquaredNorm	vcglib/vcg/space/deprecated_point.h	/^	template <class PT> static S SquaredNorm(const PT &p ) {$/;"	f	class:vcg::ndim::Point3
SquaredNorm	vcglib/vcg/space/deprecated_point.h	/^	template <class PT> static S SquaredNorm(const PT &p ) {$/;"	f	class:vcg::ndim::Point4
SquaredNorm	vcglib/vcg/space/deprecated_point.h	/^inline S SquaredNorm( Point<N,S> const & p )$/;"	f	namespace:vcg::ndim
SquaredNorm	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType SquaredNorm( void ) const$/;"	f	class:vcg::Point2
SquaredNorm	vcglib/vcg/space/deprecated_point2.h	/^inline T SquaredNorm( Point2<T> const & p ){$/;"	f	namespace:vcg
SquaredNorm	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType SquaredNorm() const$/;"	f	class:vcg::Point3
SquaredNorm	vcglib/vcg/space/deprecated_point3.h	/^inline P3ScalarType SquaredNorm( Point3<P3ScalarType> const & p )$/;"	f	namespace:vcg
SquaredNorm	vcglib/vcg/space/deprecated_point4.h	/^    inline T SquaredNorm() const$/;"	f	class:vcg::Point4
SquaredNorm	vcglib/vcg/space/deprecated_point4.h	/^inline T SquaredNorm( const Point4<T> & p )$/;"	f	namespace:vcg
SrcFace	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^class SrcFace : public vcg::Face$/;"	c	file:
SrcHasDirectAccess	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      SrcHasDirectAccess = Src::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
SrcIsAligned	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    SrcIsAligned = OtherDerived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon34
SrcMesh	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^class SrcMesh : public vcg::tri::TriMesh  <vcg::vertex::vector_ocf<SrcVertex>, vcg::face::vector_ocf<SrcFace> > { };$/;"	c	file:
SrcStorageOrder	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^      SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon422
SrcStorageOrder	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon421
SrcVertex	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^class SrcVertex : public vcg::Vertex$/;"	c	file:
StableDot	vcglib/vcg/space/deprecated_point.h	/^	inline S StableDot ( const PointType & p ) const {$/;"	f	class:vcg::ndim::Point2
StableDot	vcglib/vcg/space/deprecated_point.h	/^	inline S StableDot ( const PointType & p ) const {$/;"	f	class:vcg::ndim::Point3
StableDot	vcglib/vcg/space/deprecated_point.h	/^	inline S StableDot ( const PointType & p ) const {$/;"	f	class:vcg::ndim::Point4
StableDot	vcglib/vcg/space/deprecated_point4.h	/^	T StableDot ( const Point4<T> & p ) const$/;"	f	class:vcg::Point4
StableDot	vcglib/vcg/space/deprecated_point4.h	/^double StableDot ( Point4<T> const & p0, Point4<T> const & p1 )$/;"	f	namespace:vcg
StableDot	vcglib/vcg/space/point4.h	/^	T StableDot ( const Point4<T> & p ) const$/;"	f	class:vcg::Point4
StableDot	vcglib/vcg/space/point4.h	/^double StableDot ( Point4<T> const & p0, Point4<T> const & p1 )$/;"	f	namespace:vcg
StandardDeviation	vcglib/vcg/math/histogram.h	/^	ScalarType StandardDeviation(){ DirtyCheck(); return sqrt( Variance() );}$/;"	f	class:vcg::Distribution
StandardDeviation	vcglib/vcg/math/histogram.h	/^	ScalarType StandardDeviation(){ return sqrt(Variance());}$/;"	f	class:vcg::Histogram
Start	vcglib/vcg/container/entries_allocation_table.h	/^ typename STL_CONT::value_type  * EntryCATBase<STL_CONT>::Start()const {$/;"	f	class:vcg::EntryCATBase
StartPlaying	vcglib/wrap/gui/trackrecorder.h	/^	void StartPlaying(char * namefile){$/;"	f	struct:vcg::TrackRecorder
StartRecording	vcglib/wrap/gui/trackrecorder.h	/^	void  StartRecording(char * namefile){$/;"	f	struct:vcg::TrackRecorder
Stat	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^   struct Stat$/;"	s	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam
Stat	vcglib/vcg/complex/algorithms/point_sampling.h	/^  struct Stat$/;"	s	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
Stat	vcglib/vcg/complex/algorithms/stat.h	/^class Stat$/;"	c	namespace:vcg::tri
Stat	vcglib/vcg/space/rect_packer.h	/^  class Stat$/;"	c	class:vcg::RectPacker
StaticGrid	vcglib/apps/pivoting/pivot.h	/^    typedef GridStaticPtr<typename MESH::VertexType, typename MESH::ScalarType > StaticGrid;$/;"	t	class:vcg::tri::Pivot
Status	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    enum Status {$/;"	g	namespace:Eigen::HybridNonLinearSolverSpace
Status	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    enum Status {$/;"	g	namespace:Eigen::LevenbergMarquardtSpace
Status	vcglib/wrap/gcache/token.h	/^    enum Status { LOCKED = 1, READY = 0, CACHE = -1, REMOVE = -2, OUTSIDE = -3 };$/;"	g	class:vcg::Token
StdMapTraits	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^template<typename Scalar> struct StdMapTraits$/;"	s	namespace:Eigen
StdStemFunctions	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^class StdStemFunctions$/;"	c	namespace:Eigen
StdUnorderedMapTraits	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^template<typename Scalar> struct StdUnorderedMapTraits$/;"	s	namespace:Eigen
StdVectorContainer	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^enum { StdVectorContainer, EigenVectorContainer };$/;"	e	enum:__anon473	file:
StemFunction	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixBase
StemFunction	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixFunctionReturnValue
StemFunction	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixFunctionAtomic
StencilRenderBuffer	vcglib/wrap/gl/fbo.h	/^	StencilRenderBuffer(void) : StencilRenderTarget(), BufferRenderTarget()$/;"	f	class:StencilRenderBuffer
StencilRenderBuffer	vcglib/wrap/gl/fbo.h	/^class StencilRenderBuffer : public virtual StencilRenderTarget, public virtual BufferRenderTarget$/;"	c
StencilRenderTarget	vcglib/wrap/gl/fbo.h	/^	StencilRenderTarget(void) : RenderTarget()$/;"	f	class:StencilRenderTarget
StencilRenderTarget	vcglib/wrap/gl/fbo.h	/^class StencilRenderTarget : public virtual RenderTarget$/;"	c
StencilRenderTexture	vcglib/wrap/gl/fbo.h	/^	StencilRenderTexture(Texture2D * tex) : StencilRenderTarget(), TextureRenderTarget()$/;"	f	class:StencilRenderTexture
StencilRenderTexture	vcglib/wrap/gl/fbo.h	/^	StencilRenderTexture(void) : StencilRenderTarget(), TextureRenderTarget()$/;"	f	class:StencilRenderTexture
StencilRenderTexture	vcglib/wrap/gl/fbo.h	/^class StencilRenderTexture : public virtual StencilRenderTarget, public virtual TextureRenderTarget$/;"	c
StencilTexture	vcglib/wrap/gl/fbo.h	/^	StencilTexture(void) : Texture()$/;"	f	class:StencilTexture
StencilTexture	vcglib/wrap/gl/fbo.h	/^class StencilTexture : public virtual Texture$/;"	c
StencilTexture2D	vcglib/wrap/gl/fbo.h	/^	StencilTexture2D(void) : StencilTexture(), Texture2D()$/;"	f	class:StencilTexture2D
StencilTexture2D	vcglib/wrap/gl/fbo.h	/^class StencilTexture2D : public virtual StencilTexture, public virtual Texture2D$/;"	c
StiffMode	vcglib/wrap/miq/MIQ.h	/^  enum StiffMode{NO_STIFF = 0,GAUSSIAN = 1,ITERATIVE = 2};$/;"	g	class:MIQ_parametrization
StiffeningInitializer	vcglib/wrap/miq/core/stiffening.h	/^class StiffeningInitializer$/;"	c
Stop	vcglib/wrap/gui/trackrecorder.h	/^	void  Stop(){mode = OFF; trackfile = NULL;};$/;"	f	struct:vcg::TrackRecorder
StopSpinning	vcglib/wrap/gui/trackball.cpp	/^void Trackball::StopSpinning(){}$/;"	f	class:Trackball
Storage	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef internal::CompressedStorage<Scalar,Index> Storage;$/;"	t	class:Eigen::SparseMatrix
StorageBaseType	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase StorageBaseType;$/;"	t	class:Eigen::ArrayBase
StorageBaseType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef MatrixBase StorageBaseType;$/;"	t	class:Eigen::MatrixBase
StorageBaseType	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrixBase StorageBaseType;$/;"	t	class:Eigen::SparseMatrixBase
StorageKind	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::ArrayBase
StorageKind	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseBase
StorageKind	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseCoeffsBase
StorageKind	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalBase
StorageKind	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalMatrix
StorageKind	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	struct:Eigen::EigenBase
StorageKind	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MapBase
StorageKind	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MatrixBase
StorageKind	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^  typedef PermutationStorage StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::PlainObjectBase
StorageKind	vcglib/eigenlib/Eigen/src/Core/Product.h	/^                                        typename traits<RhsCleaned>::StorageKind>::ret StorageKind;$/;"	t	struct:internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^  typedef typename traits<NestedProduct>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/Select.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularBase
StorageKind	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularView
StorageKind	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^                                           typename traits<_RhsNested>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::FullPivLU
StorageKind	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::PartialPivLU
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::SparseMatrixBase
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::SkylineMatrixBase
StorageKind	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageOrdersAgree	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    StorageOrdersAgree = (int(Derived::IsRowMajor) == int(OtherDerived::IsRowMajor)),$/;"	e	enum:Eigen::internal::assign_traits::__anon36
StorageOrdersAgree	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      StorageOrdersAgree = (int(Dst::IsRowMajor) == int(Src::IsRowMajor)),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
StorageOrdersAgree	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    StorageOrdersAgree = (int(Lhs::Flags)&RowMajorBit)==(int(Rhs::Flags)&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon54
StorageOrdersMatch	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon385
StorageOrdersMatch	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon386
StorageType	vcglib/wrap/gl/fbo.h	/^	RTStorageType StorageType(void) const$/;"	f	class:BufferRenderTarget
StorageType	vcglib/wrap/gl/fbo.h	/^	RTStorageType StorageType(void) const$/;"	f	class:TextureRenderTarget
StoreInt	vcglib/wrap/ply/plylib.cpp	/^static inline void StoreInt( void * mem, const int tm, const int val )$/;"	f	namespace:vcg::ply
StraightFace	vcglib/apps/sample/trimesh_pos_demo/mesh_type.h	/^class StraightFace: public vcg::FaceSimp2< StraightVertex, DummyEdge, StraightFace,  vcg::	face::VertexRef,  vcg::	face::FFAdj,  vcg::	face::VFAdj,vcg::	face::Normal3f,vcg::face::BitFlags > {};$/;"	c
StraightVertex	vcglib/apps/sample/trimesh_pos_demo/mesh_type.h	/^class StraightVertex: public vcg::VertexSimp2< StraightVertex, DummyEdge, StraightFace, vcg::vert::Coord3f,vcg::vert::VFAdj,vcg::vert::Normal3f,vcg::vert::BitFlags>{};$/;"	c
StratifiedMontecarlo	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void StratifiedMontecarlo(MetroMesh & m, VertexSampler &ps,int sampleNum)$/;"	f	class:vcg::tri::SurfaceSampling
StreamPrecision	vcglib/eigenlib/Eigen/src/Core/IO.h	/^enum { StreamPrecision = -1,$/;"	e	enum:Eigen::__anon172
StrictlyLower	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  StrictlyLower=ZeroDiag|Lower, $/;"	e	enum:Eigen::__anon258
StrictlyUpper	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  StrictlyUpper=ZeroDiag|Upper,$/;"	e	enum:Eigen::__anon258
Stride	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    Stride()$/;"	f	class:Eigen::Stride
Stride	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    Stride(Index outerStride, Index innerStride)$/;"	f	class:Eigen::Stride
Stride	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    Stride(const Stride& other)$/;"	f	class:Eigen::Stride
Stride	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^class Stride$/;"	c	namespace:Eigen
StridedAlignedMapType	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedConstAlignedMapType	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedConstMapType	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedMapType	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StripMesh	vcglib/wrap/bmt/strip_mesh.h	/^class StripMesh {$/;"	c	namespace:vcg
StripMeshBuilder	vcglib/wrap/bmt/strip_mesh.h	/^class StripMeshBuilder {$/;"	c	namespace:vcg
SubBox	vcglib/vcg/space/index/octree_template.h	/^	BoundingBoxType SubBox(BoundingBoxType &lbb, int i)$/;"	f	class:vcg::OctreeTemplate
SubBoxAndCenterInWorldCoordinates	vcglib/vcg/space/index/octree_template.h	/^	BoundingBoxType SubBoxAndCenterInWorldCoordinates(BoundingBoxType &lbb, CoordinateType &center, int i)$/;"	f	class:vcg::OctreeTemplate
SubDiagonalReturnType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type SubDiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization
SubDiagonalType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<RealScalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> SubDiagonalType;$/;"	t	class:Eigen::Tridiagonalization
SubVector	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^                               typename ExpressionType::RowXpr>::type SubVector;$/;"	t	class:Eigen::VectorwiseOp
Subconfig13	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^            static char Subconfig13(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
SubdivFaceSampling	vcglib/apps/metro/sampling.h	/^void Sampling<MetroMesh>::SubdivFaceSampling()$/;"	f	class:vcg::Sampling
SubdivideAndSample	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void SubdivideAndSample(MetroMesh & m, std::vector<Point3f> &pvec, const Box3<ScalarType> bb, RRParam &rrp, float curDiag)$/;"	f	class:vcg::tri::SurfaceSampling
Subs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      Subs   = internal::traits<Derived>::Subs,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon45
Subs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon48
Subs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon49
SubtractiveRingRNG	vcglib/vcg/math/random_generator.h	/^	SubtractiveRingRNG(int default_seed=161803398u)$/;"	f	class:vcg::math::SubtractiveRingRNG
SubtractiveRingRNG	vcglib/vcg/math/random_generator.h	/^class SubtractiveRingRNG : public RandomGenerator$/;"	c	namespace:vcg::math
Success	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Success = 0,        $/;"	e	enum:Eigen::ComputationInfo
Success	vcglib/vcg/complex/algorithms/harmonic.h	/^		Success            = 0,$/;"	e	enum:vcg::tri::Harmonic::WeightInfo
SuggestConsistentOffsets	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void SuggestConsistentOffsets(const EntryCoordinate &at, std::vector< Offset > &offsets)$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
Sum	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar Sum() const { return sum(); }$/;"	f
Sum	vcglib/vcg/space/deprecated_point.h	/^	inline S Sum() const {$/;"	f	class:vcg::ndim::Point2
Sum	vcglib/vcg/space/deprecated_point.h	/^	inline S Sum() const {$/;"	f	class:vcg::ndim::Point3
Sum	vcglib/vcg/space/deprecated_point.h	/^	inline S Sum() const {$/;"	f	class:vcg::ndim::Point4
Sum3	vcglib/vcg/math/quadric5.h	/^	void inline Sum3 (const math::Quadric<double> & q3, float u, float v)$/;"	f	class:vcg::Quadric5
SumAll	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    static void SumAll(VertexType *v,vcg::TexCoord2f &coord, Quadric5<double>& q)$/;"	f	class:vcg::tri::QuadricTexHelper
Super	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef TextureOptimizer<MESH_TYPE> Super; \/\/ superclass (commodity)$/;"	t	class:vcg::tri::AreaPreservingTextureOptimizer
SuperDiagVectorType	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTimeMinusOne, 1> SuperDiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
SuperILU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU() : Base() { init(); }$/;"	f	class:Eigen::SuperILU
SuperILU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(SuperILU& ) { }$/;"	f	class:Eigen::SuperILU
SuperILU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperILU
SuperILU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperILU : public SuperLUBase<_MatrixType,SuperILU<_MatrixType> >$/;"	c	namespace:Eigen
SuperLU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU() : Base() { init(); }$/;"	f	class:Eigen::SuperLU
SuperLU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(SuperLU& ) { }$/;"	f	class:Eigen::SuperLU
SuperLU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperLU
SuperLU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLU : public SuperLUBase<_MatrixType,SuperLU<_MatrixType> >$/;"	c	namespace:Eigen
SuperLUBase	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase() {}$/;"	f	class:Eigen::SuperLUBase
SuperLUBase	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase(SuperLUBase& ) { }$/;"	f	class:Eigen::SuperLUBase
SuperLUBase	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLUBase : internal::noncopyable$/;"	c	namespace:Eigen
Supers	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^      Supers = internal::traits<Derived>::Supers,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon45
Supers	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon48
Supers	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon49
SupportedAccessPatterns	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon417
SupportedAccessPatterns	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon430
SupportedAccessPatterns	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    SupportedAccessPatterns = OuterRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon456
SurfaceSampling	vcglib/vcg/complex/algorithms/point_sampling.h	/^class SurfaceSampling$/;"	c	namespace:vcg::tri
SurfaceTag	vcglib/wrap/dae/colladaformat.h	/^		SurfaceTag(const QString& type = QString("2D"))$/;"	f	class:Collada::Tags::SurfaceTag
SurfaceTag	vcglib/wrap/dae/colladaformat.h	/^	class SurfaceTag : public XMLTag$/;"	c	namespace:Collada::Tags
SwapColumns	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void SwapColumns(const unsigned int i, const unsigned int j)$/;"	f
SwapColumns	vcglib/vcg/math/old_deprecated_matrix.h	/^			void SwapColumns(const unsigned int i, const unsigned int j)$/;"	f	class:vcg::ndim::Matrix
SwapDouble	vcglib/wrap/ply/plylib.cpp	/^static inline void SwapDouble( double * \/*d*\/ )$/;"	f	namespace:vcg::ply
SwapEdge	vcglib/vcg/simplex/face/topology.h	/^void SwapEdge(FaceType &f, const int z) { SwapEdge<FaceType,true>(f,z); }$/;"	f	namespace:vcg::face
SwapEdge	vcglib/vcg/simplex/face/topology.h	/^void SwapEdge(FaceType &f, const int z)$/;"	f	namespace:vcg::face
SwapFlag	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^bool SwapFlag=false;$/;"	v
SwapInt	vcglib/wrap/ply/plylib.cpp	/^static inline void SwapInt( uint * x )$/;"	f	namespace:vcg::ply
SwapRows	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED void SwapRows(const unsigned int i, const unsigned int j)$/;"	f
SwapRows	vcglib/vcg/math/old_deprecated_matrix.h	/^			void SwapRows(const unsigned int i, const unsigned int j)$/;"	f	class:vcg::ndim::Matrix
SwapShort	vcglib/wrap/ply/plylib.cpp	/^static inline void SwapShort( ushort * s )$/;"	f	namespace:vcg::ply
SwapStorage	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^      SwapStorage = 1 - MapTraits<ScalarWrapper>::IsSorted,$/;"	e	enum:Eigen::RandomSetter::__anon463
SwapWrapper	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline SwapWrapper(ExpressionType& xpr) : m_expression(xpr) {}$/;"	f	class:Eigen::SwapWrapper
SwapWrapper	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^template<typename ExpressionType> class SwapWrapper$/;"	c	namespace:Eigen
Symmetric	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Symmetric=0x20$/;"	e	enum:Eigen::__anon258
SymmetricPlanes	vcglib/vcg/complex/algorithms/symmetry.h	/^    std::vector<vcg::Plane3<ScalarType> > SymmetricPlanes;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
Sync	vcglib/wrap/gui/trackball.cpp	/^void Trackball::Sync(unsigned int msec) {$/;"	f	class:Trackball
SystemLDL	vcglib/wrap/math/system_interface_ldl.h	/^class SystemLDL:SparseMatrix<double>{$/;"	c
T	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    vcg::Matrix44<ScalarType> T;$/;"	m	struct:vcg::tri::FourPCS::Candidate
T	vcglib/vcg/simplex/tetrahedron/pos.h	/^	inline  TetraType* const & T() const$/;"	f	class:vcg::tetra::Pos
T	vcglib/vcg/simplex/tetrahedron/pos.h	/^	inline TetraType* & T()$/;"	f	class:vcg::tetra::Pos
T	vcglib/vcg/simplex/vertex/component.h	/^        TexCoordType &T()       { return _t; }$/;"	f	class:vcg::vertex::TexCoord
T	vcglib/vcg/simplex/vertex/component.h	/^  TexCoordType &T()       { static TexCoordType dummy_texcoord;  assert(0); return dummy_texcoord; }$/;"	f	class:vcg::vertex::EmptyCore
T	vcglib/vcg/simplex/vertex/component.h	/^  const TexCoordType &T() const { return _t; }$/;"	f	class:vcg::vertex::TexCoord
T	vcglib/vcg/simplex/vertex/component_occ.h	/^  TexCoordType &T() {return CAT< vector_occ<VertType>,TexCoordType>::Instance()->Get((VertType*)this); }$/;"	f	class:vcg::vertex::TexCoordOcc
T	vcglib/vcg/simplex/vertex/component_ocf.h	/^        TexCoordType &T()       { assert((*this).Base().TexCoordEnabled); return (*this).Base().TV[(*this).Index()]; }$/;"	f	class:vcg::vertex::TexCoordOcf
T	vcglib/vcg/simplex/vertex/component_ocf.h	/^  const TexCoordType &T() const { assert((*this).Base().TexCoordEnabled); return (*this).Base().TV[(*this).Index()]; }$/;"	f	class:vcg::vertex::TexCoordOcf
T0	vcglib/vcg/complex/algorithms/inertia.h	/^ double T0, T1[3], T2[3], TP[3];$/;"	m	class:vcg::tri::Inertia
T1	vcglib/vcg/complex/algorithms/inertia.h	/^ double T0, T1[3], T2[3], TP[3];$/;"	m	class:vcg::tri::Inertia
T2	vcglib/vcg/complex/algorithms/inertia.h	/^ double T0, T1[3], T2[3], TP[3];$/;"	m	class:vcg::tri::Inertia
TD	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^      static  Quadric5Temp &TD() {return *TDp();}$/;"	f	class:vcg::tri::QuadricTexHelper
TD3	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^      static  QuadricTemp &TD3() {return *TDp3();}$/;"	f	class:vcg::tri::QuadricTexHelper
TDp	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^      static  Quadric5Temp* &TDp() {static  Quadric5Temp *td; return td;}$/;"	f	class:vcg::tri::QuadricTexHelper
TDp3	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^      static  QuadricTemp* &TDp3() {static  QuadricTemp *td3; return td3;}$/;"	f	class:vcg::tri::QuadricTexHelper
TE	vcglib/vcg/complex/algorithms/hole.h	/^  typedef TrivialEar<MESH> TE;$/;"	t	class:vcg::tri::MinimumWeightEar
TE	vcglib/vcg/complex/algorithms/refine.h	/^    int TE[4][3];   \/\/ the edge-edge correspondence between refined triangles and the old one$/;"	m	class:vcg::tri::Split
TEC	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^    typedef typename vcg::tri::TriEdgeCollapse< TriMeshType, VertexPair, MYTYPE > TEC;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadric
TECQ	vcglib/apps/tridecimator/tridecimator.cpp	/^            typedef  vcg::tri::TriEdgeCollapseQuadric< MyMesh,  VertexPair, MyTriEdgeCollapse, QInfoStandard<MyVertex>  > TECQ;$/;"	t	class:MyTriEdgeCollapse	file:
TECQ	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^            typedef  TriEdgeCollapseQuadricTex< MyMesh,  VertexPair, MyTriEdgeCollapseQTex, QuadricTexHelper<MyMesh> > TECQ;$/;"	t	class:MyTriEdgeCollapseQTex	file:
TEF	vcglib/apps/sample/trimesh_hole/trimesh_hole.cpp	/^    typedef  vcg::tri::TriEdgeFlip< MyMesh,  MyDelaunayFlip > TEF;$/;"	t	class:MyDelaunayFlip	file:
TEST_IN_PLACE_SPLIT	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^#define TEST_IN_PLACE_SPLIT$/;"	d	file:
TETRA_TYPE	vcglib/vcg/simplex/tetrahedron/tetrahedron.h	/^#define TETRA_TYPE /;"	d
TEXCOORD_PER_VERTEX	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            TEXCOORD_PER_VERTEX = (1 << 7),$/;"	e	enum:vcg::tri::AttributeSeam::ASMask
TEXCOORD_PER_WEDGE	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            TEXCOORD_PER_WEDGE  = (1 << 8)$/;"	e	enum:vcg::tri::AttributeSeam::ASMask
TEXTURE	vcglib/wrap/gl/fbo.h	/^		TEXTURE$/;"	e	enum:RenderTarget::__anon516
TGAHeader	vcglib/wrap/io_trimesh/export_idtf.h	/^	struct TGAHeader$/;"	s	class:vcg::tri::io::TGA_Exporter
TGA_Exporter	vcglib/wrap/io_trimesh/export_idtf.h	/^class TGA_Exporter$/;"	c	namespace:vcg::tri::io
THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
TMId	vcglib/wrap/gl/trimesh.h	/^    std::vector<unsigned int> TMId;$/;"	m	class:vcg::GlTrimesh
TMNone	vcglib/wrap/gl/trimesh.h	/^    enum TextureMode{TMNone, TMPerVert, TMPerWedge, TMPerWedgeMulti};$/;"	e	enum:vcg::GLW::TextureMode
TMPerVert	vcglib/wrap/gl/trimesh.h	/^    enum TextureMode{TMNone, TMPerVert, TMPerWedge, TMPerWedgeMulti};$/;"	e	enum:vcg::GLW::TextureMode
TMPerWedge	vcglib/wrap/gl/trimesh.h	/^    enum TextureMode{TMNone, TMPerVert, TMPerWedge, TMPerWedgeMulti};$/;"	e	enum:vcg::GLW::TextureMode
TMPerWedgeMulti	vcglib/wrap/gl/trimesh.h	/^    enum TextureMode{TMNone, TMPerVert, TMPerWedge, TMPerWedgeMulti};$/;"	e	enum:vcg::GLW::TextureMode
TOP_FOOT_SIZE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define TOP_FOOT_SIZE\\/;"	d	file:
TOP_LEFT	vcglib/wrap/qt/gl_label.h	/^    enum LabelPosition { TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT} ;$/;"	e	enum:vcg::glLabel::LabelPosition
TOP_RIGHT	vcglib/wrap/qt/gl_label.h	/^    enum LabelPosition { TOP_LEFT, TOP_RIGHT, BOTTOM_LEFT, BOTTOM_RIGHT} ;$/;"	e	enum:vcg::glLabel::LabelPosition
TOSTRING_H	vcglib/wrap/qt/to_string.h	/^#define TOSTRING_H$/;"	d
TP	vcglib/vcg/complex/algorithms/inertia.h	/^ double T0, T1[3], T2[3], TP[3];$/;"	m	class:vcg::tri::Inertia
TR	vcglib/wrap/gl/tetramesh.h	/^			vcg::Matrix44<float> TR;$/;"	m	class:vcg::tetra::GlTetramesh::ClipPlane
TRACKBALL_H	vcglib/wrap/gui/trackball.h	/^#define TRACKBALL_H$/;"	d
TRACKMODE_H	vcglib/wrap/gui/trackmode.h	/^#define TRACKMODE_H$/;"	d
TRACKUTILS_H	vcglib/wrap/gui/trackutils.h	/^#define TRACKUTILS_H$/;"	d
TREEBIN_SHIFT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define TREEBIN_SHIFT /;"	d	file:
TRI_TRI_INT_EPSILON	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define TRI_TRI_INT_EPSILON /;"	d
TRI_TRI_INT_EPSILON	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef TRI_TRI_INT_EPSILON /;"	d
TRY_LOCK	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define TRY_LOCK(/;"	d	file:
TT	vcglib/vcg/container/container_allocation_table.h	/^typedef CATEntry<STL_CONT, EntryCAT<STL_CONT,ATTR_TYPE> > TT;$/;"	t	class:vcg::CAT
TT	vcglib/vcg/container/vector_occ.h	/^	typedef  std::vector<VALUE_TYPE> TT;	$/;"	t	class:vcg::vector_occ
TTAdj	vcglib/vcg/simplex/tetrahedron/component.h	/^	TTAdj(){$/;"	f	class:vcg::tetra::TTAdj
TTAdj	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class TTAdj: public T {$/;"	c	namespace:vcg::tetra
TTi	vcglib/vcg/simplex/tetrahedron/component.h	/^	char & TTi( const int j ) { static char z=0; return z; }$/;"	f	class:vcg::tetra::EmptyAdj
TTi	vcglib/vcg/simplex/tetrahedron/component.h	/^  char        &TTi(const int j)       { return _tti[j]; }$/;"	f	class:vcg::tetra::TTAdj
TTp	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer & TTp( const int ) { static typename T::TetraPointer tp=0; return tp; }$/;"	f	class:vcg::tetra::EmptyAdj
TTp	vcglib/vcg/simplex/tetrahedron/component.h	/^  typename T::TetraPointer       &TTp(const int j)        { assert(j>=0 && j<4);  return _ttp[j]; }$/;"	f	class:vcg::tetra::TTAdj
TTp	vcglib/vcg/simplex/tetrahedron/component.h	/^  typename T::TetraPointer const  TTp(const int j) const  { assert(j>=0 && j<4);  return _ttp[j]; }$/;"	f	class:vcg::tetra::TTAdj::T
TTp1	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer  const  TTp1( const int j ) const { return TTp((j+1)%4);}$/;"	f	class:vcg::tetra::TTAdj::T
TTp1	vcglib/vcg/simplex/tetrahedron/component.h	/^  typename T::TetraPointer        &TTp1( const int j )       { return TTp((j+1)%4);}$/;"	f	class:vcg::tetra::TTAdj
TTp2	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer        &TTp2( const int j )       { return TTp((j+2)%4);}$/;"	f	class:vcg::tetra::TTAdj
TTp2	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer  const  TTp2( const int j ) const { return TTp((j+2)%4);}$/;"	f	class:vcg::tetra::TTAdj::T
TV	vcglib/vcg/complex/algorithms/refine.h	/^    int TV[4][3];   \/\/ The triangles coded as the following convention$/;"	m	class:vcg::tri::Split
TV	vcglib/vcg/simplex/vertex/component_ocf.h	/^  std::vector<typename VALUE_TYPE::TexCoordType> TV;$/;"	m	class:vcg::vertex::vector_ocf
TWO_SIZE_T_SIZES	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define TWO_SIZE_T_SIZES /;"	d	file:
T_CHAR	vcglib/wrap/ply/plylib.h	/^	T_CHAR,$/;"	e	enum:vcg::ply::PlyTypes
T_DOUBLE	vcglib/wrap/ply/plylib.h	/^	T_DOUBLE,$/;"	e	enum:vcg::ply::PlyTypes
T_FLOAT	vcglib/wrap/ply/plylib.h	/^	T_FLOAT,$/;"	e	enum:vcg::ply::PlyTypes
T_INT	vcglib/wrap/ply/plylib.h	/^	T_INT,$/;"	e	enum:vcg::ply::PlyTypes
T_MAXTYPE	vcglib/wrap/ply/plylib.h	/^	T_MAXTYPE$/;"	e	enum:vcg::ply::PlyTypes
T_NOTYPE	vcglib/wrap/ply/plylib.h	/^	T_NOTYPE,$/;"	e	enum:vcg::ply::PlyTypes
T_SHORT	vcglib/wrap/ply/plylib.h	/^	T_SHORT,$/;"	e	enum:vcg::ply::PlyTypes
T_UCHAR	vcglib/wrap/ply/plylib.h	/^	T_UCHAR,$/;"	e	enum:vcg::ply::PlyTypes
T_UINT	vcglib/wrap/ply/plylib.h	/^	T_UINT,$/;"	e	enum:vcg::ply::PlyTypes
T_USHORT	vcglib/wrap/ply/plylib.h	/^	T_USHORT,$/;"	e	enum:vcg::ply::PlyTypes
TagAttribute	vcglib/wrap/dae/xmldocumentmanaging.h	/^	typedef std::pair<QString,QString> TagAttribute;$/;"	t	class:XMLTag
TagAttributes	vcglib/wrap/dae/xmldocumentmanaging.h	/^	typedef QVector<TagAttribute> TagAttributes;$/;"	t	class:XMLTag
Tags	vcglib/wrap/dae/colladaformat.h	/^namespace Tags$/;"	n	namespace:Collada
TangentAngleToVect	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static CoordType TangentAngleToVect(const FaceType &f,const ScalarType &angle)$/;"	f	class:vcg::tri::CrossField
TangentVectToAngle	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static ScalarType TangentVectToAngle(const CoordType dirX,$/;"	f	class:vcg::tri::CrossField
Target	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^    Target = SSE$/;"	e	enum:Eigen::Architecture::Type
Target	vcglib/wrap/gl/fbo.h	/^	GLenum Target(void) const$/;"	f	class:Texture1D
Target	vcglib/wrap/gl/fbo.h	/^	GLenum Target(void) const$/;"	f	class:Texture2D
Target	vcglib/wrap/gl/fbo.h	/^	GLenum Target(void) const$/;"	f	class:Texture3D
TargetCurrentGeometry	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  void TargetCurrentGeometry(){$/;"	f	class:vcg::tri::AreaPreservingTextureOptimizer
TargetRowMajor	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^      TargetRowMajor = (SparseMatrixType::Flags & RowMajorBit) ? 1 : 0,$/;"	e	enum:Eigen::RandomSetter::__anon463
TaskFunc	vcglib/wrap/callback.h	/^typedef void TaskFunc(int t,void * contest); $/;"	t	namespace:vcg
TechniqueCommonTag	vcglib/wrap/dae/colladaformat.h	/^		TechniqueCommonTag()$/;"	f	class:Collada::Tags::TechniqueCommonTag
TechniqueCommonTag	vcglib/wrap/dae/colladaformat.h	/^	class TechniqueCommonTag : public XMLTag$/;"	c	namespace:Collada::Tags
TechniqueTag	vcglib/wrap/dae/colladaformat.h	/^		TechniqueTag(const QString& sid)$/;"	f	class:Collada::Tags::TechniqueTag
TechniqueTag	vcglib/wrap/dae/colladaformat.h	/^	class TechniqueTag : public XMLTag$/;"	c	namespace:Collada::Tags
TempData	vcglib/vcg/complex/algorithms/geodesic.h	/^    TempData(){}$/;"	f	struct:vcg::tri::Geodesic::TempData
TempData	vcglib/vcg/complex/algorithms/geodesic.h	/^    TempData(const ScalarType & _d):d(_d),source(0),parent(0){}$/;"	f	struct:vcg::tri::Geodesic::TempData
TempData	vcglib/vcg/complex/algorithms/geodesic.h	/^  struct TempData{$/;"	s	class:vcg::tri::Geodesic
TempDataType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef SimpleTempData<std::vector<VertexType>, TempData >  TempDataType;$/;"	t	class:vcg::tri::Geodesic
TemplatedOctree	vcglib/vcg/space/index/octree.h	/^        typedef vcg::OctreeTemplate< VoxelType, SCALAR_TYPE >	TemplatedOctree;$/;"	t	class:vcg::Octree
Terminate	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void Terminate(){}$/;"	f
TessellatePlanarPolygon2	vcglib/vcg/space/planar_polygon_tessellation.h	/^	void TessellatePlanarPolygon2( POINT_CONTAINER &  points2, std::vector<int> & output){$/;"	f	namespace:vcg
TessellatePlanarPolygon3	vcglib/vcg/space/planar_polygon_tessellation.h	/^	void TessellatePlanarPolygon3( POINT_CONTAINER &  points, std::vector<int> & output){$/;"	f	namespace:vcg
Test10	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^            static char Test10(unsigned char config, int u)$/;"	f	class:vcg::tri::MCLookUpTable
Test12	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^            static char Test12(unsigned char config, int u)$/;"	f	class:vcg::tri::MCLookUpTable
Test13	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^            static char Test13(unsigned char config, int u)$/;"	f	class:vcg::tri::MCLookUpTable
Test3	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^            static char Test3(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Test4	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^            static char Test4(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Test6	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^            static char Test6(unsigned char config, int u)$/;"	f	class:vcg::tri::MCLookUpTable
Test7	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^            static char Test7(unsigned char config, int u)$/;"	f	class:vcg::tri::MCLookUpTable
TestAlignment	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^FourPCS<MeshType>::TestAlignment(Candidate  & fp){$/;"	f	class:vcg::tri::FourPCS
TestAndRemoveDoublet	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool TestAndRemoveDoublet(FaceType &f, int wedge, MeshType& m){$/;"	f	class:vcg::tri::BitQuad
TestAndRemoveSinglet	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool TestAndRemoveSinglet(FaceType &f, int wedge, MeshType& m){$/;"	f	class:vcg::tri::BitQuad
TestBox	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^MyScalarType TestBox(int num_test=100000,$/;"	f
TestClosest	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^static void TestClosest(void) {$/;"	f	file:
TestClosest	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^MyScalarType TestClosest(unsigned int num_test=1000000,$/;"	f
TestCorrectClosest	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^int TestCorrectClosest(int num_test=1000,$/;"	f
TestCorrectIntersect	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^int TestCorrectIntersect(int num_test=1000,bool use_sub=false)$/;"	f
TestEdgeRotation	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static int TestEdgeRotation(const FaceType &f, int w0, ScalarType *gain=NULL)$/;"	f	class:vcg::tri::BitQuad
TestFace	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            inline bool TestFace(signed char face)$/;"	f	class:vcg::tri::MarchingCubes
TestFaceFace	vcglib/vcg/complex/algorithms/update/topology.h	/^static void TestFaceFace(MeshType &m)$/;"	f	class:vcg::tri::UpdateTopology
TestFaceFaceIntersection	vcglib/vcg/complex/algorithms/clean.h	/^  static	bool TestFaceFaceIntersection(FaceType *f0,FaceType *f1)$/;"	f	class:vcg::tri::Clean
TestFunc1	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  TestFunc1() : m_inputs(InputsAtCompileTime), m_values(ValuesAtCompileTime) {}$/;"	f	struct:TestFunc1
TestFunc1	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  TestFunc1(int inputs, int values) : m_inputs(inputs), m_values(values) {}$/;"	f	struct:TestFunc1
TestFunc1	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^struct TestFunc1$/;"	s	file:
TestFunc1	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  TestFunc1() : m_inputs(InputsAtCompileTime), m_values(ValuesAtCompileTime) {}$/;"	f	struct:TestFunc1
TestFunc1	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  TestFunc1(int inputs, int values) : m_inputs(inputs), m_values(values) {}$/;"	f	struct:TestFunc1
TestFunc1	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^struct TestFunc1$/;"	s	file:
TestIntegerEdges	vcglib/wrap/miq/quadrangulator.h	/^    void TestIntegerEdges()$/;"	f	class:Quadrangulator
TestInterior	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            inline bool TestInterior(signed char s)$/;"	f	class:vcg::tri::MarchingCubes
TestIntersection	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^MyScalarType TestIntersection(unsigned int num_test=1000000,bool use_sub=false)$/;"	f
TestIsProper	vcglib/wrap/miq/quadrangulator.h	/^    void TestIsProper(TriMesh &Tmesh)$/;"	f	class:Quadrangulator
TestKClosest	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^static void TestKClosest(void) {$/;"	f	file:
TestRay	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^static void TestRay(void) {$/;"	f	file:
TestSeamMapping	vcglib/wrap/miq/core/vertex_indexing.h	/^    void TestSeamMapping()$/;"	f	class:VertexIndexing
TestSeamMapping	vcglib/wrap/miq/core/vertex_indexing.h	/^    void TestSeamMapping(FaceType *f)$/;"	f	class:VertexIndexing
TestSeamMapping	vcglib/wrap/miq/core/vertex_indexing.h	/^    void TestSeamMapping(int indexVert)$/;"	f	class:VertexIndexing
TestVertexFace	vcglib/vcg/complex/algorithms/update/topology.h	/^static void TestVertexFace(MeshType &m)$/;"	f	class:vcg::tri::UpdateTopology
TestVertexRotation	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static bool TestVertexRotation(const FaceType &f, int w0)$/;"	f	class:vcg::tri::BitQuad
Tetra	vcglib/vcg/space/tetra3.h	/^class Tetra$/;"	c	namespace:vcg
Tetra3	vcglib/vcg/space/tetra3.h	/^ class Tetra3:public Tetra$/;"	c	namespace:vcg
TetraArity1	vcglib/vcg/simplex/tetrahedron/base.h	/^          class TetraArity1: public A<TetraBase<BVT,BET,BFT,BTT> > {};$/;"	c	namespace:vcg
TetraArity2	vcglib/vcg/simplex/tetrahedron/base.h	/^          class TetraArity2: public B<TetraArity1<BVT,BET,BFT,BTT, A> > {};$/;"	c	namespace:vcg
TetraArity3	vcglib/vcg/simplex/tetrahedron/base.h	/^          class TetraArity3: public C<TetraArity2<BVT,BET,BFT,BTT, A, B> > {};$/;"	c	namespace:vcg
TetraArity4	vcglib/vcg/simplex/tetrahedron/base.h	/^          class TetraArity4: public D<TetraArity3<BVT,BET,BFT,BTT, A, B, C> > {};$/;"	c	namespace:vcg
TetraArity5	vcglib/vcg/simplex/tetrahedron/base.h	/^          class TetraArity5: public E<TetraArity4<BVT,BET,BFT,BTT, A, B, C, D> > {};$/;"	c	namespace:vcg
TetraArity6	vcglib/vcg/simplex/tetrahedron/base.h	/^          class TetraArity6: public F<TetraArity5<BVT,BET,BFT,BTT, A, B, C, D, E> > {};$/;"	c	namespace:vcg
TetraArity7	vcglib/vcg/simplex/tetrahedron/base.h	/^          class TetraArity7: public G<TetraArity6<BVT,BET,BFT,BTT, A, B, C, D, E, F> > {};$/;"	c	namespace:vcg
TetraArity8	vcglib/vcg/simplex/tetrahedron/base.h	/^          class TetraArity8: public H<TetraArity7<BVT,BET,BFT,BTT, A, B, C, D, E, F, G> > {};$/;"	c	namespace:vcg
TetraArityMax	vcglib/vcg/simplex/tetrahedron/base.h	/^          class TetraArityMax: public I<TetraArity8<BVT,BET,BFT,BTT, A, B, C, D, E, F, G, H> > {$/;"	c	namespace:vcg
TetraBase	vcglib/vcg/simplex/tetrahedron/base.h	/^class TetraBase: public  tetra::EmptyVertexRef<$/;"	c	namespace:vcg
TetraData	vcglib/wrap/io_tetramesh/io_ply.h	/^  PropDescriptor *TetraData;$/;"	m	class:vcg::tetra::io::PlyInfo
TetraDefaultDeriver	vcglib/vcg/simplex/tetrahedron/base.h	/^class TetraDefaultDeriver : public T {};$/;"	c	namespace:vcg
TetraDesc	vcglib/wrap/io_tetramesh/import_ply.h	/^static const  PropDescriptor &TetraDesc(int i)  $/;"	f	class:vcg::tetra::io::ImporterPLY
TetraEdgeCollapse	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	TetraEdgeCollapse()$/;"	f	class:vcg::tetra::TetraEdgeCollapse
TetraEdgeCollapse	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	TetraEdgeCollapse(PosType p,int mark)$/;"	f	class:vcg::tetra::TetraEdgeCollapse
TetraEdgeCollapse	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^class TetraEdgeCollapse: public LocalOptimization<TETRA_MESH_TYPE>::LocModType$/;"	c	namespace:vcg::tetra
TetraEdgeCollapseOp	vcglib/vcg/complex/algorithms/local_optimization.h	/^enum ModifierType{	TetraEdgeCollapseOp, TriEdgeSwapOp, TriVertexSplitOp,$/;"	e	enum:vcg::ModifierType
TetraEdgeSpliOpt	vcglib/vcg/complex/algorithms/local_optimization.h	/^				TriEdgeCollapseOp,TetraEdgeSpliOpt,TetraEdgeSwapOp, TriEdgeFlipOp,$/;"	e	enum:vcg::ModifierType
TetraEdgeSwapOp	vcglib/vcg/complex/algorithms/local_optimization.h	/^				TriEdgeCollapseOp,TetraEdgeSpliOpt,TetraEdgeSwapOp, TriEdgeFlipOp,$/;"	e	enum:vcg::ModifierType
TetraIterator	vcglib/wrap/gl/pick.h	/^	typedef typename TETRA_MESH_TYPE::TetraIterator TetraIterator;$/;"	t	class:vcg::GLPickTetra
TetraIterator	vcglib/wrap/io_tetramesh/export_ply.h	/^typedef typename SaveMeshType::TetraIterator TetraIterator;$/;"	t	class:vcg::tetra::io::ExporterPLY
TetraIterator	vcglib/wrap/io_tetramesh/export_ts.h	/^	typedef typename MESHTYPE::TetraIterator TetraIterator;$/;"	t	struct:vcg::tetra::io::ExporterTS
TetraIterator	vcglib/wrap/io_tetramesh/import_ply.h	/^typedef typename OpenMeshType::TetraIterator TetraIterator;$/;"	t	class:vcg::tetra::io::ImporterPLY
TetraPointer	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsTetraType: public T{typedef A TetraType;		typedef TetraType * TetraPointer		;};$/;"	t	struct:vcg::Use::AsTetraType
TetraPointer	vcglib/vcg/complex/used_types.h	/^        typedef TetraType * TetraPointer	;$/;"	t	struct:vcg::DummyTypes
TetraPointer	vcglib/vcg/simplex/tetrahedron/base.h	/^  typedef BTT *TetraPointer;$/;"	t	class:vcg::TetraTypeHolder
TetraPointer	vcglib/wrap/gl/pick.h	/^	typedef typename TETRA_MESH_TYPE::TetraPointer  TetraPointer;$/;"	t	class:vcg::GLPickTetra
TetraPointer	vcglib/wrap/io_tetramesh/export_ply.h	/^typedef typename SaveMeshType::TetraPointer TetraPointer;$/;"	t	class:vcg::tetra::io::ExporterPLY
TetraSimp2	vcglib/vcg/simplex/tetrahedron/base.h	/^              class TetraSimp2: public TetraArityMax<BVT,BET,BFT,DumTT, A, B, C, D, E, F, G, H, I>  {};$/;"	c	namespace:vcg
TetraSimp3	vcglib/vcg/simplex/tetrahedron/base.h	/^              class TetraSimp3: public TetraArityMax<BVT,BET,BFT,BTT, A, B, C, D, E, F, G, H, I>  {};$/;"	c	namespace:vcg
TetraType	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  typedef	typename TETRA_MESH_TYPE::TetraType TetraType;$/;"	t	class:vcg::tetra::TetraEdgeCollapse
TetraType	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsTetraType: public T{typedef A TetraType;		typedef TetraType * TetraPointer		;};$/;"	t	struct:vcg::Use::AsTetraType
TetraType	vcglib/vcg/complex/used_types.h	/^        typedef char TetraType;$/;"	t	struct:vcg::DummyTypes
TetraType	vcglib/vcg/simplex/tetrahedron/base.h	/^  typedef BTT TetraType;$/;"	t	class:vcg::TetraTypeHolder
TetraType	vcglib/vcg/simplex/tetrahedron/pos.h	/^	typedef  MTTYPE  TetraType;$/;"	t	class:vcg::tetra::PosJump
TetraType	vcglib/vcg/simplex/tetrahedron/pos.h	/^	typedef  MTTYPE  TetraType;$/;"	t	class:vcg::tetra::PosLoop
TetraType	vcglib/vcg/simplex/tetrahedron/pos.h	/^	typedef  MTTYPE TetraType;$/;"	t	class:vcg::tetra::VTIterator
TetraType	vcglib/vcg/simplex/tetrahedron/pos.h	/^	typedef MTTYPE TetraType;$/;"	t	class:vcg::tetra::Pos
TetraType	vcglib/wrap/gl/tetramesh.h	/^	typedef typename CONT_TETRA::value_type TetraType; $/;"	t	class:vcg::tetra::GlTetramesh
TetraType	vcglib/wrap/io_tetramesh/export_ply.h	/^typedef typename SaveMeshType::TetraType TetraType;$/;"	t	class:vcg::tetra::io::ExporterPLY
TetraType	vcglib/wrap/io_tetramesh/import_ply.h	/^typedef typename OpenMeshType::TetraType TetraType;$/;"	t	class:vcg::tetra::io::ImporterPLY
TetraTypeHolder	vcglib/vcg/simplex/tetrahedron/base.h	/^class TetraTypeHolder{$/;"	c	namespace:vcg
Tetrahedron	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Tetrahedron(TetraMeshType &in)$/;"	f	namespace:vcg::tri
Tetramesh	vcglib/wrap/io_tetramesh/import_ts.h	/^	typedef MESHTYPE Tetramesh;$/;"	t	class:vcg::tetra::io::ImporterTS
TexCoord	vcglib/vcg/simplex/vertex/component.h	/^template <class A, class TT> class TexCoord: public TT {$/;"	c	namespace:vcg::vertex
TexCoord2	vcglib/vcg/space/texcoord2.h	/^  TexCoord2() {  };$/;"	f	class:vcg::TexCoord2
TexCoord2	vcglib/vcg/space/texcoord2.h	/^  TexCoord2(T u, T v) { if(NMAX>0) _n[0]=0; _t[0][0]=u; _t[0][1]=v; };$/;"	f	class:vcg::TexCoord2
TexCoord2	vcglib/vcg/space/texcoord2.h	/^class TexCoord2$/;"	c	namespace:vcg
TexCoord2Simple	vcglib/vcg/space/texcoord2.h	/^class TexCoord2Simple$/;"	c	namespace:vcg
TexCoord2d	vcglib/vcg/simplex/vertex/component.h	/^template <class TT> class TexCoord2d: public TexCoord<TexCoord2<double,1>, TT> {$/;"	c	namespace:vcg::vertex
TexCoord2d	vcglib/vcg/space/texcoord2.h	/^typedef TexCoord2<double> TexCoord2d;$/;"	t	namespace:vcg
TexCoord2dOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class TexCoord2dOcc: public TexCoordOcc<TexCoord2<double,1>, T> {};$/;"	c	namespace:vcg::vertex
TexCoord2f	vcglib/vcg/simplex/vertex/component.h	/^template <class TT> class TexCoord2f: public TexCoord<TexCoord2<float,1>, TT> {$/;"	c	namespace:vcg::vertex
TexCoord2f	vcglib/vcg/space/texcoord2.h	/^typedef TexCoord2<float>  TexCoord2f;$/;"	t	namespace:vcg
TexCoord2fOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class TexCoord2fOcc: public TexCoordOcc<TexCoord2<float,1>, T> {};$/;"	c	namespace:vcg::vertex
TexCoord2s	vcglib/vcg/simplex/vertex/component.h	/^template <class TT> class TexCoord2s: public TexCoord<TexCoord2<short,1>, TT> {$/;"	c	namespace:vcg::vertex
TexCoord2sOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class TexCoord2sOcc: public TexCoordOcc<TexCoord2<short,1>, T> {};$/;"	c	namespace:vcg::vertex
TexCoordEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  bool TexCoordEnabled;$/;"	m	class:vcg::vertex::vector_ocf
TexCoordOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class A, class TT> class TexCoordOcc: public TT {$/;"	c	namespace:vcg::vertex
TexCoordOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class A, class TT> class TexCoordOcf: public TT {$/;"	c	namespace:vcg::vertex
TexCoordType	vcglib/vcg/simplex/face/component.h	/^  typedef A TexCoordType;$/;"	t	class:vcg::face::WedgeTexCoord
TexCoordType	vcglib/vcg/simplex/face/component.h	/^  typedef vcg::TexCoord2<float,1> TexCoordType;$/;"	t	class:vcg::face::EmptyCore
TexCoordType	vcglib/vcg/simplex/face/component_ocf.h	/^  typedef A TexCoordType;$/;"	t	class:vcg::face::WedgeTexCoordOcf
TexCoordType	vcglib/vcg/simplex/vertex/component.h	/^  typedef A TexCoordType;$/;"	t	class:vcg::vertex::TexCoord
TexCoordType	vcglib/vcg/simplex/vertex/component.h	/^  typedef vcg::TexCoord2<float,1> TexCoordType;$/;"	t	class:vcg::vertex::EmptyCore
TexCoordType	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef A TexCoordType;$/;"	t	class:vcg::vertex::TexCoordOcc
TexCoordType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef A TexCoordType;$/;"	t	class:vcg::vertex::TexCoordOcf
TexCoordfOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class TexCoordfOcf: public TexCoordOcf<TexCoord2<float,1>, T> {$/;"	c	namespace:vcg::vertex
TexDecimation	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^void TexDecimation(MyMesh &m, bool CleaningFlag,int TargetFaceNum)$/;"	f
TexInd	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^unsigned int TexInd=0;$/;"	v
TextUtility	vcglib/wrap/io_trimesh/export_idtf.h	/^class TextUtility$/;"	c
TextVector	vcglib/wrap/glw/utility.h	/^		typedef std::vector<std::string>             TextVector;$/;"	t	class:glw::ShaderHeaderBuilder
Texture	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void Texture(MetroMesh & m, VertexSampler &ps, int textureWidth, int textureHeight, bool correctSafePointsBaryCoords=true)$/;"	f	class:vcg::tri::SurfaceSampling
Texture	vcglib/wrap/gl/fbo.h	/^	Texture(void) : GLObject(), Bindable(), FrameBufferSemantic()$/;"	f	class:Texture
Texture	vcglib/wrap/gl/fbo.h	/^class Texture : public GLObject, public Bindable, public FrameBufferSemantic$/;"	c
Texture	vcglib/wrap/glw/texture.h	/^		Texture(Context * ctx)$/;"	f	class:glw::Texture
Texture	vcglib/wrap/glw/texture.h	/^class Texture : public Renderable$/;"	c	namespace:glw
Texture1D	vcglib/wrap/gl/fbo.h	/^	Texture1D(void) : Texture()$/;"	f	class:Texture1D
Texture1D	vcglib/wrap/gl/fbo.h	/^class Texture1D : public virtual Texture$/;"	c
Texture2D	vcglib/wrap/gl/fbo.h	/^	Texture2D(void) : Texture()$/;"	f	class:Texture2D
Texture2D	vcglib/wrap/gl/fbo.h	/^class Texture2D : public virtual Texture$/;"	c
Texture2D	vcglib/wrap/glw/texture2d.h	/^		Texture2D(Context * ctx)$/;"	f	class:glw::Texture2D
Texture2D	vcglib/wrap/glw/texture2d.h	/^class Texture2D : public Texture$/;"	c	namespace:glw
Texture2DArguments	vcglib/wrap/glw/texture2d.h	/^		Texture2DArguments(void)$/;"	f	class:glw::Texture2DArguments
Texture2DArguments	vcglib/wrap/glw/texture2d.h	/^class Texture2DArguments : public TextureArguments$/;"	c	namespace:glw
Texture2DBindingParams	vcglib/wrap/glw/texture2d.h	/^		Texture2DBindingParams(GLenum aUnit)$/;"	f	class:glw::Texture2DBindingParams
Texture2DBindingParams	vcglib/wrap/glw/texture2d.h	/^		Texture2DBindingParams(void)$/;"	f	class:glw::Texture2DBindingParams
Texture2DBindingParams	vcglib/wrap/glw/texture2d.h	/^class Texture2DBindingParams : public TextureBindingParams$/;"	c	namespace:glw
Texture2DHandle	vcglib/wrap/glw/texture2d.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeTexture2D> ::Type Texture2DHandle;$/;"	t	namespace:glw
Texture2DPtr	vcglib/wrap/glw/texture2d.h	/^typedef   detail::ObjectSharedPointerTraits  <Texture2D> ::Type Texture2DPtr;$/;"	t	namespace:glw
Texture2DType	vcglib/wrap/glw/type.h	/^	Texture2DType,$/;"	e	enum:glw::Type
Texture3D	vcglib/wrap/gl/fbo.h	/^	Texture3D(void) : Texture()$/;"	f	class:Texture3D
Texture3D	vcglib/wrap/gl/fbo.h	/^class Texture3D : public virtual Texture$/;"	c
TextureArguments	vcglib/wrap/glw/texture.h	/^		TextureArguments(void)$/;"	f	class:glw::TextureArguments
TextureArguments	vcglib/wrap/glw/texture.h	/^class TextureArguments : public RenderableArguments$/;"	c	namespace:glw
TextureBindingParams	vcglib/wrap/glw/texture.h	/^		TextureBindingParams(GLenum aTarget, GLenum aUnit)$/;"	f	class:glw::TextureBindingParams
TextureBindingParams	vcglib/wrap/glw/texture.h	/^		TextureBindingParams(void)$/;"	f	class:glw::TextureBindingParams
TextureBindingParams	vcglib/wrap/glw/texture.h	/^class TextureBindingParams : public RenderableBindingParams$/;"	c	namespace:glw
TextureCube	vcglib/wrap/glw/texturecube.h	/^		TextureCube(Context * ctx)$/;"	f	class:glw::TextureCube
TextureCube	vcglib/wrap/glw/texturecube.h	/^class TextureCube : public Texture$/;"	c	namespace:glw
TextureCubeArguments	vcglib/wrap/glw/texturecube.h	/^		TextureCubeArguments(void)$/;"	f	class:glw::TextureCubeArguments
TextureCubeArguments	vcglib/wrap/glw/texturecube.h	/^class TextureCubeArguments : public TextureArguments$/;"	c	namespace:glw
TextureCubeBindingParams	vcglib/wrap/glw/texturecube.h	/^		TextureCubeBindingParams(GLenum aUnit)$/;"	f	class:glw::TextureCubeBindingParams
TextureCubeBindingParams	vcglib/wrap/glw/texturecube.h	/^		TextureCubeBindingParams(void)$/;"	f	class:glw::TextureCubeBindingParams
TextureCubeBindingParams	vcglib/wrap/glw/texturecube.h	/^class TextureCubeBindingParams : public TextureBindingParams$/;"	c	namespace:glw
TextureCubeHandle	vcglib/wrap/glw/texturecube.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeTextureCube> ::Type TextureCubeHandle;$/;"	t	namespace:glw
TextureCubePtr	vcglib/wrap/glw/texturecube.h	/^typedef   detail::ObjectSharedPointerTraits  <TextureCube> ::Type TextureCubePtr;$/;"	t	namespace:glw
TextureCubeType	vcglib/wrap/glw/type.h	/^	TextureCubeType,$/;"	e	enum:glw::Type
TextureHandle	vcglib/wrap/glw/texture.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeTexture> ::Type TextureHandle;$/;"	t	namespace:glw
TextureMode	vcglib/wrap/gl/trimesh.h	/^    enum TextureMode{TMNone, TMPerVert, TMPerWedge, TMPerWedgeMulti};$/;"	g	class:vcg::GLW
TextureOptimizer	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  TextureOptimizer(MeshType &_m):m(_m),isFixed(_m.vert){$/;"	f	class:vcg::tri::TextureOptimizer
TextureOptimizer	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^class TextureOptimizer{$/;"	c	namespace:vcg::tri
TexturePtr	vcglib/wrap/glw/texture.h	/^typedef   detail::ObjectSharedPointerTraits  <Texture> ::Type TexturePtr;$/;"	t	namespace:glw
TextureRenderTarget	vcglib/wrap/gl/fbo.h	/^	TextureRenderTarget(void) : RenderTarget()$/;"	f	class:TextureRenderTarget
TextureRenderTarget	vcglib/wrap/gl/fbo.h	/^class TextureRenderTarget : public virtual RenderTarget$/;"	c
TextureSampleMode	vcglib/wrap/glw/texture.h	/^		TextureSampleMode(GLenum rMinFilter, GLenum rMagFilter, GLenum rWrapS, GLenum rWrapT, GLenum rWrapR)$/;"	f	class:glw::TextureSampleMode
TextureSampleMode	vcglib/wrap/glw/texture.h	/^		TextureSampleMode(void)$/;"	f	class:glw::TextureSampleMode
TextureSampleMode	vcglib/wrap/glw/texture.h	/^class TextureSampleMode$/;"	c	namespace:glw
TextureTag	vcglib/wrap/dae/colladaformat.h	/^		TextureTag(const QString& texture,const QString& texcoord)$/;"	f	class:Collada::Tags::TextureTag
TextureTag	vcglib/wrap/dae/colladaformat.h	/^	class TextureTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
ThenMatrixNested	vcglib/eigenlib/Eigen/src/Core/Select.h	/^  typedef typename ThenMatrixType::Nested ThenMatrixNested;$/;"	t	struct:Eigen::internal::traits
ThisConstantIsPrivateInPlainObjectBase	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::DenseBase::__anon59
ThisConstantIsPrivateInPlainObjectBase	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::PlainObjectBase::__anon191
ThisType	vcglib/vcg/complex/algorithms/attribute_seam.h	/^        typedef AttributeSeam ThisType;$/;"	t	class:vcg::tri::AttributeSeam
ThisType	vcglib/vcg/container/vector_occ.h	/^	typedef  vector_occ<VALUE_TYPE> ThisType;$/;"	t	class:vcg::vector_occ
ThisType	vcglib/wrap/glw/bookkeeping.h	/^		typedef ObjectSharedPointer<TObject, TDeleter, NoType>    ThisType;$/;"	t	class:glw::detail::ObjectSharedPointer
ThisType	vcglib/wrap/glw/bookkeeping.h	/^		typedef ObjectSharedPointer<TObject, TDeleter, TBaseObject>                             ThisType;$/;"	t	class:glw::detail::ObjectSharedPointer
ThisType	vcglib/wrap/glw/bookkeeping.h	/^		typedef RefCountedObject<TObject, TDeleter, NoType> ThisType;$/;"	t	class:glw::detail::RefCountedObject
ThisType	vcglib/wrap/glw/bookkeeping.h	/^		typedef RefCountedObject<TObject, TDeleter, TBaseObject>                            ThisType;$/;"	t	class:glw::detail::RefCountedObject
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef BoundBuffer ThisType;$/;"	t	class:glw::BoundBuffer
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef BoundFeedbackBuffer ThisType;$/;"	t	class:glw::BoundFeedbackBuffer
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef BoundIndexBuffer ThisType;$/;"	t	class:glw::BoundIndexBuffer
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef BoundPixelPackBuffer ThisType;$/;"	t	class:glw::BoundPixelPackBuffer
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef BoundPixelUnpackBuffer ThisType;$/;"	t	class:glw::BoundPixelUnpackBuffer
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef BoundUniformBuffer ThisType;$/;"	t	class:glw::BoundUniformBuffer
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef BoundVertexBuffer ThisType;$/;"	t	class:glw::BoundVertexBuffer
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef Buffer ThisType;$/;"	t	class:glw::Buffer
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef BufferArguments ThisType;$/;"	t	class:glw::BufferArguments
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef BufferBindingParams ThisType;$/;"	t	class:glw::BufferBindingParams
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef FeedbackBufferBindingParams ThisType;$/;"	t	class:glw::FeedbackBufferBindingParams
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef IndexBufferBindingParams ThisType;$/;"	t	class:glw::IndexBufferBindingParams
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef PixelPackBufferBindingParams ThisType;$/;"	t	class:glw::PixelPackBufferBindingParams
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef PixelUnpackBufferBindingParams ThisType;$/;"	t	class:glw::PixelUnpackBufferBindingParams
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef SafeBuffer ThisType;$/;"	t	class:glw::SafeBuffer
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef UniformBufferBindingParams ThisType;$/;"	t	class:glw::UniformBufferBindingParams
ThisType	vcglib/wrap/glw/buffer.h	/^		typedef VertexBufferBindingParams ThisType;$/;"	t	class:glw::VertexBufferBindingParams
ThisType	vcglib/wrap/glw/context.h	/^		typedef Context             ThisType;$/;"	t	class:glw::Context
ThisType	vcglib/wrap/glw/fragmentshader.h	/^		typedef BoundFragmentShader ThisType;$/;"	t	class:glw::BoundFragmentShader
ThisType	vcglib/wrap/glw/fragmentshader.h	/^		typedef FragmentShader ThisType;$/;"	t	class:glw::FragmentShader
ThisType	vcglib/wrap/glw/fragmentshader.h	/^		typedef FragmentShaderArguments ThisType;$/;"	t	class:glw::FragmentShaderArguments
ThisType	vcglib/wrap/glw/fragmentshader.h	/^		typedef FragmentShaderBindingParams ThisType;$/;"	t	class:glw::FragmentShaderBindingParams
ThisType	vcglib/wrap/glw/fragmentshader.h	/^		typedef SafeFragmentShader ThisType;$/;"	t	class:glw::SafeFragmentShader
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef BoundDrawFramebuffer ThisType;$/;"	t	class:glw::BoundDrawFramebuffer
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef BoundFramebuffer ThisType;$/;"	t	class:glw::BoundFramebuffer
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef BoundReadDrawFramebuffer ThisType;$/;"	t	class:glw::BoundReadDrawFramebuffer
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef BoundReadFramebuffer ThisType;$/;"	t	class:glw::BoundReadFramebuffer
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef DrawFramebufferBindingParams ThisType;$/;"	t	class:glw::DrawFramebufferBindingParams
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef Framebuffer ThisType;$/;"	t	class:glw::Framebuffer
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef FramebufferArguments ThisType;$/;"	t	class:glw::FramebufferArguments
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef FramebufferBindingParams ThisType;$/;"	t	class:glw::FramebufferBindingParams
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef ReadDrawFramebufferBindingParams ThisType;$/;"	t	class:glw::ReadDrawFramebufferBindingParams
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef ReadFramebufferBindingParams ThisType;$/;"	t	class:glw::ReadFramebufferBindingParams
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef RenderTarget ThisType;$/;"	t	class:glw::RenderTarget
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef RenderTargetBinding ThisType;$/;"	t	class:glw::RenderTargetBinding
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef RenderTargetMapping ThisType;$/;"	t	class:glw::RenderTargetMapping
ThisType	vcglib/wrap/glw/framebuffer.h	/^		typedef SafeFramebuffer ThisType;$/;"	t	class:glw::SafeFramebuffer
ThisType	vcglib/wrap/glw/geometryshader.h	/^		typedef BoundGeometryShader ThisType;$/;"	t	class:glw::BoundGeometryShader
ThisType	vcglib/wrap/glw/geometryshader.h	/^		typedef GeometryShader ThisType;$/;"	t	class:glw::GeometryShader
ThisType	vcglib/wrap/glw/geometryshader.h	/^		typedef GeometryShaderArguments ThisType;$/;"	t	class:glw::GeometryShaderArguments
ThisType	vcglib/wrap/glw/geometryshader.h	/^		typedef GeometryShaderBindingParams ThisType;$/;"	t	class:glw::GeometryShaderBindingParams
ThisType	vcglib/wrap/glw/geometryshader.h	/^		typedef SafeGeometryShader ThisType;$/;"	t	class:glw::SafeGeometryShader
ThisType	vcglib/wrap/glw/noncopyable.h	/^		typedef NonCopyable ThisType;$/;"	t	class:glw::detail::NonCopyable
ThisType	vcglib/wrap/glw/object.h	/^		typedef BoundObject           ThisType;$/;"	t	class:glw::BoundObject
ThisType	vcglib/wrap/glw/object.h	/^		typedef Object              ThisType;$/;"	t	class:glw::Object
ThisType	vcglib/wrap/glw/object.h	/^		typedef ObjectArguments ThisType;$/;"	t	class:glw::ObjectArguments
ThisType	vcglib/wrap/glw/object.h	/^		typedef ObjectBindingParams ThisType;$/;"	t	class:glw::ObjectBindingParams
ThisType	vcglib/wrap/glw/object.h	/^		typedef SafeObject          ThisType;$/;"	t	class:glw::SafeObject
ThisType	vcglib/wrap/glw/objectdeleter.h	/^		typedef ObjectDeleter ThisType;$/;"	t	class:glw::detail::ObjectDeleter
ThisType	vcglib/wrap/glw/program.h	/^				typedef UniformInfo ThisType;$/;"	t	class:glw::Program::UniformInfo
ThisType	vcglib/wrap/glw/program.h	/^		typedef BoundProgram ThisType;$/;"	t	class:glw::BoundProgram
ThisType	vcglib/wrap/glw/program.h	/^		typedef FragmentOutputBinding ThisType;$/;"	t	class:glw::FragmentOutputBinding
ThisType	vcglib/wrap/glw/program.h	/^		typedef GeometryStage ThisType;$/;"	t	class:glw::GeometryStage
ThisType	vcglib/wrap/glw/program.h	/^		typedef Program ThisType;$/;"	t	class:glw::Program
ThisType	vcglib/wrap/glw/program.h	/^		typedef ProgramArguments   ThisType;$/;"	t	class:glw::ProgramArguments
ThisType	vcglib/wrap/glw/program.h	/^		typedef ProgramBindingParams ThisType;$/;"	t	class:glw::ProgramBindingParams
ThisType	vcglib/wrap/glw/program.h	/^		typedef RasterizerSettings ThisType;$/;"	t	class:glw::RasterizerSettings
ThisType	vcglib/wrap/glw/program.h	/^		typedef SafeProgram ThisType;$/;"	t	class:glw::SafeProgram
ThisType	vcglib/wrap/glw/program.h	/^		typedef TransformFeedbackStream ThisType;$/;"	t	class:glw::TransformFeedbackStream
ThisType	vcglib/wrap/glw/program.h	/^		typedef VertexAttributeBinding ThisType;$/;"	t	class:glw::VertexAttributeBinding
ThisType	vcglib/wrap/glw/renderable.h	/^		typedef BoundRenderable ThisType;$/;"	t	class:glw::BoundRenderable
ThisType	vcglib/wrap/glw/renderable.h	/^		typedef Renderable ThisType;$/;"	t	class:glw::Renderable
ThisType	vcglib/wrap/glw/renderable.h	/^		typedef RenderableArguments ThisType;$/;"	t	class:glw::RenderableArguments
ThisType	vcglib/wrap/glw/renderable.h	/^		typedef RenderableBindingParams ThisType;$/;"	t	class:glw::RenderableBindingParams
ThisType	vcglib/wrap/glw/renderable.h	/^		typedef SafeRenderable ThisType;$/;"	t	class:glw::SafeRenderable
ThisType	vcglib/wrap/glw/renderbuffer.h	/^		typedef BoundRenderbuffer ThisType;$/;"	t	class:glw::BoundRenderbuffer
ThisType	vcglib/wrap/glw/renderbuffer.h	/^		typedef Renderbuffer ThisType;$/;"	t	class:glw::Renderbuffer
ThisType	vcglib/wrap/glw/renderbuffer.h	/^		typedef RenderbufferArguments ThisType;$/;"	t	class:glw::RenderbufferArguments
ThisType	vcglib/wrap/glw/renderbuffer.h	/^		typedef RenderbufferBindingParams ThisType;$/;"	t	class:glw::RenderbufferBindingParams
ThisType	vcglib/wrap/glw/renderbuffer.h	/^		typedef SafeRenderbuffer ThisType;$/;"	t	class:glw::SafeRenderbuffer
ThisType	vcglib/wrap/glw/shader.h	/^		typedef BoundShader ThisType;$/;"	t	class:glw::BoundShader
ThisType	vcglib/wrap/glw/shader.h	/^		typedef SafeShader ThisType;$/;"	t	class:glw::SafeShader
ThisType	vcglib/wrap/glw/shader.h	/^		typedef Shader ThisType;$/;"	t	class:glw::Shader
ThisType	vcglib/wrap/glw/shader.h	/^		typedef ShaderArguments ThisType;$/;"	t	class:glw::ShaderArguments
ThisType	vcglib/wrap/glw/shader.h	/^		typedef ShaderBindingParams ThisType;$/;"	t	class:glw::ShaderBindingParams
ThisType	vcglib/wrap/glw/texture.h	/^		typedef BoundTexture ThisType;$/;"	t	class:glw::BoundTexture
ThisType	vcglib/wrap/glw/texture.h	/^		typedef SafeTexture ThisType;$/;"	t	class:glw::SafeTexture
ThisType	vcglib/wrap/glw/texture.h	/^		typedef Texture     ThisType;$/;"	t	class:glw::Texture
ThisType	vcglib/wrap/glw/texture.h	/^		typedef TextureArguments    ThisType;$/;"	t	class:glw::TextureArguments
ThisType	vcglib/wrap/glw/texture.h	/^		typedef TextureBindingParams ThisType;$/;"	t	class:glw::TextureBindingParams
ThisType	vcglib/wrap/glw/texture.h	/^		typedef TextureSampleMode ThisType;$/;"	t	class:glw::TextureSampleMode
ThisType	vcglib/wrap/glw/texture2d.h	/^		typedef BoundTexture2D ThisType;$/;"	t	class:glw::BoundTexture2D
ThisType	vcglib/wrap/glw/texture2d.h	/^		typedef SafeTexture2D ThisType;$/;"	t	class:glw::SafeTexture2D
ThisType	vcglib/wrap/glw/texture2d.h	/^		typedef Texture2D ThisType;$/;"	t	class:glw::Texture2D
ThisType	vcglib/wrap/glw/texture2d.h	/^		typedef Texture2DArguments ThisType;$/;"	t	class:glw::Texture2DArguments
ThisType	vcglib/wrap/glw/texture2d.h	/^		typedef Texture2DBindingParams ThisType;$/;"	t	class:glw::Texture2DBindingParams
ThisType	vcglib/wrap/glw/texturecube.h	/^		typedef BoundTextureCube ThisType;$/;"	t	class:glw::BoundTextureCube
ThisType	vcglib/wrap/glw/texturecube.h	/^		typedef SafeTextureCube ThisType;$/;"	t	class:glw::SafeTextureCube
ThisType	vcglib/wrap/glw/texturecube.h	/^		typedef TextureCube ThisType;$/;"	t	class:glw::TextureCube
ThisType	vcglib/wrap/glw/texturecube.h	/^		typedef TextureCubeArguments ThisType;$/;"	t	class:glw::TextureCubeArguments
ThisType	vcglib/wrap/glw/texturecube.h	/^		typedef TextureCubeBindingParams ThisType;$/;"	t	class:glw::TextureCubeBindingParams
ThisType	vcglib/wrap/glw/utility.h	/^		typedef ShaderHeaderBuilder ThisType;$/;"	t	class:glw::ShaderHeaderBuilder
ThisType	vcglib/wrap/glw/vertexshader.h	/^		typedef BoundVertexShader ThisType;$/;"	t	class:glw::BoundVertexShader
ThisType	vcglib/wrap/glw/vertexshader.h	/^		typedef SafeVertexShader ThisType;$/;"	t	class:glw::SafeVertexShader
ThisType	vcglib/wrap/glw/vertexshader.h	/^		typedef VertexShader ThisType;$/;"	t	class:glw::VertexShader
ThisType	vcglib/wrap/glw/vertexshader.h	/^		typedef VertexShaderArguments ThisType;$/;"	t	class:glw::VertexShaderArguments
ThisType	vcglib/wrap/glw/vertexshader.h	/^		typedef VertexShaderBindingParams ThisType;$/;"	t	class:glw::VertexShaderBindingParams
ThisTypeIterator	vcglib/vcg/simplex/face/component_ocf.h	/^    typedef typename vector_ocf<VALUE_TYPE>::iterator ThisTypeIterator;$/;"	t	class:vcg::face::vector_ocf
ThisTypeIterator	vcglib/vcg/simplex/vertex/component_ocf.h	/^	typedef typename vector_ocf<VALUE_TYPE>::iterator ThisTypeIterator;$/;"	t	class:vcg::vertex::vector_ocf
Through	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane
Through	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane
Through	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine
Through	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane
Through	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane
Through	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine
Tiling1	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling1(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling10_1_1	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling10_1_1(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling10_1_1_	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling10_1_1_(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling10_1_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling10_1_2(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling10_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling10_2(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling10_2_	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling10_2_(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling11	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling11(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling12_1_1	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling12_1_1(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling12_1_1_	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling12_1_1_(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling12_1_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling12_1_2(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling12_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling12_2(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling12_2_	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling12_2_(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling13_1	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling13_1(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling13_1_	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling13_1_(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling13_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling13_2(unsigned char config, unsigned char u)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling13_2_	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling13_2_(unsigned char config, unsigned char u)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling13_3	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling13_3(unsigned char config, unsigned int u)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling13_3_	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling13_3_(unsigned char config, unsigned char u)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling13_4	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling13_4(unsigned char config, unsigned int u)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling13_5_1	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling13_5_1(unsigned char config, int u)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling13_5_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling13_5_2(unsigned char config, int u)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling14	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling14(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling2(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling3_1	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling3_1(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling3_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling3_2(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling4_1	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling4_1(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling4_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling4_2(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling5	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling5(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling6_1_1	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling6_1_1(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling6_1_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling6_1_2(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling6_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling6_2(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling7_1	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling7_1(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling7_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling7_2(unsigned char config, int u)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling7_3	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling7_3(unsigned char config, unsigned char u)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling7_4_1	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling7_4_1(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling7_4_2	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling7_4_2(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling8	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling8(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tiling9	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^			static const char* Tiling9(unsigned char config)$/;"	f	class:vcg::tri::MCLookUpTable
Tmark	vcglib/vcg/complex/algorithms/closest.h	/^			Tmark(	MESH_TYPE *m) {SetMesh(m);}$/;"	f	class:vcg::tri::Tmark
Tmark	vcglib/vcg/complex/algorithms/closest.h	/^			Tmark(){}$/;"	f	class:vcg::tri::Tmark
Tmark	vcglib/vcg/complex/algorithms/closest.h	/^		class Tmark$/;"	c	namespace:vcg::tri
TmpFlags	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    TmpFlags = _MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon359
TmpMatrixType	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1, Options, MaxRowsAtCompileTime, 1> TmpMatrixType;$/;"	t	class:Eigen::LDLT
ToAscii	vcglib/wrap/gui/trackball.cpp	/^void Trackball::ToAscii(char* result){$/;"	f	class:Trackball
ToAxis	vcglib/vcg/math/quaternion.h	/^template <class S> void Quaternion<S>::ToAxis(S &phi, Point3<S> &a) const {$/;"	f	class:vcg::Quaternion
ToCartesian	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 & ToCartesian() {$/;"	f	class:vcg::ndim::Point2
ToColor4b	vcglib/wrap/qt/col_qt_convert.h	/^		inline static vcg::Color4b ToColor4b(const QColor& col)$/;"	f	class:vcg::ColorConverter
ToDeg	vcglib/vcg/math/base.h	/^inline double  ToDeg(const double &a){return a*180.0\/M_PI;}$/;"	f	namespace:vcg::math
ToDeg	vcglib/vcg/math/base.h	/^inline float   ToDeg(const float &a){return a*180.0f\/float(M_PI);}$/;"	f	namespace:vcg::math
ToEigenMatrix	vcglib/vcg/math/matrix33.h	/^    void ToEigenMatrix(EigenMatrix33Type & m) const {$/;"	f	class:vcg::Matrix33
ToEigenMatrix	vcglib/vcg/math/matrix44.h	/^	void ToEigenMatrix(EigenMatrix44Type & m) const {$/;"	f	class:vcg::Matrix44
ToEigenVector	vcglib/vcg/space/deprecated_point3.h	/^    inline void ToEigenVector( EigenVector & b ) const$/;"	f	class:vcg::Point3
ToEulerAngles	vcglib/vcg/math/matrix44.h	/^void Matrix44<T>::ToEulerAngles(T &alpha, T &beta, T &gamma)$/;"	f	class:vcg::Matrix44
ToEulerAngles	vcglib/vcg/math/old_matrix44.h	/^void Matrix44<T>::ToEulerAngles(Scalar &alpha, Scalar &beta, Scalar &gamma)$/;"	f	class:vcg::Matrix44
ToEulerAngles	vcglib/vcg/math/quaternion.h	/^void Quaternion<S>::ToEulerAngles(S &alpha, S &beta, S &gamma) const$/;"	f	class:vcg::Quaternion
ToMatrix	vcglib/vcg/math/matrix44.h	/^	void ToMatrix(Matrix44Type & m) const {for(int i = 0; i < 16; i++) m.V()[i]=V()[i];}$/;"	f	class:vcg::Matrix44
ToMatrix	vcglib/vcg/math/old_matrix44.h	/^	void ToMatrix(Matrix44Type & m) const { m = (*this).template cast<typename Matrix44Type::Scalar>(); }$/;"	f	class:vcg::Matrix44
ToMatrix	vcglib/vcg/math/quaternion.h	/^template <class S> void Quaternion<S>::ToMatrix(Matrix33<S> &m) const	{$/;"	f	class:vcg::Quaternion
ToMatrix	vcglib/vcg/math/quaternion.h	/^template <class S> void Quaternion<S>::ToMatrix(Matrix44<S> &m) const	{$/;"	f	class:vcg::Quaternion
ToPolar	vcglib/vcg/math/eigen_matrix_addons.h	/^void ToPolar(Scalar &ro, Scalar &theta, Scalar &phi) const$/;"	f
ToPolar	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 & ToPolar(){$/;"	f	class:vcg::ndim::Point2
ToPolar	vcglib/vcg/space/deprecated_point.h	/^	void ToPolar( S & ro, S & tetha, S & fi ) const$/;"	f	class:vcg::ndim::Point
ToPolarRad	vcglib/vcg/space/deprecated_point3.h	/^    void ToPolarRad(P3ScalarType &ro, P3ScalarType &theta, P3ScalarType &phi) const$/;"	f	class:vcg::Point3
ToQColor	vcglib/wrap/qt/col_qt_convert.h	/^		inline static QColor ToQColor(const vcg::Color4b& col) $/;"	f	class:vcg::ColorConverter
ToRad	vcglib/vcg/math/base.h	/^inline double  ToRad(const double &a){return M_PI*a\/180.0;}$/;"	f	namespace:vcg::math
ToRad	vcglib/vcg/math/base.h	/^inline float   ToRad(const float &a){return float(M_PI)*a\/180.0f;}$/;"	f	namespace:vcg::math
ToSplit	vcglib/wrap/miq/quadrangulator.h	/^    static bool ToSplit(const vcg::Point2<ScalarType> &uv0,$/;"	f	class:Quadrangulator
ToSplit	vcglib/wrap/miq/quadrangulator.h	/^    static bool ToSplit(const vcg::face::Pos<TriFaceType> &ep,$/;"	f	class:Quadrangulator
ToUnsignedB5G5R5	vcglib/vcg/space/color4.h	/^inline static unsigned short ToUnsignedB5G5R5(Color4 &) { return 0;}$/;"	f	class:vcg::Color4
ToUnsignedB5G5R5	vcglib/vcg/space/color4.h	/^inline unsigned short Color4<unsigned char>::ToUnsignedB5G5R5(Color4<unsigned char> &cc)$/;"	f	class:vcg::Color4
ToUnsignedR5G5B5	vcglib/vcg/space/color4.h	/^inline static unsigned short ToUnsignedR5G5B5(Color4 &) { return 0;}$/;"	f	class:vcg::Color4
ToUnsignedR5G5B5	vcglib/vcg/space/color4.h	/^inline unsigned short Color4<unsigned char>::ToUnsignedR5G5B5(Color4<unsigned char> &cc)$/;"	f	class:vcg::Color4
ToUpdate	vcglib/vcg/space/index/space_iterators.h	/^		bool ToUpdate()$/;"	f	class:vcg::ClosestIterator
Toggle	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void Toggle(bool &flag) {flag = !flag;}$/;"	f
Token	vcglib/wrap/gcache/token.h	/^    Token(): count(OUTSIDE) {}$/;"	f	class:vcg::Token
Token	vcglib/wrap/gcache/token.h	/^class Token {$/;"	c	namespace:vcg
TokenizeNextLine	vcglib/wrap/io_trimesh/import_obj.h	/^                inline static void TokenizeNextLine(std::ifstream &stream, std::vector< std::string > &tokens, std::vector<Color4b> *colVec)$/;"	f	class:vcg::tri::io::ImporterOBJ
TokenizeNextLine	vcglib/wrap/io_trimesh/import_off.h	/^  inline static void TokenizeNextLine(std::ifstream &stream, std::vector< std::string > &tokens)$/;"	f	class:vcg::tri::io::ImporterOFF
TolTooSmall	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        TolTooSmall = 3,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
TooManyFunctionEvaluation	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        TooManyFunctionEvaluation = 2,$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
TooManyFunctionEvaluation	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        TooManyFunctionEvaluation = 5,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
TopLeft	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopLeft	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeftCeil	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeftFloor	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRight	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopRight	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightCeil	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightFloor	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopoEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	inline TopoEdgeFlip() {}$/;"	f	class:vcg::tri::TopoEdgeFlip
TopoEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	inline TopoEdgeFlip(const TopoEdgeFlip &par)$/;"	f	class:vcg::tri::TopoEdgeFlip
TopoEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  inline TopoEdgeFlip(const PosType pos, int mark, BaseParameterClass *pp)$/;"	f	class:vcg::tri::TopoEdgeFlip
TopoEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^class TopoEdgeFlip : public PlanarEdgeFlip<TRIMESH_TYPE, MYTYPE>$/;"	c	namespace:vcg::tri
TopologicalVertexColoring	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void TopologicalVertexColoring(MeshType &m, std::vector<VertexType *> &seedVec)$/;"	f	class:vcg::tri::VoronoiProcessing
Torus	vcglib/vcg/complex/algorithms/create/platonic.h	/^void Torus(MeshType &m, float hRingRadius, float vRingRadius, int hRingDiv=24, int vRingDiv=12 )$/;"	f	namespace:vcg::tri
Tr	vcglib/wrap/io_trimesh/io_material.h	/^		float Tr;\/\/alpha$/;"	m	struct:vcg::tri::io::Material
Tra	vcglib/vcg/math/shot.h	/^      Point3<ScalarType>   Tra() const  { return tra;}$/;"	f	class:vcg::Shot::ReferenceFrame
Trace	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED Scalar Trace() const { return trace(); }$/;"	f
Trace	vcglib/vcg/math/matrix33.h	/^S Trace() const$/;"	f	class:vcg::Matrix33
TrackMode	vcglib/wrap/gui/trackmode.h	/^class TrackMode {$/;"	c	namespace:vcg
TrackRecorder	vcglib/wrap/gui/trackrecorder.h	/^	TrackRecorder(){Stop();}$/;"	f	struct:vcg::TrackRecorder
TrackRecorder	vcglib/wrap/gui/trackrecorder.h	/^struct TrackRecorder{$/;"	s	namespace:vcg
Trackball	vcglib/wrap/gui/trackball.cpp	/^Trackball::Trackball(): current_button(0), current_mode(NULL), inactive_mode(NULL),$/;"	f	class:Trackball
Trackball	vcglib/wrap/gui/trackball.h	/^class Trackball: public Transform {$/;"	c	namespace:vcg
Traits	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    typedef internal::LDLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LDLT
Traits	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    typedef internal::LLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LLT
Traits	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::PermutationBase
Traits	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map
Traits	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationMatrix> Traits;$/;"	t	class:Eigen::PermutationMatrix
Traits	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationType> Traits;$/;"	t	class:Eigen::Transpose
Traits	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationWrapper> Traits;$/;"	t	class:Eigen::PermutationWrapper
Traits	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::TranspositionsBase
Traits	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map
Traits	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Transpositions> Traits;$/;"	t	class:Eigen::Transpositions
Traits	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<TranspositionsWrapper> Traits;$/;"	t	class:Eigen::TranspositionsWrapper
Traits	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> Traits;$/;"	t	struct:Eigen::internal::gebp_kernel
Traits	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef gebp_traits<LhsScalar,RhsScalar> Traits;$/;"	t	class:Eigen::internal::gemm_blocking_space
Traits	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;$/;"	t	struct:Eigen::internal::tribb_kernel
Traits	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  typedef gebp_traits<Scalar,Scalar> Traits;$/;"	t	struct:Eigen::internal::product_triangular_matrix_matrix
Traits	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef internal::pardiso_traits<Derived> Traits;$/;"	t	class:Eigen::PardisoImpl
Traits	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialCholesky> Traits;$/;"	t	class:Eigen::SimplicialCholesky
Traits	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT> Traits;$/;"	t	class:Eigen::SimplicialLDLT
Traits	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT> Traits;$/;"	t	class:Eigen::SimplicialLLT
Traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef internal::traits<SparseDenseOuterProduct> Traits;$/;"	t	class:Eigen::SparseDenseOuterProduct
Traits	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef internal::traits<MatrixType> Traits;$/;"	t	class:Eigen::MatrixFunction
TraitsBase	vcglib/eigenlib/Eigen/src/Core/Map.h	/^  typedef traits<PlainObjectType> TraitsBase;$/;"	t	struct:Eigen::internal::traits
TraitsBase	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    typedef traits<Quaternion<_Scalar, _Options> > TraitsBase;$/;"	t	struct:Eigen::internal::traits
TransfMatrix	vcglib/wrap/dae/util_dae.h	/^		static void TransfMatrix(const QDomNode parentnode,const QDomNode presentnode,vcg::Matrix44f& m)$/;"	f	class:vcg::tri::io::UtilDAE
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Transform /;"	d
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Transform$/;"	d
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform() { }$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r) { *this = r; }$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const ScalingType& s) { *this = s; }$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t) { *this = t; }$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  Transform(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform()$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,Mode,OtherOptions>& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim,Mode,Options>& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform
Transform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Transform	vcglib/wrap/gl/tetramesh.h	/^			void Transform(vcg::Matrix44<float> Tr)$/;"	f	class:vcg::tetra::GlTetramesh::ClipPlane
Transform	vcglib/wrap/gui/trackball.cpp	/^Transform::Transform() {$/;"	f	class:Transform
Transform	vcglib/wrap/gui/trackball.h	/^class Transform {$/;"	c	namespace:vcg
Transform2d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Transform2d /;"	d
Transform2d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Transform2d$/;"	d
Transform2d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,2> Transform2d;$/;"	t	namespace:Eigen
Transform2f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Transform2f /;"	d
Transform2f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Transform2f$/;"	d
Transform2f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,2> Transform2f;$/;"	t	namespace:Eigen
Transform3d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Transform3d /;"	d
Transform3d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Transform3d$/;"	d
Transform3d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,3> Transform3d;$/;"	t	namespace:Eigen
Transform3f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Transform3f /;"	d
Transform3f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Transform3f$/;"	d
Transform3f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,3> Transform3f;$/;"	t	namespace:Eigen
TransformFeedbackStream	vcglib/wrap/glw/program.h	/^		TransformFeedbackStream(void)$/;"	f	class:glw::TransformFeedbackStream
TransformFeedbackStream	vcglib/wrap/glw/program.h	/^class TransformFeedbackStream$/;"	c	namespace:glw
TransformGL	vcglib/wrap/gl/camera.h	/^static void TransformGL(vcg::Camera<S> & camera, S nearDist, S farDist ) $/;"	f	struct:GlCamera
TransformGL	vcglib/wrap/gl/shot.h	/^static void TransformGL(vcg::Shot<ScalarType> & shot)$/;"	f	struct:GlShot
TransformTimeDiagonalMode	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  enum { TransformTimeDiagonalMode = ((Mode==int(Isometry))?Affine:int(Mode)) };$/;"	e	enum:Eigen::Transform::__anon374
TransformTimeDiagonalReturnType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,TransformTimeDiagonalMode> TransformTimeDiagonalReturnType;$/;"	t	class:Eigen::Transform
TransformTraits	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^enum TransformTraits {$/;"	g	namespace:Eigen
TransformType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Scaling
TransformType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl
TransformType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl
TransformType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Translation
TransformType	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Mode, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product
TransformType	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Projective, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product
TransformType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,AffineCompact,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
TransformType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Mode,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
TransformationMatrix	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static vcg::Matrix33<ScalarType> TransformationMatrix(const FaceType &f)$/;"	f	class:vcg::tri::CrossField
TransformationMatrix	vcglib/vcg/math/matrix33.h	/^vcg::Matrix33<S> TransformationMatrix(const vcg::Point3<S> dirX,$/;"	f	namespace:vcg
Translate	vcglib/vcg/complex/algorithms/update/position.h	/^static void Translate(ComputeMeshType &m, const Point3<ScalarType> &t)$/;"	f	class:vcg::tri::UpdatePosition
Translate	vcglib/vcg/space/box.h	/^	void Translate( const PointType & p )$/;"	f	class:vcg::Box
Translate	vcglib/vcg/space/box2.h	/^	void Translate( const PointType & p )$/;"	f	class:vcg::Box2
Translate	vcglib/vcg/space/box3.h	/^    void Translate( const Point3<BoxScalarType> & p )$/;"	f	class:vcg::Box3
Translate	vcglib/wrap/gl/tetramesh.h	/^			void Translate(float L)$/;"	f	class:vcg::tetra::GlTetramesh::ClipPlane
Translate	vcglib/wrap/gui/trackball.cpp	/^void Trackball::Translate(Point3f tr)$/;"	f	class:Trackball
TranslateTag	vcglib/wrap/dae/colladaformat.h	/^		TranslateTag(const QString& sid,const vcg::Point4f& p)$/;"	f	class:Collada::Tags::TranslateTag
TranslateTag	vcglib/wrap/dae/colladaformat.h	/^	class TranslateTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
Translation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Translation /;"	d
Translation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Translation$/;"	d
Translation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation
Translation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation
Translation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation
Translation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation
Translation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation
Translation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Translation	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation
Translation	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation
Translation	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation
Translation	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation
Translation	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation
Translation	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Translation2d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Translation2d /;"	d
Translation2d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Translation2d$/;"	d
Translation2d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Translation2d	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Translation2f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Translation2f /;"	d
Translation2f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Translation2f$/;"	d
Translation2f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Translation2f	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Translation3d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Translation3d /;"	d
Translation3d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Translation3d$/;"	d
Translation3d	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Translation3d	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Translation3f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define Translation3f /;"	d
Translation3f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Translation3f$/;"	d
Translation3f	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
Translation3f	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
TranslationPart	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1> TranslationPart;$/;"	t	class:Eigen::Transform
TranslationPart	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1,int(Mode)==(AffineCompact)> TranslationPart;$/;"	t	class:Eigen::Transform
TranslationType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Scaling
TranslationType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform
TranslationType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform
TransparencyTag	vcglib/wrap/dae/colladaformat.h	/^		TransparencyTag()$/;"	f	class:Collada::Tags::TransparencyTag
TransparencyTag	vcglib/wrap/dae/colladaformat.h	/^	class TransparencyTag : public XMLTag$/;"	c	namespace:Collada::Tags
TransparentTag	vcglib/wrap/dae/colladaformat.h	/^		TransparentTag()$/;"	f	class:Collada::Tags::TransparentTag
TransparentTag	vcglib/wrap/dae/colladaformat.h	/^	class TransparentTag : public XMLTag$/;"	c	namespace:Collada::Tags
Transpose	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    Transpose(const PermutationType& p) : m_permutation(p) {}$/;"	f	class:Eigen::Transpose
Transpose	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^class Transpose<PermutationBase<Derived> >$/;"	c	namespace:Eigen
Transpose	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline Transpose(MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Transpose
Transpose	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class Transpose$/;"	c	namespace:Eigen
Transpose	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    Transpose(const TranspositionType& t) : m_transpositions(t) {}$/;"	f	class:Eigen::Transpose
Transpose	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^class Transpose<TranspositionsBase<TranspositionsDerived> >$/;"	c	namespace:Eigen
Transpose	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon207
Transpose	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon205
Transpose	vcglib/vcg/math/eigen.h	/^Transpose(const Eigen::Matrix<Scalar,Size,Size,StorageOrder>& m)$/;"	f	namespace:vcg
Transpose	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Derived& Transpose() { transposeInPlace(); return derived(); };$/;"	f
Transpose	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline const Eigen::Transpose<Derived> Transpose() const { return transpose(); };$/;"	f
Transpose	vcglib/vcg/math/matrix33.h	/^    Matrix33 & Transpose()$/;"	f	class:vcg::Matrix33
Transpose	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> &Transpose(Matrix44<T> &m) {$/;"	f	namespace:vcg
Transpose	vcglib/vcg/math/old_deprecated_matrix.h	/^			void Transpose()$/;"	f	class:vcg::ndim::Matrix
TransposeImpl	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Dense>$/;"	c	namespace:Eigen
TransposeImpl	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>$/;"	c	namespace:Eigen
TransposeImpl_base	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base$/;"	s	namespace:Eigen::internal
TransposeImpl_base	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base<MatrixType, false>$/;"	s	namespace:Eigen::internal
TransposeLhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    TransposeLhs = LhsRowMajor && (!RhsRowMajor)$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon423
TransposeMode	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      TransposeMode = (Mode & Upper ? Lower : 0)$/;"	e	enum:Eigen::TriangularView::__anon253
TransposeRhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    TransposeRhs = (!LhsRowMajor) && RhsRowMajor,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon423
TransposeTypeWithSameStorageOrder	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^          TransposeTypeWithSameStorageOrder;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
TransposedSkylineMatrix	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    typedef SkylineMatrix<Scalar, (Flags&~RowMajorBit) | (IsRowMajor ? RowMajorBit : 0) > TransposedSkylineMatrix;$/;"	t	class:Eigen::SkylineMatrix
TransposedSparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    typedef SparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)> TransposedSparseMatrix;$/;"	t	class:Eigen::SparseMatrix
TransposedSparseMatrix	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    typedef DynamicSparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)> TransposedSparseMatrix;$/;"	t	class:Eigen::DynamicSparseMatrix
TranspositionType	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::LDLT
TranspositionType	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsDerived TranspositionType;$/;"	t	class:Eigen::Transpose
TranspositionType	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::PartialPivLU
Transpositions	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    explicit inline Transpositions(const MatrixBase<Other>& indices) : m_indices(indices)$/;"	f	class:Eigen::Transpositions
Transpositions	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Transpositions() {}$/;"	f	class:Eigen::Transpositions
Transpositions	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(Index size) : m_indices(size)$/;"	f	class:Eigen::Transpositions
Transpositions	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const Transpositions& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::Transpositions
Transpositions	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions
Transpositions	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^class Transpositions : public TranspositionsBase<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	c	namespace:Eigen
TranspositionsBase	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^class TranspositionsBase$/;"	c	namespace:Eigen
TranspositionsWrapper	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline TranspositionsWrapper(IndicesType& indices)$/;"	f	class:Eigen::TranspositionsWrapper
TranspositionsWrapper	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^class TranspositionsWrapper$/;"	c	namespace:Eigen
Traversal	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    Traversal = int(MayInnerVectorize)  ? int(InnerVectorizedTraversal)$/;"	e	enum:Eigen::internal::assign_traits::__anon37
Traversal	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      Traversal = MayLinearize ? LinearVectorizedTraversal$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon44
Traversal	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)$/;"	e	enum:Eigen::internal::redux_traits::__anon225
TraversalSize	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    TraversalSize = Direction==Vertical ? RowsAtCompileTime : ColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon321
Tree	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	inline TreeType & Tree(void) {$/;"	f	class:vcg::AABBBinaryTreeIndex
Tree	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	inline const TreeType & Tree(void) const {$/;"	f	class:vcg::AABBBinaryTreeIndex
TreeTest	vcglib/eigenlib/unsupported/test/BVH.cpp	/^struct TreeTest$/;"	s	file:
TreeType	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	typedef AABBBinaryTree<ObjType, ScalarType, NodeAuxData> TreeType;$/;"	t	class:vcg::AABBBinaryTreeIndex
TreeType	vcglib/vcg/space/index/aabb_binary_tree/closest.h	/^	typedef TREETYPE TreeType;$/;"	t	class:vcg::AABBBinaryTreeClosest
TreeType	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	typedef TREETYPE TreeType;$/;"	t	class:vcg::AABBBinaryTreeFrustumCull
TreeType	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^	typedef TREETYPE TreeType;$/;"	t	class:vcg::AABBBinaryTreeKClosest
TreeType	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^	typedef TREETYPE TreeType;$/;"	t	class:vcg::AABBBinaryTreeRay
TriAreaGradient	vcglib/vcg/complex/algorithms/smooth.h	/^static CoordType TriAreaGradient(CoordType &p,CoordType &p0,CoordType &p1)$/;"	f	class:vcg::tri::Smooth
TriEdgeCollapse	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	inline	TriEdgeCollapse()$/;"	f	class:vcg::tri::TriEdgeCollapse
TriEdgeCollapse	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^   inline TriEdgeCollapse(const VertexPair &p, int mark, BaseParameterClass *pp)$/;"	f	class:vcg::tri::TriEdgeCollapse
TriEdgeCollapse	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^class TriEdgeCollapse: public LocalOptimization<TriMeshType>::LocModType$/;"	c	namespace:vcg::tri
TriEdgeCollapseOp	vcglib/vcg/complex/algorithms/local_optimization.h	/^				TriEdgeCollapseOp,TetraEdgeSpliOpt,TetraEdgeSwapOp, TriEdgeFlipOp,$/;"	e	enum:vcg::ModifierType
TriEdgeCollapseQuadric	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^	inline TriEdgeCollapseQuadric(){}$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
TriEdgeCollapseQuadric	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^    inline TriEdgeCollapseQuadric(const VertexPair &p, int i, BaseParameterClass *pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
TriEdgeCollapseQuadric	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^class TriEdgeCollapseQuadric: public TriEdgeCollapse< TriMeshType, VertexPair, MYTYPE>$/;"	c	namespace:vcg::tri
TriEdgeCollapseQuadricParameter	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  TriEdgeCollapseQuadricParameter() {this->SetDefaultParams();}$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricParameter
TriEdgeCollapseQuadricParameter	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^class TriEdgeCollapseQuadricParameter : public BaseParameterClass$/;"	c	namespace:vcg::tri
TriEdgeCollapseQuadricTex	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  inline TriEdgeCollapseQuadricTex(const VertexPair &p, int mark, BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
TriEdgeCollapseQuadricTex	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^class TriEdgeCollapseQuadricTex: public vcg::tri::TriEdgeCollapse< TriMeshType, VertexPair, MYTYPE>$/;"	c	namespace:vcg::tri
TriEdgeCollapseQuadricTexParameter	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  TriEdgeCollapseQuadricTexParameter()$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
TriEdgeCollapseQuadricTexParameter	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^class TriEdgeCollapseQuadricTexParameter : public BaseParameterClass$/;"	c	namespace:vcg::tri
TriEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	inline TriEdgeFlip() {}$/;"	f	class:vcg::tri::TriEdgeFlip
TriEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	inline TriEdgeFlip(const TriEdgeFlip &par)$/;"	f	class:vcg::tri::TriEdgeFlip
TriEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  inline TriEdgeFlip(const PosType pos, int mark, BaseParameterClass *pp)$/;"	f	class:vcg::tri::TriEdgeFlip
TriEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^class TriEdgeFlip : public PlanarEdgeFlip<TRIMESH_TYPE, MYTYPE>$/;"	c	namespace:vcg::tri
TriEdgeFlipOp	vcglib/vcg/complex/algorithms/local_optimization.h	/^				TriEdgeCollapseOp,TetraEdgeSpliOpt,TetraEdgeSwapOp, TriEdgeFlipOp,$/;"	e	enum:vcg::ModifierType
TriEdgeSwapOp	vcglib/vcg/complex/algorithms/local_optimization.h	/^enum ModifierType{	TetraEdgeCollapseOp, TriEdgeSwapOp, TriVertexSplitOp,$/;"	e	enum:vcg::ModifierType
TriFaceType	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^typedef CMesh::FaceType TriFaceType;$/;"	t	file:
TriFaceType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::FaceType TriFaceType;$/;"	t	class:vcg::tri::FeasibilityCheck
TriFaceType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::FaceType TriFaceType;$/;"	t	class:vcg::tri::FitmapsCollapse
TriFaceType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::FaceType TriFaceType;$/;"	t	class:vcg::tri::OperationWeight
TriFaceType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::FaceType TriFaceType;$/;"	t	class:vcg::tri::QuadDiagonalCollapse
TriFaceType	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename TriMeshType::FaceType TriFaceType;$/;"	t	class:vcg::tri::QuadDiagonalCollapseBase
TriFaceType	vcglib/wrap/miq/quadrangulator.h	/^    typedef typename TriMesh::FaceType TriFaceType;$/;"	t	class:Quadrangulator
TriHashSetIterator	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename STDEXT::hash_set<SimpleTri,SimpleTriHashFunc>::iterator TriHashSetIterator;$/;"	t	class:vcg::tri::Clustering
TriHashSetIterator	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename STDEXT::hash_set<SimpleTri>::iterator TriHashSetIterator;$/;"	t	class:vcg::tri::Clustering
TriMesh	vcglib/vcg/complex/base.h	/^    TriMesh()$/;"	f	class:vcg::tri::TriMesh
TriMesh	vcglib/vcg/complex/base.h	/^    TriMesh(const TriMesh & ){}$/;"	f	class:vcg::tri::TriMesh
TriMesh	vcglib/vcg/complex/base.h	/^class TriMesh$/;"	c	namespace:vcg::tri
TriMeshClipper	vcglib/vcg/complex/algorithms/clip.h	/^class TriMeshClipper$/;"	c	namespace:vcg::tri
TriMeshGrid	vcglib/apps/sample/trimesh_intersection/trimesh_intersection.cpp	/^typedef vcg::GridStaticPtr<MyMesh::FaceType, MyMesh::ScalarType> TriMeshGrid;$/;"	t	file:
TriMeshGrid	vcglib/apps/sample/trimesh_ray/trimesh_ray.cpp	/^typedef vcg::GridStaticPtr<MyMesh::FaceType, MyMesh::ScalarType> TriMeshGrid;$/;"	t	file:
TriMeshGrid	vcglib/vcg/complex/algorithms/clean.h	/^  typedef GridStaticPtr<FaceType, ScalarType > TriMeshGrid;$/;"	t	class:vcg::tri::Clean
TriMeshGrid	vcglib/vcg/complex/algorithms/point_sampling.h	/^typedef GridStaticPtr<FaceType, ScalarType > TriMeshGrid;$/;"	t	class:vcg::tri::SurfaceSampling
TriMeshType	vcglib/vcg/complex/algorithms/clip.h	/^	typedef TRIMESHTYPE TriMeshType;$/;"	t	class:vcg::tri::TriMeshClipper
TriMeshType	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  typedef	 TRI_MESH_TYPE TriMeshType;$/;"	t	class:vcg::tri::EdgeCollapser
TriNum	vcglib/vcg/complex/algorithms/refine.h	/^    int TriNum;			\/\/ number of triangles$/;"	m	class:vcg::tri::Split
TriRayIterator	vcglib/vcg/complex/algorithms/closest.h	/^			TriRayIterator(GridType &_Si,const ScalarType &max_d):RayBaseType(_Si,FintFunct(),max_d){}$/;"	f	class:vcg::tri::TriRayIterator
TriRayIterator	vcglib/vcg/complex/algorithms/closest.h	/^		class TriRayIterator:public vcg::RayIterator<GRID,vcg::RayTriangleIntersectionFunctor<true>,FaceTmark<MESH> >$/;"	c	namespace:vcg::tri
TriSet	vcglib/vcg/complex/algorithms/clustering.h	/^  STDEXT::hash_set<SimpleTri,SimpleTriHashFunc> TriSet;$/;"	m	class:vcg::tri::Clustering
TriSet	vcglib/vcg/complex/algorithms/clustering.h	/^  STDEXT::hash_set<SimpleTri> TriSet;$/;"	m	class:vcg::tri::Clustering
TriSplit	vcglib/vcg/complex/algorithms/refine.h	/^class TriSplit$/;"	c	namespace:vcg::tri
TriTable	vcglib/vcg/complex/algorithms/create/emc_lookup_table.h	/^			static int* TriTable(unsigned char cubetype, int u)$/;"	f	class:vcg::tri::EMCLookUpTable
TriVertexSplitOp	vcglib/vcg/complex/algorithms/local_optimization.h	/^enum ModifierType{	TetraEdgeCollapseOp, TriEdgeSwapOp, TriVertexSplitOp,$/;"	e	enum:vcg::ModifierType
TriVertexType	vcglib/wrap/miq/quadrangulator.h	/^    typedef typename TriMesh::VertexType TriVertexType;$/;"	t	class:Quadrangulator
Triangle2	vcglib/vcg/space/triangle2.h	/^	Triangle2()$/;"	f	class:vcg::Triangle2
Triangle2	vcglib/vcg/space/triangle2.h	/^	Triangle2(const CoordType &p0,const CoordType &p1,const CoordType &p2)$/;"	f	class:vcg::Triangle2
Triangle2	vcglib/vcg/space/triangle2.h	/^template <class SCALAR_TYPE> class Triangle2$/;"	c	namespace:vcg
Triangle3	vcglib/vcg/space/triangle3.h	/^	Triangle3(){}$/;"	f	class:vcg::Triangle3
Triangle3	vcglib/vcg/space/triangle3.h	/^	Triangle3(const CoordType & c0,const CoordType & c1,const CoordType & c2){_v[0]=c0;_v[1]=c1;_v[2]=c2;}$/;"	f	class:vcg::Triangle3
Triangle3	vcglib/vcg/space/triangle3.h	/^template <class ScalarTriangleType> class Triangle3$/;"	c	namespace:vcg
TriangleInfo	vcglib/vcg/complex/algorithms/clip.h	/^  class TriangleInfo$/;"	c	class:vcg::tri::TriMeshClipper
TriangleInfoVec	vcglib/vcg/complex/algorithms/clip.h	/^  typedef std::vector<TriangleInfo> TriangleInfoVec;$/;"	t	class:vcg::tri::TriMeshClipper
TrianglePointDistance	vcglib/vcg/space/distance3.h	/^void TrianglePointDistance(const vcg::Triangle3<ScalarType> &t,$/;"	f	namespace:vcg
TriangleSegmentDistance	vcglib/vcg/space/distance3.h	/^void TriangleSegmentDistance(const vcg::Triangle3<ScalarType> &t,$/;"	f	namespace:vcg
TriangleTriangleDistance	vcglib/vcg/space/distance3.h	/^void TriangleTriangleDistance(const  vcg::Triangle3<ScalarType> &t0,$/;"	f	namespace:vcg
TriangleTriangleIntersect2D	vcglib/vcg/space/intersection2.h	/^	bool TriangleTriangleIntersect2D(const vcg::Triangle2<ScalarType> &tr0,$/;"	f	namespace:vcg
TriangleType	vcglib/vcg/space/triangle2.h	/^  typedef Triangle2<ScalarType> TriangleType;$/;"	t	class:vcg::Triangle2
TrianglesTag	vcglib/wrap/dae/colladaformat.h	/^		TrianglesTag(const int count)$/;"	f	class:Collada::Tags::TrianglesTag
TrianglesTag	vcglib/wrap/dae/colladaformat.h	/^		TrianglesTag(const int count,const QString& material)$/;"	f	class:Collada::Tags::TrianglesTag
TrianglesTag	vcglib/wrap/dae/colladaformat.h	/^	class TrianglesTag : public XMLTag$/;"	c	namespace:Collada::Tags
TriangularBase	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularBase() { eigen_assert(!((Mode&UnitDiag) && (Mode&ZeroDiag))); }$/;"	f	class:Eigen::TriangularBase
TriangularBase	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^template<typename Derived> class TriangularBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
TriangularProduct	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct
TriangularProduct	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false>$/;"	s	namespace:Eigen
TriangularProduct	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct
TriangularProduct	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,false,Lhs,true,Rhs,false>$/;"	s	namespace:Eigen
TriangularProduct	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,true,Lhs,false,Rhs,true>$/;"	s	namespace:Eigen
TriangularView	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::TriangularView
TriangularView	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^template<typename _MatrixType, unsigned int _Mode> class TriangularView$/;"	c	namespace:Eigen
TriangularViewReturnType	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase
TridiagonalMatrix	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    TridiagonalMatrix(Index size = Size) : Base(size,size,Options&SelfAdjoint?0:1,1) {}$/;"	f	class:Eigen::internal::TridiagonalMatrix
TridiagonalMatrix	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^class TridiagonalMatrix : public BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor>$/;"	c	namespace:Eigen::internal
Tridiagonalization	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::Tridiagonalization
Tridiagonalization	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization
Tridiagonalization	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename _MatrixType> class Tridiagonalization$/;"	c	namespace:Eigen
TridiagonalizationMatrixTReturnType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    TridiagonalizationMatrixTReturnType(const MatrixType& mat) : m_matrix(mat) { }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
TridiagonalizationMatrixTReturnType	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename MatrixType> struct TridiagonalizationMatrixTReturnType$/;"	s	namespace:Eigen::internal
TridiagonalizationType	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Tridiagonalization<MatrixType> TridiagonalizationType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Triplet	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^  Triplet() : m_row(0), m_col(0), m_value(0) {}$/;"	f	class:Eigen::Triplet
Triplet	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^  Triplet(const Index& i, const Index& j, const Scalar& v = Scalar(0))$/;"	f	class:Eigen::Triplet
Triplet	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^class Triplet$/;"	c	namespace:Eigen
TristripDesc	vcglib/wrap/io_trimesh/import_ply.h	/^static const PropDescriptor &TristripDesc(int i)$/;"	f	class:vcg::tri::io::ImporterPLY
TrivialEar	vcglib/vcg/complex/algorithms/hole.h	/^  TrivialEar(){}$/;"	f	class:vcg::tri::TrivialEar
TrivialEar	vcglib/vcg/complex/algorithms/hole.h	/^  TrivialEar(const PosType & ep)$/;"	f	class:vcg::tri::TrivialEar
TrivialEar	vcglib/vcg/complex/algorithms/hole.h	/^template<class MESH> class TrivialEar$/;"	c	namespace:vcg::tri
TrivialSampler	vcglib/vcg/complex/algorithms/point_sampling.h	/^  TrivialSampler()$/;"	f	class:vcg::tri::TrivialSampler
TrivialSampler	vcglib/vcg/complex/algorithms/point_sampling.h	/^  TrivialSampler(std::vector<CoordType> &Vec)$/;"	f	class:vcg::tri::TrivialSampler
TrivialSampler	vcglib/vcg/complex/algorithms/point_sampling.h	/^class TrivialSampler$/;"	c	namespace:vcg::tri
TrivialWalker	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^class TrivialWalker$/;"	c	namespace:vcg::tri
Tsai2Shot	vcglib/wrap/tsai/tsaimethods.cpp	/^void TsaiMethods::Tsai2Shot(vcg::Shot<double>* shot, bool p_foc ) {$/;"	f	class:TsaiMethods
TsaiCorrelation	vcglib/wrap/tsai/tsaimethods.h	/^struct TsaiCorrelation {$/;"	s
TsaiMethods	vcglib/wrap/tsai/tsaimethods.h	/^class TsaiMethods$/;"	c
TwKeyPressQt	vcglib/wrap/qt/anttweakbarMapper.cpp	/^int TwKeyPressQt(QKeyEvent *e)$/;"	f
TwKeyPressQt	vcglib/wrap/qt/anttweakbarMapperNew.cpp	/^int TwKeyPressQt(QKeyEvent *e)$/;"	f
TwMousePressQt	vcglib/wrap/qt/anttweakbarMapper.cpp	/^int TwMousePressQt(QMouseEvent *e)$/;"	f
TwMousePressQt	vcglib/wrap/qt/anttweakbarMapper.cpp	/^int TwMousePressQt(QWidget *qw, QMouseEvent *e)$/;"	f
TwMousePressQt	vcglib/wrap/qt/anttweakbarMapperNew.cpp	/^int TwMousePressQt(QMouseEvent *e)$/;"	f
TwMousePressQt	vcglib/wrap/qt/anttweakbarMapperNew.cpp	/^int TwMousePressQt(QWidget *qw, QMouseEvent *e)$/;"	f
TwMouseReleaseQt	vcglib/wrap/qt/anttweakbarMapper.cpp	/^int TwMouseReleaseQt(QMouseEvent *e)$/;"	f
TwMouseReleaseQt	vcglib/wrap/qt/anttweakbarMapper.cpp	/^int TwMouseReleaseQt(QWidget *qw, QMouseEvent *e)$/;"	f
TwMouseReleaseQt	vcglib/wrap/qt/anttweakbarMapperNew.cpp	/^int TwMouseReleaseQt(QMouseEvent *e)$/;"	f
TwMouseReleaseQt	vcglib/wrap/qt/anttweakbarMapperNew.cpp	/^int TwMouseReleaseQt(QWidget *qw, QMouseEvent *e)$/;"	f
Type	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^                 BuildType>::type Type;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType
Type	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	t	struct:Eigen::DenseBase::ConstFixedSegmentReturnType
Type	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	t	struct:Eigen::DenseBase::FixedSegmentReturnType
Type	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, EvalBeforeAssigningBit | EvalBeforeNestingBit> Type;$/;"	t	struct:Eigen::ProductReturnType
Type	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, NestByRefBit> Type;$/;"	t	struct:Eigen::ProductReturnType
Type	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  typedef GeneralProduct<Lhs\/*Nested*\/, Rhs\/*Nested*\/, ProductType> Type;$/;"	t	struct:Eigen::ProductReturnType
Type	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstDiagonalIndexReturnType
Type	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::DiagonalIndexReturnType
Type	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstTriangularViewReturnType
Type	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::TriangularViewReturnType
Type	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstSelfAdjointViewReturnType
Type	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::SelfAdjointViewReturnType
Type	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReduxReturnType
Type	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReturnType
Type	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^                        Direction==Horizontal ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::ExtendedType
Type	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  enum Type {$/;"	g	namespace:Eigen::Architecture
Type	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^                 0, MatrixType::MaxRowsAtCompileTime, MatrixType::MaxColsAtCompileTime> Type;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type
Type	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef DenseTimeSparseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType
Type	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef SparseDenseOuterProduct<Lhs,Rhs,false> Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType
Type	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef SparseDenseOuterProduct<Rhs,Lhs,true> Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType
Type	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef SparseTimeDenseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType
Type	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef SparseSparseProduct<LhsNested, RhsNested> Type;$/;"	t	struct:Eigen::SparseSparseProductReturnType
Type	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:ConstNColsBlockXpr
Type	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:ConstNRowsBlockXpr
Type	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:NColsBlockXpr
Type	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:NRowsBlockXpr
Type	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef SkylineProduct<LhsNested, RhsNested, ProductMode> Type;$/;"	t	struct:Eigen::SkylineProductReturnType
Type	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef google::dense_hash_map<KeyType,Scalar> Type;$/;"	t	struct:Eigen::GoogleDenseHashMapTraits
Type	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef google::sparse_hash_map<KeyType,Scalar> Type;$/;"	t	struct:Eigen::GoogleSparseHashMapTraits
Type	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef std::map<KeyType,Scalar> Type;$/;"	t	struct:Eigen::StdMapTraits
Type	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  typedef std::unordered_map<KeyType,Scalar> Type;$/;"	t	struct:Eigen::StdUnorderedMapTraits
Type	vcglib/vcg/space/index/octree.h	/^        typedef T Type;$/;"	t	class:vcg::ReferenceType
Type	vcglib/vcg/space/index/octree.h	/^        typedef typename ReferenceType<T>::Type Type;$/;"	t	class:vcg::ReferenceType
Type	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		struct ReferenceType { typedef TYPE Type; };$/;"	t	struct:vcg::PerfectSpatialHashing::ReferenceType
Type	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		struct ReferenceType< TYPE * > { typedef typename ReferenceType<TYPE>::Type Type; };$/;"	t	struct:vcg::PerfectSpatialHashing::ReferenceType
Type	vcglib/vcg/space/point.h	/^	typedef Eigen::Matrix<S,N,1> Type;$/;"	t	class:vcg::ndim::Point
Type	vcglib/vcg/space/point2.h	/^	typedef Eigen::Matrix<_Scalar,2,1> Type;$/;"	t	class:vcg::Point2
Type	vcglib/vcg/space/point3.h	/^	typedef Eigen::Matrix<_Scalar,3,1> Type;$/;"	t	class:vcg::Point3
Type	vcglib/vcg/space/point4.h	/^	typedef Eigen::Matrix<T,4,1> Type;$/;"	t	class:vcg::Point4
Type	vcglib/wrap/gl/deprecated_space.h	/^{ typedef Point2<typename Derived::Scalar> Type; };$/;"	t	struct:vcg::EvalToKnownPointType
Type	vcglib/wrap/gl/deprecated_space.h	/^{ typedef Point3<typename Derived::Scalar> Type; };$/;"	t	struct:vcg::EvalToKnownPointType
Type	vcglib/wrap/gl/deprecated_space.h	/^{ typedef Point4<typename Derived::Scalar> Type; };$/;"	t	struct:vcg::EvalToKnownPointType
Type	vcglib/wrap/gl/shaders.h	/^	ShaderType Type(void) const$/;"	f	class:FragmentShader
Type	vcglib/wrap/gl/shaders.h	/^	ShaderType Type(void) const$/;"	f	class:GeometryShader
Type	vcglib/wrap/gl/shaders.h	/^	ShaderType Type(void) const$/;"	f	class:VertexShader
Type	vcglib/wrap/gl/space.h	/^{ typedef Point2<typename Derived::Scalar> Type; };$/;"	t	struct:vcg::EvalToKnownPointType
Type	vcglib/wrap/gl/space.h	/^{ typedef Point3<typename Derived::Scalar> Type; };$/;"	t	struct:vcg::EvalToKnownPointType
Type	vcglib/wrap/gl/space.h	/^{ typedef Point4<typename Derived::Scalar> Type; };$/;"	t	struct:vcg::EvalToKnownPointType
Type	vcglib/wrap/glw/bookkeeping.h	/^template <typename T, typename B> struct DeleterOfType             { typedef typename DeleterOfType<B, typename BaseOf<B>::Type>::Type Type; };$/;"	t	struct:glw::detail::DeleterOfType
Type	vcglib/wrap/glw/bookkeeping.h	/^template <typename T, typename B> struct RootOfType                { typedef typename RootOfType<B,  typename BaseOf<B>::Type>::Type  Type;  };$/;"	t	struct:glw::detail::RootOfType
Type	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct BaseOf                    { typedef NoType Type;                                                    };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct DeleterOf                 { typedef typename DeleterOfType<T, typename BaseOf<T>::Type>::Type Type; };$/;"	t	struct:glw::detail::DeleterOf
Type	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct DeleterOfType<T, NoType>  { typedef DefaultDeleter<T>                                         Type; };$/;"	t	struct:glw::detail::DeleterOfType
Type	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct RootOf                    { typedef typename RootOfType<T, typename BaseOf<T>::Type>::Type   Type;  };$/;"	t	struct:glw::detail::RootOf
Type	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct RootOfType<T, NoType>     { typedef T                                                        Type;  };$/;"	t	struct:glw::detail::RootOfType
Type	vcglib/wrap/glw/bookkeeping.h	/^template <typename T> struct ObjectSharedPointerTraits { typedef ObjectSharedPointer<T, typename DeleterOf<typename RootOf<T>::Type>::Type, typename BaseOf<T>::Type> Type; };$/;"	t	struct:glw::detail::ObjectSharedPointerTraits
Type	vcglib/wrap/glw/bookkeeping.h	/^template <typename T> struct RefCountedObjectTraits { typedef RefCountedObject<T, typename DeleterOf<T>::Type, typename BaseOf<T>::Type> Type; };$/;"	t	struct:glw::detail::RefCountedObjectTraits
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf      <BoundBuffer> { typedef BoundObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundFeedbackBuffer> { typedef BoundBuffer Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundIndexBuffer> { typedef BoundBuffer Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundPixelPackBuffer> { typedef BoundBuffer Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundPixelUnpackBuffer> { typedef BoundBuffer Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundUniformBuffer> { typedef BoundBuffer Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundVertexBuffer> { typedef BoundBuffer Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <SafeBuffer> { typedef SafeObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf <Buffer> { typedef Object Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase  <BoundBuffer> { typedef Buffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundFeedbackBuffer> { typedef Buffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundIndexBuffer> { typedef Buffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundPixelPackBuffer> { typedef Buffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundPixelUnpackBuffer> { typedef Buffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundUniformBuffer> { typedef Buffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundVertexBuffer> { typedef Buffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <SafeBuffer> { typedef Buffer     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBound <Buffer     > { typedef BoundBuffer Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectSafe <Buffer    > { typedef SafeBuffer Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf    <BoundBuffer> { typedef BufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundFeedbackBuffer> { typedef FeedbackBufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundIndexBuffer> { typedef IndexBufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundPixelPackBuffer> { typedef PixelPackBufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundPixelUnpackBuffer> { typedef PixelUnpackBufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundUniformBuffer> { typedef UniformBufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundVertexBuffer> { typedef VertexBufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/context.h	/^			typedef detail::ObjectSharedPointer<ObjectBoundType, typename detail::DeleterOf<typename detail::RootOf<ObjectBoundType>::Type>::Type, typename detail::BaseOf<ObjectBoundType>::Type> Type;$/;"	t	struct:glw::Context::BindingHandleFromObject
Type	vcglib/wrap/glw/context.h	/^			typedef detail::ObjectSharedPointer<ObjectSafeType, typename detail::DeleterOf<typename detail::RootOf<ObjectSafeType>::Type>::Type, typename detail::BaseOf<ObjectSafeType>::Type> Type;$/;"	t	struct:glw::Context::SafeHandleFromObject
Type	vcglib/wrap/glw/context.h	/^			typedef detail::ObjectSharedPointer<TBinding, typename detail::DeleterOf<typename detail::RootOf<TBinding>::Type>::Type, typename detail::BaseOf<TBinding>::Type> Type;$/;"	t	struct:glw::Context::BindingHandleFromBinding
Type	vcglib/wrap/glw/context.h	/^			typedef detail::ObjectSharedPointer<TObject, typename detail::DeleterOf<typename detail::RootOf<TObject>::Type>::Type, typename detail::BaseOf<TObject>::Type> Type;$/;"	t	struct:glw::Context::PtrFromObject
Type	vcglib/wrap/glw/context.h	/^			typedef detail::RefCountedObject<ObjectBoundType, typename detail::DeleterOf<typename detail::RootOf<ObjectBoundType>::Type>::Type, typename detail::BaseOf<ObjectBoundType>::Type> Type;$/;"	t	struct:glw::Context::RefCountedBindingHandleFromObject
Type	vcglib/wrap/glw/context.h	/^			typedef detail::RefCountedObject<ObjectSafeType, typename detail::DeleterOf<typename detail::RootOf<ObjectSafeType>::Type>::Type, typename detail::BaseOf<ObjectSafeType>::Type> Type;$/;"	t	struct:glw::Context::RefCountedSafeHandleFromObject
Type	vcglib/wrap/glw/context.h	/^			typedef detail::RefCountedObject<TBinding, typename detail::DeleterOf<typename detail::RootOf<TBinding>::Type>::Type, typename detail::BaseOf<TBinding>::Type> Type;$/;"	t	struct:glw::Context::RefCountedBindingHandleFromBinding
Type	vcglib/wrap/glw/context.h	/^			typedef detail::RefCountedObject<TObject, typename detail::DeleterOf<typename detail::RootOf<TObject>::Type>::Type, typename detail::BaseOf<TObject>::Type> Type;$/;"	t	struct:glw::Context::RefCountedPtrFromObject
Type	vcglib/wrap/glw/context.h	/^			typedef typename SafeHandleFromObject<typename ObjectFromBinding<TBinding>::Type>::Type Type;$/;"	t	struct:glw::Context::SafeHandleFromBinding
Type	vcglib/wrap/glw/context.h	/^			typedef typename detail::ObjectBase<TBinding>::Type Type;$/;"	t	struct:glw::Context::ObjectFromBinding
Type	vcglib/wrap/glw/context.h	/^			typedef typename detail::ObjectBound<TObject>::Type Type;$/;"	t	struct:glw::Context::ObjectBoundFromObject
Type	vcglib/wrap/glw/context.h	/^			typedef typename detail::ObjectSafe<TObject>::Type Type;$/;"	t	struct:glw::Context::ObjectSafeFromObject
Type	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct BaseOf      <BoundFragmentShader> { typedef BoundShader Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct BaseOf     <SafeFragmentShader> { typedef SafeShader Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct BaseOf <FragmentShader> { typedef Shader Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectBase  <BoundFragmentShader> { typedef FragmentShader      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectBase <SafeFragmentShader> { typedef FragmentShader     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectBound <FragmentShader     > { typedef BoundFragmentShader Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectSafe <FragmentShader    > { typedef SafeFragmentShader Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ParamsOf    <BoundFragmentShader> { typedef FragmentShaderBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf      <BoundFramebuffer> { typedef BoundObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <BoundDrawFramebuffer> { typedef BoundFramebuffer Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <BoundReadDrawFramebuffer> { typedef BoundFramebuffer Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <BoundReadFramebuffer> { typedef BoundFramebuffer Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <SafeFramebuffer> { typedef SafeObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf <Framebuffer> { typedef Object Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase  <BoundFramebuffer> { typedef Framebuffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <BoundDrawFramebuffer> { typedef Framebuffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <BoundReadDrawFramebuffer> { typedef Framebuffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <BoundReadFramebuffer> { typedef Framebuffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <SafeFramebuffer> { typedef Framebuffer     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBound <Framebuffer     > { typedef BoundFramebuffer Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectSafe <Framebuffer    > { typedef SafeFramebuffer Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf    <BoundFramebuffer> { typedef FramebufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf   <BoundDrawFramebuffer> { typedef DrawFramebufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf   <BoundReadDrawFramebuffer> { typedef ReadDrawFramebufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf   <BoundReadFramebuffer> { typedef ReadFramebufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct BaseOf      <BoundGeometryShader> { typedef BoundShader Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct BaseOf     <SafeGeometryShader> { typedef SafeShader Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct BaseOf <GeometryShader> { typedef Shader Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectBase  <BoundGeometryShader> { typedef GeometryShader      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectBase <SafeGeometryShader> { typedef GeometryShader     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectBound <GeometryShader     > { typedef BoundGeometryShader Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectSafe <GeometryShader    > { typedef SafeGeometryShader Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ParamsOf    <BoundGeometryShader> { typedef GeometryShaderBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct BaseOf      <BoundObject> { typedef NoType                      Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct BaseOf     <SafeObject> { typedef NoType                     Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct BaseOf    <Object> { typedef NoType        Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct DeleterOf   <BoundObject> { typedef DefaultDeleter<BoundObject> Type; }; };$/;"	t	struct:glw::detail::DeleterOf
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct DeleterOf  <SafeObject> { typedef DefaultDeleter<SafeObject> Type; }; };$/;"	t	struct:glw::detail::DeleterOf
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct DeleterOf <Object> { typedef ObjectDeleter Type; }; };$/;"	t	struct:glw::detail::DeleterOf
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectBase  <BoundObject> { typedef Object                      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectBase <SafeObject> { typedef Object                     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectBound <Object     > { typedef BoundObject                 Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectSafe <Object    > { typedef SafeObject                 Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ParamsOf    <BoundObject> { typedef ObjectBindingParams         Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ObjectBase  { typedef NoType        Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ObjectBound { typedef NoType        Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ObjectSafe  { typedef NoType        Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ParamsOf { typedef NoType Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct BaseOf      <BoundProgram> { typedef BoundObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct BaseOf     <SafeProgram> { typedef SafeObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct BaseOf <Program> { typedef Object Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectBase  <BoundProgram> { typedef Program      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectBase <SafeProgram> { typedef Program     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectBound <Program     > { typedef BoundProgram Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectSafe <Program    > { typedef SafeProgram Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ParamsOf    <BoundProgram> { typedef ProgramBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct BaseOf      <BoundRenderable> { typedef BoundObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct BaseOf     <SafeRenderable> { typedef SafeObject     Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct BaseOf <Renderable> { typedef Object Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectBase  <BoundRenderable> { typedef Renderable      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectBase <SafeRenderable> { typedef Renderable     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectBound <Renderable     > { typedef BoundRenderable Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectSafe <Renderable    > { typedef SafeRenderable Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ParamsOf    <BoundRenderable> { typedef RenderableBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct BaseOf      <BoundRenderbuffer> { typedef BoundObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct BaseOf     <SafeRenderbuffer> { typedef SafeRenderable   Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct BaseOf <Renderbuffer> { typedef Renderable Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectBase  <BoundRenderbuffer> { typedef Renderbuffer      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectBase <SafeRenderbuffer> { typedef Renderbuffer     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectBound <Renderbuffer     > { typedef BoundRenderbuffer Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectSafe <Renderbuffer    > { typedef SafeRenderbuffer Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ParamsOf    <BoundRenderbuffer> { typedef RenderbufferBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct BaseOf      <BoundShader> { typedef BoundObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct BaseOf     <SafeShader> { typedef SafeObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct BaseOf <Shader> { typedef Object Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectBase  <BoundShader> { typedef Shader      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectBase <SafeShader> { typedef Shader     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectBound <Shader     > { typedef BoundShader Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectSafe <Shader    > { typedef SafeShader Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ParamsOf    <BoundShader> { typedef ShaderBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct BaseOf      <BoundTexture> { typedef BoundObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct BaseOf     <SafeTexture> { typedef SafeRenderable   Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct BaseOf <Texture> { typedef Renderable Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectBase  <BoundTexture> { typedef Texture      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectBase <SafeTexture> { typedef Texture     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectBound <Texture     > { typedef BoundTexture Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectSafe <Texture    > { typedef SafeTexture Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ParamsOf    <BoundTexture> { typedef TextureBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct BaseOf      <BoundTexture2D> { typedef BoundObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct BaseOf     <SafeTexture2D> { typedef SafeTexture   Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct BaseOf <Texture2D> { typedef Texture Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectBase  <BoundTexture2D> { typedef Texture2D      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectBase <SafeTexture2D> { typedef Texture2D     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectBound <Texture2D     > { typedef BoundTexture2D Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectSafe <Texture2D    > { typedef SafeTexture2D Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ParamsOf    <BoundTexture2D> { typedef Texture2DBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct BaseOf      <BoundTextureCube> { typedef BoundObject Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct BaseOf     <SafeTextureCube> { typedef SafeTexture   Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct BaseOf <TextureCube> { typedef Texture Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectBase  <BoundTextureCube> { typedef TextureCube      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectBase <SafeTextureCube> { typedef TextureCube     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectBound <TextureCube     > { typedef BoundTextureCube Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectSafe <TextureCube    > { typedef SafeTextureCube Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ParamsOf    <BoundTextureCube> { typedef TextureCubeBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/glw/type.h	/^enum Type$/;"	g	namespace:glw
Type	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct BaseOf      <BoundVertexShader> { typedef BoundShader Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct BaseOf     <SafeVertexShader> { typedef SafeShader Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct BaseOf <VertexShader> { typedef Shader Type; }; };$/;"	t	struct:glw::detail::BaseOf
Type	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectBase  <BoundVertexShader> { typedef VertexShader      Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectBase <SafeVertexShader> { typedef VertexShader     Type; }; };$/;"	t	struct:glw::detail::ObjectBase
Type	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectBound <VertexShader     > { typedef BoundVertexShader Type; }; };$/;"	t	struct:glw::detail::ObjectBound
Type	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectSafe <VertexShader    > { typedef SafeVertexShader Type; }; };$/;"	t	struct:glw::detail::ObjectSafe
Type	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ParamsOf    <BoundVertexShader> { typedef VertexShaderBindingParams Type; }; };$/;"	t	struct:glw::detail::ParamsOf
Type	vcglib/wrap/system/qgetopt.h	/^    enum Type { SWITCH, OPTION, ARGUMENT, OPTIONAL };$/;"	g	struct:GetOpt::Option
TypeNameBounds	vcglib/vcg/container/container_allocation_table.h	/^		static std::map< std::string,CATBaseBase *> & TypeNameBounds(){$/;"	f	struct:vcg::Env
TypeSize	vcglib/wrap/ply/plylib.cpp	/^static int TypeSize[] = {$/;"	m	namespace:vcg::ply	file:
TypesPool	vcglib/vcg/connectors/hedge.h	/^						public: typedef AllTypes::AHEdgeType IAm; typedef UserTypes TypesPool;};$/;"	t	class:vcg::HEdge
TypesPool	vcglib/vcg/simplex/edge/base.h	/^						public: typedef AllTypes::AEdgeType IAm; typedef UserTypes TypesPool;};$/;"	t	class:vcg::Edge
TypesPool	vcglib/vcg/simplex/face/base.h	/^							public: typedef AllTypes::AFaceType IAm; typedef UserTypes TypesPool;};$/;"	t	class:vcg::Face
TypesPool	vcglib/vcg/simplex/vertex/base.h	/^			 public: typedef AllTypes::AVertexType IAm; typedef UserTypes TypesPool;};$/;"	t	class:vcg::Vertex
U	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  std::vector< Candidate > U;$/;"	m	class:vcg::tri::FourPCS
U	vcglib/vcg/space/texcoord2.h	/^    inline T & U() { return _t[0]; }$/;"	f	class:vcg::TexCoord2Simple
U	vcglib/vcg/space/texcoord2.h	/^    inline T & U() { return _t[0][0]; }$/;"	f	class:vcg::TexCoord2
U	vcglib/vcg/space/texcoord2.h	/^    inline T & U(const int i) { (void)i; assert(i==0); return _t[0]; }$/;"	f	class:vcg::TexCoord2Simple
U	vcglib/vcg/space/texcoord2.h	/^    inline T & U(const int i) { assert(i>0 && i<NMAX);  return _t[i][0]; }$/;"	f	class:vcg::TexCoord2
U	vcglib/vcg/space/texcoord2.h	/^    inline const T & U() const { return _t[0]; }$/;"	f	class:vcg::TexCoord2Simple
U	vcglib/vcg/space/texcoord2.h	/^    inline const T & U() const { return _t[0][0]; }$/;"	f	class:vcg::TexCoord2
U	vcglib/vcg/space/texcoord2.h	/^    inline const T & U(const int i) const { (void)i; assert(i==0); return _t[0]; }$/;"	f	class:vcg::TexCoord2Simple
U	vcglib/vcg/space/texcoord2.h	/^    inline const T & U(const int i) const { assert(i>0 && i<NMAX); return _t[i][0]; }$/;"	f	class:vcg::TexCoord2
U3DError	vcglib/wrap/io_trimesh/export_u3d.h	/^	enum U3DError $/;"	g	class:vcg::tri::io::ExporterU3D
UIntHMap	vcglib/vcg/complex/algorithms/clip.h	/^  typedef STDEXT::hash_map<unsigned int, EdgeIntersections> UIntHMap;$/;"	t	class:vcg::tri::TriMeshClipper
UIntHMap_i	vcglib/vcg/complex/algorithms/clip.h	/^  typedef typename UIntHMap::iterator UIntHMap_i;$/;"	t	class:vcg::tri::TriMeshClipper
UIntHMap_v	vcglib/vcg/complex/algorithms/clip.h	/^  typedef typename UIntHMap::value_type UIntHMap_v;$/;"	t	class:vcg::tri::TriMeshClipper
UIntValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^const unsigned int & AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::UIntValue(void) const {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
UIntValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^unsigned int & AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::UIntValue(void) {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
UMatrixType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType,  Upper>           UMatrixType;$/;"	t	class:Eigen::SuperLU
UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
UNDEF	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  UNDEF=0,$/;"	e	enum:vcg::RawVolumeImporter::DataType
UNDEFINED	vcglib/img/img_attributes.h	/^    UNDEFINED,$/;"	e	enum:img::COLORSPACE
UPPER_MASK	vcglib/vcg/math/random_generator.h	/^	static const unsigned int UPPER_MASK = 0x80000000u; \/\/ most significant w-r bits$/;"	m	class:vcg::math::MarsenneTwisterRNG
USAGE_ERROR_ACTION	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define USAGE_ERROR_ACTION(/;"	d	file:
USECOMISO	vcglib/wrap/miq/MIQ.h	/^#define USECOMISO$/;"	d
USER0	vcglib/vcg/connectors/hedge.h	/^		USER0      = 0x0200			\/\/ First user bit$/;"	e	enum:vcg::HEdgeArityMax::__anon484
USER0	vcglib/vcg/simplex/edge/base.h	/^		USER0      = 0x0200			\/\/ First user bit$/;"	e	enum:vcg::EdgeArityMax::__anon496
USER0	vcglib/vcg/simplex/face/base.h	/^		USER0       = 0x00200000$/;"	e	enum:vcg::FaceArityMax::__anon497
USER0	vcglib/vcg/simplex/tetrahedron/base.h	/^		USER0       = 0x00004000$/;"	e	enum:vcg::TetraArityMax::__anon498
USER0	vcglib/vcg/simplex/vertex/base.h	/^		USER0      = 0x0200			\/\/ First user bit$/;"	e	enum:vcg::VertexArityMax::__anon499
USE_AABB_TREE	vcglib/apps/metro/sampling.h	/^			USE_AABB_TREE                   = 0x1000,$/;"	e	enum:vcg::SamplingFlags::__anon1
USE_BUILTIN_FFS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define USE_BUILTIN_FFS /;"	d	file:
USE_DEV_RANDOM	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define USE_DEV_RANDOM /;"	d	file:
USE_DL_PREFIX	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define USE_DL_PREFIX$/;"	d	file:
USE_DL_PREFIX	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define USE_DL_PREFIX$/;"	d
USE_EPSILON_TEST	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define USE_EPSILON_TEST$/;"	d
USE_EPSILON_TEST	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#undef USE_EPSILON_TEST$/;"	d
USE_HASH_GRID	vcglib/apps/metro/sampling.h	/^			USE_HASH_GRID                   = 0x0800,$/;"	e	enum:vcg::SamplingFlags::__anon1
USE_LOCKS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define USE_LOCKS /;"	d	file:
USE_LOCK_BIT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define USE_LOCK_BIT /;"	d	file:
USE_MMAP_BIT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^    #define USE_MMAP_BIT /;"	d	file:
USE_NONCONTIGUOUS_BIT	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define USE_NONCONTIGUOUS_BIT /;"	d	file:
USE_OCTREE	vcglib/apps/metro/sampling.h	/^						USE_OCTREE                      = 0x2000$/;"	e	enum:vcg::SamplingFlags::__anon1
USE_SPIN_LOCKS	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define USE_SPIN_LOCKS /;"	d	file:
USE_STATIC_GRID	vcglib/apps/metro/sampling.h	/^			USE_STATIC_GRID                 = 0x0400,$/;"	e	enum:vcg::SamplingFlags::__anon1
UTD	vcglib/vcg/container/container_allocation_table.h	/^static bool & UTD(){$/;"	f	class:vcg::CATEntry
UVCoordType	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			typedef typename vcg::Point2<ScalarType> UVCoordType;$/;"	t	class:vcg::tri::UV_Utils
UV_Utils	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^		class UV_Utils$/;"	c	namespace:vcg::tri
UmfPackLU	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU() { init(); }$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(UmfPackLU& ) { }$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^class UmfPackLU : internal::noncopyable$/;"	c	namespace:Eigen
UmfpackMatrixType	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar,ColMajor,int> UmfpackMatrixType;$/;"	t	class:Eigen::UmfPackLU
UnMarkAll	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^	void UnMarkAll(){mark++;}$/;"	f	class:MyMarker
UnMarkAll	vcglib/vcg/complex/algorithms/closest.h	/^			inline void UnMarkAll() const {}$/;"	f	class:vcg::tri::VertTmark
UnMarkAll	vcglib/vcg/complex/algorithms/closest.h	/^			void UnMarkAll(){ vcg::tri::UnMarkAll(*m);}$/;"	f	class:vcg::tri::Tmark
UnMarkAll	vcglib/vcg/complex/base.h	/^template <class MeshType> inline void UnMarkAll(MeshType & m)$/;"	f	namespace:vcg::tri
UnProject	vcglib/vcg/math/camera.h	/^vcg::Point3<S> Camera<S>::UnProject(const vcg::Point2<S> & p, const S & d) const$/;"	f	class:vcg::Camera
UnProject	vcglib/vcg/math/shot.h	/^vcg::Point3<S> Shot<S,RotationType>::UnProject(const vcg::Point2<S> & p, const S & d) const$/;"	f	class:vcg::Shot
UnProject	vcglib/wrap/gui/view.h	/^template <class T> Point3<T> View<T>::UnProject(const Point3<T> &p) const {$/;"	f	class:vcg::View
UnProject_Substitute	vcglib/vcg/math/shot.h	/^vcg::Point3<S> Shot<S,RotationType>::UnProject_Substitute(const vcg::Point2<S> & p, const S & d) const$/;"	f	class:vcg::Shot
Unaligned	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Unaligned=0, $/;"	e	enum:Eigen::__anon259
Unbind	vcglib/wrap/gl/gl_object.h	/^	void Unbind(void)$/;"	f	class:Bindable
UndistortedToDistorted	vcglib/vcg/math/camera.h	/^vcg::Point2<Scalar> Camera<Scalar>::UndistortedToDistorted(vcg::Point2<Scalar>  u) const$/;"	f	class:vcg::Camera
Undo	vcglib/wrap/gui/trackball.cpp	/^void Trackball::Undo(){$/;"	f	class:Trackball
Undo	vcglib/wrap/gui/trackmode.cpp	/^void AreaMode::Undo(){$/;"	f	class:AreaMode
Undo	vcglib/wrap/gui/trackmode.cpp	/^void PathMode::Undo(){$/;"	f	class:PathMode
Undo	vcglib/wrap/gui/trackmode.cpp	/^void TrackMode::Undo(){}$/;"	f	class:TrackMode
Uniform	vcglib/vcg/math/gen_normal.h	/^static void Uniform(int vn, std::vector<Point3<ScalarType > > &NN)$/;"	f	class:vcg::GenNormal
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, GLfloat x)$/;"	f	class:Program
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, GLfloat x, GLfloat y)$/;"	f	class:Program
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, GLfloat x, GLfloat y, GLfloat z)$/;"	f	class:Program
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)$/;"	f	class:Program
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, GLint x)$/;"	f	class:Program
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, GLint x, GLint y)$/;"	f	class:Program
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, GLint x, GLint y, GLint z)$/;"	f	class:Program
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, GLint x, GLint y, GLint z, GLint w)$/;"	f	class:Program
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, const vcg::Point2f& p)$/;"	f	class:Program
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, const vcg::Point3f& p)$/;"	f	class:Program
Uniform	vcglib/wrap/gl/shaders.h	/^	void Uniform(const char * name, const vcg::Point4f& p)$/;"	f	class:Program
UniformBufferBindingParams	vcglib/wrap/glw/buffer.h	/^		UniformBufferBindingParams(GLuint aIndex, GLintptr aOffset, GLsizeiptr aSize)$/;"	f	class:glw::UniformBufferBindingParams
UniformBufferBindingParams	vcglib/wrap/glw/buffer.h	/^		UniformBufferBindingParams(void)$/;"	f	class:glw::UniformBufferBindingParams
UniformBufferBindingParams	vcglib/wrap/glw/buffer.h	/^class UniformBufferBindingParams : public BufferBindingParams$/;"	c	namespace:glw
UniformCone	vcglib/vcg/math/gen_normal.h	/^static void UniformCone(int vn, std::vector<Point3<ScalarType > > &NN, ScalarType AngleRad, Point3x dir=Point3x(0,1,0))$/;"	f	class:vcg::GenNormal
UniformGrid	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			UniformGrid() {}$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
UniformGrid	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		class UniformGrid$/;"	c	class:vcg::PerfectSpatialHashing
UniformInfo	vcglib/wrap/glw/program.h	/^				UniformInfo(void)$/;"	f	class:glw::Program::UniformInfo
UniformInfo	vcglib/wrap/glw/program.h	/^		class UniformInfo$/;"	c	class:glw::Program
UniformMap	vcglib/wrap/glw/program.h	/^		typedef std::map<std::string, UniformInfo> UniformMap;$/;"	t	class:glw::Program
UniformMapConstIterator	vcglib/wrap/glw/program.h	/^		typedef UniformMap::const_iterator         UniformMapConstIterator;$/;"	t	class:glw::Program
UniformMapIterator	vcglib/wrap/glw/program.h	/^		typedef UniformMap::iterator               UniformMapIterator;$/;"	t	class:glw::Program
UniformMapValue	vcglib/wrap/glw/program.h	/^		typedef UniformMap::value_type             UniformMapValue;$/;"	t	class:glw::Program
UniformParameters	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	struct UniformParameters$/;"	s	class:SplatRenderer
UniformScaling	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  UniformScaling() {}$/;"	f	class:Eigen::UniformScaling
UniformScaling	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  explicit inline UniformScaling(const Scalar& s) : m_factor(s) {}$/;"	f	class:Eigen::UniformScaling
UniformScaling	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  inline explicit UniformScaling(const UniformScaling<OtherScalarType>& other)$/;"	f	class:Eigen::UniformScaling
UniformScaling	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^class UniformScaling$/;"	c	namespace:Eigen
Union	vcglib/vcg/math/disjoint_set.h	/^		void Union(OBJECT_TYPE *x, OBJECT_TYPE *y)$/;"	f	class:vcg::DisjointSet
Unit	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index i)$/;"	f	class:Eigen::MatrixBase
Unit	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index size, Index i)$/;"	f	class:Eigen::MatrixBase
UnitDiag	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  UnitDiag=0x4, $/;"	e	enum:Eigen::__anon258
UnitDiagBit	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitDiagBit = UnitDiag;$/;"	m	namespace:Eigen
UnitLower	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  UnitLower=UnitDiag|Lower, $/;"	e	enum:Eigen::__anon258
UnitLowerTriangular	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitLowerTriangular = UnitLower;$/;"	m	namespace:Eigen
UnitTest_Append	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^bool UnitTest_Append(const char *filename1, const char *filename2)$/;"	f
UnitTest_Closest	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^bool UnitTest_Closest(const char *filename1, int sampleNum, float dispPerc, std::vector<int> resultVec)$/;"	f
UnitUpper	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  UnitUpper=UnitDiag|Upper,$/;"	e	enum:Eigen::__anon258
UnitUpperTriangular	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitUpperTriangular = UnitUpper;$/;"	m	namespace:Eigen
UnitW	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitW()$/;"	f	class:Eigen::MatrixBase
UnitX	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitX()$/;"	f	class:Eigen::MatrixBase
UnitY	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitY()$/;"	f	class:Eigen::MatrixBase
UnitZ	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitZ()$/;"	f	class:Eigen::MatrixBase
Unroll	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^      Unroll = CoeffReadCost != Dynamic && CoeffReadCost <= EIGEN_UNROLLING_LIMIT,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon195
Unrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal))$/;"	e	enum:Eigen::internal::assign_traits::__anon39
Unrolling	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    Unrolling = Cost != Dynamic && Cost <= UnrollingLimit$/;"	e	enum:Eigen::internal::redux_traits::__anon227
Unrolling	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^      Unrolling   = (RhsIsVectorAtCompileTime && Rhs::SizeAtCompileTime != Dynamic && Rhs::SizeAtCompileTime <= 8)$/;"	e	enum:Eigen::internal::trsolve_traits::__anon245
UnrollingLimit	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    UnrollingLimit      = EIGEN_UNROLLING_LIMIT * (Vectorized ? int(PacketSize) : 1),$/;"	e	enum:Eigen::internal::assign_traits::__anon38
UnrollingLimit	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    UnrollingLimit = EIGEN_UNROLLING_LIMIT * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))$/;"	e	enum:Eigen::internal::redux_traits::__anon226
Unset	vcglib/wrap/gl/fbo.h	/^	bool Unset(void)$/;"	f	class:TextureRenderTarget
UnsetView	vcglib/wrap/gl/shot.h	/^static void	UnsetView()$/;"	f	struct:GlShot
UnsharpMask	vcglib/img/img_filter.h	/^inline void UnsharpMask(const Image<Channels,SrcScalarType,SrcSafe> &source,Image<Channels,DestScalarType,DestSafe> &destination,int radius,float factor)$/;"	f	namespace:img
UnsupportedFormat	vcglib/wrap/io_trimesh/import_gts.h	/^					UnsupportedFormat, ErrorNotTriangularFace};$/;"	e	enum:vcg::tri::io::ImporterGTS::GTSCodes
UnsupportedFormat	vcglib/wrap/io_trimesh/import_off.h	/^                 UnsupportedFormat, ErrorNotTriangularFace,ErrorHighDimension,ErrorDegenerateFace};$/;"	e	enum:vcg::tri::io::ImporterOFF::OFFCodes
Unusable	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^      Unusable(const Unusable&) {}$/;"	f	class:Eigen::ReturnByValue::Unusable
Unusable	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    class Unusable{$/;"	c	class:Eigen::ReturnByValue
Unusable	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^#define Unusable /;"	d
UpAxisTag	vcglib/wrap/dae/colladaformat.h	/^		UpAxisTag(const QString& up = "Y_UP")$/;"	f	class:Collada::Tags::UpAxisTag
UpAxisTag	vcglib/wrap/dae/colladaformat.h	/^	class UpAxisTag : public XMLLeafTag$/;"	c	namespace:Collada::Tags
UpLo	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LDLT::__anon4
UpLo	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LLT::__anon6
UpLo	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::CholmodBase::__anon7
UpLo	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^    UpLo = _UpLo$/;"	e	enum:Eigen::ConjugateGradient::__anon384
UpLo	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLDLT::__anon395
UpLo	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLLT::__anon394
UpLo	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = Options&(Upper|Lower) };$/;"	e	enum:Eigen::PardisoLDLT::__anon393
UpLo	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PardisoLLT::__anon392
UpLo	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialCholesky::__anon405
UpLo	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLDLT::__anon404
UpLo	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLLT::__anon403
UpLo	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = internal::traits<Derived>::UpLo };$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon399
UpLo	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon400
UpLo	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon401
UpLo	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon402
Update	vcglib/vcg/complex/allocate.h	/^                void Update(SimplexPointerType &vp)$/;"	f	class:vcg::tri::Allocator::PointerUpdater
Update	vcglib/vcg/container/container_allocation_table.h	/^Update(const ValueType * pt)$/;"	f	class:vcg::CATEntry
Update	vcglib/vcg/container/vector_occ.h	/^		Update(){$/;"	f	class:vcg::vector_occ
Update	vcglib/wrap/gl/trimesh.h	/^void Update(\/*Change c=CHAll*\/)$/;"	f	class:vcg::GlTrimesh
Update	vcglib/wrap/gui/activecoordinateframe.cpp	/^void ActiveCoordinateFrame::Update()$/;"	f	class:ActiveCoordinateFrame
Update	vcglib/wrap/mt/mt.h	/^  class Update {$/;"	c	class:vcg::MT
UpdateAllocatedCells	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        void UpdateAllocatedCells()$/;"	f	class:vcg::SpatialHashTable2D
UpdateAllocatedCells	vcglib/vcg/space/index/spatial_hashing.h	/^		void UpdateAllocatedCells()$/;"	f	class:vcg::SpatialHashTable
UpdateBounding	vcglib/vcg/complex/algorithms/update/bounding.h	/^class UpdateBounding$/;"	c	namespace:vcg::tri
UpdateColor	vcglib/vcg/complex/algorithms/update/color.h	/^class UpdateColor$/;"	c	namespace:vcg::tri
UpdateComponentEP	vcglib/vcg/complex/algorithms/update/component_ep.h	/^	class UpdateComponentEP$/;"	c	namespace:vcg::tri
UpdateCoord	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    inline void UpdateCoord (PC_Chord &coord, const unsigned long mark, const PC_ResultCode resultCode) {$/;"	f	class:vcg::tri::PolychordCollapse::PC_Chords
UpdateCurvature	vcglib/vcg/complex/algorithms/update/curvature.h	/^class UpdateCurvature$/;"	c	namespace:vcg::tri
UpdateCurvatureFitting	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^class UpdateCurvatureFitting$/;"	c	namespace:vcg::tri
UpdateFlags	vcglib/vcg/complex/algorithms/update/flag.h	/^class UpdateFlags$/;"	c	namespace:vcg::tri
UpdateHalfEdges	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                class UpdateHalfEdges{$/;"	c	namespace:vcg::tri
UpdateHeap	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            inline  void UpdateHeap(HeapType & h_ret)$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
UpdateHeap	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  void UpdateHeap(typename LocalOptimization<TETRA_MESH_TYPE>::HeapType & h_ret)$/;"	f	class:vcg::tetra::TetraEdgeCollapse
UpdateHeap	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  inline  void UpdateHeap(HeapType & h_ret, BaseParameterClass *pp)$/;"	f	class:vcg::tri::TriEdgeCollapse
UpdateHeap	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  inline  void UpdateHeap(HeapType & h_ret,BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
UpdateHeap	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  inline  void UpdateHeap(HeapType & h_ret,BaseParameterClass *_pp)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
UpdateHeap	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	void UpdateHeap(HeapType &heap)$/;"	f	class:vcg::tri::TopoEdgeFlip
UpdateHeap	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^  virtual void UpdateHeap(HeapType &heap, BaseParameterClass *pp)$/;"	f	class:vcg::tri::PlanarEdgeFlip
UpdateIndexed	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                struct UpdateIndexed{$/;"	s	namespace:vcg::tri
UpdateNormal	vcglib/vcg/complex/algorithms/update/normal.h	/^class   UpdateNormal$/;"	c	namespace:vcg::tri
UpdatePosition	vcglib/vcg/complex/algorithms/update/position.h	/^class UpdatePosition$/;"	c	namespace:vcg::tri
UpdateQuality	vcglib/vcg/complex/algorithms/update/quality.h	/^class UpdateQuality$/;"	c	namespace:vcg::tri
UpdateSelection	vcglib/vcg/complex/algorithms/update/selection.h	/^class UpdateSelection$/;"	c	namespace:vcg::tri
UpdateSize	vcglib/vcg/container/simple_temporary_data.h	/^    bool UpdateSize(){$/;"	f	class:vcg::SimpleTempData
UpdateTexture	vcglib/vcg/complex/algorithms/update/texture.h	/^class UpdateTexture$/;"	c	namespace:vcg::tri
UpdateTopology	vcglib/vcg/complex/algorithms/update/topology.h	/^class UpdateTopology$/;"	c	namespace:vcg::tri
UpdateTrackball	vcglib/wrap/gui/trackrecorder.h	/^	void UpdateTrackball(Trackball & t){$/;"	f	struct:vcg::TrackRecorder
UpdateUVBox	vcglib/wrap/miq/core/param_stats.h	/^void UpdateUVBox(MeshType &mesh)$/;"	f
UpdateValencyInFlags	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void UpdateValencyInFlags(MeshType& m){$/;"	f	class:vcg::tri::BitQuad
UpdateValencyInQuality	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void UpdateValencyInQuality(MeshType& m){$/;"	f	class:vcg::tri::BitQuad
UpdateView	vcglib/wrap/gui/frustum.h	/^template <class T> void Frustum<T>::UpdateView() {$/;"	f	class:vcg::Frustum
UpdateVis	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void UpdateVis()$/;"	f
Upper	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Upper=0x2,                      $/;"	e	enum:Eigen::__anon258
Upper	vcglib/vcg/container/container_allocation_table.h	/^static ValueType *& Upper() {$/;"	f	class:vcg::CATEntry
UpperBidiagonalization	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization() : m_householder(), m_bidiagonal(), m_isInitialized(false) {}$/;"	f	class:Eigen::internal::UpperBidiagonalization
UpperBidiagonalization	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization
UpperBidiagonalization	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^template<typename _MatrixType> class UpperBidiagonalization$/;"	c	namespace:Eigen::internal
UpperTriangular	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangular = Upper;$/;"	m	namespace:Eigen
UpperTriangularBit	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangularBit = Upper;$/;"	m	namespace:Eigen
UpperTriangularType	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    typedef Matrix< Scalar, Dynamic, Dynamic > UpperTriangularType;$/;"	t	class:Eigen::HybridNonLinearSolver
Usage	vcglib/apps/metro/metro.cpp	/^void Usage()$/;"	f
Usage	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^void Usage()$/;"	f
Usage	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^void Usage()$/;"	f
Usage	vcglib/apps/tridecimator/tridecimator.cpp	/^void Usage()$/;"	f
Use	vcglib/vcg/complex/used_types.h	/^    struct Use{$/;"	s	namespace:vcg
UseArea	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      UseArea;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
UseArea	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  bool	    UseArea;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
UseVertexWeight	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^  bool      UseVertexWeight;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricParameter
UseVertexWeight	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  bool	    UseVertexWeight;$/;"	m	class:vcg::tri::TriEdgeCollapseQuadricTexParameter
UsedTypes	vcglib/apps/metro/metro.cpp	/^struct UsedTypes:public vcg::UsedTypes< vcg::Use<CFace>::AsFaceType, vcg::Use<CVertex>::AsVertexType>{};$/;"	s	file:
UsedTypes	vcglib/vcg/complex/used_types.h	/^                    class UsedTypes: public Arity12<DummyTypes,$/;"	c	namespace:vcg
UserAsked	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        UserAsked = 6$/;"	e	enum:Eigen::HybridNonLinearSolverSpace::Status
UserAsked	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        UserAsked = 9$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
UtilDAE	vcglib/wrap/dae/util_dae.h	/^	class UtilDAE$/;"	c	namespace:vcg::tri::io
Utils_sampling	utils_sampling.cpp	/^namespace Utils_sampling {$/;"	n	file:
Utils_sampling	utils_sampling.hpp	/^namespace Utils_sampling {$/;"	n
V	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^	VOX_TYPE &V(const int &x,const int &y,const int &z) {$/;"	f	class:vcg::SimpleVolume
V	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  float &V() {return _v;};$/;"	f	class:vcg::SimpleVoxel
V	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  float V() const {return _v;};$/;"	f	class:vcg::SimpleVoxel
V	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	float V(int x, int y, int z) const$/;"	f	class:ImplicitSphere
V	vcglib/apps/unsupported/extractors/extractor/SphereDifference.h	/^	float V(int x, int y, int z) $/;"	f	class:SphereDifference
V	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^	float V(int x, int y, int z)$/;"	f	class:SphereUnion
V	vcglib/apps/unsupported/extractors/extractor/Volume.h	/^	float V(const int pi, const int pj, const int pk)$/;"	f	class:Volume
V	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	float V(int pi, int pj, int pk)$/;"	f	class:Walker
V	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  VertexType* V() {return f->V(e);}$/;"	f	class:vcg::tri::BitQuad::Pos
V	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    VOX_TYPE &V(const Point3i &pi) {$/;"	f	class:vcg::SimpleVolume
V	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    VOX_TYPE &V(const int &x,const int &y,const int &z) {$/;"	f	class:vcg::SimpleVolume
V	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    float V(int pi, int pj, int pk)$/;"	f	class:vcg::tri::TrivialWalker
V	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  float &V() {return _v;}$/;"	f	class:vcg::SimpleVoxel
V	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  float &V() {return _v;}$/;"	f	class:vcg::SimpleVoxelWithNormal
V	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  float V() const {return _v;}$/;"	f	class:vcg::SimpleVoxel
V	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  float V() const {return _v;}$/;"	f	class:vcg::SimpleVoxelWithNormal
V	vcglib/vcg/complex/algorithms/create/resampler.h	/^		float V(const Point3i &p)$/;"	f	class:vcg::tri::Resampler::Walker
V	vcglib/vcg/complex/algorithms/create/resampler.h	/^		float V(int x,int y,int z)$/;"	f	class:vcg::tri::Resampler::Walker
V	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  VERTEX_TYPE *&V(int i) { return v[i]; }$/;"	f	class:vcg::tri::BasicVertexPair
V	vcglib/vcg/connectors/halfedge_pos.h	/^            VertexPointer V()$/;"	f	class:vcg::hedge::Pos
V	vcglib/vcg/math/eigen_matrix_addons.h	/^EIGEN_DEPRECATED Scalar* V() { return data(); }$/;"	f
V	vcglib/vcg/math/eigen_matrix_addons.h	/^EIGEN_DEPRECATED const Scalar* V() const { return data(); }$/;"	f
V	vcglib/vcg/math/eigen_matrix_addons.h	/^EIGEN_DEPRECATED inline const Scalar& V( const int i ) const$/;"	f
V	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar V(int i) const { return (*this)[i]; };$/;"	f
V	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline Scalar& V(int i) { return (*this)[i]; };$/;"	f
V	vcglib/vcg/math/matrix44.h	/^template <class T>  T *Matrix44<T>::V()  { return _a;}$/;"	f	class:vcg::Matrix44
V	vcglib/vcg/math/matrix44.h	/^template <class T> const T *Matrix44<T>::V() const { return _a;}$/;"	f	class:vcg::Matrix44
V	vcglib/vcg/math/quaternion.h	/^  S & V ( const int i )	{ assert(i>=0 && i<4); return Point4<S>::V(i); }$/;"	f	class:vcg::Quaternion
V	vcglib/vcg/math/quaternion.h	/^  const S & V ( const int i ) const	{ assert(i>=0 && i<4); return Point4<S>::V(i); }$/;"	f	class:vcg::Quaternion
V	vcglib/vcg/simplex/edge/component.h	/^	inline       typename T::VertexType *       &  V( const int j )       { (void)j; assert(0);  static typename T::VertexType *vp=0;         return vp;    }$/;"	f	class:vcg::edge::EmptyCore
V	vcglib/vcg/simplex/edge/component.h	/^	inline       typename T::VertexType * const &  V( const int j ) const { (void)j; assert(0);  static typename T::VertexType *vp=0;         return vp;    }$/;"	f	class:vcg::edge::EmptyCore::T
V	vcglib/vcg/simplex/edge/component.h	/^  inline typename T::VertexType *       & V( const int j ) 	     { assert(j>=0 && j<2); return v[j]; }$/;"	f	class:vcg::edge::VertexRef
V	vcglib/vcg/simplex/edge/component.h	/^  inline typename T::VertexType * const & V( const int j ) const { assert(j>=0 && j<2); return v[j]; }$/;"	f	class:vcg::edge::VertexRef::T
V	vcglib/vcg/simplex/edge/pos.h	/^   VertexType *& V(){ return v; }$/;"	f	class:vcg::edge::Pos
V	vcglib/vcg/simplex/edge/pos.h	/^  inline VertexType *V() const { return e->V(z);}$/;"	f	class:vcg::edge::VEIterator
V	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType * &V( const int )       { assert(0);		static typename T::VertexType *vp=0; return vp; }$/;"	f	class:vcg::face::EmptyCore
V	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType * &V( const int j )       { assert(j>=0 && j<3); return v[j]; } \/\/\/ \\brief The pointer to the i-th vertex$/;"	f	class:vcg::face::VertexRef
V	vcglib/vcg/simplex/face/component_occ.h	/^  inline typename T::VertexType *       & V( const int j ) 	     { assert(j>=0 && j<3); $/;"	f	class:vcg::face::VertexRefOcc
V	vcglib/vcg/simplex/face/component_occ.h	/^  inline typename T::VertexType * const & V( const int j ) const { assert(j>=0 && j<3); $/;"	f	class:vcg::face::VertexRefOcc::T
V	vcglib/vcg/simplex/face/component_polygon.h	/^  inline typename T::VertexType *       & V( const int j )       { assert(j>=0 && j<this->VN()); return _vpoly[j]; }$/;"	f	class:vcg::face::PFVAdj
V	vcglib/vcg/simplex/face/component_polygon.h	/^  inline typename T::VertexType * const & V( const int j ) const { assert(j>=0 && j<this->VN()); return _vpoly[j]; }$/;"	f	class:vcg::face::PFVAdj::T
V	vcglib/vcg/simplex/face/pos.h	/^   VertexType * V() const { return v; }$/;"	f	class:vcg::face::Pos
V	vcglib/vcg/simplex/face/pos.h	/^   VertexType *& V(){ return v; }$/;"	f	class:vcg::face::Pos
V	vcglib/vcg/simplex/face/pos.h	/^  inline VertexType *V() const { return f->V(z);}$/;"	f	class:vcg::face::VFIterator
V	vcglib/vcg/simplex/tetrahedron/component.h	/^  inline typename T::VertexType *       & V( const int j ) 	     { assert(j>=0 && j<4); return v[j]; }$/;"	f	class:vcg::tetra::VertexRef
V	vcglib/vcg/simplex/tetrahedron/component.h	/^  inline typename T::VertexType *       & V( const int j ) 	    {	assert(0);		static typename T::VertexType *vp=0; return vp; }$/;"	f	class:vcg::tetra::EmptyVertexRef
V	vcglib/vcg/simplex/tetrahedron/component.h	/^  inline typename T::VertexType * const & V( const int j ) const {	assert(0);		static typename T::VertexType *vp=0; return vp; }$/;"	f	class:vcg::tetra::EmptyVertexRef::T
V	vcglib/vcg/simplex/tetrahedron/component.h	/^  inline typename T::VertexType * const & V( const int j ) const { assert(j>=0 && j<4); return v[j]; }$/;"	f	class:vcg::tetra::VertexRef::T
V	vcglib/vcg/simplex/tetrahedron/pos.h	/^	inline char & V()$/;"	f	class:vcg::tetra::Pos
V	vcglib/vcg/simplex/tetrahedron/pos.h	/^	inline const char & V() const$/;"	f	class:vcg::tetra::Pos
V	vcglib/vcg/space/deprecated_point.h	/^    inline S & V( const int i )$/;"	f	class:vcg::ndim::Point
V	vcglib/vcg/space/deprecated_point.h	/^    inline const S & V( const int i ) const$/;"	f	class:vcg::ndim::Point
V	vcglib/vcg/space/deprecated_point.h	/^    inline const S * V() const$/;"	f	class:vcg::ndim::Point
V	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType & V( const int i )$/;"	f	class:vcg::Point2
V	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType * V()$/;"	f	class:vcg::Point2
V	vcglib/vcg/space/deprecated_point2.h	/^	inline const ScalarType & V( const int i ) const$/;"	f	class:vcg::Point2
V	vcglib/vcg/space/deprecated_point2.h	/^	inline const ScalarType * V() const$/;"	f	class:vcg::Point2
V	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType & V( const int i )$/;"	f	class:vcg::Point3
V	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType * V()$/;"	f	class:vcg::Point3
V	vcglib/vcg/space/deprecated_point3.h	/^    inline const P3ScalarType & V( const int i ) const$/;"	f	class:vcg::Point3
V	vcglib/vcg/space/deprecated_point3.h	/^    inline const P3ScalarType * V() const$/;"	f	class:vcg::Point3
V	vcglib/vcg/space/deprecated_point4.h	/^    inline T & V ( const int i )$/;"	f	class:vcg::Point4
V	vcglib/vcg/space/deprecated_point4.h	/^    inline T * V()$/;"	f	class:vcg::Point4
V	vcglib/vcg/space/deprecated_point4.h	/^    inline T const * V() const$/;"	f	class:vcg::Point4
V	vcglib/vcg/space/deprecated_point4.h	/^    inline const T & V ( const int i ) const$/;"	f	class:vcg::Point4
V	vcglib/vcg/space/texcoord2.h	/^    inline T & V() { return _t[0][1]; }$/;"	f	class:vcg::TexCoord2
V	vcglib/vcg/space/texcoord2.h	/^    inline T & V() { return _t[1]; }$/;"	f	class:vcg::TexCoord2Simple
V	vcglib/vcg/space/texcoord2.h	/^    inline T & V(const int i) { (void)i; assert(i==0); return _t[1]; }$/;"	f	class:vcg::TexCoord2Simple
V	vcglib/vcg/space/texcoord2.h	/^    inline T & V(const int i) { assert(i>0 && i<NMAX);  return _t[i][1]; }$/;"	f	class:vcg::TexCoord2
V	vcglib/vcg/space/texcoord2.h	/^    inline const T & V() const { return _t[0][1]; }$/;"	f	class:vcg::TexCoord2
V	vcglib/vcg/space/texcoord2.h	/^    inline const T & V() const { return _t[1]; }$/;"	f	class:vcg::TexCoord2Simple
V	vcglib/vcg/space/texcoord2.h	/^    inline const T & V(const int i) const { (void)i; assert(i==0); return _t[1]; }$/;"	f	class:vcg::TexCoord2Simple
V	vcglib/vcg/space/texcoord2.h	/^    inline const T & V(const int i) const { assert(i>0 && i<NMAX); return _t[i][1]; }$/;"	f	class:vcg::TexCoord2
V0	vcglib/vcg/simplex/edge/component.h	/^	inline       typename T::VertexType *       &  V0( const int j )       { return V(j);}$/;"	f	class:vcg::edge::VertexRef
V0	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::VertexType * const &  V0( const int j ) const { return V(j);}$/;"	f	class:vcg::edge::VertexRef::T
V0	vcglib/vcg/simplex/edge/pos.h	/^  inline VertexType * const & V0() const { return e->V0(z);}$/;"	f	class:vcg::edge::VEIterator
V0	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType * & V0( const int j )       { return V(j);}        \/** \\brief Return the pointer to the j-th vertex of the face. *\/$/;"	f	class:vcg::face::VertexRef
V0	vcglib/vcg/simplex/face/component_occ.h	/^	inline		VertexType *       &  V0( const int j )       { return V(j);}$/;"	f	class:vcg::face::VertexRefOcc
V0	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	VertexType * const &  V0( const int j ) const { return V(j);}$/;"	f	class:vcg::face::VertexRefOcc
V0	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        VertexType *       &  V0( const int j )       { return V(j);}$/;"	f	class:vcg::face::PFVAdj
V0	vcglib/vcg/simplex/face/component_polygon.h	/^  inline const  VertexType * const &  V0( const int j ) const { return V(j);}$/;"	f	class:vcg::face::PFVAdj
V0	vcglib/vcg/simplex/face/pos.h	/^  inline VertexType * const & V0() const { return f->V0(z);}$/;"	f	class:vcg::face::VFIterator
V0	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline       typename T::VertexType *       &  V0( const int j )       { return V(j);}$/;"	f	class:vcg::tetra::VertexRef
V0	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::VertexType * const &  V0( const int j ) const { return V(j);}$/;"	f	class:vcg::tetra::VertexRef::T
V1	vcglib/vcg/simplex/edge/component.h	/^	inline       typename T::VertexType *       &  V1( const int j )       { return V((j+1)%2);}$/;"	f	class:vcg::edge::VertexRef
V1	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::VertexType * const &  V1( const int j ) const { return V((j+1)%2);}$/;"	f	class:vcg::edge::VertexRef::T
V1	vcglib/vcg/simplex/edge/pos.h	/^  inline VertexType * const & V1() const { return e->V1(z);}$/;"	f	class:vcg::edge::VEIterator
V1	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType * & V1( const int j )       { return V((j+1)%3);}  \/** \\brief Return the pointer to the ((j+1)%3)-th vertex of the face. *\/$/;"	f	class:vcg::face::VertexRef
V1	vcglib/vcg/simplex/face/component_occ.h	/^	inline       	VertexType *       &  V1( const int j )       { return V((j+1)%3);}$/;"	f	class:vcg::face::VertexRefOcc
V1	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	VertexType * const &  V1( const int j ) const { return V((j+1)%3);}$/;"	f	class:vcg::face::VertexRefOcc
V1	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        VertexType *       &  V1( const int j )       { return V((j+1)%this->VN());}$/;"	f	class:vcg::face::PFVAdj
V1	vcglib/vcg/simplex/face/component_polygon.h	/^  inline const  VertexType * const &  V1( const int j ) const { return V((j+1)%this->VN());}$/;"	f	class:vcg::face::PFVAdj
V1	vcglib/vcg/simplex/face/pos.h	/^  inline VertexType * const & V1() const { return f->V1(z);}$/;"	f	class:vcg::face::VFIterator
V1	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline       typename T::VertexType *       &  V1( const int j )       { return V((j+1)%4);}$/;"	f	class:vcg::tetra::VertexRef
V1	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::VertexType * const &  V1( const int j ) const { return V((j+1)%4);}$/;"	f	class:vcg::tetra::VertexRef::T
V2	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType * & V2( const int j )       { return V((j+2)%3);}  \/** \\brief Return the pointer to the ((j+2)%3)-th vertex of the face. *\/$/;"	f	class:vcg::face::VertexRef
V2	vcglib/vcg/simplex/face/component_occ.h	/^	inline       	VertexType *       &  V2( const int j )       { return V((j+2)%3);}$/;"	f	class:vcg::face::VertexRefOcc
V2	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	VertexType * const &  V2( const int j ) const { return V((j+2)%3);}$/;"	f	class:vcg::face::VertexRefOcc
V2	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        VertexType *       &  V2( const int j )       { return V((j+2)%this->VN());}$/;"	f	class:vcg::face::PFVAdj
V2	vcglib/vcg/simplex/face/component_polygon.h	/^  inline const  VertexType * const &  V2( const int j ) const { return V((j+2)%this->VN());}$/;"	f	class:vcg::face::PFVAdj
V2	vcglib/vcg/simplex/face/pos.h	/^  inline VertexType * const & V2() const { return f->V2(z);}$/;"	f	class:vcg::face::VFIterator
V2	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline       typename T::VertexType *       &  V2( const int j )       { return V((j+2)%4);}$/;"	f	class:vcg::tetra::VertexRef
V2	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::VertexType * const &  V2( const int j ) const { return V((j+2)%4);}$/;"	f	class:vcg::tetra::VertexRef::T
VALENCY_FLAGS	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef enum { VALENCY_FLAGS = 24 } ___; \/\/ this bit and the 4 successive one are devoted to store valency$/;"	e	enum:vcg::tri::BitQuad::__anon480
VALUE_BOOL	vcglib/apps/trimeshinfo/Node.h	/^enum values {VALUE_INTEGER, VALUE_FLOAT, VALUE_BOOL, VALUE_STRING};$/;"	e	enum:values
VALUE_FLOAT	vcglib/apps/trimeshinfo/Node.h	/^enum values {VALUE_INTEGER, VALUE_FLOAT, VALUE_BOOL, VALUE_STRING};$/;"	e	enum:values
VALUE_INTEGER	vcglib/apps/trimeshinfo/Node.h	/^enum values {VALUE_INTEGER, VALUE_FLOAT, VALUE_BOOL, VALUE_STRING};$/;"	e	enum:values
VALUE_NODE	vcglib/apps/trimeshinfo/Node.h	/^const int		VALUE_NODE=				5; $/;"	v
VALUE_STRING	vcglib/apps/trimeshinfo/Node.h	/^enum values {VALUE_INTEGER, VALUE_FLOAT, VALUE_BOOL, VALUE_STRING};$/;"	e	enum:values
VCGADDONS_H	vcglib/vcg/space/index/kdtree/mlsutils.h	/^#define VCGADDONS_H$/;"	d
VCGLIB_GL_SURFACE_H	vcglib/wrap/gl/gl_surface.h	/^#define VCGLIB_GL_SURFACE_H$/;"	d
VCGLIB_SPATIAL_HASHING	vcglib/vcg/space/index/spatial_hashing.h	/^#define VCGLIB_SPATIAL_HASHING$/;"	d
VCGLIB_SPATIAL_HASHING_2D	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^#define VCGLIB_SPATIAL_HASHING_2D$/;"	d
VCGLIB_TRACKRECORDER	vcglib/wrap/gui/trackrecorder.h	/^#define VCGLIB_TRACKRECORDER$/;"	d
VCGLIB_UPDATE_CURVATURE_	vcglib/vcg/complex/algorithms/update/curvature.h	/^#define VCGLIB_UPDATE_CURVATURE_$/;"	d
VCGLIB_UPDATE_CURVATURE_FITTING	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^#define VCGLIB_UPDATE_CURVATURE_FITTING$/;"	d
VCGMaterialBridge	vcglib/wrap/io_trimesh/import_fbx.h	/^		VCGMaterialBridge(OpenMeshType& m,KFbxSurfaceMaterial& mat)$/;"	f	class:ImporterFBX::VCGMaterialBridge
VCGMaterialBridge	vcglib/wrap/io_trimesh/import_fbx.h	/^	class VCGMaterialBridge$/;"	c	class:ImporterFBX
VCG_ALL_TYPES_H	vcglib/vcg/complex/all_types.h	/^#define VCG_ALL_TYPES_H$/;"	d
VCG_BITQUAD_CRE	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^#define VCG_BITQUAD_CRE$/;"	d
VCG_BITQUAD_SUPPORT	vcglib/vcg/complex/algorithms/bitquad_support.h	/^#define VCG_BITQUAD_SUPPORT$/;"	d
VCG_BMT_H	vcglib/wrap/bmt/bmt.h	/^#define VCG_BMT_H$/;"	d
VCG_EIGEN_INHERIT_ASSIGNMENT_OPERATOR	vcglib/vcg/math/eigen.h	/^#define VCG_EIGEN_INHERIT_ASSIGNMENT_OPERATOR(/;"	d
VCG_EIGEN_INHERIT_ASSIGNMENT_OPERATORS	vcglib/vcg/math/eigen.h	/^#define VCG_EIGEN_INHERIT_ASSIGNMENT_OPERATORS(/;"	d
VCG_EIGEN_INHERIT_SCALAR_ASSIGNMENT_OPERATOR	vcglib/vcg/math/eigen.h	/^	#define VCG_EIGEN_INHERIT_SCALAR_ASSIGNMENT_OPERATOR(/;"	d
VCG_GL_MATH_H	vcglib/wrap/gl/deprecated_math.h	/^#define VCG_GL_MATH_H$/;"	d
VCG_GL_MATH_H	vcglib/wrap/gl/math.h	/^#define VCG_GL_MATH_H$/;"	d
VCG_GL_POS_H	vcglib/wrap/gl/pos.h	/^#define VCG_GL_POS_H$/;"	d
VCG_GL_SPACE_H	vcglib/wrap/gl/deprecated_space.h	/^#define VCG_GL_SPACE_H$/;"	d
VCG_GL_SPACE_H	vcglib/wrap/gl/space.h	/^#define VCG_GL_SPACE_H$/;"	d
VCG_HEDGE_POS	vcglib/vcg/connectors/halfedge_pos.h	/^#define VCG_HEDGE_POS$/;"	d
VCG_HEDGE_TOPOLOGY	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^#define VCG_HEDGE_TOPOLOGY$/;"	d
VCG_ILLUMINANT_A	vcglib/vcg/space/colorspace.h	/^		VCG_ILLUMINANT_A = 0,	$/;"	e	enum:vcg::ColorSpace::Illuminant
VCG_ILLUMINANT_B	vcglib/vcg/space/colorspace.h	/^		VCG_ILLUMINANT_B = 1,	$/;"	e	enum:vcg::ColorSpace::Illuminant
VCG_ILLUMINANT_C	vcglib/vcg/space/colorspace.h	/^		VCG_ILLUMINANT_C = 2,$/;"	e	enum:vcg::ColorSpace::Illuminant
VCG_ILLUMINANT_D50	vcglib/vcg/space/colorspace.h	/^		VCG_ILLUMINANT_D50 = 3,	$/;"	e	enum:vcg::ColorSpace::Illuminant
VCG_ILLUMINANT_D55	vcglib/vcg/space/colorspace.h	/^		VCG_ILLUMINANT_D55 = 4,	$/;"	e	enum:vcg::ColorSpace::Illuminant
VCG_ILLUMINANT_D65	vcglib/vcg/space/colorspace.h	/^		VCG_ILLUMINANT_D65 = 5,	$/;"	e	enum:vcg::ColorSpace::Illuminant
VCG_ILLUMINANT_D75	vcglib/vcg/space/colorspace.h	/^		VCG_ILLUMINANT_D75 = 6,$/;"	e	enum:vcg::ColorSpace::Illuminant
VCG_ILLUMINANT_E	vcglib/vcg/space/colorspace.h	/^		VCG_ILLUMINANT_E = 7,$/;"	e	enum:vcg::ColorSpace::Illuminant
VCG_ILLUMINANT_INVALID	vcglib/vcg/space/colorspace.h	/^		VCG_ILLUMINANT_INVALID = 8$/;"	e	enum:vcg::ColorSpace::Illuminant
VCG_INSIDE	vcglib/vcg/complex/algorithms/inside.h	/^#define VCG_INSIDE$/;"	d
VCG_MATH_UNIONSET_H	vcglib/vcg/math/disjoint_set.h	/^#define VCG_MATH_UNIONSET_H$/;"	d
VCG_MESH_HPP__	vcg_mesh.hpp	/^#define VCG_MESH_HPP__$/;"	d
VCG_MT_H	vcglib/wrap/mt/mt.h	/^#define VCG_MT_H$/;"	d
VCG_PARAM_DISTORTION	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^#define VCG_PARAM_DISTORTION$/;"	d
VCG_PIVOT_H	vcglib/apps/pivoting/pivot.h	/^#define VCG_PIVOT_H$/;"	d
VCG_PLANE3_H	vcglib/vcg/space/plane3.h	/^#define VCG_PLANE3_H$/;"	d
VCG_POISSON_SOLVER	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^#define VCG_POISSON_SOLVER$/;"	d
VCG_SPACE_INDEX_OCTREETEMPLATE_H	vcglib/vcg/space/index/octree_template.h	/^#define VCG_SPACE_INDEX_OCTREETEMPLATE_H$/;"	d
VCG_SPACE_INDEX_OCTREE_H	vcglib/vcg/space/index/octree.h	/^#define VCG_SPACE_INDEX_OCTREE_H$/;"	d
VCG_SPACE_INDEX_PERFECT_SPATIAL_HASHING_H	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^#define VCG_SPACE_INDEX_PERFECT_SPATIAL_HASHING_H$/;"	d
VCG_SPHERE_H	vcglib/vcg/space/sphere3.h	/^#define VCG_SPHERE_H$/;"	d
VCG_STRIP_MESH_H	vcglib/wrap/bmt/strip_mesh.h	/^#define VCG_STRIP_MESH_H$/;"	d
VCG_SYMMETRY_H	vcglib/vcg/complex/algorithms/symmetry.h	/^#define VCG_SYMMETRY_H$/;"	d
VCG_TANGENT_FIELD_OPERATORS	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^#define VCG_TANGENT_FIELD_OPERATORS$/;"	d
VCG_TRI_ATTRIBUTE_SEAM_H	vcglib/vcg/complex/algorithms/attribute_seam.h	/^#define VCG_TRI_ATTRIBUTE_SEAM_H$/;"	d
VCG_USED_TYPES_H	vcglib/vcg/complex/used_types.h	/^#define VCG_USED_TYPES_H$/;"	d
VCG_UV_UTILS	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^#define VCG_UV_UTILS$/;"	d
VCG_WRAP_QT_GLLABEL_H	vcglib/wrap/qt/gl_label.h	/^#define VCG_WRAP_QT_GLLABEL_H$/;"	d
VDistFunct	vcglib/vcg/complex/algorithms/closest.h	/^			typedef vcg::vertex::PointDistanceFunctor<typename MESH::ScalarType> VDistFunct;$/;"	t	class:vcg::tri::ClosestVertexIterator
VEAdj	vcglib/vcg/simplex/edge/component.h	/^	VEAdj(){_ep[0]=0;_ep[1]=0;_zp[0]=-1;_zp[1]=-1;}$/;"	f	class:vcg::edge::VEAdj
VEAdj	vcglib/vcg/simplex/edge/component.h	/^  template <class T> class VEAdj: public T {$/;"	c	namespace:vcg::edge
VEAdj	vcglib/vcg/simplex/vertex/component.h	/^  VEAdj(){_ep=0;_zp=-1;}$/;"	f	class:vcg::vertex::VEAdj
VEAdj	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class VEAdj: public T {$/;"	c	namespace:vcg::vertex
VEIterator	vcglib/vcg/simplex/edge/pos.h	/^	VEIterator(){}$/;"	f	class:vcg::edge::VEIterator
VEIterator	vcglib/vcg/simplex/edge/pos.h	/^	VEIterator(EdgeType * _e,  const int &  _z){e = _e; z = _z;}$/;"	f	class:vcg::edge::VEIterator
VEIterator	vcglib/vcg/simplex/edge/pos.h	/^	VEIterator(VertexType * _v){$/;"	f	class:vcg::edge::VEIterator
VEIterator	vcglib/vcg/simplex/edge/pos.h	/^class VEIterator$/;"	c	namespace:vcg::edge
VERIFY_IS_APPROX_ABS	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^#define VERIFY_IS_APPROX_ABS(/;"	d	file:
VERIFY_MATRIX	vcglib/eigenlib/unsupported/test/openglsupport.cpp	/^#define VERIFY_MATRIX(/;"	d	file:
VERIFY_UNIFORM	vcglib/eigenlib/unsupported/test/openglsupport.cpp	/^#define VERIFY_UNIFORM(/;"	d	file:
VERIFY_UNIFORMi	vcglib/eigenlib/unsupported/test/openglsupport.cpp	/^#define VERIFY_UNIFORMi(/;"	d	file:
VERTCOLOR	vcglib/wrap/dae/colladaformat.h	/^		enum ARRAYSEMANTIC {VERTPOSITION,VERTNORMAL,VERTCOLOR, FACENORMAL,WEDGETEXCOORD};$/;"	e	enum:Collada::Tags::FloatArrayTag::ARRAYSEMANTIC
VERTEX	vcglib/wrap/gl/shaders.h	/^		VERTEX,$/;"	e	enum:Shader::__anon517
VERTEX_SAMPLING	vcglib/apps/metro/sampling.h	/^						VERTEX_SAMPLING									= 0x0002,$/;"	e	enum:vcg::SamplingFlags::__anon1
VERTNORMAL	vcglib/wrap/dae/colladaformat.h	/^		enum ARRAYSEMANTIC {VERTPOSITION,VERTNORMAL,VERTCOLOR, FACENORMAL,WEDGETEXCOORD};$/;"	e	enum:Collada::Tags::FloatArrayTag::ARRAYSEMANTIC
VERTPOSITION	vcglib/wrap/dae/colladaformat.h	/^		enum ARRAYSEMANTIC {VERTPOSITION,VERTNORMAL,VERTCOLOR, FACENORMAL,WEDGETEXCOORD};$/;"	e	enum:Collada::Tags::FloatArrayTag::ARRAYSEMANTIC
VEStarVE	vcglib/vcg/simplex/edge/topology.h	/^void VEStarVE(typename EdgeType::VertexType* vp, std::vector<EdgeType *> &starVec)$/;"	f	namespace:vcg::edge
VEi	vcglib/vcg/simplex/edge/component.h	/^	int &VEi(const int & i){ return _zp[i];}$/;"	f	class:vcg::edge::VEAdj
VEi	vcglib/vcg/simplex/edge/component.h	/^    int &VEi(const int &){static int z=0; assert(0); return z;}$/;"	f	class:vcg::edge::EmptyCore
VEi	vcglib/vcg/simplex/vertex/component.h	/^  int &VEi()       { static int z=0; return z;}$/;"	f	class:vcg::vertex::EmptyCore
VEi	vcglib/vcg/simplex/vertex/component.h	/^  int &VEi()       {return _zp; }$/;"	f	class:vcg::vertex::VEAdj
VEp	vcglib/vcg/simplex/edge/component.h	/^	typename T::EdgePointer &VEp(const int & i) {return _ep[i]; }$/;"	f	class:vcg::edge::VEAdj
VEp	vcglib/vcg/simplex/edge/component.h	/^    typename T::EdgePointer &VEp(const int &  ) { static typename T::EdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::edge::EmptyCore
VEp	vcglib/vcg/simplex/vertex/component.h	/^  typename T::EdgePointer &VEp()       {return _ep; }$/;"	f	class:vcg::vertex::VEAdj
VEp	vcglib/vcg/simplex/vertex/component.h	/^  typename TT::EdgePointer &VEp()       { static typename TT::EdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::vertex::EmptyCore
VFAdj	vcglib/vcg/simplex/face/component.h	/^    VFAdj(){$/;"	f	class:vcg::face::VFAdj
VFAdj	vcglib/vcg/simplex/face/component.h	/^template <class T> class VFAdj: public T {$/;"	c	namespace:vcg::face
VFAdj	vcglib/vcg/simplex/vertex/component.h	/^    VFAdj(){_fp=0;_zp=-1;}$/;"	f	class:vcg::vertex::VFAdj
VFAdj	vcglib/vcg/simplex/vertex/component.h	/^  template <class T> class VFAdj: public T {$/;"	c	namespace:vcg::vertex
VFAdjOcc	vcglib/vcg/simplex/face/component_occ.h	/^template <class T> class VFAdjOcc : public VFAdjOccBase<VFAdjTypeSup<typename T::FacePointer>,T>{};$/;"	c	namespace:vcg::face
VFAdjOcc	vcglib/vcg/simplex/vertex/component_occ.h	/^template <class T> class VFAdjOcc: public T {$/;"	c	namespace:vcg::vertex
VFAdjOccBase	vcglib/vcg/simplex/face/component_occ.h	/^template <class A, class T> class VFAdjOccBase: public T {$/;"	c	namespace:vcg::face
VFAdjOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class VFAdjOcf: public T {$/;"	c	namespace:vcg::face
VFAdjOcf	vcglib/vcg/simplex/vertex/component_ocf.h	/^template <class T> class VFAdjOcf: public T {$/;"	c	namespace:vcg::vertex
VFAdjType	vcglib/vcg/simplex/face/component.h	/^  typedef int VFAdjType;$/;"	t	class:vcg::face::EmptyCore
VFAdjType	vcglib/vcg/simplex/face/component_occ.h	/^	typedef VFAdjTypeSup<typename T::VertexPointer> VFAdjType;$/;"	t	class:vcg::face::VFAdjOccBase
VFAdjType	vcglib/vcg/simplex/tetrahedron/component.h	/^	typedef int VFAdjType;$/;"	t	class:vcg::tetra::EmptyAdj
VFAdjType	vcglib/vcg/simplex/vertex/component_ocf.h	/^struct VFAdjType {$/;"	s	class:vcg::vertex::vector_ocf
VFAdjTypeSup	vcglib/vcg/simplex/face/component_occ.h	/^struct VFAdjTypeSup {$/;"	s	namespace:vcg::face
VFAdjacencyEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  bool VFAdjacencyEnabled;$/;"	m	class:vcg::face::vector_ocf
VFAdjacencyEnabled	vcglib/vcg/simplex/vertex/component_ocf.h	/^  bool VFAdjacencyEnabled;$/;"	m	class:vcg::vertex::vector_ocf
VFAppend	vcglib/vcg/simplex/face/topology.h	/^void VFAppend(FaceType* & f, int z)$/;"	f	namespace:vcg::face
VFClear	vcglib/vcg/simplex/face/component.h	/^  void VFClear(int j) {$/;"	f	class:vcg::face::EmptyCore
VFClear	vcglib/vcg/simplex/vertex/component.h	/^  void VFClear() {$/;"	f	class:vcg::vertex::EmptyCore
VFDetach	vcglib/vcg/simplex/face/topology.h	/^void VFDetach(FaceType & f)$/;"	f	namespace:vcg::face
VFDetach	vcglib/vcg/simplex/face/topology.h	/^void VFDetach(FaceType & f, int z)$/;"	f	namespace:vcg::face
VFExtendedStarVF	vcglib/vcg/simplex/face/topology.h	/^void VFExtendedStarVF(typename FaceType::VertexType* vp,$/;"	f	namespace:vcg::face
VFI	vcglib/vcg/complex/algorithms/edge_collapse.h	/^    typedef typename vcg::face::VFIterator<FaceType>  VFI;$/;"	t	class:vcg::tri::EdgeCollapser
VFIEdgeType	vcglib/vcg/simplex/edge/pos.h	/^	typedef  EdgeType  VFIEdgeType;$/;"	t	class:vcg::edge::VEIterator
VFIFaceType	vcglib/vcg/simplex/face/pos.h	/^	typedef  FaceType  VFIFaceType;$/;"	t	class:vcg::face::VFIterator
VFIVec	vcglib/vcg/complex/algorithms/edge_collapse.h	/^    typedef typename std::vector<vcg::face::VFIterator<FaceType> > VFIVec;$/;"	t	class:vcg::tri::EdgeCollapser
VFIterator	vcglib/vcg/simplex/face/pos.h	/^	VFIterator(){}$/;"	f	class:vcg::face::VFIterator
VFIterator	vcglib/vcg/simplex/face/pos.h	/^	VFIterator(FaceType * _f,  const int &  _z){f = _f; z = _z;  assert(z>=0 && "VFAdj must be initialized");}$/;"	f	class:vcg::face::VFIterator
VFIterator	vcglib/vcg/simplex/face/pos.h	/^	VFIterator(VertexType * _v){f = _v->VFp(); z = _v->VFi(); assert(z>=0 && "VFAdj must be initialized");}$/;"	f	class:vcg::face::VFIterator
VFIterator	vcglib/vcg/simplex/face/pos.h	/^class VFIterator$/;"	c	namespace:vcg::face
VFIteratorType	vcglib/vcg/complex/algorithms/update/curvature.h	/^    typedef vcg::face::VFIterator<FaceType> VFIteratorType;$/;"	t	class:vcg::tri::UpdateCurvature
VFIteratorType	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^	typedef vcg::face::VFIterator<FaceType> VFIteratorType;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
VFLocalIterator	vcglib/vcg/complex/algorithms/smooth.h	/^        typedef typename vcg::face::VFIterator<FaceType> VFLocalIterator;$/;"	t	class:vcg::tri::Smooth
VFOrderedStarFF	vcglib/vcg/simplex/face/topology.h	/^void VFOrderedStarFF(Pos<FaceType> &startPos,$/;"	f	namespace:vcg::face
VFStarVF	vcglib/vcg/simplex/face/topology.h	/^void VFStarVF( typename FaceType::VertexType* vp,$/;"	f	namespace:vcg::face
VFi	vcglib/vcg/simplex/face/component.h	/^  char &VFi(const int j) {return _efi[j]; }$/;"	f	class:vcg::face::EFAdj
VFi	vcglib/vcg/simplex/face/component.h	/^  char &VFi(const int j) {return _vfi[j]; }$/;"	f	class:vcg::face::VFAdj
VFi	vcglib/vcg/simplex/face/component.h	/^  char &VFi(int)       { static char z=0; assert(0); return z;}$/;"	f	class:vcg::face::EmptyCore
VFi	vcglib/vcg/simplex/face/component_occ.h	/^  char &VFi(const int j) { return (CAT< vector_occ<FaceType>,VFAdjTypeSup<FacePointer> >::Instance()->Get((FaceType*)this))._vfi[j];}$/;"	f	class:vcg::face::VFAdjOccBase
VFi	vcglib/vcg/simplex/face/component_ocf.h	/^  char &VFi(const int j) {$/;"	f	class:vcg::face::VFAdjOcf
VFi	vcglib/vcg/simplex/face/component_polygon.h	/^  char &VFi(const int j) {return _vfiP[j]; }$/;"	f	class:vcg::face::PVFAdj
VFi	vcglib/vcg/simplex/vertex/component.h	/^    int &VFi()       { return _zp; }$/;"	f	class:vcg::vertex::VFAdj
VFi	vcglib/vcg/simplex/vertex/component.h	/^  int &VFi()       { static int z=-1; assert(0); return z;}$/;"	f	class:vcg::vertex::EmptyCore
VFi	vcglib/vcg/simplex/vertex/component_ocf.h	/^    int &VFi()       {$/;"	f	class:vcg::vertex::VFAdjOcf
VFlip	vcglib/vcg/simplex/edge/pos.h	/^	VertexType *VFlip()$/;"	f	class:vcg::edge::Pos
VFlip	vcglib/vcg/simplex/face/pos.h	/^    VertexType *VFlip() const$/;"	f	class:vcg::face::Pos
VFp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer &VFp(const int j)        { assert(j>=0 && j<3);  return _vfp[j]; }$/;"	f	class:vcg::face::VFAdj
VFp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer &VFp(int)       { static typename T::FacePointer fp=0; assert(0); return fp; }$/;"	f	class:vcg::face::EmptyCore
VFp	vcglib/vcg/simplex/face/component_occ.h	/^  	FacePointer &VFp(const int j) {$/;"	f	class:vcg::face::VFAdjOccBase
VFp	vcglib/vcg/simplex/face/component_ocf.h	/^  typename T::FacePointer &VFp(const int j) {$/;"	f	class:vcg::face::VFAdjOcf
VFp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::FacePointer       &VFp(const int j)        { assert(j>=0 && j<this->VN());  return _vfpP[j]; }$/;"	f	class:vcg::face::PVFAdj
VFp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::FacePointer const  VFp(const int j) const  { assert(j>=0 && j<this->VN());  return _vfpP[j]; }$/;"	f	class:vcg::face::PVFAdj::T
VFp	vcglib/vcg/simplex/vertex/component.h	/^    typename T::FacePointer &VFp()        { return _fp; }$/;"	f	class:vcg::vertex::VFAdj
VFp	vcglib/vcg/simplex/vertex/component.h	/^  typename TT::FacePointer &VFp()       { static typename TT::FacePointer fp=0;  assert(0); return fp; }$/;"	f	class:vcg::vertex::EmptyCore
VFp	vcglib/vcg/simplex/vertex/component_ocf.h	/^	typename T::FacePointer &VFp()       {$/;"	f	class:vcg::vertex::VFAdjOcf
VFrustum	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	class VFrustum {$/;"	c	class:vcg::AABBBinaryTreeFrustumCull
VFrustumPlane	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^	class VFrustumPlane {$/;"	c	class:vcg::AABBBinaryTreeFrustumCull
VHAdj	vcglib/vcg/simplex/vertex/component.h	/^	VHAdj(){_hp=0;_zp=-1;}$/;"	f	class:vcg::vertex::VHAdj
VHAdj	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class VHAdj: public T {$/;"	c	namespace:vcg::vertex
VHi	vcglib/vcg/simplex/vertex/component.h	/^	int &VHi() {return _zp; }$/;"	f	class:vcg::vertex::VHAdj
VHi	vcglib/vcg/simplex/vertex/component.h	/^  int &VHi()       { static int z=0; return z;}$/;"	f	class:vcg::vertex::EmptyCore
VHp	vcglib/vcg/simplex/vertex/component.h	/^	typename T::HEdgePointer &VHp()       {return _hp; }$/;"	f	class:vcg::vertex::VHAdj
VHp	vcglib/vcg/simplex/vertex/component.h	/^  typename TT::HEdgePointer &VHp()       { static typename TT::HEdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::vertex::EmptyCore
VIPair	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef internal::vector_int_pair<Scalar, Dim> VIPair;$/;"	t	class:Eigen::KdBVH
VIPairList	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef std::vector<VIPair, aligned_allocator<VIPair> > VIPairList;$/;"	t	class:Eigen::KdBVH
VISITED	vcglib/vcg/connectors/hedge.h	/^		VISITED    = 0x0010,		\/\/ This bit can be used to mark the visited edge$/;"	e	enum:vcg::HEdgeArityMax::__anon484
VISITED	vcglib/vcg/simplex/edge/base.h	/^		VISITED    = 0x0010,		\/\/ This bit can be used to mark the visited edge$/;"	e	enum:vcg::EdgeArityMax::__anon496
VISITED	vcglib/vcg/simplex/face/base.h	/^    VISITED     = 0x00000010,		\/\/ Face has been visited. Usualy this is a per-algorithm used bit. $/;"	e	enum:vcg::FaceArityMax::__anon497
VISITED	vcglib/vcg/simplex/tetrahedron/base.h	/^    VISITED     = 0x00000010,		\/\/ Face has been visited. Usualy this is a per-algorithm used bit. $/;"	e	enum:vcg::TetraArityMax::__anon498
VISITED	vcglib/vcg/simplex/vertex/base.h	/^		VISITED    = 0x0010,		\/\/ This bit can be used to mark the visited vertex$/;"	e	enum:vcg::VertexArityMax::__anon499
VInd	vcglib/vcg/simplex/edge/pos.h	/^   int VInd(){$/;"	f	class:vcg::edge::Pos
VInd	vcglib/vcg/simplex/face/pos.h	/^   int VInd()$/;"	f	class:vcg::face::Pos
VMIErrorCodes	vcglib/wrap/io_trimesh/import_vmi.h	/^       enum VMIErrorCodes {$/;"	g	class:vcg::tri::io::ImporterVMI
VMI_FAILED_OPEN	vcglib/wrap/io_trimesh/import_vmi.h	/^                VMI_FAILED_OPEN$/;"	e	enum:vcg::tri::io::ImporterVMI::VMIErrorCodes
VMI_INCOMPATIBLE_FACE_TYPE	vcglib/wrap/io_trimesh/import_vmi.h	/^                VMI_INCOMPATIBLE_FACE_TYPE,$/;"	e	enum:vcg::tri::io::ImporterVMI::VMIErrorCodes
VMI_INCOMPATIBLE_VERTEX_TYPE	vcglib/wrap/io_trimesh/import_vmi.h	/^                VMI_INCOMPATIBLE_VERTEX_TYPE,$/;"	e	enum:vcg::tri::io::ImporterVMI::VMIErrorCodes
VMI_NO_ERROR	vcglib/wrap/io_trimesh/import_vmi.h	/^                VMI_NO_ERROR = 0,$/;"	e	enum:vcg::tri::io::ImporterVMI::VMIErrorCodes
VManifold	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool VManifold;$/;"	m	struct:MeshInfo	file:
VN	vcglib/apps/unsupported/shadevis/visshader.h	/^	std::vector< Point3x > VN;				 \/\/ Vettore delle normali che ho usato per calcolare la mask e i float in W;$/;"	m	class:vcg::VisShader
VN	vcglib/vcg/complex/base.h	/^    inline int VN() const { return vn; }$/;"	f	class:vcg::tri::TriMesh
VN	vcglib/vcg/simplex/face/base.h	/^        inline int VN()  const { return 3;}$/;"	f	class:vcg::FaceTypeHolder
VN	vcglib/vcg/simplex/face/component_polygon.h	/^  inline const int &  VN() const { return _ns;}$/;"	f	class:vcg::face::PolyInfo
VOL	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^	static int VOL(){static int vol=0; return vol++;}$/;"	f	struct:FAIL
VON_KRIES	vcglib/vcg/space/colorspace.h	/^	enum ConeResponse	{	BRADFORD = 0,	VON_KRIES = 1, XYZ_SCALING = 2};$/;"	e	enum:vcg::ColorSpace::ConeResponse
VORONOI_ATLAS_H	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^#define VORONOI_ATLAS_H$/;"	d
VORONOI_PROCESSING_H	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^#define VORONOI_PROCESSING_H$/;"	d
VTAdj	vcglib/vcg/simplex/tetrahedron/component.h	/^	VTAdj() { _vtp[0]=0; _vtp[1]=0; _vtp[2]=0; _vtp[3]=0; }$/;"	f	class:vcg::tetra::VTAdj
VTAdj	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class VTAdj: public T {$/;"	c	namespace:vcg::tetra
VTAdj	vcglib/vcg/simplex/vertex/component.h	/^	VTAdj() { _tp = 0; _zp=-1;}$/;"	f	class:vcg::vertex::VTAdj
VTAdj	vcglib/vcg/simplex/vertex/component.h	/^template <class T> class VTAdj: public T {$/;"	c	namespace:vcg::vertex
VTIterator	vcglib/vcg/simplex/tetrahedron/pos.h	/^	VTIterator(){}$/;"	f	class:vcg::tetra::VTIterator
VTIterator	vcglib/vcg/simplex/tetrahedron/pos.h	/^	VTIterator(TetraType  * const tp, int const zp)$/;"	f	class:vcg::tetra::VTIterator
VTIterator	vcglib/vcg/simplex/tetrahedron/pos.h	/^class VTIterator$/;"	c	namespace:vcg::tetra
VTi	vcglib/vcg/simplex/tetrahedron/component.h	/^	char & VTi( const int j ) { return _vti[j]; }$/;"	f	class:vcg::tetra::VTAdj
VTi	vcglib/vcg/simplex/tetrahedron/component.h	/^	char & VTi( const int j ) { static char z=0; return z; }$/;"	f	class:vcg::tetra::EmptyAdj
VTi	vcglib/vcg/simplex/vertex/component.h	/^	int &VTi() {return _zp; }$/;"	f	class:vcg::vertex::VTAdj
VTi	vcglib/vcg/simplex/vertex/component.h	/^  int &VTi() { static int z = 0; return z; }$/;"	f	class:vcg::vertex::EmptyCore
VTp	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer & VTp( const int ) { static typename T::TetraPointer tp=0; return tp; }$/;"	f	class:vcg::tetra::EmptyAdj
VTp	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer & VTp( const int j ) { assert( j >= 0 && j < 4 ); return _vtp[j]; }$/;"	f	class:vcg::tetra::VTAdj
VTp	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer const VTp( const int j ) const { assert( j >= 0 && j < 4 ); return _vtp[j]; }$/;"	f	class:vcg::tetra::VTAdj::T
VTp	vcglib/vcg/simplex/vertex/component.h	/^	typename T::TetraPointer &VTp()       { return _tp; }$/;"	f	class:vcg::vertex::VTAdj
VTp	vcglib/vcg/simplex/vertex/component.h	/^  typename TT::TetraPointer &VTp()       { static typename TT::TetraPointer tp = 0;  assert(0); return tp; }$/;"	f	class:vcg::vertex::EmptyCore
VV	vcglib/apps/unsupported/shadevis/visshader.h	/^	std::vector<float> VV;$/;"	m	class:vcg::VisShader
VV	vcglib/vcg/complex/algorithms/create/resampler.h	/^		std::pair<bool,float> VV(int x,int y,int z)$/;"	f	class:vcg::tri::Resampler::Walker
VVExtendedStarVF	vcglib/vcg/simplex/face/topology.h	/^void VVExtendedStarVF(typename FaceType::VertexType* vp,$/;"	f	namespace:vcg::face
VVOrderedStarFF	vcglib/vcg/simplex/face/topology.h	/^void VVOrderedStarFF(Pos<FaceType> &startPos,$/;"	f	namespace:vcg::face
VVStarVE	vcglib/vcg/simplex/edge/topology.h	/^void VVStarVE(typename EdgeType::VertexType* vp, std::vector<typename EdgeType::VertexType *> &starVec)$/;"	f	namespace:vcg::edge
VVStarVF	vcglib/vcg/simplex/face/topology.h	/^void VVStarVF( typename FaceType::VertexType* vp, std::vector<typename FaceType::VertexType *> &starVec)$/;"	f	namespace:vcg::face
Val	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  float &Val(const int &x,const int &y,const int &z) {$/;"	f	class:vcg::SimpleVolume
Val	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  float Val(const int &x,const int &y,const int &z) const {$/;"	f	class:vcg::SimpleVolume
Val	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  float &Val(const int &x,const int &y,const int &z) {$/;"	f	class:vcg::SimpleVolume
Val	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  float Val(const int &x,const int &y,const int &z) const {$/;"	f	class:vcg::SimpleVolume
Val	vcglib/vcg/math/gen_normal.h	/^    Point3x &Val(int i, int j) {$/;"	f	class:vcg::GenNormal::OctaLevel
ValenceAttr	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef typename MESH_TYPE::template PerVertexAttributeHandle<int> ValenceAttr;$/;"	t	struct:vcg::tri::EvenPointLoopGeneric
ValenceAttr	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef typename MESH_TYPE::template PerVertexAttributeHandle<int> ValenceAttr;$/;"	t	struct:vcg::tri::OddPointLoopGeneric
ValidObject	vcglib/wrap/gl/gl_object.h	/^	bool ValidObject(void) const$/;"	f	class:GLObject
ValidateAttachment	vcglib/wrap/gl/fbo.h	/^	bool ValidateAttachment(GLenum attachment) const$/;"	f	class:ColorRenderTarget
ValidateAttachment	vcglib/wrap/gl/fbo.h	/^	bool ValidateAttachment(GLenum attachment) const$/;"	f	class:DepthRenderTarget
ValidateAttachment	vcglib/wrap/gl/fbo.h	/^	bool ValidateAttachment(GLenum attachment) const$/;"	f	class:StencilRenderTarget
ValidateColor	vcglib/wrap/gl/fbo.h	/^	static bool ValidateColor(GLenum type)$/;"	f	class:FrameBufferSemantic
ValidateDepth	vcglib/wrap/gl/fbo.h	/^	static bool ValidateDepth(GLenum type)$/;"	f	class:FrameBufferSemantic
ValidateEntry	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void ValidateEntry(EntryCoordinate &entry)$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
ValidateEntryCoordinate	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void ValidateEntryCoordinate(EntryCoordinate &entry)$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
ValidateFormat	vcglib/wrap/gl/fbo.h	/^	bool ValidateFormat(GLenum format) const$/;"	f	class:ColorRenderTarget
ValidateFormat	vcglib/wrap/gl/fbo.h	/^	bool ValidateFormat(GLenum format) const$/;"	f	class:ColorTexture
ValidateFormat	vcglib/wrap/gl/fbo.h	/^	bool ValidateFormat(GLenum format) const$/;"	f	class:DepthRenderTarget
ValidateFormat	vcglib/wrap/gl/fbo.h	/^	bool ValidateFormat(GLenum format) const$/;"	f	class:DepthTexture
ValidateFormat	vcglib/wrap/gl/fbo.h	/^	bool ValidateFormat(GLenum format) const$/;"	f	class:StencilRenderTarget
ValidateFormat	vcglib/wrap/gl/fbo.h	/^	bool ValidateFormat(GLenum format) const$/;"	f	class:StencilTexture
ValidateFormat	vcglib/wrap/gl/fbo.h	/^	static bool ValidateFormat(FBSType type, GLenum format)$/;"	f	class:FrameBufferSemantic
ValidateStencil	vcglib/wrap/gl/fbo.h	/^	static bool ValidateStencil(GLenum type)$/;"	f	class:FrameBufferSemantic
Value	vcglib/wrap/glw/framebuffer.h	/^		typedef Map::value_type                Value;$/;"	t	class:glw::RenderTargetMapping
Value	vcglib/wrap/glw/framebuffer.h	/^		typedef Map::value_type          Value;$/;"	t	class:glw::RenderTargetBinding
Value	vcglib/wrap/glw/program.h	/^		typedef Map::value_type               Value;$/;"	t	class:glw::FragmentOutputBinding
Value	vcglib/wrap/glw/program.h	/^		typedef Map::value_type               Value;$/;"	t	class:glw::VertexAttributeBinding
ValueApplyDiff	vcglib/vcg/complex/algorithms/update/color.h	/^static int ValueApplyDiff(int old_value, int new_value, float intensity)$/;"	f	class:vcg::tri::UpdateColor
ValueBrightnessContrast	vcglib/vcg/complex/algorithms/update/color.h	/^static int ValueBrightnessContrast(unsigned char ivalue, float brightness, float contrast)$/;"	f	class:vcg::tri::UpdateColor
ValueEqualize	vcglib/vcg/complex/algorithms/update/color.h	/^static int ValueEqualize(int cdfValue, int cdfMin, int cdfMax)$/;"	f	class:vcg::tri::UpdateColor
ValueLevels	vcglib/vcg/complex/algorithms/update/color.h	/^static int ValueLevels(int value, float gamma, float in_min, float in_max, float out_min, float out_max)$/;"	f	class:vcg::tri::UpdateColor
ValueMul	vcglib/vcg/complex/algorithms/update/color.h	/^static int ValueMul(int value, float factor)$/;"	f	class:vcg::tri::UpdateColor
ValueNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^	ValueNode(void){node_type = VALUE_NODE;value = "empty";};$/;"	f	class:ValueNode
ValueNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^class ValueNode: public Node$/;"	c
ValuePow	vcglib/vcg/complex/algorithms/update/color.h	/^static float ValuePow(float value, float exponent)$/;"	f	class:vcg::tri::UpdateColor
ValueType	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  typedef typename Functor::ValueType ValueType;$/;"	t	class:Eigen::AutoDiffJacobian
ValueType	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    typedef typename Functor::ValueType ValueType;$/;"	t	class:Eigen::NumericalDiff
ValueType	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,1> ValueType;$/;"	t	struct:Functor	file:
ValueType	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,1> ValueType;$/;"	t	struct:Functor	file:
ValueType	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,1> ValueType;$/;"	t	struct:TestFunc1	file:
ValueType	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  typedef Matrix<Scalar,ValuesAtCompileTime,1> ValueType;$/;"	t	struct:TestFunc1	file:
ValueType	vcglib/vcg/container/container_allocation_table.h	/^typedef  typename STL_CONT::value_type ValueType;$/;"	t	class:vcg::CATBase
ValueType	vcglib/vcg/container/container_allocation_table.h	/^typedef  typename STL_CONT::value_type ValueType;$/;"	t	class:vcg::CATEntry
ValueType	vcglib/vcg/container/container_allocation_table.h	/^typedef typename STL_CONT::value_type ValueType;$/;"	t	class:vcg::CAT
ValuesAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^    ValuesAtCompileTime = Functor::ValuesAtCompileTime$/;"	e	enum:Eigen::AutoDiffJacobian::__anon444
ValuesAtCompileTime	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^        ValuesAtCompileTime = Functor::ValuesAtCompileTime$/;"	e	enum:Eigen::NumericalDiff::__anon447
ValuesAtCompileTime	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    ValuesAtCompileTime = NY$/;"	e	enum:Functor::__anon475	file:
ValuesAtCompileTime	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^    ValuesAtCompileTime = NY$/;"	e	enum:Functor::__anon476	file:
ValuesAtCompileTime	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^    ValuesAtCompileTime = NY$/;"	e	enum:TestFunc1::__anon472	file:
ValuesAtCompileTime	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^    ValuesAtCompileTime = NY$/;"	e	enum:TestFunc1::__anon474	file:
Variance	vcglib/vcg/math/histogram.h	/^	ScalarType Variance(){ DirtyCheck(); return sqrdAvg - avg*avg ;}$/;"	f	class:vcg::Distribution
Variance	vcglib/vcg/math/histogram.h	/^	ScalarType Variance(){ return fabs(rms\/cnt-Avg()*Avg());}$/;"	f	class:vcg::Histogram
VaryingVector	vcglib/wrap/glw/program.h	/^		typedef std::vector<std::string> VaryingVector;$/;"	t	class:glw::TransformFeedbackStream
Vd	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^    static std::vector<std::pair<vcg::TexCoord2f ,Quadric5<double> > > &Vd(VertexType *v){return (TD()[*v]);}$/;"	f	class:vcg::tri::QuadricTexHelper
Vec3	utils_sampling.hpp	/^    Vec3() { x = y = z = 0; }$/;"	f	struct:Utils_sampling::Vec3
Vec3	utils_sampling.hpp	/^    Vec3(float x_, float y_, float z_) : x(x_), y(y_), z(z_) { }$/;"	f	struct:Utils_sampling::Vec3
Vec3	utils_sampling.hpp	/^struct Vec3 {$/;"	s	namespace:Utils_sampling
Vec3	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    typedef Point3<Scalar> Vec3;$/;"	t	class:vcg::tri::Zonohedron
VecIndex	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    typedef int VecIndex; \/\/  a number in [0..n)$/;"	t	class:vcg::tri::Zonohedron
VecSampler	vcg_mesh.hpp	/^class VecSampler : public vcg::tri::TrivialSampler<MyMesh> { };$/;"	c	namespace:vcg
VecType	vcglib/vcg/simplex/face/component.h	/^        typedef Point3<S> VecType;$/;"	t	struct:vcg::face::CurvatureDirBaseType
VecType	vcglib/vcg/simplex/face/component.h	/^  typedef typename CurvatureDirType::VecType VecType;$/;"	t	class:vcg::face::CurvatureDir
VecType	vcglib/vcg/simplex/face/component_ocf.h	/^        typedef Point3<S> VecType;$/;"	t	struct:vcg::face::CurvatureDirOcfBaseType
VecType	vcglib/vcg/simplex/face/component_ocf.h	/^  typedef typename CurvatureDirType::VecType VecType;$/;"	t	class:vcg::face::CurvatureDirOcf
VecType	vcglib/vcg/simplex/vertex/component.h	/^          typedef Point3<S> VecType;$/;"	t	struct:vcg::vertex::CurvatureDirBaseType
VecType	vcglib/vcg/simplex/vertex/component.h	/^    typedef typename CurvatureDirType::VecType VecType;$/;"	t	class:vcg::vertex::CurvatureDir
VecType	vcglib/vcg/simplex/vertex/component.h	/^  typedef Point3f VecType;$/;"	t	class:vcg::vertex::EmptyCore
VecType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef Point3<S> VecType;$/;"	t	struct:vcg::vertex::CurvatureDirTypeOcc
VecType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename CurvatureDirTypeOcc::VecType VecType;$/;"	t	class:vcg::vertex::CurvatureDirOcc
VecType	vcglib/vcg/simplex/vertex/component_ocf.h	/^	typedef Point3<S> VecType;$/;"	t	struct:vcg::vertex::CurvatureDirTypeOcf
VecType	vcglib/vcg/simplex/vertex/component_ocf.h	/^  typedef typename CurvatureDirType::VecType VecType;$/;"	t	class:vcg::vertex::CurvatureDirOcf
VectProd	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 VectProd ( const Point4 &x, const Point4 &z ) const$/;"	f	class:vcg::Point4
VectProd	vcglib/vcg/space/point4.h	/^	inline Point4 VectProd ( const Point4 &x, const Point4 &z ) const$/;"	f	class:vcg::Point4
VectToAngle	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			static ScalarType VectToAngle(const FaceType &f,const CoordType &vect3D)$/;"	f	class:vcg::tri::CrossField
Vector	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::DiagonalPreconditioner
Vector	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::IncompleteLUT
Vector	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::PastixBase
Vector	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::SuperLUBase
Vector	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::UmfPackLU
Vector	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::IncompleteLU
Vector2	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D
Vector2	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
Vector2	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D
Vector2d	vcglib/vcg/space/deprecated_point.h	/^typedef Point2<double> Vector2d;$/;"	t	namespace:vcg::ndim
Vector2d	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<double,2,1> Vector2d;$/;"	t	namespace:vcg::ndim
Vector2f	vcglib/vcg/space/deprecated_point.h	/^typedef Point2<float>  Vector2f;$/;"	t	namespace:vcg::ndim
Vector2f	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<float ,2,1> Vector2f;$/;"	t	namespace:vcg::ndim
Vector2i	vcglib/vcg/space/deprecated_point.h	/^typedef Point2<int>	  Vector2i;$/;"	t	namespace:vcg::ndim
Vector2i	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<int   ,2,1> Vector2i;$/;"	t	namespace:vcg::ndim
Vector2s	vcglib/vcg/space/deprecated_point.h	/^typedef Point2<short>  Vector2s;$/;"	t	namespace:vcg::ndim
Vector2s	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<short ,2,1> Vector2s;$/;"	t	namespace:vcg::ndim
Vector3	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis
Vector3	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::Quaternion
Vector3	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis
Vector3	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::QuaternionBase
Vector3d	vcglib/vcg/space/deprecated_point.h	/^typedef Point3<double> Vector3d;$/;"	t	namespace:vcg::ndim
Vector3d	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<double,3,1> Vector3d;$/;"	t	namespace:vcg::ndim
Vector3f	vcglib/vcg/space/deprecated_point.h	/^typedef Point3<float>  Vector3f;$/;"	t	namespace:vcg::ndim
Vector3f	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<float ,3,1> Vector3f;$/;"	t	namespace:vcg::ndim
Vector3i	vcglib/vcg/space/deprecated_point.h	/^typedef Point3<int>	  Vector3i;$/;"	t	namespace:vcg::ndim
Vector3i	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<int   ,3,1> Vector3i;$/;"	t	namespace:vcg::ndim
Vector3s	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealSchur
Vector3s	vcglib/vcg/space/deprecated_point.h	/^typedef Point3<short>  Vector3s;$/;"	t	namespace:vcg::ndim
Vector3s	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<short ,3,1> Vector3s;$/;"	t	namespace:vcg::ndim
Vector4d	vcglib/vcg/space/deprecated_point.h	/^typedef Point4<double> Vector4d;$/;"	t	namespace:vcg::ndim
Vector4d	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<double,4,1> Vector4d;$/;"	t	namespace:vcg::ndim
Vector4f	vcglib/vcg/space/deprecated_point.h	/^typedef Point4<float>  Vector4f;$/;"	t	namespace:vcg::ndim
Vector4f	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<float ,4,1> Vector4f;$/;"	t	namespace:vcg::ndim
Vector4i	vcglib/vcg/space/deprecated_point.h	/^typedef Point4<int>	  Vector4i;$/;"	t	namespace:vcg::ndim
Vector4i	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<int   ,4,1> Vector4i;$/;"	t	namespace:vcg::ndim
Vector4s	vcglib/vcg/space/deprecated_point.h	/^typedef Point4<short>  Vector4s;$/;"	t	namespace:vcg::ndim
Vector4s	vcglib/vcg/space/point.h	/^typedef Eigen::Matrix<short ,4,1> Vector4s;$/;"	t	namespace:vcg::ndim
VectorBlock	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start)$/;"	f	class:Eigen::VectorBlock
VectorBlock	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start, Index size)$/;"	f	class:Eigen::VectorBlock
VectorBlock	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^template<typename VectorType, int Size> class VectorBlock$/;"	c	namespace:Eigen
VectorComparator	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^    VectorComparator(int inDim) : dim(inDim) {}$/;"	f	struct:Eigen::KdBVH::VectorComparator
VectorComparator	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  struct VectorComparator \/\/compares vectors, or, more specificall, VIPairs along a particular dimension$/;"	s	class:Eigen::KdBVH
VectorI	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSelfAdjointView
VectorI	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
VectorNBW	vcglib/vcg/container/simple_temporary_data.h	/^    VectorNBW():data(0),datasize(0),datareserve(0){}$/;"	f	class:vcg::VectorNBW
VectorNBW	vcglib/vcg/container/simple_temporary_data.h	/^class VectorNBW: public std::vector<TYPE> {};$/;"	c	namespace:vcg
VectorNBW	vcglib/vcg/container/simple_temporary_data.h	/^class VectorNBW<bool>{$/;"	c	namespace:vcg
VectorType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::AlignedBox
VectorType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane
VectorType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::ParametrizedLine
VectorType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Scaling
VectorType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform
VectorType	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation
VectorType	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, 1, Size, Options | RowMajor, 1, MaxSize> VectorType;$/;"	t	class:Eigen::HessenbergDecomposition
VectorType	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::RealVectorType VectorType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
VectorType	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1>  VectorType;$/;"	t	class:Eigen::AlignedBox
VectorType	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane
VectorType	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename plain_matrix_type<Derived>::type VectorType;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
VectorType	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1,Options> VectorType;$/;"	t	class:Eigen::ParametrizedLine
VectorType	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::RotationBase
VectorType	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform
VectorType	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation
VectorType	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::PardisoImpl
VectorType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholesky
VectorType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholeskyBase
VectorType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLDLT
VectorType	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLLT
VectorType	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef Matrix<Scalar, Dim, 1> VectorType;$/;"	t	class:Eigen::KdBVH
VectorType	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef Matrix<Scalar, Dim, 1> VectorType;$/;"	t	struct:Eigen::internal::vector_int_pair
VectorType	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typedef Matrix<Scalar, Traits::RowsAtCompileTime, 1> VectorType;$/;"	t	class:Eigen::MatrixFunction
VectorType	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1> VectorType;$/;"	t	class:Eigen::MatrixFunctionAtomic
VectorType	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType; $/;"	t	class:Eigen::MatrixMarketIterator
VectorType	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  typedef Matrix<double, Dim, 1> VectorType;$/;"	t	struct:Ball	file:
VectorType	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  typedef Matrix<double, Dim, 1> VectorType;$/;"	t	struct:BallPointStuff	file:
VectorType	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  typedef Matrix<double, Dim, 1> VectorType;$/;"	t	struct:TreeTest	file:
VectorType	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^template<typename Scalar> struct VectorType<EigenVectorContainer,Scalar>$/;"	s	file:
VectorType	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^template<typename Scalar> struct VectorType<StdVectorContainer,Scalar>$/;"	s	file:
VectorType	vcglib/vcg/space/index/kdtree/kdtree.h	/^	typedef vcg::Point3<Scalar> VectorType;$/;"	t	class:KdTree
VectorTypeList	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  typedef std::vector<VectorType, aligned_allocator<VectorType> > VectorTypeList;$/;"	t	struct:TreeTest	file:
Vectorizable	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^    Vectorizable = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasMul && packet_traits<RhsScalar>::HasMul$/;"	e	enum:Eigen::internal::scalar_product_op::__anon71
Vectorizable	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    Vectorizable = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon169
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon10
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon11
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon16
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon17
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon27
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon28
Vectorizable	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon29
Vectorizable	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable  = Traits::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon202
Vectorizable	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
Vectorizable	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
Vectorizable	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon200
Vectorizable	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
Vectorizable	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon210
Vectorizable	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon211
Vectorized	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    Vectorized = int(Traversal) == InnerVectorizedTraversal$/;"	e	enum:Eigen::internal::assign_traits::__anon37
VectorizedSize	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    VectorizedSize = (Size \/ PacketSize) * PacketSize$/;"	e	enum:Eigen::internal::redux_impl::__anon232
VectorwiseOp	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    inline VectorwiseOp(ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::VectorwiseOp
VectorwiseOp	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^template<typename ExpressionType, int Direction> class VectorwiseOp$/;"	c	namespace:Eigen
Verse	vcglib/wrap/gui/trackmode.cpp	/^int PathMode::Verse(Point3f reference_point,Point3f current_point,Point3f prev_point,Point3f next_point)$/;"	f	class:PathMode
VertContainer	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  typedef typename TriMeshType::VertContainer VertContainer;$/;"	t	class:vcg::tri::EdgeCollapser
VertContainer	vcglib/vcg/complex/algorithms/update/curvature.h	/^    typedef typename MeshType::VertContainer VertContainer;$/;"	t	class:vcg::tri::UpdateCurvature
VertContainer	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^	typedef typename MeshType::VertContainer VertContainer;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
VertContainer	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::VertContainer VertContainer;$/;"	t	class:vcg::tri::Allocator
VertContainer	vcglib/vcg/complex/base.h	/^                                typedef CONT VertContainer;$/;"	t	struct:vcg::tri::MeshTypeHolder
VertContainer	vcglib/vcg/complex/base.h	/^                typedef CONTV									VertContainer;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
VertContainer	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::VertContainer VertContainer;$/;"	t	class:vcg::tri::TriMesh
VertContainer	vcglib/wrap/io_trimesh/export_vmi.h	/^        typedef typename SaveMeshType::VertContainer VertContainer;$/;"	t	class:vcg::tri::io::ExporterVMI
VertContainer	vcglib/wrap/io_trimesh/import_vmi.h	/^        typedef typename OpenMeshType::VertContainer VertContainer;$/;"	t	class:vcg::tri::io::ImporterVMI
VertDesc	vcglib/wrap/io_tetramesh/import_ply.h	/^static const  PropDescriptor &VertDesc(int i)  $/;"	f	class:vcg::tetra::io::ImporterPLY
VertDesc	vcglib/wrap/io_trimesh/import_ply.h	/^static const  PropDescriptor &VertDesc(int i)$/;"	f	class:vcg::tri::io::ImporterPLY
VertDist	vcglib/vcg/complex/algorithms/geodesic.h	/^    VertDist(){}$/;"	f	struct:vcg::tri::Geodesic::VertDist
VertDist	vcglib/vcg/complex/algorithms/geodesic.h	/^    VertDist(VertexPointer _v, ScalarType _d):v(_v),d(_d){}$/;"	f	struct:vcg::tri::Geodesic::VertDist
VertDist	vcglib/vcg/complex/algorithms/geodesic.h	/^  struct VertDist{$/;"	s	class:vcg::tri::Geodesic
VertDist	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename tri::Geodesic<MeshType>::VertDist VertDist;$/;"	t	class:vcg::tri::VoronoiProcessing
VertPointer	vcglib/vcg/simplex/tetrahedron/base.h	/^  typedef BVT *VertPointer;$/;"	t	class:vcg::TetraTypeHolder
VertReg	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            VertReg(){}$/;"	f	class:vcg::tri::VertReg
VertReg	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^        template <class MeshType> class VertReg: public EdgeFlipPriority<MeshType>$/;"	c	namespace:vcg::tri
VertTmark	vcglib/vcg/complex/algorithms/closest.h	/^			inline VertTmark(){}$/;"	f	class:vcg::tri::VertTmark
VertTmark	vcglib/vcg/complex/algorithms/closest.h	/^			inline VertTmark(MESH_TYPE *){}$/;"	f	class:vcg::tri::VertTmark
VertTmark	vcglib/vcg/complex/algorithms/closest.h	/^		class VertTmark$/;"	c	namespace:vcg::tri
VertToSplit	vcglib/wrap/gl/trimesh.h	/^    class VertToSplit$/;"	c	class:vcg::GLW
VertType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename T::VertType VertType;$/;"	t	class:vcg::vertex::ColorOcc
VertType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename T::VertType VertType;$/;"	t	class:vcg::vertex::CoordOcc
VertType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename T::VertType VertType;$/;"	t	class:vcg::vertex::FlagOcc
VertType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename T::VertType VertType;$/;"	t	class:vcg::vertex::NormalOcc
VertType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename T::VertType VertType;$/;"	t	class:vcg::vertex::QualityOcc
VertType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename T::VertType VertType;$/;"	t	class:vcg::vertex::VFAdjOcc
VertType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename TT::VertType VertType;$/;"	t	class:vcg::vertex::CurvatureDirOcc
VertType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename TT::VertType VertType;$/;"	t	class:vcg::vertex::CurvatureOcc
VertType	vcglib/vcg/simplex/vertex/component_occ.h	/^	typedef typename TT::VertType VertType;$/;"	t	class:vcg::vertex::TexCoordOcc
VertType	vcglib/vcg/simplex/vertex/component_occ.h	/^  typedef typename TT::VertType VertType;$/;"	t	class:vcg::vertex::RadiusOcc
Vertex	vcglib/apps/unsupported/extractors/extractor/Definitions.h	/^class Vertex : public vcg::VertexAFVMVN< ScalarType, Edge, Face > {};$/;"	c
Vertex	vcglib/vcg/connectors/hedge_component.h	/^        typename T::VertexPointer & Vertex()                    { return this->HVp();}$/;"	f	class:vcg::hedge::HEdgeData
Vertex	vcglib/vcg/simplex/vertex/base.h	/^							class Vertex: public VertexArityMax<UserTypes, A, B, C, D, E, F, G, H, I, J, K, L>  {$/;"	c	namespace:vcg
VertexAll	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t VertexAll(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
VertexAreaUniform	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void VertexAreaUniform(MetroMesh & m, VertexSampler &ps, int sampleNum)$/;"	f	class:vcg::tri::SurfaceSampling
VertexArityMax	vcglib/vcg/simplex/vertex/base.h	/^class VertexArityMax: public Arity12<vertex::EmptyCore<UserTypes>, A, B, C, D, E, F, G, H, I, J, K, L> {$/;"	c	namespace:vcg
VertexAttributeBinding	vcglib/wrap/glw/program.h	/^		VertexAttributeBinding(void)$/;"	f	class:glw::VertexAttributeBinding
VertexAttributeBinding	vcglib/wrap/glw/program.h	/^class VertexAttributeBinding$/;"	c	namespace:glw
VertexBorder	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void VertexBorder(MetroMesh & m, VertexSampler &ps)$/;"	f	class:vcg::tri::SurfaceSampling
VertexBorderCorner	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void VertexBorderCorner(MetroMesh & m, VertexSampler &ps, float angleRad)$/;"	f	class:vcg::tri::SurfaceSampling
VertexBorderFromFace	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void VertexBorderFromFace(MeshType &m)$/;"	f	class:vcg::tri::UpdateFlags
VertexBorderFromNone	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void VertexBorderFromNone(MeshType &m)$/;"	f	class:vcg::tri::UpdateFlags
VertexBufferBindingParams	vcglib/wrap/glw/buffer.h	/^		VertexBufferBindingParams(void)$/;"	f	class:glw::VertexBufferBindingParams
VertexBufferBindingParams	vcglib/wrap/glw/buffer.h	/^class VertexBufferBindingParams : public BufferBindingParams$/;"	c	namespace:glw
VertexClamp	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexClamp(MeshType &m, float qmin, float qmax)$/;"	f	class:vcg::tri::UpdateQuality
VertexClear	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void VertexClear(MeshType &m, unsigned int FlagMask = 0xffffffff)$/;"	f	class:vcg::tri::UpdateFlags
VertexClear	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t VertexClear(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
VertexClearB	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void VertexClearB(MeshType &m) { VertexClear(m,VertexType::BORDER);}$/;"	f	class:vcg::tri::UpdateFlags
VertexClearS	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void VertexClearS(MeshType &m) { VertexClear(m,VertexType::SELECTED);}$/;"	f	class:vcg::tri::UpdateFlags
VertexClearV	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void VertexClearV(MeshType &m) { VertexClear(m,VertexType::VISITED);}$/;"	f	class:vcg::tri::UpdateFlags
VertexClipInfo	vcglib/vcg/complex/algorithms/clip.h	/^      class VertexClipInfo$/;"	c	class:vcg::tri::TriMeshClipper
VertexClipInfoVec	vcglib/vcg/complex/algorithms/clip.h	/^  typedef typename std::vector< VertexClipInfo<ScalarType> > VertexClipInfoVec;$/;"	t	class:vcg::tri::TriMeshClipper
VertexColorAttribute	vcglib/wrap/io_trimesh/import_dae.h	/^		static int VertexColorAttribute(ColladaMesh& m,const QStringList face,const QStringList wc,const QDomNode wcsrc,const int faceind, const int vertind,const int colorcomponent)$/;"	f	class:vcg::tri::io::ImporterDAE
VertexColorLaplacian	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexColorLaplacian(MeshType &m, int step, bool SmoothSelected=false, vcg::CallBackPos * cb=0)$/;"	f	class:vcg::tri::Smooth
VertexConstDataWrapper	vcglib/vcg/space/index/kdtree/kdtree.h	/^  inline VertexConstDataWrapper(MeshType &m):$/;"	f	class:VertexConstDataWrapper
VertexConstDataWrapper	vcglib/vcg/space/index/kdtree/kdtree.h	/^class VertexConstDataWrapper :public  ConstDataWrapper<typename MeshType::CoordType>$/;"	c
VertexConstant	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexConstant(MeshType &m, float q)$/;"	f	class:vcg::tri::UpdateQuality
VertexCoordLaplacian	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordLaplacian(MeshType &m, int step, bool SmoothSelected=false, bool cotangentWeight=false, vcg::CallBackPos * cb=0)$/;"	f	class:vcg::tri::Smooth
VertexCoordLaplacianAngleWeighted	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordLaplacianAngleWeighted(MeshType &m, int step, ScalarType delta)$/;"	f	class:vcg::tri::Smooth
VertexCoordLaplacianBlend	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordLaplacianBlend(MeshType &m, int step, float alpha, bool SmoothSelected=false)$/;"	f	class:vcg::tri::Smooth
VertexCoordLaplacianCurvatureFlow	vcglib/vcg/complex/algorithms/smooth.h	/^void VertexCoordLaplacianCurvatureFlow(MeshType &\/*m*\/, int \/*step*\/, ScalarType \/*delta*\/)$/;"	f	class:vcg::tri::Smooth
VertexCoordLaplacianHC	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordLaplacianHC(MeshType &m, int step, bool SmoothSelected=false )$/;"	f	class:vcg::tri::Smooth
VertexCoordLaplacianQuality	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordLaplacianQuality(MeshType &m, int step, bool SmoothSelected=false)$/;"	f	class:vcg::tri::Smooth
VertexCoordLaplacianReproject	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordLaplacianReproject(MeshType& m, GRID& grid, MeshTypeTri& gridmesh)$/;"	f	class:vcg::tri::Smooth
VertexCoordLaplacianReproject	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordLaplacianReproject(MeshType& m, GRID& grid, MeshTypeTri& gridmesh, typename MeshType::VertexType* vp)$/;"	f	class:vcg::tri::Smooth
VertexCoordPasoDoble	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordPasoDoble(MeshType &m, int step, typename MeshType::ScalarType Sigma=0, int FitStep=10, typename MeshType::ScalarType FitLambda=0.05)$/;"	f	class:vcg::tri::Smooth
VertexCoordPasoDobleFast	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordPasoDobleFast(MeshType &m, int NormalSmoothStep, typename MeshType::ScalarType Sigma=0, int FitStep=50, bool SmoothSelected =false)$/;"	f	class:vcg::tri::Smooth
VertexCoordPlanarLaplacian	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordPlanarLaplacian(MeshType &m, int step, float AngleThrRad = math::ToRad(1.0), bool SmoothSelected=false, vcg::CallBackPos * cb=0)$/;"	f	class:vcg::tri::Smooth
VertexCoordScaleDependentLaplacian_Fujiwara	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordScaleDependentLaplacian_Fujiwara(MeshType &m, int step, ScalarType delta)$/;"	f	class:vcg::tri::Smooth
VertexCoordTaubin	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordTaubin(MeshType &m, int step, float lambda, float mu, bool SmoothSelected=false, vcg::CallBackPos * cb=0)$/;"	f	class:vcg::tri::Smooth
VertexCoordViewDepth	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexCoordViewDepth(MeshType &m,$/;"	f	class:vcg::tri::Smooth
VertexCount	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t VertexCount(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
VertexCrease	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void VertexCrease(MetroMesh & m, VertexSampler &ps)$/;"	f	class:vcg::tri::SurfaceSampling
VertexData	vcglib/wrap/io_tetramesh/io_ply.h	/^  PropDescriptor *VertexData;$/;"	m	class:vcg::tetra::io::PlyInfo
VertexData	vcglib/wrap/io_trimesh/io_ply.h	/^  PropDescriptor *VertexData;$/;"	m	class:vcg::tri::io::PlyInfo
VertexEdge	vcglib/vcg/complex/algorithms/update/topology.h	/^static void VertexEdge(MeshType &m)$/;"	f	class:vcg::tri::UpdateTopology
VertexFace	vcglib/vcg/complex/algorithms/update/topology.h	/^static void VertexFace(MeshType &m)$/;"	f	class:vcg::tri::UpdateTopology
VertexFromAbsoluteCurvature	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexFromAbsoluteCurvature(MeshType &m)$/;"	f	class:vcg::tri::UpdateQuality
VertexFromBorderFlag	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t VertexFromBorderFlag(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
VertexFromEdgeLoose	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t VertexFromEdgeLoose(MeshType &m, bool preserveSelection=false)$/;"	f	class:vcg::tri::UpdateSelection
VertexFromFace	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexFromFace( MeshType &m, bool areaWeighted=true)$/;"	f	class:vcg::tri::UpdateQuality
VertexFromFaceLoose	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t VertexFromFaceLoose(MeshType &m, bool preserveSelection=false)$/;"	f	class:vcg::tri::UpdateSelection
VertexFromFaceStrict	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t VertexFromFaceStrict(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
VertexFromGaussianCurvatureDir	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexFromGaussianCurvatureDir(MeshType &m)$/;"	f	class:vcg::tri::UpdateQuality
VertexFromGaussianCurvatureHG	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexFromGaussianCurvatureHG(MeshType &m)$/;"	f	class:vcg::tri::UpdateQuality
VertexFromMeanCurvatureDir	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexFromMeanCurvatureDir(MeshType &m)$/;"	f	class:vcg::tri::UpdateQuality
VertexFromMeanCurvatureHG	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexFromMeanCurvatureHG(MeshType &m)$/;"	f	class:vcg::tri::UpdateQuality
VertexFromPlane	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexFromPlane(MeshType &m, const Plane3<ScalarType> &pl)$/;"	f	class:vcg::tri::UpdateQuality
VertexFromQualityRange	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t VertexFromQualityRange(MeshType &m,float minq, float maxq)$/;"	f	class:vcg::tri::UpdateSelection
VertexFromRMSCurvature	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexFromRMSCurvature(MeshType &m)$/;"	f	class:vcg::tri::UpdateQuality
VertexInBox	vcglib/vcg/complex/algorithms/update/selection.h	/^static int VertexInBox( MeshType & m, const Box3Type &bb)$/;"	f	class:vcg::tri::UpdateSelection
VertexIndex	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	typedef int VertexIndex;$/;"	t	class:Walker
VertexIndex	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    typedef int VertexIndex;$/;"	t	class:vcg::tri::TrivialWalker
VertexIndex	vcglib/vcg/complex/algorithms/create/resampler.h	/^		typedef int VertexIndex;$/;"	t	class:vcg::tri::Resampler::Walker
VertexIndex	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    int VertexIndex(VertexType* v)$/;"	f	class:vcg::tri::PoissonSolver
VertexIndexing	vcglib/wrap/miq/core/vertex_indexing.h	/^    VertexIndexing(){mesh=NULL;}$/;"	f	class:VertexIndexing
VertexIndexing	vcglib/wrap/miq/core/vertex_indexing.h	/^class VertexIndexing$/;"	c
VertexInvert	vcglib/vcg/complex/algorithms/update/selection.h	/^static size_t VertexInvert(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
VertexIterator	vcglib/apps/metro/sampling.h	/^    typedef typename MetroMesh::VertexIterator	VertexIterator;$/;"	t	class:vcg::Sampling
VertexIterator	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^typedef CMesh::VertexIterator VertexIterator;$/;"	t	file:
VertexIterator	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^typedef MyMesh::VertexIterator  VertexIterator;$/;"	t	file:
VertexIterator	vcglib/apps/unsupported/shadevis/visshader.h	/^    typedef typename MESH_TYPE::VertexIterator VertexIterator;$/;"	t	class:vcg::VisShader
VertexIterator	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::FourPCS
VertexIterator	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::BitQuadCreation
VertexIterator	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::BitQuadOptimization
VertexIterator	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::BitQuad
VertexIterator	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::Clean
VertexIterator	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::ConnectedComponentIterator
VertexIterator	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::Clustering
VertexIterator	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::AdvancingTest
VertexIterator	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  typedef typename MESH::VertexIterator     VertexIterator;$/;"	t	class:vcg::tri::BallPivoting
VertexIterator	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef typename TRIMESH_TYPE::VertexIterator	VertexIterator;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
VertexIterator	vcglib/vcg/complex/algorithms/create/extrude.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::Extrude
VertexIterator	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef typename TRIMESH_TYPE::VertexIterator	VertexIterator;$/;"	t	class:vcg::tri::MarchingCubes
VertexIterator	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef typename MeshType::VertexIterator      VertexIterator;$/;"	t	class:vcg::tri::CylinderClipping
VertexIterator	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  typedef	typename TriMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::EdgeCollapser
VertexIterator	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::AnisotropicDistance
VertexIterator	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::Geodesic
VertexIterator	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::HalfedgeQuadClean
VertexIterator	vcglib/vcg/complex/algorithms/inertia.h	/^	typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::Inertia
VertexIterator	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::TopoEdgeFlip
VertexIterator	vcglib/vcg/complex/algorithms/nring.h	/^    typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::Nring
VertexIterator	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:OverlapEstimation
VertexIterator	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UV_Utils
VertexIterator	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MetroMesh::VertexIterator  VertexIterator;$/;"	t	class:vcg::tri::SurfaceSampling
VertexIterator	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::PointCloudNormal
VertexIterator	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  typedef typename PolyMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::PolychordCollapse
VertexIterator	vcglib/vcg/complex/algorithms/smooth.h	/^            typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::Smooth
VertexIterator	vcglib/vcg/complex/algorithms/stat.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::Stat
VertexIterator	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef typename MESH_TYPE::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::AreaPreservingTextureOptimizer
VertexIterator	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef typename MESH_TYPE::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::TextureOptimizer
VertexIterator	vcglib/vcg/complex/algorithms/update/bounding.h	/^typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateBounding
VertexIterator	vcglib/vcg/complex/algorithms/update/color.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateColor
VertexIterator	vcglib/vcg/complex/algorithms/update/component_ep.h	/^		typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateComponentEP
VertexIterator	vcglib/vcg/complex/algorithms/update/curvature.h	/^    typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateCurvature
VertexIterator	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^	typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
VertexIterator	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::Fitmaps
VertexIterator	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateFlags
VertexIterator	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateHalfEdges
VertexIterator	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::HalfEdgeTopology
VertexIterator	vcglib/vcg/complex/algorithms/update/normal.h	/^typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateNormal
VertexIterator	vcglib/vcg/complex/algorithms/update/position.h	/^typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdatePosition
VertexIterator	vcglib/vcg/complex/algorithms/update/quality.h	/^  typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateQuality
VertexIterator	vcglib/vcg/complex/algorithms/update/selection.h	/^typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateSelection
VertexIterator	vcglib/vcg/complex/algorithms/update/texture.h	/^typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateTexture
VertexIterator	vcglib/vcg/complex/algorithms/update/topology.h	/^typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::UpdateTopology
VertexIterator	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::VertexIterator		VertexIterator;$/;"	t	class:vcg::tri::VoronoiProcessing
VertexIterator	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::Allocator
VertexIterator	vcglib/vcg/complex/base.h	/^                                typedef typename VertContainer::iterator VertexIterator;$/;"	t	struct:vcg::tri::MeshTypeHolder
VertexIterator	vcglib/vcg/complex/base.h	/^                typedef typename CONTV::iterator				VertexIterator;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
VertexIterator	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::VertexIterator				VertexIterator;$/;"	t	class:vcg::tri::TriMesh
VertexIterator	vcglib/wrap/dae/poly_triangulator.h	/^		typedef typename std::vector<VertexType>::iterator VertexIterator; $/;"	t	class:vcg::tri::io::PolygonalMesh
VertexIterator	vcglib/wrap/gl/pick.h	/^  typedef typename MESH_TYPE::VertexIterator VertexIterator;$/;"	t	class:vcg::GLPickTri
VertexIterator	vcglib/wrap/io_tetramesh/export_ply.h	/^typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tetra::io::ExporterPLY
VertexIterator	vcglib/wrap/io_tetramesh/export_ts.h	/^	typedef typename MESHTYPE::VertexIterator VertexIterator;$/;"	t	struct:vcg::tetra::io::ExporterTS
VertexIterator	vcglib/wrap/io_tetramesh/import_ply.h	/^typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tetra::io::ImporterPLY
VertexIterator	vcglib/wrap/io_tetramesh/import_ts.h	/^	typedef typename Tetramesh::VertexIterator VertexIterator;$/;"	t	class:vcg::tetra::io::ImporterTS
VertexIterator	vcglib/wrap/io_trimesh/export_3ds.h	/^		typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::Exporter3DS
VertexIterator	vcglib/wrap/io_trimesh/export_fbx.h	/^	typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:ExporterFBX
VertexIterator	vcglib/wrap/io_trimesh/export_gts.h	/^				typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ExporterGTS
VertexIterator	vcglib/wrap/io_trimesh/export_idtf.h	/^typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ExporterIDTF
VertexIterator	vcglib/wrap/io_trimesh/export_obj.h	/^  typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ExporterOBJ
VertexIterator	vcglib/wrap/io_trimesh/export_off.h	/^				typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ExporterOFF
VertexIterator	vcglib/wrap/io_trimesh/export_ply.h	/^typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ExporterPLY
VertexIterator	vcglib/wrap/io_trimesh/export_smf.h	/^		typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ExporterSMF
VertexIterator	vcglib/wrap/io_trimesh/export_vmi.h	/^        typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ExporterVMI
VertexIterator	vcglib/wrap/io_trimesh/export_vrml.h	/^				typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ExporterWRL
VertexIterator	vcglib/wrap/io_trimesh/import_asc.h	/^typedef typename MESH_TYPE::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterASC
VertexIterator	vcglib/wrap/io_trimesh/import_ctm.h	/^typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterCTM
VertexIterator	vcglib/wrap/io_trimesh/import_fbx.h	/^	typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:ImporterFBX
VertexIterator	vcglib/wrap/io_trimesh/import_gts.h	/^				typedef typename MESH_TYPE::VertexIterator	VertexIterator;$/;"	t	class:vcg::tri::io::ImporterGTS
VertexIterator	vcglib/wrap/io_trimesh/import_nvm.h	/^typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterNVM
VertexIterator	vcglib/wrap/io_trimesh/import_obj.h	/^                typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterOBJ
VertexIterator	vcglib/wrap/io_trimesh/import_off.h	/^  typedef typename MESH_TYPE::VertexIterator	VertexIterator;$/;"	t	class:vcg::tri::io::ImporterOFF
VertexIterator	vcglib/wrap/io_trimesh/import_out.h	/^typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterOUT
VertexIterator	vcglib/wrap/io_trimesh/import_ply.h	/^typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterPLY
VertexIterator	vcglib/wrap/io_trimesh/import_ptx.h	/^		typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterPTX
VertexIterator	vcglib/wrap/io_trimesh/import_raw.h	/^typedef typename MESH_TYPE::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterRAW
VertexIterator	vcglib/wrap/io_trimesh/import_smf.h	/^		typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterSMF
VertexIterator	vcglib/wrap/io_trimesh/import_stl.h	/^typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterSTL
VertexIterator	vcglib/wrap/io_trimesh/import_vmi.h	/^        typedef typename OpenMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::ImporterVMI
VertexIterator	vcglib/wrap/io_trimesh/io_material.h	/^		typedef typename SaveMeshType::VertexIterator VertexIterator;$/;"	t	class:vcg::tri::io::Materials
VertexIteratorLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::VertexIterator	VertexIteratorLeft;$/;"	t	class:vcg::tri::Append
VertexIteratorRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::VertexIterator VertexIteratorRight;$/;"	t	class:vcg::tri::Append
VertexLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::VertexType			VertexLeft;$/;"	t	class:vcg::tri::Append
VertexMap	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    typedef std::map< Signature, int > VertexMap;$/;"	t	class:vcg::tri::Zonohedron
VertexMaskBitFromString	vcglib/wrap/io_trimesh/import_vmi.h	/^    static int  VertexMaskBitFromString(std::string s){$/;"	f	class:vcg::tri::io::ImporterVMI
VertexNonManifoldEdges	vcglib/vcg/complex/algorithms/update/selection.h	/^void VertexNonManifoldEdges(MeshType &m)$/;"	f	class:vcg::tri::UpdateSelection
VertexNormalLaplacian	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexNormalLaplacian(MeshType &m, int step,bool SmoothSelected=false)$/;"	f	class:vcg::tri::Smooth
VertexNormalPointCloud	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexNormalPointCloud(MeshType &m, int neighborNum, int iterNum, KdTree<float> *tp=0)$/;"	f	class:vcg::tri::Smooth
VertexNormalize	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexNormalize(MeshType &m, float qmin=0.0, float qmax=1.0)$/;"	f	class:vcg::tri::UpdateQuality
VertexNumber	vcglib/vcg/complex/base.h	/^int & VertexNumber(){ return vn;}$/;"	f	class:vcg::tri::TriMesh
VertexPair	vcglib/apps/tridecimator/tridecimator.cpp	/^typedef BasicVertexPair<MyVertex> VertexPair;$/;"	t	file:
VertexPair	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^typedef BasicVertexPair<MyVertex> VertexPair;$/;"	t	file:
VertexPairEdgePtr	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                VertexPairEdgePtr(VertexPointer _v0,VertexPointer _v1,HEdgePointer _ep):v0(_v0),v1(_v1),ep(_ep){if(v0>v1) std::swap(v0,v1);}$/;"	f	struct:vcg::tri::UpdateHalfEdges::VertexPairEdgePtr
VertexPairEdgePtr	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                VertexPairEdgePtr(VertexPointer _v0,VertexPointer _v1,HEdgePointer _ep):v0(_v0),v1(_v1),ep(_ep){if(v0>v1) std::swap(v0,v1);}$/;"	f	struct:vcg::tri::UpdateIndexed::VertexPairEdgePtr
VertexPairEdgePtr	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            struct VertexPairEdgePtr{$/;"	s	class:vcg::tri::UpdateHalfEdges
VertexPairEdgePtr	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            struct VertexPairEdgePtr{$/;"	s	struct:vcg::tri::UpdateIndexed
VertexPointer	vcglib/apps/metro/sampling.h	/^    typedef typename MetroMesh::VertexPointer		VertexPointer;$/;"	t	class:vcg::Sampling
VertexPointer	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^typedef CMesh::VertexPointer VertexPointer;$/;"	t	file:
VertexPointer	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^typedef MyMesh::VertexPointer  VertexPointer;$/;"	t	file:
VertexPointer	vcglib/apps/unsupported/extractors/extractor/Definitions.h	/^typedef Vertex* VertexPointer;$/;"	t
VertexPointer	vcglib/apps/unsupported/shadevis/visshader.h	/^    typedef typename MESH_TYPE::VertexPointer  VertexPointer;$/;"	t	class:vcg::VisShader
VertexPointer	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::BitQuad
VertexPointer	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::Clean
VertexPointer	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::ConnectedComponentIterator
VertexPointer	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::Clustering
VertexPointer	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef typename TRIMESH_TYPE::VertexPointer	VertexPointer;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
VertexPointer	vcglib/vcg/complex/algorithms/create/extrude.h	/^  typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::Extrude
VertexPointer	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef typename TRIMESH_TYPE::VertexPointer	VertexPointer;$/;"	t	class:vcg::tri::MarchingCubes
VertexPointer	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::TrivialWalker
VertexPointer	vcglib/vcg/complex/algorithms/create/resampler.h	/^		typedef typename New_Mesh::VertexType* VertexPointer;$/;"	t	class:vcg::tri::Resampler::Walker
VertexPointer	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef typename MeshType::VertexPointer       VertexPointer;$/;"	t	class:vcg::tri::CylinderClipping
VertexPointer	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  typedef	typename FaceType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::EdgeCollapser
VertexPointer	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::Geodesic
VertexPointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::HalfedgeQuadClean
VertexPointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::Homeometry
VertexPointer	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::VertReg
VertexPointer	vcglib/vcg/complex/algorithms/hole.h	/^            typedef typename MESH::VertexPointer		VertexPointer;$/;"	t	class:vcg::tri::Hole
VertexPointer	vcglib/vcg/complex/algorithms/hole.h	/^  typedef typename MESH::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::TrivialEar
VertexPointer	vcglib/vcg/complex/algorithms/inertia.h	/^	typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::Inertia
VertexPointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::FitmapsCollapse
VertexPointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::QuadDiagonalCollapse
VertexPointer	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::QuadDiagonalCollapseBase
VertexPointer	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef typename TriMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadricTex
VertexPointer	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::PlanarEdgeFlip
VertexPointer	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::TopoEdgeFlip
VertexPointer	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:OverlapEstimation
VertexPointer	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MetroMesh::VertexPointer   VertexPointer;$/;"	t	class:vcg::tri::SurfaceSampling
VertexPointer	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^  typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::PointCloudNormal
VertexPointer	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  typedef typename PolyMeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::PolychordCollapse
VertexPointer	vcglib/vcg/complex/algorithms/smooth.h	/^            typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::Smooth
VertexPointer	vcglib/vcg/complex/algorithms/stat.h	/^  typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::Stat
VertexPointer	vcglib/vcg/complex/algorithms/update/bounding.h	/^typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::UpdateBounding
VertexPointer	vcglib/vcg/complex/algorithms/update/color.h	/^  typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::UpdateColor
VertexPointer	vcglib/vcg/complex/algorithms/update/component_ep.h	/^		typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::UpdateComponentEP
VertexPointer	vcglib/vcg/complex/algorithms/update/curvature.h	/^    typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::UpdateCurvature
VertexPointer	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^	typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
VertexPointer	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::UpdateFlags
VertexPointer	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::UpdateHalfEdges
VertexPointer	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	struct:vcg::tri::UpdateIndexed
VertexPointer	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::HalfEdgeTopology
VertexPointer	vcglib/vcg/complex/algorithms/update/normal.h	/^typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::UpdateNormal
VertexPointer	vcglib/vcg/complex/algorithms/update/position.h	/^typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::UpdatePosition
VertexPointer	vcglib/vcg/complex/algorithms/update/quality.h	/^  typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::UpdateQuality
VertexPointer	vcglib/vcg/complex/algorithms/update/selection.h	/^typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::UpdateSelection
VertexPointer	vcglib/vcg/complex/algorithms/update/texture.h	/^typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::UpdateTexture
VertexPointer	vcglib/vcg/complex/algorithms/update/topology.h	/^typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::UpdateTopology
VertexPointer	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::VertexPointer		VertexPointer;$/;"	t	class:vcg::tri::VoronoiProcessing
VertexPointer	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::VertexPointer  VertexPointer;$/;"	t	class:vcg::tri::Allocator
VertexPointer	vcglib/vcg/complex/base.h	/^                                typedef VertexType * VertexPointer;$/;"	t	struct:vcg::tri::MeshTypeHolder
VertexPointer	vcglib/vcg/complex/base.h	/^                typedef typename TYPESPOOL::VertexPointer		VertexPointer;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
VertexPointer	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::VertexPointer					VertexPointer;$/;"	t	class:vcg::tri::TriMesh
VertexPointer	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsVertexType: public T{typedef A VertexType;	typedef VertexType * VertexPointer	;};$/;"	t	struct:vcg::Use::AsVertexType
VertexPointer	vcglib/vcg/complex/used_types.h	/^        typedef VertexType * VertexPointer;$/;"	t	struct:vcg::DummyTypes
VertexPointer	vcglib/vcg/connectors/halfedge_pos.h	/^            typedef typename MeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::hedge::Pos
VertexPointer	vcglib/wrap/dae/poly_triangulator.h	/^		typedef VertexType* VertexPointer;$/;"	t	class:vcg::tri::io::PolygonalMesh
VertexPointer	vcglib/wrap/gl/pick.h	/^  typedef typename MESH_TYPE::VertexPointer  VertexPointer;$/;"	t	class:vcg::GLPickTri
VertexPointer	vcglib/wrap/io_tetramesh/export_ply.h	/^typedef typename SaveMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tetra::io::ExporterPLY
VertexPointer	vcglib/wrap/io_tetramesh/export_ts.h	/^	typedef typename MESHTYPE::VertexPointer VertexPointer;$/;"	t	struct:vcg::tetra::io::ExporterTS
VertexPointer	vcglib/wrap/io_tetramesh/import_ply.h	/^typedef typename OpenMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tetra::io::ImporterPLY
VertexPointer	vcglib/wrap/io_tetramesh/import_ts.h	/^	typedef typename Tetramesh::VertexPointer VertexPointer;$/;"	t	class:vcg::tetra::io::ImporterTS
VertexPointer	vcglib/wrap/io_trimesh/export_ctm.h	/^                typedef typename SaveMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ExporterCTM
VertexPointer	vcglib/wrap/io_trimesh/export_fbx.h	/^	typedef typename SaveMeshType::VertexPointer VertexPointer;$/;"	t	class:ExporterFBX
VertexPointer	vcglib/wrap/io_trimesh/export_gts.h	/^				typedef typename SaveMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ExporterGTS
VertexPointer	vcglib/wrap/io_trimesh/export_idtf.h	/^typedef typename SaveMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ExporterIDTF
VertexPointer	vcglib/wrap/io_trimesh/export_off.h	/^				typedef typename SaveMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ExporterOFF
VertexPointer	vcglib/wrap/io_trimesh/export_ply.h	/^typedef typename SaveMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ExporterPLY
VertexPointer	vcglib/wrap/io_trimesh/export_smf.h	/^		typedef typename SaveMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ExporterSMF
VertexPointer	vcglib/wrap/io_trimesh/export_vrml.h	/^				typedef typename SaveMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ExporterWRL
VertexPointer	vcglib/wrap/io_trimesh/import_asc.h	/^typedef typename MESH_TYPE::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ImporterASC
VertexPointer	vcglib/wrap/io_trimesh/import_ctm.h	/^typedef typename OpenMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ImporterCTM
VertexPointer	vcglib/wrap/io_trimesh/import_fbx.h	/^	typedef typename OpenMeshType::VertexPointer VertexPointer;$/;"	t	class:ImporterFBX
VertexPointer	vcglib/wrap/io_trimesh/import_gts.h	/^				typedef typename MESH_TYPE::VertexPointer		VertexPointer;$/;"	t	class:vcg::tri::io::ImporterGTS
VertexPointer	vcglib/wrap/io_trimesh/import_nvm.h	/^typedef typename OpenMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ImporterNVM
VertexPointer	vcglib/wrap/io_trimesh/import_obj.h	/^                typedef typename OpenMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ImporterOBJ
VertexPointer	vcglib/wrap/io_trimesh/import_off.h	/^  typedef typename MESH_TYPE::VertexPointer		VertexPointer;$/;"	t	class:vcg::tri::io::ImporterOFF
VertexPointer	vcglib/wrap/io_trimesh/import_out.h	/^typedef typename OpenMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ImporterOUT
VertexPointer	vcglib/wrap/io_trimesh/import_ply.h	/^typedef typename OpenMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ImporterPLY
VertexPointer	vcglib/wrap/io_trimesh/import_ptx.h	/^		typedef typename OpenMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ImporterPTX
VertexPointer	vcglib/wrap/io_trimesh/import_raw.h	/^typedef typename MESH_TYPE::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ImporterRAW
VertexPointer	vcglib/wrap/io_trimesh/import_smf.h	/^		typedef typename OpenMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ImporterSMF
VertexPointer	vcglib/wrap/io_trimesh/import_stl.h	/^typedef typename OpenMeshType::VertexPointer VertexPointer;$/;"	t	class:vcg::tri::io::ImporterSTL
VertexPointerIterator	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    typedef typename vector<VertexPointer>::iterator VertexPointerIterator;$/;"	t	class:OverlapEstimation
VertexPointerLeft	vcglib/vcg/complex/append.h	/^ typedef typename MeshLeft::VertexPointer		VertexPointerLeft;$/;"	t	class:vcg::tri::Append
VertexPointerRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::VertexPointer  VertexPointerRight;$/;"	t	class:vcg::tri::Append
VertexPointerSampler	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        VertexPointerSampler(){ m = new MeshType(); m->Tr.SetIdentity(); m->sfn=0; }$/;"	f	class:OverlapEstimation::VertexPointerSampler
VertexPointerSampler	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    class VertexPointerSampler$/;"	c	class:OverlapEstimation
VertexQualityLaplacian	vcglib/vcg/complex/algorithms/smooth.h	/^static void VertexQualityLaplacian(MeshType &m, int step=1, bool SmoothSelected=false)$/;"	f	class:vcg::tri::Smooth
VertexRef	vcglib/vcg/simplex/edge/component.h	/^	VertexRef(){$/;"	f	class:vcg::edge::VertexRef
VertexRef	vcglib/vcg/simplex/edge/component.h	/^template <class T> class VertexRef: public T {$/;"	c	namespace:vcg::edge
VertexRef	vcglib/vcg/simplex/face/component.h	/^    VertexRef(){$/;"	f	class:vcg::face::VertexRef
VertexRef	vcglib/vcg/simplex/face/component.h	/^template <class T> class VertexRef: public T {$/;"	c	namespace:vcg::face
VertexRef	vcglib/vcg/simplex/tetrahedron/component.h	/^	VertexRef(){$/;"	f	class:vcg::tetra::VertexRef
VertexRef	vcglib/vcg/simplex/tetrahedron/component.h	/^template <class T> class VertexRef: public T {$/;"	c	namespace:vcg::tetra
VertexRefOcc	vcglib/vcg/simplex/face/component_occ.h	/^template <class T> class VertexRefOcc: public T {$/;"	c	namespace:vcg::face
VertexRight	vcglib/vcg/complex/append.h	/^ typedef typename ConstMeshRight::VertexType			VertexRight;$/;"	t	class:vcg::tri::Append
VertexSampling	vcglib/apps/metro/sampling.h	/^void Sampling<MetroMesh>::VertexSampling()$/;"	f	class:vcg::Sampling
VertexSaturate	vcglib/vcg/complex/algorithms/update/quality.h	/^static void VertexSaturate(MeshType &m, ScalarType gradientThr=1.0)$/;"	f	class:vcg::tri::UpdateQuality
VertexSet	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void VertexSet(MeshType &m, unsigned int FlagMask)$/;"	f	class:vcg::tri::UpdateFlags
VertexSetB	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void VertexSetB(MeshType &m) { VertexSet(m,VertexType::BORDER);}$/;"	f	class:vcg::tri::UpdateFlags
VertexSetV	vcglib/vcg/complex/algorithms/update/flag.h	/^  static void VertexSetV(MeshType &m) { VertexSet(m,VertexType::VISITED);}$/;"	f	class:vcg::tri::UpdateFlags
VertexShader	vcglib/wrap/gl/shaders.h	/^	VertexShader(void) : Shader()$/;"	f	class:VertexShader
VertexShader	vcglib/wrap/gl/shaders.h	/^class VertexShader : public Shader$/;"	c
VertexShader	vcglib/wrap/glw/vertexshader.h	/^		VertexShader(Context * ctx)$/;"	f	class:glw::VertexShader
VertexShader	vcglib/wrap/glw/vertexshader.h	/^class VertexShader : public Shader$/;"	c	namespace:glw
VertexShaderArguments	vcglib/wrap/glw/vertexshader.h	/^		VertexShaderArguments(void)$/;"	f	class:glw::VertexShaderArguments
VertexShaderArguments	vcglib/wrap/glw/vertexshader.h	/^class VertexShaderArguments : public ShaderArguments$/;"	c	namespace:glw
VertexShaderBindingParams	vcglib/wrap/glw/vertexshader.h	/^		VertexShaderBindingParams(void)$/;"	f	class:glw::VertexShaderBindingParams
VertexShaderBindingParams	vcglib/wrap/glw/vertexshader.h	/^class VertexShaderBindingParams : public ShaderBindingParams$/;"	c	namespace:glw
VertexShaderHandle	vcglib/wrap/glw/vertexshader.h	/^typedef   detail::ObjectSharedPointerTraits      <SafeVertexShader> ::Type VertexShaderHandle;$/;"	t	namespace:glw
VertexShaderPtr	vcglib/wrap/glw/vertexshader.h	/^typedef   detail::ObjectSharedPointerTraits  <VertexShader> ::Type VertexShaderPtr;$/;"	t	namespace:glw
VertexShaderType	vcglib/wrap/glw/type.h	/^	VertexShaderType,$/;"	e	enum:glw::Type
VertexStar	vcglib/vcg/simplex/edge/pos.h	/^	VertexStar() {}$/;"	f	class:vcg::edge::VertexStar
VertexStar	vcglib/vcg/simplex/edge/pos.h	/^	VertexStar(EDGETYPE  * const ep, int const zp)$/;"	f	class:vcg::edge::VertexStar
VertexStar	vcglib/vcg/simplex/edge/pos.h	/^class VertexStar$/;"	c	namespace:vcg::edge
VertexToInd	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    std::map<VertexType*,int> VertexToInd;$/;"	m	class:vcg::tri::PoissonSolver
VertexType	vcglib/apps/metro/sampling.h	/^        typedef typename MetroMesh::VertexType			VertexType;$/;"	t	class:vcg::Sampling
VertexType	vcglib/apps/unsupported/shadevis/visshader.h	/^		typedef typename MESH_TYPE::VertexType  VertexType;$/;"	t	class:vcg::VisShader
VertexType	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::FourPCS
VertexType	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::BitQuadCreation
VertexType	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::BitQuadOptimization
VertexType	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::BitQuad
VertexType	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::Clean
VertexType	vcglib/vcg/complex/algorithms/clean.h	/^  typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::ConnectedComponentIterator
VertexType	vcglib/vcg/complex/algorithms/clip.h	/^	typedef typename FaceType::VertexType VertexType;$/;"	t	class:vcg::tri::TriMeshClipper
VertexType	vcglib/vcg/complex/algorithms/clip.h	/^    typedef typename MESH_TYPE::VertexType VertexType;$/;"	t	class:vcg::tri::GenericVertexInterpolator
VertexType	vcglib/vcg/complex/algorithms/closest.h	/^		typedef typename  MESH_TYPE::VertexType VertexType;$/;"	t	class:vcg::tri::VertTmark
VertexType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::VertexType  VertexType;$/;"	t	class:vcg::tri::AverageColorCell
VertexType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::VertexType  VertexType;$/;"	t	class:vcg::tri::Clustering
VertexType	vcglib/vcg/complex/algorithms/clustering.h	/^  typedef typename MeshType::VertexType  VertexType;$/;"	t	class:vcg::tri::NearestToCenter
VertexType	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::VertexType     VertexType;$/;"	t	class:vcg::tri::AdvancingFront
VertexType	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  typedef typename MESH::VertexType     VertexType;$/;"	t	class:vcg::tri::AdvancingTest
VertexType	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  typedef typename MESH::VertexType     VertexType;$/;"	t	class:vcg::tri::BallPivoting
VertexType	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef typename TRIMESH_TYPE::VertexType			VertexType;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
VertexType	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef typename TRIMESH_TYPE::VertexType			VertexType;$/;"	t	class:vcg::tri::MarchingCubes
VertexType	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^  typedef typename MeshType::VertexType          VertexType;$/;"	t	class:vcg::tri::CylinderClipping
VertexType	vcglib/vcg/complex/algorithms/edge_collapse.h	/^    typedef	typename FaceType::VertexType VertexType;$/;"	t	class:vcg::tri::EdgeCollapser
VertexType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::AnisotropicDistance
VertexType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::Geodesic
VertexType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::IsotropicDistance
VertexType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::VertexType VertexType;$/;"	t	struct:vcg::tri::BasicCrossFunctor
VertexType	vcglib/vcg/complex/algorithms/geodesic.h	/^  typedef typename MeshType::VertexType VertexType;$/;"	t	struct:vcg::tri::EuclideanDistance
VertexType	vcglib/vcg/complex/algorithms/harmonic.h	/^	typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::Harmonic
VertexType	vcglib/vcg/complex/algorithms/hole.h	/^            typedef typename MESH::VertexType				VertexType;$/;"	t	class:vcg::tri::Hole
VertexType	vcglib/vcg/complex/algorithms/inertia.h	/^	typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::Inertia
VertexType	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  typedef	typename TetraType::VertexType VertexType;$/;"	t	class:vcg::tetra::TetraEdgeCollapse
VertexType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  typedef	typename TriMeshType::FaceType::VertexType VertexType;$/;"	t	class:vcg::tri::TriEdgeCollapse
VertexType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^		typedef typename TriMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadric
VertexType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::QuadricTexHelper
VertexType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  typedef typename TriMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::TriEdgeCollapseQuadricTex
VertexType	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	typedef typename TRIMESH_TYPE::VertexType VertexType;$/;"	t	class:vcg::tri::PlanarEdgeFlip
VertexType	vcglib/vcg/complex/algorithms/nring.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::Nring
VertexType	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:OverlapEstimation
VertexType	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^			typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::Distortion
VertexType	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::PoissonSolver
VertexType	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^			typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::CrossField
VertexType	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^			typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::UV_Utils
VertexType	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^  typedef typename VoroMesh::VertexType VertexType;$/;"	t	class:vcg::tri::VoronoiAtlas
VertexType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MeshType::VertexType  VertexType;$/;"	t	class:vcg::tri::MeshSampler
VertexType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::TrivialSampler
VertexType	vcglib/vcg/complex/algorithms/point_sampling.h	/^  typedef typename MetroMesh::VertexType      VertexType;$/;"	t	class:vcg::tri::SurfaceSampling
VertexType	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^  typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::PointCloudNormal
VertexType	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  typedef typename PolyMeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::PolychordCollapse
VertexType	vcglib/vcg/complex/algorithms/refine.h	/^     typedef typename MESH_TYPE::VertexType VertexType;$/;"	t	struct:vcg::tri::MidPoint
VertexType	vcglib/vcg/complex/algorithms/refine.h	/^  typedef typename MeshType::VertexType VertexType;$/;"	t	struct:vcg::tri::BaseInterpolator
VertexType	vcglib/vcg/complex/algorithms/refine.h	/^  typedef typename TRIMESH_TYPE::VertexType VertexType;$/;"	t	class:vcg::tri::TriSplit
VertexType	vcglib/vcg/complex/algorithms/smooth.h	/^            typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::Smooth
VertexType	vcglib/vcg/complex/algorithms/stat.h	/^  typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::Stat
VertexType	vcglib/vcg/complex/algorithms/symmetry.h	/^    typedef typename TriMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::ExtrinsicPlaneSymmetry
VertexType	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef typename MESH_TYPE::VertexType VertexType;$/;"	t	class:vcg::tri::AreaPreservingTextureOptimizer
VertexType	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  typedef typename MESH_TYPE::VertexType VertexType;$/;"	t	class:vcg::tri::TextureOptimizer
VertexType	vcglib/vcg/complex/algorithms/update/bounding.h	/^typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::UpdateBounding
VertexType	vcglib/vcg/complex/algorithms/update/color.h	/^  typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::UpdateColor
VertexType	vcglib/vcg/complex/algorithms/update/component_ep.h	/^		typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::UpdateComponentEP
VertexType	vcglib/vcg/complex/algorithms/update/curvature.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::UpdateCurvature
VertexType	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^	typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
VertexType	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::Fitmaps
VertexType	vcglib/vcg/complex/algorithms/update/flag.h	/^  typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::UpdateFlags
VertexType	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::UpdateHalfEdges
VertexType	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^            typedef typename MeshType::VertexType VertexType;$/;"	t	struct:vcg::tri::UpdateIndexed
VertexType	vcglib/vcg/complex/algorithms/update/normal.h	/^typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::UpdateNormal
VertexType	vcglib/vcg/complex/algorithms/update/position.h	/^typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::UpdatePosition
VertexType	vcglib/vcg/complex/algorithms/update/quality.h	/^  typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::UpdateQuality
VertexType	vcglib/vcg/complex/algorithms/update/selection.h	/^typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::UpdateSelection
VertexType	vcglib/vcg/complex/algorithms/update/texture.h	/^typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::UpdateTexture
VertexType	vcglib/vcg/complex/algorithms/update/topology.h	/^typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::UpdateTopology
VertexType	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::VertexType				VertexType;$/;"	t	class:vcg::tri::VoronoiProcessing
VertexType	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  typedef typename MeshType::VertexType	VertexType;$/;"	t	class:vcg::tri::ClusteringSampler
VertexType	vcglib/vcg/complex/allocate.h	/^            typedef typename MeshType::VertexType     VertexType;$/;"	t	class:vcg::tri::Allocator
VertexType	vcglib/vcg/complex/base.h	/^                                typedef typename VertContainer::value_type VertexType;$/;"	t	struct:vcg::tri::MeshTypeHolder
VertexType	vcglib/vcg/complex/base.h	/^                typedef _Vertex 								VertexType;$/;"	t	struct:vcg::tri::BaseMeshTypeHolder
VertexType	vcglib/vcg/complex/base.h	/^        typedef typename TriMesh::VertexType						VertexType;$/;"	t	class:vcg::tri::TriMesh
VertexType	vcglib/vcg/complex/used_types.h	/^        template <class T> struct AsVertexType: public T{typedef A VertexType;	typedef VertexType * VertexPointer	;};$/;"	t	struct:vcg::Use::AsVertexType
VertexType	vcglib/vcg/complex/used_types.h	/^        typedef _Vertex VertexType; 		\/\/ simplex types$/;"	t	struct:vcg::DummyTypes
VertexType	vcglib/vcg/simplex/edge/pos.h	/^	typedef	typename EDGETYPE::VertexType VertexType;$/;"	t	class:vcg::edge::Pos
VertexType	vcglib/vcg/simplex/edge/pos.h	/^	typedef typename EdgeType::VertexType VertexType;$/;"	t	class:vcg::edge::VEIterator
VertexType	vcglib/vcg/simplex/face/component_occ.h	/^  typedef typename T::VertexType VertexType;$/;"	t	class:vcg::face::VertexRefOcc
VertexType	vcglib/vcg/simplex/face/component_polygon.h	/^  typedef typename  T::VertexType VertexType;$/;"	t	class:vcg::face::PFVAdj
VertexType	vcglib/vcg/simplex/face/component_polygon.h	/^  typedef typename T::VertexType VertexType;$/;"	t	class:vcg::face::PVFAdj
VertexType	vcglib/vcg/simplex/face/jumping_pos.h	/^			typedef typename	FaceType::VertexType		VertexType;$/;"	t	class:vcg::face::JumpingPos
VertexType	vcglib/vcg/simplex/face/pos.h	/^	typedef typename FaceType::VertexType VertexType;$/;"	t	class:vcg::face::Pos
VertexType	vcglib/vcg/simplex/face/pos.h	/^	typedef typename FaceType::VertexType VertexType;$/;"	t	class:vcg::face::VFIterator
VertexType	vcglib/vcg/simplex/tetrahedron/base.h	/^  typedef BVT VertexType;$/;"	t	class:vcg::TetraTypeHolder
VertexType	vcglib/vcg/simplex/tetrahedron/pos.h	/^	typedef	typename TetraType::VertexType VertexType;$/;"	t	class:vcg::tetra::Pos
VertexType	vcglib/wrap/dae/poly_triangulator.h	/^		typedef typename FaceType::BaseVertexType VertexType;$/;"	t	class:vcg::tri::io::PolygonalMesh
VertexType	vcglib/wrap/gl/gl_field.h	/^	typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::GLField
VertexType	vcglib/wrap/gl/pick.h	/^	typedef typename TETRA_MESH_TYPE::VertexType  VertexType;$/;"	t	class:vcg::GLPickTetra
VertexType	vcglib/wrap/gl/pick.h	/^  typedef typename MESH_TYPE::VertexType  VertexType;$/;"	t	class:vcg::GLPickTri
VertexType	vcglib/wrap/gl/tetramesh.h	/^  typedef typename TetraType::VertexType VertexType;$/;"	t	class:vcg::tetra::GlTetramesh
VertexType	vcglib/wrap/io_tetramesh/export_ply.h	/^typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tetra::io::ExporterPLY
VertexType	vcglib/wrap/io_tetramesh/export_ts.h	/^	typedef typename MESHTYPE::VertexType VertexType;$/;"	t	struct:vcg::tetra::io::ExporterTS
VertexType	vcglib/wrap/io_tetramesh/import_ply.h	/^typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:vcg::tetra::io::ImporterPLY
VertexType	vcglib/wrap/io_tetramesh/import_ts.h	/^	typedef typename Tetramesh::VertexType VertexType;$/;"	t	class:vcg::tetra::io::ImporterTS
VertexType	vcglib/wrap/io_trimesh/export_3ds.h	/^		typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::Exporter3DS
VertexType	vcglib/wrap/io_trimesh/export_fbx.h	/^	typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:ExporterFBX
VertexType	vcglib/wrap/io_trimesh/export_field.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ExporterFIELD
VertexType	vcglib/wrap/io_trimesh/export_gts.h	/^				typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ExporterGTS
VertexType	vcglib/wrap/io_trimesh/export_idtf.h	/^typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ExporterIDTF
VertexType	vcglib/wrap/io_trimesh/export_obj.h	/^  typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ExporterOBJ
VertexType	vcglib/wrap/io_trimesh/export_off.h	/^				typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ExporterOFF
VertexType	vcglib/wrap/io_trimesh/export_ply.h	/^typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ExporterPLY
VertexType	vcglib/wrap/io_trimesh/export_smf.h	/^		typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ExporterSMF
VertexType	vcglib/wrap/io_trimesh/export_vmi.h	/^            typedef typename MeshType::VertexType VertexType;$/;"	t	struct:vcg::tri::io::ExporterVMI::SaveVertexOcf
VertexType	vcglib/wrap/io_trimesh/export_vmi.h	/^        typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ExporterVMI
VertexType	vcglib/wrap/io_trimesh/export_vrml.h	/^				typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ExporterWRL
VertexType	vcglib/wrap/io_trimesh/import_asc.h	/^typedef typename MESH_TYPE::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterASC
VertexType	vcglib/wrap/io_trimesh/import_ctm.h	/^typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterCTM
VertexType	vcglib/wrap/io_trimesh/import_fbx.h	/^	typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:ImporterFBX
VertexType	vcglib/wrap/io_trimesh/import_field.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterFIELD
VertexType	vcglib/wrap/io_trimesh/import_gts.h	/^				typedef typename MESH_TYPE::VertexType			VertexType;$/;"	t	class:vcg::tri::io::ImporterGTS
VertexType	vcglib/wrap/io_trimesh/import_nvm.h	/^typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterNVM
VertexType	vcglib/wrap/io_trimesh/import_obj.h	/^                typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterOBJ
VertexType	vcglib/wrap/io_trimesh/import_off.h	/^  typedef typename MESH_TYPE::VertexType			VertexType;$/;"	t	class:vcg::tri::io::ImporterOFF
VertexType	vcglib/wrap/io_trimesh/import_out.h	/^typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterOUT
VertexType	vcglib/wrap/io_trimesh/import_ply.h	/^typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterPLY
VertexType	vcglib/wrap/io_trimesh/import_ptx.h	/^		typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterPTX
VertexType	vcglib/wrap/io_trimesh/import_raw.h	/^typedef typename MESH_TYPE::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterRAW
VertexType	vcglib/wrap/io_trimesh/import_smf.h	/^		typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterSMF
VertexType	vcglib/wrap/io_trimesh/import_stl.h	/^typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterSTL
VertexType	vcglib/wrap/io_trimesh/import_vmi.h	/^                        typedef typename OpenMeshType::VertexType VertexType;$/;"	t	struct:vcg::tri::io::ImporterVMI::LoadVertexOcf
VertexType	vcglib/wrap/io_trimesh/import_vmi.h	/^        typedef typename OpenMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::ImporterVMI
VertexType	vcglib/wrap/io_trimesh/io_material.h	/^		typedef typename SaveMeshType::VertexType VertexType;$/;"	t	class:vcg::tri::io::Materials
VertexType	vcglib/wrap/miq/core/poisson_solver.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:PoissonSolver
VertexType	vcglib/wrap/miq/core/seams_initializer.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:SeamsInitializer
VertexType	vcglib/wrap/miq/core/stiffening.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:StiffeningInitializer
VertexType	vcglib/wrap/miq/core/vertex_indexing.h	/^    typedef typename MeshType::VertexType VertexType;$/;"	t	class:VertexIndexing
VertexType	vcglib/wrap/miq/quadrangulator.h	/^        typedef typename MESH_TYPE::VertexType VertexType;$/;"	t	class:Quadrangulator::EdgePredicate
VertexType	vcglib/wrap/miq/quadrangulator.h	/^        typedef typename MESH_TYPE::VertexType VertexType;$/;"	t	struct:Quadrangulator::SplitMidPoint
VertexTypeP	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        typedef typename MeshType::VertexPointer VertexTypeP;$/;"	t	class:vcg::tri::UpdateCurvatureFitting
VertexUniform	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void VertexUniform(MetroMesh & m, VertexSampler &ps, int sampleNum)$/;"	f	class:vcg::tri::SurfaceSampling
VertexVectorHasPerVertexColor	vcglib/vcg/complex/base.h	/^template < class VertexType> bool VertexVectorHasPerVertexColor       (const std::vector<VertexType> &) {  return VertexType::HasColor       (); }$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexColor	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool VertexVectorHasPerVertexColor(const vertex::vector_ocf<VertexType> &fv)$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexCurvature	vcglib/vcg/complex/base.h	/^template < class VertexType> bool VertexVectorHasPerVertexCurvature   (const std::vector<VertexType> &) {  return VertexType::HasCurvature   (); }$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexCurvature	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool VertexVectorHasPerVertexCurvature(const vertex::vector_ocf<VertexType> &fv)$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexCurvatureDir	vcglib/vcg/complex/base.h	/^template < class VertexType> bool VertexVectorHasPerVertexCurvatureDir(const std::vector<VertexType> &) {  return VertexType::HasCurvatureDir(); }$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexCurvatureDir	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool VertexVectorHasPerVertexCurvatureDir(const vertex::vector_ocf<VertexType> &fv)$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexFlags	vcglib/vcg/complex/base.h	/^template < class VertexType> bool VertexVectorHasPerVertexFlags       (const std::vector<VertexType> &) {  return VertexType::HasFlags       (); }$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexMark	vcglib/vcg/complex/base.h	/^template < class VertexType> bool VertexVectorHasPerVertexMark        (const std::vector<VertexType> &) {  return VertexType::HasMark        (); }$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexNormal	vcglib/vcg/complex/base.h	/^template < class VertexType> bool VertexVectorHasPerVertexNormal      (const std::vector<VertexType> &) {  return VertexType::HasNormal      (); }$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexNormal	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool VertexVectorHasPerVertexNormal(const vertex::vector_ocf<VertexType> &fv)$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexQuality	vcglib/vcg/complex/base.h	/^template < class VertexType> bool VertexVectorHasPerVertexQuality     (const std::vector<VertexType> &) {  return VertexType::HasQuality     (); }$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexQuality	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool VertexVectorHasPerVertexQuality(const vertex::vector_ocf<VertexType> &fv)$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexRadius	vcglib/vcg/complex/base.h	/^template < class VertexType> bool VertexVectorHasPerVertexRadius      (const std::vector<VertexType> &) {  return VertexType::HasRadius      (); }$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexRadius	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool VertexVectorHasPerVertexRadius(const vertex::vector_ocf<VertexType> &fv)$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexTexCoord	vcglib/vcg/complex/base.h	/^template < class VertexType> bool VertexVectorHasPerVertexTexCoord    (const std::vector<VertexType> &) {  return VertexType::HasTexCoord    (); }$/;"	f	namespace:vcg::tri
VertexVectorHasPerVertexTexCoord	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool VertexVectorHasPerVertexTexCoord(const vertex::vector_ocf<VertexType> &fv)$/;"	f	namespace:vcg::tri
VertexVectorHasVFAdjacency	vcglib/vcg/complex/base.h	/^template < class VertexType> bool VertexVectorHasVFAdjacency     (const std::vector<VertexType> &) {  return VertexType::HasVFAdjacency(); }$/;"	f	namespace:vcg::tri
VertexVectorHasVFAdjacency	vcglib/vcg/simplex/vertex/component_ocf.h	/^bool VertexVectorHasVFAdjacency(const vertex::vector_ocf<VertexType> &fv)$/;"	f	namespace:vcg::tri
VertexVisShader	vcglib/apps/unsupported/shadevis/visshader.h	/^	VertexVisShader(MESH_TYPE &me):VisShader<MESH_TYPE>(me)$/;"	f	class:vcg::VertexVisShader
VertexVisShader	vcglib/apps/unsupported/shadevis/visshader.h	/^template <class MESH_TYPE> class VertexVisShader : public VisShader<MESH_TYPE>$/;"	c	namespace:vcg
VertexWeighted	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void VertexWeighted(MetroMesh & m, VertexSampler &ps, int sampleNum)$/;"	f	class:vcg::tri::SurfaceSampling
Vertical	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  Vertical, $/;"	e	enum:Eigen::DirectionType
VerticesTag	vcglib/wrap/dae/colladaformat.h	/^		VerticesTag(const QString& id)$/;"	f	class:Collada::Tags::VerticesTag
VerticesTag	vcglib/wrap/dae/colladaformat.h	/^	class VerticesTag : public XMLTag$/;"	c	namespace:Collada::Tags
Vi	vcglib/vcg/simplex/tetrahedron/pos.h	/^inline const int & Vi() const$/;"	f	class:vcg::tetra::VTIterator
Vi	vcglib/vcg/simplex/tetrahedron/pos.h	/^inline int & Vi()$/;"	f	class:vcg::tetra::VTIterator
View	vcglib/wrap/gui/view.h	/^template <class T> class View {$/;"	c	namespace:vcg
ViewAngle	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^float ViewAngle=33;$/;"	v
ViewDisplay	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void  ViewDisplay (void)$/;"	f
ViewInit	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void  ViewInit (void) {$/;"	f
ViewKey	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void ViewKey(unsigned char key, int , int )$/;"	f
ViewLineFromModel	vcglib/wrap/gui/view.h	/^template <class T> Line3<T> View<T>::ViewLineFromModel(const Point3<T> &p)$/;"	f	class:vcg::View
ViewLineFromWindow	vcglib/wrap/gui/view.h	/^template <class T> Line3<T> View<T>::ViewLineFromWindow(const Point3<T> &p)$/;"	f	class:vcg::View
ViewMenu	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void ViewMenu(int val)$/;"	f
ViewMouse	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void ViewMouse(int button, int state, int x, int y)$/;"	f
ViewMouseMotion	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void ViewMouseMotion(int x, int y)$/;"	f
ViewPlaneFromModel	vcglib/wrap/gui/view.h	/^template <class T> Plane3<T> View<T>::ViewPlaneFromModel(const Point3<T> &p)$/;"	f	class:vcg::View
ViewPoint	vcglib/wrap/gui/frustum.h	/^template <class T> Point3<T> Frustum<T>::ViewPoint() {$/;"	f	class:vcg::Frustum
ViewPoint	vcglib/wrap/gui/view.h	/^template <class T> Point3<T> View<T>::ViewPoint() const {$/;"	f	class:vcg::View
ViewReshape	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void  ViewReshape(GLsizei w, GLsizei h)$/;"	f
ViewSpecialKey	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void ViewSpecialKey(int , int , int )$/;"	f
ViewVector	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^vector<Point3f> ViewVector;$/;"	v
ViewportPx	vcglib/vcg/math/camera.h	/^    Point2<int>	ViewportPx;			\/\/\/ Dimension of the Image Plane (in pixels)$/;"	m	class:vcg::Camera
ViewportPxToLocal	vcglib/vcg/math/camera.h	/^vcg::Point2<S> Camera<S>::ViewportPxToLocal(const vcg::Point2<S> & p) const$/;"	f	class:vcg::Camera
ViewportPxTo_neg1_1	vcglib/vcg/math/camera.h	/^vcg::Point2<S> Camera<S>::ViewportPxTo_neg1_1(const vcg::Point2<S> & p) const$/;"	f	class:vcg::Camera
VisMax	vcglib/apps/unsupported/shadevis/visshader.h	/^		enum {VisMax=MAXVIS};$/;"	e	enum:vcg::VisShader::__anon3
VisShader	vcglib/apps/unsupported/shadevis/visshader.h	/^	VisShader(MESH_TYPE &me):m(me)$/;"	f	class:vcg::VisShader
VisShader	vcglib/apps/unsupported/shadevis/visshader.h	/^template <class MESH_TYPE, int MAXVIS=2048> class VisShader $/;"	c	namespace:vcg
Visit	vcglib/vcg/complex/algorithms/geodesic.h	/^  static  VertexPointer Visit($/;"	f	class:vcg::tri::Geodesic
Visit	vcglib/wrap/mt/mt.h	/^  void Visit(Node *node, std::queue<Node *> &qnode) {    $/;"	f	class:vcg::MT
VisitPolychord	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^  static void VisitPolychord (const PolyMeshType &mesh,$/;"	f	class:vcg::tri::PolychordCollapse
VisualSceneTag	vcglib/wrap/dae/colladaformat.h	/^		VisualSceneTag(const QString& id,const QString& name)$/;"	f	class:Collada::Tags::VisualSceneTag
VisualSceneTag	vcglib/wrap/dae/colladaformat.h	/^	class VisualSceneTag : public XMLTag$/;"	c	namespace:Collada::Tags
VmlSize	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^      VmlSize = MightLinearize ? MaxSizeAtCompileTime : InnerMaxSize,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon43
Vo	vcglib/vcg/connectors/halfedge_pos.h	/^            VertexPointer Vo()$/;"	f	class:vcg::hedge::Pos
VofE	vcglib/vcg/space/tetra3.h	/^  static int VofE(const int &indexE,const int &indexV)$/;"	f	class:vcg::Tetra
VofEE	vcglib/vcg/space/tetra3.h	/^static int VofEE(const int &indexE0,const int &indexE1)$/;"	f	class:vcg::Tetra
VofF	vcglib/vcg/space/tetra3.h	/^	static int VofF(const int &indexF,const int &indexV)$/;"	f	class:vcg::Tetra
VofFFF	vcglib/vcg/space/tetra3.h	/^static int VofFFF(const int &indexF0,const int &indexF1,const int &indexF2)$/;"	f	class:vcg::Tetra
VoidType	vcglib/vcg/math/base.h	/^    VoidType(){};$/;"	f	class:vcg::VoidType
VoidType	vcglib/vcg/math/base.h	/^class VoidType{ public:$/;"	c	namespace:vcg
Vol	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  std::vector<VoxelType> Vol;$/;"	m	class:vcg::SimpleVolume
Vol	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  std::vector<VoxelType> Vol;$/;"	m	class:vcg::SimpleVolume
Volume	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	float Volume;$/;"	m	struct:MeshInfo	file:
Volume	vcglib/apps/unsupported/extractors/extractor/Volume.h	/^	Volume()$/;"	f	class:Volume
Volume	vcglib/apps/unsupported/extractors/extractor/Volume.h	/^class Volume$/;"	c
Volume	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef AlignedBox<Scalar, Dim> Volume;$/;"	t	class:Eigen::KdBVH
Volume	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	static int &Volume()           {static int vol=0; return vol;}$/;"	f	class:vcg::tri::TriEdgeCollapse::FailStat
Volume	vcglib/vcg/space/box.h	/^	inline S Volume() const$/;"	f	class:vcg::Box
Volume	vcglib/vcg/space/box3.h	/^    BoxScalarType Volume() const$/;"	f	class:vcg::Box3
VolumeAxis	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^typedef enum { XAxis=0,YAxis=1,ZAxis=2} VolumeAxis;$/;"	t	class:vcg::SimpleVolume	typeref:enum:vcg::SimpleVolume::__anon2
VolumeAxis	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    typedef enum { XAxis=0,YAxis=1,ZAxis=2} VolumeAxis;$/;"	t	class:vcg::SimpleVolume	typeref:enum:vcg::SimpleVolume::__anon481
VolumeIterator	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef const int *VolumeIterator; \/\/the iterators are just pointers into the tree's vectors$/;"	t	class:Eigen::KdBVH
VolumeList	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  typedef std::vector<Volume, aligned_allocator<Volume> > VolumeList;$/;"	t	class:Eigen::KdBVH
VoroEdge	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^  class VoroEdge    : public Edge< VoroUsedTypes>{};$/;"	c	class:vcg::tri::VoronoiAtlas
VoroFace	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^  class VoroFace    : public Face<  VoroUsedTypes, face::VertexRef, face::BitFlags, face::FFAdj ,face::VFAdj , face::WedgeTexCoord2f> {};$/;"	c	class:vcg::tri::VoronoiAtlas
VoroMesh	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^  class VoroMesh    : public tri::TriMesh< std::vector<VoroVertex>, std::vector<VoroFace> , std::vector<VoroEdge>  > {};$/;"	c	class:vcg::tri::VoronoiAtlas
VoroUsedTypes	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^  struct VoroUsedTypes : public UsedTypes<	Use<VoroVertex>   ::template AsVertexType,$/;"	s	class:vcg::tri::VoronoiAtlas
VoroVertex	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^  class VoroVertex  : public Vertex< VoroUsedTypes, vertex::Coord3f, vertex::Normal3f, vertex::TexCoord2f, vertex::VFAdj , vertex::Qualityf, vertex::Color4b, vertex::BitFlags  >{};$/;"	c	class:vcg::tri::VoronoiAtlas
VoronoiAreaColoring	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void VoronoiAreaColoring(MeshType &m,std::vector<VertexType *> &seedVec,$/;"	f	class:vcg::tri::VoronoiProcessing
VoronoiAtlas	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^class VoronoiAtlas$/;"	c	namespace:vcg::tri
VoronoiAtlasParam	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^   VoronoiAtlasParam()$/;"	f	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam
VoronoiAtlasParam	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^ struct VoronoiAtlasParam$/;"	s	class:vcg::tri::VoronoiAtlas
VoronoiColoring	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static void VoronoiColoring(MeshType &m, bool frontierFlag=true)$/;"	f	class:vcg::tri::VoronoiProcessing
VoronoiEdge	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^class VoronoiEdge$/;"	c	class:vcg::tri::VoronoiProcessing
VoronoiProcessing	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^class VoronoiProcessing$/;"	c	namespace:vcg::tri
VoronoiProcessingParameter	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  VoronoiProcessingParameter()$/;"	f	struct:vcg::tri::VoronoiProcessingParameter
VoronoiProcessingParameter	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^struct VoronoiProcessingParameter$/;"	s	namespace:vcg::tri
VoronoiRelaxing	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static int VoronoiRelaxing(MeshType &m, std::vector<VertexType *> &seedVec,$/;"	f	class:vcg::tri::VoronoiProcessing
Votes	vcglib/vcg/complex/algorithms/symmetry.h	/^    std::vector<ScalarType> Votes;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
VotingPos	vcglib/vcg/complex/algorithms/symmetry.h	/^    std::vector<std::vector<std::pair<CoordType,CoordType>  > > VotingPos;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
Voxel	vcglib/vcg/space/index/octree.h	/^        Voxel() { count = begin = end = -1; }$/;"	f	struct:vcg::Voxel
Voxel	vcglib/vcg/space/index/octree.h	/^    struct Voxel$/;"	s	namespace:vcg
Voxel	vcglib/vcg/space/index/octree_template.h	/^	inline VoxelPointer	Voxel(const NodePointer n)				{ return &(n->voxel);				}$/;"	f	class:vcg::OctreeTemplate
VoxelPointer	vcglib/vcg/space/index/octree.h	/^        typedef						VoxelType													* VoxelPointer;$/;"	t	class:vcg::Octree
VoxelPointer	vcglib/vcg/space/index/octree_template.h	/^	typedef VoxelType							  * VoxelPointer;$/;"	t	class:vcg::OctreeTemplate
VoxelType	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  typedef VOX_TYPE VoxelType;$/;"	t	class:vcg::SimpleVolume
VoxelType	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  typedef VOX_TYPE VoxelType;$/;"	t	class:vcg::SimpleVolume
VoxelType	vcglib/vcg/space/index/octree.h	/^        typedef 					vcg::Voxel													VoxelType;$/;"	t	class:vcg::Octree
VoxelType	vcglib/vcg/space/index/octree_template.h	/^	typedef VOXEL_TYPE				        VoxelType;$/;"	t	class:vcg::OctreeTemplate
Vt	vcglib/vcg/simplex/tetrahedron/pos.h	/^inline TetraType* & Vt()$/;"	f	class:vcg::tetra::VTIterator
W	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^      static typename VERTEX_TYPE::ScalarType W(VERTEX_TYPE &\/*v*\/) {return 1.0;}$/;"	f	class:vcg::tri::QInfoStandard
W	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^      static typename VERTEX_TYPE::ScalarType W(VERTEX_TYPE *\/*v*\/) {return 1.0;}$/;"	f	class:vcg::tri::QInfoStandard
W	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^      static typename VertexType::ScalarType W(VertexType & \/*v*\/) {return 1.0;}$/;"	f	class:vcg::tri::QuadricTexHelper
W	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^      static typename VertexType::ScalarType W(VertexType * \/*v*\/) {return 1.0;}$/;"	f	class:vcg::tri::QuadricTexHelper
W	vcglib/vcg/math/eigen_matrix_addons.h	/^inline Scalar& W() { return data()[SizeAtCompileTime-1]; }$/;"	f
W	vcglib/vcg/math/eigen_matrix_addons.h	/^inline const Scalar& W() const { return data()[SizeAtCompileTime-1]; }$/;"	f
W	vcglib/vcg/space/deprecated_point.h	/^    inline S &W() { return _v[N-1]; }$/;"	f	class:vcg::ndim::Point
W	vcglib/vcg/space/deprecated_point.h	/^    inline const S &W() const { return _v[N-1]; }$/;"	f	class:vcg::ndim::Point
W	vcglib/vcg/space/deprecated_point4.h	/^    inline T &W() {return _v[3];}$/;"	f	class:vcg::Point4
WArc	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    WArc(VertexPointer _s,VertexPointer _t):src(_s),trg(_t),w(fabs(_s->cN()*_t->cN())){}$/;"	f	class:vcg::tri::PointCloudNormal::WArc
WArc	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^  class WArc$/;"	c	class:vcg::tri::PointCloudNormal
WC	vcglib/vcg/simplex/face/component.h	/^  ColorType &WC(const int)       { static ColorType dumcolor(vcg::Color4b::White);  assert(0); return dumcolor; }$/;"	f	class:vcg::face::EmptyCore
WC	vcglib/vcg/simplex/face/component.h	/^  ColorType &WC(int i) { return _color[i]; }$/;"	f	class:vcg::face::WedgeColor
WC	vcglib/vcg/simplex/face/component_ocf.h	/^  ColorType &WC(const int i)              { assert((*this).Base().WedgeColorEnabled); return (*this).Base().WCV[(*this).Index()].wc[i]; }$/;"	f	class:vcg::face::WedgeColorOcf
WCV	vcglib/vcg/simplex/face/component_ocf.h	/^  std::vector<class WedgeColorTypePack> WCV;$/;"	m	class:vcg::face::vector_ocf
WEDGETEXCOORD	vcglib/wrap/dae/colladaformat.h	/^		enum ARRAYSEMANTIC {VERTPOSITION,VERTNORMAL,VERTCOLOR, FACENORMAL,WEDGETEXCOORD};$/;"	e	enum:Collada::Tags::FloatArrayTag::ARRAYSEMANTIC
WHEEL	vcglib/wrap/gui/trackball.h	/^                WHEEL         = 0x0008, \/\/\/< Mouse wheel activated.$/;"	e	enum:vcg::Trackball::Button
WIDE_GAMUT	vcglib/vcg/space/colorspace.h	/^		WIDE_GAMUT = 15$/;"	e	enum:vcg::ColorSpace::RGBSpaces
WIN32	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define WIN32 /;"	d	file:
WIN32_LEAN_AND_MEAN	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define WIN32_LEAN_AND_MEAN$/;"	d	file:
WINDOW_H_POS_DEMO	vcglib/apps/sample/trimesh_pos_demo/window.h	/^#define WINDOW_H_POS_DEMO$/;"	d
WIRE	vcglib/apps/sample/trimesh_QT/glarea.h	/^  enum DrawMode{SMOOTH=0,POINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:GLArea::DrawMode
WIRE	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^enum DrawMode{SMOOTH=0,PERPOINTS,WIRE,FLATWIRE,HIDDEN,FLAT};$/;"	e	enum:DrawMode	file:
WN	vcglib/vcg/simplex/face/component.h	/^  NormalType &WN(int) { static NormalType dummy_normal(0, 0, 0);  assert(0); return dummy_normal; }$/;"	f	class:vcg::face::EmptyCore
WN	vcglib/vcg/simplex/face/component.h	/^  inline NormalType &WN(int i)       { return _wn[i]; }$/;"	f	class:vcg::face::WedgeRealNormal
WN	vcglib/vcg/simplex/face/component.h	/^  inline NormalType &WN(int j)       { return _wnorm[j]; }$/;"	f	class:vcg::face::WedgeNormal
WN	vcglib/vcg/simplex/face/component_ocf.h	/^  NormalType &WN(const int i)              { assert((*this).Base().WedgeNormalEnabled); return (*this).Base().WNV[(*this).Index()].wn[i]; }$/;"	f	class:vcg::face::WedgeNormalOcf
WNV	vcglib/vcg/simplex/face/component_ocf.h	/^  std::vector<class WedgeNormalTypePack> WNV;$/;"	m	class:vcg::face::vector_ocf
WRAP_GL_PICKING_H	vcglib/wrap/gl/picking.h	/^#define WRAP_GL_PICKING_H$/;"	d
WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
WT	vcglib/vcg/simplex/face/component.h	/^  TexCoordType &WT(const int i)       { return _wt[i]; }$/;"	f	class:vcg::face::WedgeTexCoord
WT	vcglib/vcg/simplex/face/component.h	/^  TexCoordType &WT(const int) { static TexCoordType dummy_texture;  assert(0); return dummy_texture;}$/;"	f	class:vcg::face::EmptyCore
WT	vcglib/vcg/simplex/face/component_occ.h	/^		WedgeTexCoordType &WT(const int&i) {return CAT< vector_occ<FaceType>,WedgeTexCoordType>::Instance()->Get((FaceType*)this);}$/;"	f	class:vcg::face::WedgeTexCoordOcc
WT	vcglib/vcg/simplex/face/component_ocf.h	/^  TexCoordType &WT(const int i)       { assert((*this).Base().WedgeTexEnabled); return (*this).Base().WTV[(*this).Index()].wt[i]; }$/;"	f	class:vcg::face::WedgeTexCoordOcf
WTV	vcglib/vcg/simplex/face/component_ocf.h	/^  std::vector<class WedgeTexTypePack> WTV;$/;"	m	class:vcg::face::vector_ocf
WV	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^		static std::vector<typename TriMeshType::VertexPointer>  & WV(){$/;"	f	class:vcg::tri::TriEdgeCollapseQuadric
WV	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  static std::vector<VertexPointer>  & WV(){$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
Walker	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	Walker(const BoundingBox &bbox, const vcg::Point3i &resolution)$/;"	f	class:Walker
Walker	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^class Walker$/;"	c
Walker	vcglib/vcg/complex/algorithms/create/resampler.h	/^		Walker(const Box3f &_bbox, Point3i _siz )$/;"	f	class:vcg::tri::Resampler::Walker
Walker	vcglib/vcg/complex/algorithms/create/resampler.h	/^	class Walker : BasicGrid<float>$/;"	c	class:vcg::tri::Resampler
WedgeAttribute	vcglib/wrap/dae/util_dae.h	/^		struct WedgeAttribute$/;"	s	class:vcg::tri::io::UtilDAE
WedgeColor	vcglib/vcg/simplex/face/component.h	/^template <class A, class T> class WedgeColor: public T {$/;"	c	namespace:vcg::face
WedgeColor4b	vcglib/vcg/simplex/face/component.h	/^template <class T> class WedgeColor4b: public WedgeColor<vcg::Color4b, T> {$/;"	c	namespace:vcg::face
WedgeColor4bOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class WedgeColor4bOcf: public WedgeColorOcf<vcg::Color4b, T> {};$/;"	c	namespace:vcg::face
WedgeColor4f	vcglib/vcg/simplex/face/component.h	/^template <class T> class WedgeColor4f: public WedgeColor<vcg::Color4f, T> {$/;"	c	namespace:vcg::face
WedgeColorEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  bool WedgeColorEnabled;$/;"	m	class:vcg::face::vector_ocf
WedgeColorOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  WedgeColorOcf(){ }$/;"	f	class:vcg::face::WedgeColorOcf
WedgeColorOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class A, class TT> class WedgeColorOcf: public TT {$/;"	c	namespace:vcg::face
WedgeColorTypePack	vcglib/vcg/simplex/face/component_ocf.h	/^  WedgeColorTypePack() {$/;"	f	class:vcg::face::vector_ocf::WedgeColorTypePack
WedgeColorTypePack	vcglib/vcg/simplex/face/component_ocf.h	/^class WedgeColorTypePack {$/;"	c	class:vcg::face::vector_ocf
WedgeInterp	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    Color4<ScalarType> WedgeInterp(Color4<ScalarType> &c0, Color4<ScalarType> &c1)$/;"	f	class:vcg::tri::CylinderClipping::CylMidPoint
WedgeInterp	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    TexCoord2<ScalarType,1> WedgeInterp(TexCoord2<ScalarType,1> &t0, TexCoord2<ScalarType,1> &t1)$/;"	f	class:vcg::tri::CylinderClipping::CylMidPoint
WedgeInterp	vcglib/vcg/complex/algorithms/refine.h	/^    Color4<typename MESH_TYPE::ScalarType> WedgeInterp(Color4<typename MESH_TYPE::ScalarType> &c0, Color4<typename MESH_TYPE::ScalarType> &c1)$/;"	f	class:vcg::tri::QualityMidPointFunctor
WedgeInterp	vcglib/vcg/complex/algorithms/refine.h	/^    Color4<typename MESH_TYPE::ScalarType> WedgeInterp(Color4<typename MESH_TYPE::ScalarType> &c0, Color4<typename MESH_TYPE::ScalarType> &c1)$/;"	f	struct:vcg::tri::MidPoint
WedgeInterp	vcglib/vcg/complex/algorithms/refine.h	/^    Color4<typename MESH_TYPE::ScalarType> WedgeInterp(Color4<typename MESH_TYPE::ScalarType> &c0, Color4<typename MESH_TYPE::ScalarType> &c1)$/;"	f	struct:vcg::tri::MidPointArc
WedgeInterp	vcglib/vcg/complex/algorithms/refine.h	/^    Color4<typename MESH_TYPE::ScalarType> WedgeInterp(Color4<typename MESH_TYPE::ScalarType> &c0, Color4<typename MESH_TYPE::ScalarType> &c1)$/;"	f	struct:vcg::tri::MidPointButterfly
WedgeInterp	vcglib/vcg/complex/algorithms/refine.h	/^    Color4<typename MESH_TYPE::ScalarType> WedgeInterp(Color4<typename MESH_TYPE::ScalarType> &c0, Color4<typename MESH_TYPE::ScalarType> &c1)$/;"	f	struct:vcg::tri::MidPointSphere
WedgeInterp	vcglib/vcg/complex/algorithms/refine.h	/^    TexCoord2<FL_TYPE,1> WedgeInterp(TexCoord2<FL_TYPE,1> &t0, TexCoord2<FL_TYPE,1> &t1)$/;"	f	class:vcg::tri::QualityMidPointFunctor
WedgeInterp	vcglib/vcg/complex/algorithms/refine.h	/^    TexCoord2<FL_TYPE,1> WedgeInterp(TexCoord2<FL_TYPE,1> &t0, TexCoord2<FL_TYPE,1> &t1)$/;"	f	struct:vcg::tri::MidPoint
WedgeInterp	vcglib/vcg/complex/algorithms/refine.h	/^    TexCoord2<FL_TYPE,1> WedgeInterp(TexCoord2<FL_TYPE,1> &t0, TexCoord2<FL_TYPE,1> &t1)$/;"	f	struct:vcg::tri::MidPointArc
WedgeInterp	vcglib/vcg/complex/algorithms/refine.h	/^    TexCoord2<FL_TYPE,1> WedgeInterp(TexCoord2<FL_TYPE,1> &t0, TexCoord2<FL_TYPE,1> &t1)$/;"	f	struct:vcg::tri::MidPointButterfly
WedgeInterp	vcglib/vcg/complex/algorithms/refine.h	/^    TexCoord2<FL_TYPE,1> WedgeInterp(TexCoord2<FL_TYPE,1> &t0, TexCoord2<FL_TYPE,1> &t1)$/;"	f	struct:vcg::tri::MidPointSphere
WedgeInterp	vcglib/vcg/complex/algorithms/refine_loop.h	/^	Color4<typename MESH_TYPE::ScalarType> WedgeInterp(Color4<typename MESH_TYPE::ScalarType> &c0, Color4<typename MESH_TYPE::ScalarType> &c1)$/;"	f	struct:vcg::tri::EvenPointLoopGeneric
WedgeInterp	vcglib/vcg/complex/algorithms/refine_loop.h	/^	Color4<typename MESH_TYPE::ScalarType> WedgeInterp(Color4<typename MESH_TYPE::ScalarType> &c0, Color4<typename MESH_TYPE::ScalarType> &c1)$/;"	f	struct:vcg::tri::OddPointLoopGeneric
WedgeInterp	vcglib/vcg/complex/algorithms/refine_loop.h	/^	Color4b WedgeInterp(Color4b &c0, Color4b &c1)$/;"	f	struct:vcg::tri::EvenPointLoopGeneric
WedgeInterp	vcglib/vcg/complex/algorithms/refine_loop.h	/^	TexCoord2<FL_TYPE,1> WedgeInterp(TexCoord2<FL_TYPE,1> &t0, TexCoord2<FL_TYPE,1> &t1)$/;"	f	struct:vcg::tri::EvenPointLoopGeneric
WedgeInterp	vcglib/vcg/complex/algorithms/refine_loop.h	/^	TexCoord2<FL_TYPE,1> WedgeInterp(TexCoord2<FL_TYPE,1> &t0, TexCoord2<FL_TYPE,1> &t1)$/;"	f	struct:vcg::tri::OddPointLoopGeneric
WedgeInterp	vcglib/wrap/miq/quadrangulator.h	/^        vcg::TexCoord2<ScalarType> WedgeInterp(vcg::TexCoord2<ScalarType> &t0,$/;"	f	struct:Quadrangulator::SplitMidPoint
WedgeNormal	vcglib/vcg/simplex/face/component.h	/^template <class T> class WedgeNormal: public T {$/;"	c	namespace:vcg::face
WedgeNormal3dOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class WedgeNormal3dOcf: public WedgeNormalOcf<vcg::Point3d, T> {};$/;"	c	namespace:vcg::face
WedgeNormal3fOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class WedgeNormal3fOcf: public WedgeNormalOcf<vcg::Point3f, T> {};$/;"	c	namespace:vcg::face
WedgeNormal3sOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class WedgeNormal3sOcf: public WedgeNormalOcf<vcg::Point3s, T> {};$/;"	c	namespace:vcg::face
WedgeNormalAttribute	vcglib/wrap/io_trimesh/import_dae.h	/^		static int WedgeNormalAttribute(ColladaMesh& m,const QStringList face,const QStringList wn,const QDomNode wnsrc,const int meshfaceind,const int faceind,const int component)$/;"	f	class:vcg::tri::io::ImporterDAE
WedgeNormalEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  bool WedgeNormalEnabled;$/;"	m	class:vcg::face::vector_ocf
WedgeNormalOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  WedgeNormalOcf(){ }$/;"	f	class:vcg::face::WedgeNormalOcf
WedgeNormalOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class A, class TT> class WedgeNormalOcf: public TT {$/;"	c	namespace:vcg::face
WedgeNormalTypePack	vcglib/vcg/simplex/face/component_ocf.h	/^  WedgeNormalTypePack() {$/;"	f	class:vcg::face::vector_ocf::WedgeNormalTypePack
WedgeNormalTypePack	vcglib/vcg/simplex/face/component_ocf.h	/^class WedgeNormalTypePack {$/;"	c	class:vcg::face::vector_ocf
WedgeRealNormal	vcglib/vcg/simplex/face/component.h	/^template <class A, class T> class WedgeRealNormal: public T {$/;"	c	namespace:vcg::face
WedgeRealNormal3d	vcglib/vcg/simplex/face/component.h	/^template <class TT> class WedgeRealNormal3d: public WedgeRealNormal<vcg::Point3d, TT> {$/;"	c	namespace:vcg::face
WedgeRealNormal3f	vcglib/vcg/simplex/face/component.h	/^template <class TT> class WedgeRealNormal3f: public WedgeRealNormal<vcg::Point3f, TT> {$/;"	c	namespace:vcg::face
WedgeRealNormal3s	vcglib/vcg/simplex/face/component.h	/^template <class TT> class WedgeRealNormal3s: public WedgeRealNormal<vcg::Point3s, TT> {$/;"	c	namespace:vcg::face
WedgeTexCoord	vcglib/vcg/simplex/face/component.h	/^template <class A, class T> class WedgeTexCoord: public T {$/;"	c	namespace:vcg::face
WedgeTexCoord2d	vcglib/vcg/simplex/face/component.h	/^template <class TT> class WedgeTexCoord2d: public WedgeTexCoord<TexCoord2<double,1>, TT> {$/;"	c	namespace:vcg::face
WedgeTexCoord2f	vcglib/vcg/simplex/face/component.h	/^template <class TT> class WedgeTexCoord2f: public WedgeTexCoord<TexCoord2<float,1>, TT> {$/;"	c	namespace:vcg::face
WedgeTexCoord2s	vcglib/vcg/simplex/face/component.h	/^template <class TT> class WedgeTexCoord2s: public WedgeTexCoord<TexCoord2<short,1>, TT> {$/;"	c	namespace:vcg::face
WedgeTexCoordOcc	vcglib/vcg/simplex/face/component_occ.h	/^	template <class A, class T> class WedgeTexCoordOcc: public T {$/;"	c	namespace:vcg::face
WedgeTexCoordOcf	vcglib/vcg/simplex/face/component_ocf.h	/^  WedgeTexCoordOcf(){ }$/;"	f	class:vcg::face::WedgeTexCoordOcf
WedgeTexCoordOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class A, class TT> class WedgeTexCoordOcf: public TT {$/;"	c	namespace:vcg::face
WedgeTexCoordType	vcglib/vcg/simplex/face/component.h	/^  typedef int WedgeTexCoordType;$/;"	t	class:vcg::face::EmptyCore
WedgeTexCoordType	vcglib/vcg/simplex/face/component.h	/^  typedef int WedgeTexCoordType;$/;"	t	class:vcg::face::WedgeTexCoord
WedgeTexCoordType	vcglib/vcg/simplex/face/component_occ.h	/^		typedef A WedgeTexCoordType;$/;"	t	class:vcg::face::WedgeTexCoordOcc
WedgeTexCoordfOcc	vcglib/vcg/simplex/face/component_occ.h	/^	template <class T> class WedgeTexCoordfOcc: public WedgeTexCoordOcc<TexCoord2<float,1>, T> {};$/;"	c	namespace:vcg::face
WedgeTexCoordfOcf	vcglib/vcg/simplex/face/component_ocf.h	/^template <class T> class WedgeTexCoordfOcf: public WedgeTexCoordOcf<TexCoord2<float,1>, T> {};$/;"	c	namespace:vcg::face
WedgeTexEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  bool WedgeTexEnabled;$/;"	m	class:vcg::face::vector_ocf
WedgeTexFromCamera	vcglib/vcg/complex/algorithms/update/texture.h	/^static void WedgeTexFromCamera(ComputeMeshType &m, Plane3<ScalarType> &pl)$/;"	f	class:vcg::tri::UpdateTexture
WedgeTexFromPlane	vcglib/vcg/complex/algorithms/update/texture.h	/^static void WedgeTexFromPlane(ComputeMeshType &m, const Point3<ScalarType> &uVec, const Point3<ScalarType> &vVec, bool aspectRatio)$/;"	f	class:vcg::tri::UpdateTexture
WedgeTexFromVertexTex	vcglib/vcg/complex/algorithms/update/texture.h	/^static void WedgeTexFromVertexTex(ComputeMeshType &m)$/;"	f	class:vcg::tri::UpdateTexture
WedgeTexRemoveNull	vcglib/vcg/complex/algorithms/update/texture.h	/^static void WedgeTexRemoveNull(ComputeMeshType &m, const std::string &texturename)$/;"	f	class:vcg::tri::UpdateTexture
WedgeTexTypePack	vcglib/vcg/simplex/face/component_ocf.h	/^  WedgeTexTypePack() {$/;"	f	class:vcg::face::vector_ocf::WedgeTexTypePack
WedgeTexTypePack	vcglib/vcg/simplex/face/component_ocf.h	/^class WedgeTexTypePack {$/;"	c	class:vcg::face::vector_ocf
WedgeTextureAttribute	vcglib/wrap/io_trimesh/import_dae.h	/^		static int WedgeTextureAttribute(ColladaMesh& m,const QStringList face,int ind_txt,const QStringList wt,const QDomNode wtsrc,const int meshfaceind,const int faceind,const int component,const int stride = 2)$/;"	f	class:vcg::tri::io::ImporterDAE
WedgeTextureAttribute	vcglib/wrap/io_trimesh/import_dae.h	/^		static int WedgeTextureAttribute(typename ColladaMesh::FaceType::TexCoordType & WT, const QStringList faceIndexList, int ind_txt, const QStringList wt, const QDomNode wtsrc,const int faceind,const int stride = 2)$/;"	f	class:vcg::tri::io::ImporterDAE
Weight	vcglib/vcg/complex/algorithms/hole.h	/^            Weight( float An, float Ar ) { ang=An ; ar= Ar;}$/;"	f	class:vcg::tri::Hole::Weight
Weight	vcglib/vcg/complex/algorithms/hole.h	/^            Weight() { ang = 180; ar = FLT_MAX ;}$/;"	f	class:vcg::tri::Hole::Weight
Weight	vcglib/vcg/complex/algorithms/hole.h	/^        class Weight$/;"	c	class:vcg::tri::Hole
Weight	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef WEIGHT_TYPE Weight;$/;"	t	struct:vcg::tri::EvenPointLoopGeneric
Weight	vcglib/vcg/complex/algorithms/refine_loop.h	/^	typedef WEIGHT_TYPE Weight;$/;"	t	struct:vcg::tri::OddPointLoopGeneric
Weight	vcglib/vcg/complex/algorithms/symmetry.h	/^    std::vector<std::vector< ScalarType > > Weight;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
WeightInfo	vcglib/vcg/complex/algorithms/harmonic.h	/^	enum WeightInfo$/;"	g	class:vcg::tri::Harmonic
WeightedArea	vcglib/vcg/complex/algorithms/point_sampling.h	/^static ScalarType WeightedArea(FaceType f)$/;"	f	class:vcg::tri::SurfaceSampling
WeightedCrossCovariance	vcglib/vcg/math/matrix33.h	/^void WeightedCrossCovariance(const STLREALCONTAINER &  weights,$/;"	f	class:vcg::Matrix33
WeightedCrossCovariance	vcglib/vcg/math/old_matrix33.h	/^	void WeightedCrossCovariance(const STLREALCONTAINER &  weights,$/;"	f	class:vcg::Matrix33
WeightedFitPlaneToPointSet	vcglib/vcg/space/fitting3.h	/^void WeightedFitPlaneToPointSet(const std::vector< Point3<S> > & pointVec, const std::vector<S> &weightVec, Plane3<S> & plane)$/;"	f	namespace:vcg
WeightedMontecarlo	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void WeightedMontecarlo(MetroMesh & m, VertexSampler &ps, int sampleNum)$/;"	f	class:vcg::tri::SurfaceSampling
WeightedPoissonDiskPruning	vcglib/vcg/complex/algorithms/point_sampling.h	/^static void WeightedPoissonDiskPruning(VertexSampler &ps, MetroMesh &montecarloMesh,$/;"	f	class:vcg::tri::SurfaceSampling
WeightedPoissonSampling	poissonDisk.cpp	/^void WeightedPoissonSampling(MeshType &m, \/\/ the mesh that has to be sampled$/;"	f
WhatSon	vcglib/vcg/space/index/octree_template.h	/^	int WhatSon(NodePointer n) const$/;"	f	class:vcg::OctreeTemplate
White	vcglib/vcg/space/color4.h	/^	  White   = 0xffffffff,$/;"	e	enum:vcg::Color4::ColorConstant
Width	vcglib/wrap/gl/fbo.h	/^	GLsizei Width(void) const$/;"	f	class:BufferRenderTarget
Width	vcglib/wrap/gl/fbo.h	/^	GLsizei Width(void) const$/;"	f	class:Texture1D
Width	vcglib/wrap/gl/fbo.h	/^	GLsizei Width(void) const$/;"	f	class:Texture2D
Width	vcglib/wrap/gl/fbo.h	/^	GLsizei Width(void) const$/;"	f	class:Texture3D
Width	vcglib/wrap/gl/fbo.h	/^	GLsizei Width(void) const$/;"	f	class:TextureRenderTarget
Window	vcglib/apps/sample/trimesh_pos_demo/window.cpp	/^Window::Window()$/;"	f	class:Window
Window	vcglib/apps/sample/trimesh_pos_demo/window.h	/^class Window : public QWidget$/;"	c
WindowCoordToNormDevCoord	vcglib/wrap/gui/view.h	/^template <class T> Point3<T> View<T>::WindowCoordToNormDevCoord(const Point3<T> &p) const {$/;"	f	class:vcg::View
WindowRes	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^int WindowRes=800;$/;"	v
WithFormat	vcglib/eigenlib/Eigen/src/Core/IO.h	/^    WithFormat(const ExpressionType& matrix, const IOFormat& format)$/;"	f	class:Eigen::WithFormat
WithFormat	vcglib/eigenlib/Eigen/src/Core/IO.h	/^class WithFormat$/;"	c	namespace:Eigen
WorkMatrixType	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^            WorkMatrixType;$/;"	t	class:Eigen::JacobiSVD
WorkSpaceFactor	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = Vectorizable ? 2*nr*RealPacketSize : nr,$/;"	e	enum:Eigen::internal::gebp_traits::__anon200
WorkSpaceFactor	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr * RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
WorkSpaceFactor	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
WorkSpaceFactor	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
WorkVectorType	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^                 MatrixType::MaxRowsAtCompileTime> WorkVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
WorkspaceType	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  typedef Matrix<Scalar, 1, RowsAtCompileTime, RowMajor, 1, MaxRowsAtCompileTime> WorkspaceType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
Wrap	vcglib/vcg/math/spherical_harmonics.h	/^	static SphericalHarmonics Wrap(ScalarType * _coefficients)$/;"	f	class:vcg::math::SphericalHarmonics
WriteAccessors	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  WriteAccessors, $/;"	e	enum:Eigen::AccessorLevels
WriteFacesElement	vcglib/wrap/io_trimesh/export_obj.h	/^  inline static void WriteFacesElement(FILE *fp,int v,int vt, int vn)$/;"	f	class:vcg::tri::io::ExporterOBJ
WriteFloat	vcglib/wrap/io_trimesh/export_vmi.h	/^        static void WriteFloat( const float v)	{ WriteOut(&v,1,sizeof(float) );}$/;"	f	class:vcg::tri::io::ExporterVMI
WriteInt	vcglib/wrap/io_trimesh/export_vmi.h	/^        static void WriteInt (const unsigned int i)	{ WriteOut(&i,1,4 );}$/;"	f	class:vcg::tri::io::ExporterVMI
WriteMaterials	vcglib/wrap/io_trimesh/export_obj.h	/^  inline static int WriteMaterials(std::vector<Material> &materialVec, const char * filename, CallBackPos *cb=0)$/;"	f	class:vcg::tri::io::ExporterOBJ
WriteOut	vcglib/wrap/io_trimesh/export_vmi.h	/^        static int WriteOut(const void * src,  size_t size, size_t count){$/;"	f	class:vcg::tri::io::ExporterVMI
WritePolyVec	vcglib/vcg/space/outline2_packer.h	/^static bool WritePolyVec(const std::vector< std::vector<Point2x> > &polyVec, const char *filename)$/;"	f	class:vcg::PolyPacker
WritePos	vcglib/wrap/io_tetramesh/export_ts.h	/^	inline static void WritePos(const Point3<ScalarType> &p){$/;"	f	struct:vcg::tetra::io::ExporterTS
WritePos	vcglib/wrap/io_tetramesh/export_ts.h	/^	inline static void WritePos(const Point4<ScalarType> &p){$/;"	f	struct:vcg::tetra::io::ExporterTS
WriteShotToQDomNode	vcglib/wrap/qt/shot_qt.h	/^    QDomElement WriteShotToQDomNode($/;"	f
WriteString	vcglib/wrap/io_trimesh/export_vmi.h	/^        static void WriteString( const char * in)		{ unsigned int l = strlen(in); WriteOut(&l,4,1 ); WriteOut(in,1,l );}$/;"	f	class:vcg::tri::io::ExporterVMI
WriteVisibility	vcglib/apps/unsupported/shadevis/visshader.h	/^	 virtual bool WriteVisibility(const char * \/*filename*\/){assert( 0); return false;}$/;"	f	class:vcg::VisShader
WriteXmlBody	vcglib/wrap/io_edgemesh/export_svg.h	/^static void WriteXmlBody(FILE* fpo, EdgeMeshType &mp, SVGProperties &pro, int meshIndex)$/;"	f	class:vcg::tri::io::ExporterSVG
WriteXmlHead	vcglib/wrap/io_edgemesh/export_svg.h	/^static void WriteXmlHead(FILE *o, SVGProperties & pro)$/;"	f	class:vcg::tri::io::ExporterSVG
X	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            enum Dimension		 {X, Y, Z};$/;"	e	enum:vcg::tri::MarchingCubes::Dimension
X	vcglib/vcg/complex/algorithms/inertia.h	/^	enum {X=0,Y=1,Z=2};$/;"	e	enum:vcg::tri::Inertia::__anon482
X	vcglib/vcg/math/eigen_matrix_addons.h	/^inline Scalar &X() { return data()[0]; }$/;"	f
X	vcglib/vcg/math/eigen_matrix_addons.h	/^inline const Scalar &X() const { return data()[0]; }$/;"	f
X	vcglib/vcg/space/deprecated_point.h	/^    inline S &X() { return _v[0]; }$/;"	f	class:vcg::ndim::Point
X	vcglib/vcg/space/deprecated_point.h	/^  inline const S &X() const { return _v[0]; }$/;"	f	class:vcg::ndim::Point
X	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType &X() {return _v[0];}$/;"	f	class:vcg::Point2
X	vcglib/vcg/space/deprecated_point2.h	/^	inline const ScalarType &X() const {return _v[0];}$/;"	f	class:vcg::Point2
X	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType &X() { return _v[0]; }$/;"	f	class:vcg::Point3
X	vcglib/vcg/space/deprecated_point3.h	/^  inline const P3ScalarType &X() const { return _v[0]; }$/;"	f	class:vcg::Point3
X	vcglib/vcg/space/deprecated_point4.h	/^    inline T &X() {return _v[0];}$/;"	f	class:vcg::Point4
X	vcglib/wrap/math/system_interface_ldl.h	/^double &X(int i)$/;"	f	class:SystemLDL
X	vcglib/wrap/miq/core/poisson_solver.h	/^    std::vector< double > X;$/;"	m	class:PoissonSolver
X	vcglib/wrap/opensg/vertex_component.h	/^	ScalarType X()$/;"	f	class:vcg::vert::OSGCoordCore
X	vcglib/wrap/opensg/vertex_component.h	/^	ScalarType X()$/;"	f	class:vcg::vert::OSGNormalCore
XAxis	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^typedef enum { XAxis=0,YAxis=1,ZAxis=2} VolumeAxis;$/;"	e	enum:vcg::SimpleVolume::__anon2
XAxis	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    typedef enum { XAxis=0,YAxis=1,ZAxis=2} VolumeAxis;$/;"	e	enum:vcg::SimpleVolume::__anon481
XAxis	vcglib/wrap/gl/addons.h	/^		static void XAxis(vcg::Point3f zero, vcg::Point3f uno, Matrix44f & tr)$/;"	f	class:vcg::Add_Ons
XFILE	vcglib/wrap/ply/plylib.cpp	/^#define XFILE /;"	d	file:
XMLDocument	vcglib/wrap/dae/xmldocumentmanaging.h	/^	XMLDocument(XMLInteriorNode* root)$/;"	f	class:XMLDocument
XMLDocument	vcglib/wrap/dae/xmldocumentmanaging.h	/^class XMLDocument$/;"	c
XMLDocumentWriter	vcglib/wrap/dae/xmldocumentmanaging.h	/^	XMLDocumentWriter(const char* filename,const bool autoformatting = true)$/;"	f	class:XMLDocumentWriter
XMLDocumentWriter	vcglib/wrap/dae/xmldocumentmanaging.h	/^class XMLDocumentWriter : public XMLVisitor$/;"	c
XMLInteriorNode	vcglib/wrap/dae/xmldocumentmanaging.cpp	/^XMLInteriorNode::XMLInteriorNode(XMLTag* tag)$/;"	f	class:XMLInteriorNode
XMLInteriorNode	vcglib/wrap/dae/xmldocumentmanaging.h	/^class XMLInteriorNode : public XMLNode$/;"	c
XMLLeafNode	vcglib/wrap/dae/xmldocumentmanaging.cpp	/^XMLLeafNode::XMLLeafNode(XMLLeafTag* leaftag)$/;"	f	class:XMLLeafNode
XMLLeafNode	vcglib/wrap/dae/xmldocumentmanaging.h	/^class XMLLeafNode : public XMLNode$/;"	c
XMLLeafTag	vcglib/wrap/dae/xmldocumentmanaging.h	/^		XMLLeafTag(const QString& tagname = QString(),const QVector<QString>& text = QVector<QString>())$/;"	f	class:XMLLeafTag
XMLLeafTag	vcglib/wrap/dae/xmldocumentmanaging.h	/^class XMLLeafTag : public XMLTag$/;"	c
XMLNode	vcglib/wrap/dae/xmldocumentmanaging.cpp	/^XMLNode::XMLNode(XMLTag* tag)$/;"	f	class:XMLNode
XMLNode	vcglib/wrap/dae/xmldocumentmanaging.h	/^class XMLNode$/;"	c
XMLTag	vcglib/wrap/dae/xmldocumentmanaging.h	/^	XMLTag(const QString& tagname = QString(),const TagAttributes& attr = TagAttributes())$/;"	f	class:XMLTag
XMLTag	vcglib/wrap/dae/xmldocumentmanaging.h	/^class XMLTag$/;"	c
XMLTree	vcglib/apps/trimeshinfo/XMLTree.h	/^	XMLTree(void){verbose = false;}$/;"	f	class:XMLTree
XMLTree	vcglib/apps/trimeshinfo/XMLTree.h	/^class XMLTree$/;"	c
XMLVisitor	vcglib/wrap/dae/xmldocumentmanaging.h	/^class XMLVisitor$/;"	c
XML_SCHEMA_NAME	vcglib/apps/trimeshinfo/XMLTree.h	/^static char* XML_SCHEMA_NAME = "protegekb";$/;"	v
XYZ2RGB	vcglib/vcg/space/colorspace.h	/^	static double XYZ2RGB(int index)$/;"	f	class:vcg::ColorSpace
XYZ_SCALING	vcglib/vcg/space/colorspace.h	/^	enum ConeResponse	{	BRADFORD = 0,	VON_KRIES = 1, XYZ_SCALING = 2};$/;"	e	enum:vcg::ColorSpace::ConeResponse
XYZtoCIELab	vcglib/vcg/space/colorspace.h	/^	static Color4<T> XYZtoCIELab(const Color4<T> & color, Illuminant ref)$/;"	f	class:vcg::ColorSpace
XYZtoCIELab	vcglib/vcg/space/colorspace.h	/^	static void XYZtoCIELab(double X, double Y, double Z, double &L, double &a, double &b,$/;"	f	class:vcg::ColorSpace
XYZtoRGB	vcglib/vcg/space/colorspace.h	/^	static Color4<T> XYZtoRGB(const Color4<T> & color, Illuminant src, $/;"	f	class:vcg::ColorSpace
XYZtoRGB	vcglib/vcg/space/colorspace.h	/^	static void XYZtoRGB(double X, double Y, double Z, Illuminant src, $/;"	f	class:vcg::ColorSpace
XYZtoxyY	vcglib/vcg/space/colorspace.h	/^	static Color4<T> XYZtoxyY(const Color4<T> & color)$/;"	f	class:vcg::ColorSpace
XYZtoxyY	vcglib/vcg/space/colorspace.h	/^	static void XYZtoxyY(double X, double _Y, double Z, double &x, double &y, double &Y)$/;"	f	class:vcg::ColorSpace
XprBase	vcglib/eigenlib/Eigen/src/Core/Array.h	/^  typedef ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > XprBase;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/Array.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename traits<Ancestor>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/Product.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprType	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  typedef SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<NestedXpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprTypeIsRowMajor	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0,$/;"	e	enum:Eigen::internal::traits::__anon50
XprTypeNested	vcglib/eigenlib/Eigen/src/Core/Block.h	/^  typedef typename nested<XprType>::type XprTypeNested;$/;"	t	struct:Eigen::internal::traits
XprTypeNested	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename XprType::Nested XprTypeNested;$/;"	t	struct:Eigen::internal::traits
XtolTooSmall	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        XtolTooSmall = 7,$/;"	e	enum:Eigen::LevenbergMarquardtSpace::Status
Y	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            enum Dimension		 {X, Y, Z};$/;"	e	enum:vcg::tri::MarchingCubes::Dimension
Y	vcglib/vcg/complex/algorithms/inertia.h	/^	enum {X=0,Y=1,Z=2};$/;"	e	enum:vcg::tri::Inertia::__anon482
Y	vcglib/vcg/math/eigen_matrix_addons.h	/^inline Scalar &Y() { return data()[1]; }$/;"	f
Y	vcglib/vcg/math/eigen_matrix_addons.h	/^inline const Scalar &Y() const { return data()[1]; }$/;"	f
Y	vcglib/vcg/space/deprecated_point.h	/^    inline S &Y() { return _v[1]; }$/;"	f	class:vcg::ndim::Point
Y	vcglib/vcg/space/deprecated_point.h	/^    inline const S &Y() const { return _v[1]; }$/;"	f	class:vcg::ndim::Point
Y	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType &Y() {return _v[1];}$/;"	f	class:vcg::Point2
Y	vcglib/vcg/space/deprecated_point2.h	/^	inline const ScalarType &Y() const {return _v[1];}$/;"	f	class:vcg::Point2
Y	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType &Y() { return _v[1]; }$/;"	f	class:vcg::Point3
Y	vcglib/vcg/space/deprecated_point3.h	/^    inline const P3ScalarType &Y() const { return _v[1]; }$/;"	f	class:vcg::Point3
Y	vcglib/vcg/space/deprecated_point4.h	/^    inline T &Y() {return _v[1];}$/;"	f	class:vcg::Point4
Y	vcglib/wrap/math/system_interface_ldl.h	/^	std::vector<double> Lx,D,Y ;$/;"	m	class:SystemLDL
Y	vcglib/wrap/opensg/vertex_component.h	/^	ScalarType Y()$/;"	f	class:vcg::vert::OSGCoordCore
Y	vcglib/wrap/opensg/vertex_component.h	/^	ScalarType Y()$/;"	f	class:vcg::vert::OSGNormalCore
YAxis	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^typedef enum { XAxis=0,YAxis=1,ZAxis=2} VolumeAxis;$/;"	e	enum:vcg::SimpleVolume::__anon2
YAxis	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    typedef enum { XAxis=0,YAxis=1,ZAxis=2} VolumeAxis;$/;"	e	enum:vcg::SimpleVolume::__anon481
YOU_ALREADY_SPECIFIED_THIS_STRIDE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_ALREADY_SPECIFIED_THIS_STRIDE,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_CANNOT_MIX_ARRAYS_AND_MATRICES	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_CANNOT_MIX_ARRAYS_AND_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_MADE_A_PROGRAMMING_MISTAKE	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^        YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon319
Yellow	vcglib/vcg/space/color4.h	/^	  Yellow  = 0xff00ffff,$/;"	e	enum:vcg::Color4::ColorConstant
Z	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            enum Dimension		 {X, Y, Z};$/;"	e	enum:vcg::tri::MarchingCubes::Dimension
Z	vcglib/vcg/complex/algorithms/inertia.h	/^	enum {X=0,Y=1,Z=2};$/;"	e	enum:vcg::tri::Inertia::__anon482
Z	vcglib/vcg/math/eigen_matrix_addons.h	/^inline Scalar &Z() { assert(SizeAtCompileTime>2); return data()[2]; }$/;"	f
Z	vcglib/vcg/math/eigen_matrix_addons.h	/^inline const Scalar &Z() const { assert(SizeAtCompileTime>2); return data()[2]; }$/;"	f
Z	vcglib/vcg/space/deprecated_point.h	/^    inline S &Z() { static_assert(N>2); return _v[2]; }$/;"	f	class:vcg::ndim::Point
Z	vcglib/vcg/space/deprecated_point.h	/^    inline const S &Z() const { static_assert(N>2); return _v[2]; }$/;"	f	class:vcg::ndim::Point
Z	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType &Z() { return _v[2]; }$/;"	f	class:vcg::Point3
Z	vcglib/vcg/space/deprecated_point3.h	/^    inline const P3ScalarType &Z() const { return _v[2]; }$/;"	f	class:vcg::Point3
Z	vcglib/vcg/space/deprecated_point4.h	/^    inline T &Z() {return _v[2];}$/;"	f	class:vcg::Point4
Z	vcglib/wrap/opensg/vertex_component.h	/^	ScalarType Z()$/;"	f	class:vcg::vert::OSGCoordCore
Z	vcglib/wrap/opensg/vertex_component.h	/^	ScalarType Z()$/;"	f	class:vcg::vert::OSGNormalCore
ZAxis	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^typedef enum { XAxis=0,YAxis=1,ZAxis=2} VolumeAxis;$/;"	e	enum:vcg::SimpleVolume::__anon2
ZAxis	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    typedef enum { XAxis=0,YAxis=1,ZAxis=2} VolumeAxis;$/;"	e	enum:vcg::SimpleVolume::__anon481
ZMode	vcglib/wrap/gui/trackmode.h	/^class ZMode:public TrackMode {$/;"	c	namespace:vcg
ZOrder	vcglib/vcg/space/index/octree_template.h	/^	ZOrderType ZOrder(NodePointer n)											const	{ return ZOrder(GetPath(n), Level(n)); }$/;"	f	class:vcg::OctreeTemplate
ZOrder	vcglib/vcg/space/index/octree_template.h	/^	inline ZOrderType ZOrder(const CenterType &path, const char level) const$/;"	f	class:vcg::OctreeTemplate
ZOrderType	vcglib/vcg/space/index/octree.h	/^        typedef typename TemplatedOctree::ZOrderType 					ZOrderType;$/;"	t	class:vcg::Octree
ZOrderType	vcglib/vcg/space/index/octree_template.h	/^	typedef unsigned long long				ZOrderType;$/;"	t	class:vcg::OctreeTemplate
ZTWIST	vcglib/apps/unsupported/shadevis/visshader.h	/^	 float ZTWIST;$/;"	m	class:vcg::VisShader
Zero	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero()$/;"	f	class:Eigen::DenseBase
Zero	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
Zero	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index size)$/;"	f	class:Eigen::DenseBase
Zero	vcglib/vcg/math/quadric5.h	/^	void Zero()																\/\/ Azzera le quadriche$/;"	f	class:vcg::Quadric5
Zero	vcglib/vcg/space/box.h	/^	inline void Zero()$/;"	f	class:vcg::Box
Zero	vcglib/vcg/space/deprecated_point.h	/^	inline void Zero(){$/;"	f	class:vcg::ndim::Point2
Zero	vcglib/vcg/space/deprecated_point.h	/^	inline void Zero(){$/;"	f	class:vcg::ndim::Point3
Zero	vcglib/vcg/space/deprecated_point.h	/^	inline void Zero(){$/;"	f	class:vcg::ndim::Point4
Zero	vcglib/wrap/math/sparse_matrix.h	/^virtual void Zero()$/;"	f	class:SparseMatrix
Zero	vcglib/wrap/math/system_interface_ldl.h	/^void Zero()$/;"	f	class:SystemLDL
ZeroDiag	vcglib/eigenlib/Eigen/src/Core/util/Constants.h	/^  ZeroDiag=0x8,$/;"	e	enum:Eigen::__anon258
Zonohedron	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    Zonohedron(){}$/;"	f	class:vcg::tri::Zonohedron
Zonohedron	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^class Zonohedron{$/;"	c	namespace:vcg::tri
Zp	vcglib/vcg/simplex/vertex/component_occ.h	/^  int &Zp() {return _zp; }$/;"	f	class:vcg::vertex::VFAdjOcc
_	vcglib/wrap/system/getopt.cpp	/^# define _(/;"	d	file:
_APS_NEXT_COMMAND_VALUE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/resource.h	/^#define _APS_NEXT_COMMAND_VALUE /;"	d
_APS_NEXT_CONTROL_VALUE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/resource.h	/^#define _APS_NEXT_CONTROL_VALUE /;"	d
_APS_NEXT_RESOURCE_VALUE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/resource.h	/^#define _APS_NEXT_RESOURCE_VALUE /;"	d
_APS_NEXT_SYMED_VALUE	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/resource.h	/^#define _APS_NEXT_SYMED_VALUE /;"	d
_ATOMIC_INT_APPLE_H	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^#define _ATOMIC_INT_APPLE_H$/;"	d
_ATOMIC_INT_GENERIC_H	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^#define _ATOMIC_INT_GENERIC_H$/;"	d
_ATOMIC_INT_H	vcglib/wrap/system/multithreading/atomic_int.h	/^#define _ATOMIC_INT_H$/;"	d
_AUTOALIGN_4PCS_H_	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^#define _AUTOALIGN_4PCS_H_$/;"	d
_ActualLhsType	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualLhsType>::type _ActualLhsType;$/;"	t	class:Eigen::ProductBase
_ActualRhsType	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualRhsType>::type _ActualRhsType;$/;"	t	class:Eigen::ProductBase
_Ai	vcglib/wrap/math/sparse_matrix.h	/^	std::vector<int> _Ai;$/;"	m	class:SparseMatrix
_Ap	vcglib/wrap/math/sparse_matrix.h	/^	std::vector<int> _Ap;$/;"	m	class:SparseMatrix
_AspectRatioMedia	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^ScalarType _AspectRatioMedia(PosType p)$/;"	f	class:vcg::tetra::TetraEdgeCollapse
_Ax	vcglib/wrap/math/sparse_matrix.h	/^	std::vector<double> _Ax;$/;"	m	class:SparseMatrix
_B	vcglib/wrap/math/system_interface_ldl.h	/^	std::vector<double> _B;$/;"	m	class:SystemLDL
_BITQUAD_OPTIMIZATION	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^#define _BITQUAD_OPTIMIZATION$/;"	d
_Base	vcglib/vcg/math/old_matrix.h	/^	typedef Eigen::Matrix<_Scalar,Eigen::Dynamic,Eigen::Dynamic,Eigen::RowMajor> _Base;$/;"	t	class:vcg::ndim::Matrix
_Base	vcglib/vcg/math/old_matrix33.h	/^	typedef Eigen::Matrix<_Scalar,3,3,Eigen::RowMajor> _Base;$/;"	t	class:vcg::Matrix33
_Base	vcglib/vcg/math/old_matrix44.h	/^	typedef Eigen::Matrix<_Scalar,4,4,Eigen::RowMajor> _Base;$/;"	t	class:vcg::Matrix44
_Base	vcglib/vcg/space/point.h	/^	typedef Eigen::Matrix<S,N,1> _Base;$/;"	t	class:vcg::ndim::Point
_Base	vcglib/vcg/space/point2.h	/^	typedef Eigen::Matrix<_Scalar,2,1> _Base;$/;"	t	class:vcg::Point2
_Base	vcglib/vcg/space/point3.h	/^	typedef Eigen::Matrix<_Scalar,3,1> _Base;$/;"	t	class:vcg::Point3
_Base	vcglib/vcg/space/point4.h	/^	typedef Eigen::Matrix<T,4,1> _Base;$/;"	t	class:vcg::Point4
_CHRONOMETER_H_	vcglib/wrap/system/time/clock.h	/^#define _CHRONOMETER_H_$/;"	d
_COLLADA_FORMAT_H	vcglib/wrap/dae/colladaformat.h	/^#define _COLLADA_FORMAT_H$/;"	d
_ChooseColorTetra	vcglib/wrap/gl/tetramesh.h	/^void _ChooseColorTetra(TetraType &t)$/;"	f	class:vcg::tetra::GlTetramesh
_ChooseColorVertex	vcglib/wrap/gl/tetramesh.h	/^void _ChooseColorVertex(VertexType &v)$/;"	f	class:vcg::tetra::GlTetramesh
_Chords	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    std::vector<PC_Chord>   _Chords;$/;"	m	class:vcg::tri::PolychordCollapse::PC_Chords
_CollapseDiagHalf	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static void _CollapseDiagHalf(FaceType &f, int faux, MeshType& \/*m*\/)$/;"	f	class:vcg::tri::BitQuad
_ColorEnabled	vcglib/vcg/simplex/face/component_ocf.h	/^  bool _ColorEnabled;$/;"	m	class:vcg::face::vector_ocf
_ControlLimits	vcglib/vcg/space/index/space_iterators.h	/^		void _ControlLimits()$/;"	f	class:vcg::RayIterator
_DEFS_H	vcglib/apps/trimeshinfo/defs.h	/^#define _DEFS_H$/;"	d
_DEFS_H	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/defs.h	/^#define _DEFS_H$/;"	d
_DrawFace	vcglib/wrap/gl/tetramesh.h	/^void _DrawFace(TetraType &t,int face)$/;"	f	class:vcg::tetra::GlTetramesh
_DrawFaceSmooth	vcglib/wrap/gl/tetramesh.h	/^void _DrawFaceSmooth(TetraType &t,int face)$/;"	f	class:vcg::tetra::GlTetramesh
_DrawFlatWire	vcglib/wrap/gl/tetramesh.h	/^void 	_DrawFlatWire(){$/;"	f	class:vcg::tetra::GlTetramesh
_DrawSelectedTetra	vcglib/wrap/gl/tetramesh.h	/^void _DrawSelectedTetra(TetraType &t)$/;"	f	class:vcg::tetra::GlTetramesh
_DrawSmallTetra	vcglib/wrap/gl/tetramesh.h	/^ void _DrawSmallTetra(){$/;"	f	class:vcg::tetra::GlTetramesh
_DrawSmallTetra	vcglib/wrap/gl/tetramesh.h	/^void _DrawSmallTetra(TetraType &t)$/;"	f	class:vcg::tetra::GlTetramesh
_DrawSurface	vcglib/wrap/gl/tetramesh.h	/^void _DrawSurface(){$/;"	f	class:vcg::tetra::GlTetramesh
_DrawTetra	vcglib/wrap/gl/tetramesh.h	/^void _DrawTetra(TetraType &t)$/;"	f	class:vcg::tetra::GlTetramesh
_EC	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^vcg::tetra::EdgeCollapse<TETRA_MESH_TYPE> _EC;$/;"	m	class:vcg::tetra::TetraEdgeCollapse
_EIGEN_ACCUMULATE_PACKETS	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  #define _EIGEN_ACCUMULATE_PACKETS(/;"	d
_EIGEN_ACCUMULATE_PACKETS	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^  #undef _EIGEN_ACCUMULATE_PACKETS$/;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4f	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_FAST_Packet4f(/;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4i	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_FAST_Packet4i(/;"	d
_EIGEN_DECLARE_CONST_Packet4f	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f(/;"	d
_EIGEN_DECLARE_CONST_Packet4f	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f(/;"	d
_EIGEN_DECLARE_CONST_Packet4f	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f(/;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(/;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(/;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(/;"	d
_EIGEN_DECLARE_CONST_Packet4i	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4i(/;"	d
_EIGEN_DECLARE_CONST_Packet4i	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4i(/;"	d
_EIGEN_DECLARE_CONST_Packet4i	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4i(/;"	d
_EIGEN_SKYLINE_GENERIC_PUBLIC_INTERFACE	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^#define _EIGEN_SKYLINE_GENERIC_PUBLIC_INTERFACE(/;"	d
_EIGEN_SPARSE_PUBLIC_INTERFACE	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^#define _EIGEN_SPARSE_PUBLIC_INTERFACE(/;"	d
_Edge	vcglib/vcg/complex/used_types.h	/^struct _Edge  : public  Edge<_UsedTypes>{};$/;"	s	namespace:vcg
_EndGrid	vcglib/vcg/space/index/space_iterators.h	/^		bool  _EndGrid()$/;"	f	class:vcg::ClosestIterator
_ExtractType	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType> _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
_ExtractType	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  typedef XprType _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
_FACEDESC_FIRST_	vcglib/wrap/io_trimesh/import_ply.h	/^#define _FACEDESC_FIRST_ /;"	d
_FACEDESC_LAST_	vcglib/wrap/io_trimesh/import_ply.h	/^#define _FACEDESC_LAST_ /;"	d
_Face	vcglib/vcg/complex/used_types.h	/^struct _Face  : public  Face<_UsedTypes>{};$/;"	s	namespace:vcg
_FindLinePar	vcglib/vcg/space/index/space_iterators.h	/^		void _FindLinePar()$/;"	f	class:vcg::RayIterator
_Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^          _Flags = traits<T>::Flags$/;"	e	enum:Eigen::internal::plain_matrix_type::__anon429
_Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Flags = traits<T>::Flags & (~RowMajorBit) };$/;"	e	enum:Eigen::internal::sparse_eval::__anon427
_Flags	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Flags = traits<T>::Flags| RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_eval::__anon426
_Flags	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^          _Flags = traits<T>::Flags$/;"	e	enum:Eigen::internal::eval::__anon454
_GETOPT_H	vcglib/wrap/system/getopt.h	/^#define _GETOPT_H /;"	d
_GLW_FORWARD_MATRIX_UNIFORM_	vcglib/wrap/glw/program.h	/^#define _GLW_FORWARD_MATRIX_UNIFORM_(/;"	d
_GLW_FORWARD_MATRIX_UNIFORM_	vcglib/wrap/glw/program.h	/^#undef _GLW_FORWARD_MATRIX_UNIFORM_$/;"	d
_GLW_FORWARD_SCALAR_UNIFORM_	vcglib/wrap/glw/program.h	/^#define _GLW_FORWARD_SCALAR_UNIFORM_(/;"	d
_GLW_FORWARD_SCALAR_UNIFORM_	vcglib/wrap/glw/program.h	/^#undef _GLW_FORWARD_SCALAR_UNIFORM_$/;"	d
_GLW_FORWARD_VECTOR_UNIFORM_	vcglib/wrap/glw/program.h	/^#define _GLW_FORWARD_VECTOR_UNIFORM_(/;"	d
_GLW_FORWARD_VECTOR_UNIFORM_	vcglib/wrap/glw/program.h	/^#undef _GLW_FORWARD_VECTOR_UNIFORM_$/;"	d
_GLW_IMPLEMENT_MATRIX_UNIFORM_	vcglib/wrap/glw/program.h	/^#define _GLW_IMPLEMENT_MATRIX_UNIFORM_(/;"	d
_GLW_IMPLEMENT_MATRIX_UNIFORM_	vcglib/wrap/glw/program.h	/^#undef _GLW_IMPLEMENT_MATRIX_UNIFORM_$/;"	d
_GLW_IMPLEMENT_SCALAR_UNIFORM_	vcglib/wrap/glw/program.h	/^#define _GLW_IMPLEMENT_SCALAR_UNIFORM_(/;"	d
_GLW_IMPLEMENT_SCALAR_UNIFORM_	vcglib/wrap/glw/program.h	/^#undef _GLW_IMPLEMENT_SCALAR_UNIFORM_$/;"	d
_GLW_IMPLEMENT_VECTOR_UNIFORM_	vcglib/wrap/glw/program.h	/^#define _GLW_IMPLEMENT_VECTOR_UNIFORM_(/;"	d
_GLW_IMPLEMENT_VECTOR_UNIFORM_	vcglib/wrap/glw/program.h	/^#undef _GLW_IMPLEMENT_VECTOR_UNIFORM_$/;"	d
_HEdge	vcglib/vcg/complex/used_types.h	/^struct _HEdge : public  HEdge<_UsedTypes>{};$/;"	s	namespace:vcg
_HasDirectAccess	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      _HasDirectAccess = (int(Flags)&DirectAccessBit) ? 1 : 0 \/\/ workaround sunCC$/;"	e	enum:Eigen::SparseMatrixBase::__anon420
_Imark	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^static int& _Imark(){ static int im=0; return im;}$/;"	f	class:vcg::tetra::TetraEdgeCollapse
_Index	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Index _Index;$/;"	t	struct:Eigen::internal::sparse_eval
_Lhs	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::product_type
_Lhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::traits
_LhsNested	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
_LhsNested	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::ProductBase
_LhsNested	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::CoeffBasedProduct
_LhsNested	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_LhsNested _LhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
_LhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct
_LhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct
_LhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseSparseProduct
_LhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename traits<SkylineProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::internal::SkylineProduct
_LhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
_LhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_M	vcglib/wrap/math/system_interface_ldl.h	/^	mapType _M;$/;"	m	class:SystemLDL
_M_index1	vcglib/vcg/math/random_generator.h	/^	size_t _M_index1;$/;"	m	class:vcg::math::SubtractiveRingRNG
_M_index2	vcglib/vcg/math/random_generator.h	/^	size_t _M_index2;$/;"	m	class:vcg::math::SubtractiveRingRNG
_M_table	vcglib/vcg/math/random_generator.h	/^	unsigned int _M_table[55];$/;"	m	class:vcg::math::SubtractiveRingRNG
_MatrixType	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename internal::pastix_traits<Derived>::MatrixType _MatrixType;$/;"	t	class:Eigen::PastixBase
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::Replicate
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryViewImpl
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_XprTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryOpImpl
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename internal::remove_all<typename MatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::TransposeImpl
_MatrixTypeNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseView
_NO_PROTO	vcglib/wrap/system/getopt.cpp	/^#define _NO_PROTO$/;"	d	file:
_NewPoint	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^Point3<ScalarType> _NewPoint;$/;"	m	class:vcg::tetra::TetraEdgeCollapse
_NextCell	vcglib/vcg/space/index/space_iterators.h	/^		void _NextCell()$/;"	f	class:vcg::RayIterator
_NextShell	vcglib/vcg/space/index/space_iterators.h	/^		bool _NextShell()$/;"	f	class:vcg::ClosestIterator
_Options	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Options = ((traits<T>::Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::sparse_eval::__anon428
_PacketOnDiag	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    _PacketOnDiag = !((int(_StorageOrder) == RowMajor && int(ProductOrder) == OnTheLeft)$/;"	e	enum:Eigen::internal::traits::__anon68
_PriorityQueue_h_	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^#define _PriorityQueue_h_$/;"	d
_ResPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
_ResPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_Rhs	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::product_type
_Rhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::traits
_RhsNested	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
_RhsNested	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::ProductBase
_RhsNested	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::CoeffBasedProduct
_RhsNested	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_RhsNested _RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
_RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct
_RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct
_RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseSparseProduct
_RhsNested	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    typedef typename traits<SkylineProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::internal::SkylineProduct
_RhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
_RhsPacket	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_SC_PAGE_SIZE	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#      define _SC_PAGE_SIZE /;"	d	file:
_SameTypes	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon68
_Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::sparse_eval
_Scalar	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::plain_matrix_type
_Scalar	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^    typedef typename traits<T>::Scalar _Scalar;$/;"	t	class:Eigen::internal::eval
_StorageOrder	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    _StorageOrder = MatrixType::Flags & RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon68
_TSAI_METHODS_	vcglib/wrap/tsai/tsaimethods.h	/^#define _TSAI_METHODS_$/;"	d
_USE_GRID_UTIL_PARTIONING_	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^#define _USE_GRID_UTIL_PARTIONING_ /;"	d
_USE_OCTREE_PARTITIONING_	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^#define _USE_OCTREE_PARTITIONING_ /;"	d
_UpdateHMark	vcglib/vcg/space/index/spatial_hashing.h	/^		void _UpdateHMark(ObjType* s){ s->HMark() = this->tempMark;}$/;"	f	class:vcg::DynamicSpatialHashTable
_UpdateRadius	vcglib/vcg/space/index/space_iterators.h	/^		void _UpdateRadius()$/;"	f	class:vcg::ClosestIterator
_UsedTypes	vcglib/vcg/complex/used_types.h	/^struct _UsedTypes: public UsedTypes<$/;"	s	namespace:vcg
_VCG_EDGE_TOPOLOGY	vcglib/vcg/simplex/edge/topology.h	/^#define _VCG_EDGE_TOPOLOGY$/;"	d
_VCG_FACE_TOPOLOGY	vcglib/vcg/simplex/face/topology.h	/^#define _VCG_FACE_TOPOLOGY$/;"	d
_VCG_GL_GEOMETRY_	vcglib/wrap/gl/gl_geometry.h	/^#define _VCG_GL_GEOMETRY_$/;"	d
_VCG_INERTIA_	vcglib/vcg/complex/algorithms/inertia.h	/^#define _VCG_INERTIA_$/;"	d
_VCG_MATH_POINTMATCHING_H	vcglib/vcg/space/point_matching.h	/^#define _VCG_MATH_POINTMATCHING_H$/;"	d
_VERTDESC_LAST_	vcglib/wrap/io_trimesh/import_ply.h	/^#define _VERTDESC_LAST_ /;"	d
_Vectorizable	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    _Vectorizable = bool(int(MatrixType::Flags)&PacketAccessBit) && _SameTypes && ((!_PacketOnDiag) || (bool(int(DiagonalType::Flags)&PacketAccessBit))),$/;"	e	enum:Eigen::internal::traits::__anon68
_Vertex	vcglib/vcg/complex/used_types.h	/^struct _Vertex: public  Vertex<_UsedTypes>{};$/;"	s	namespace:vcg
_VolumePreservingError	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^ScalarType _VolumePreservingError(PosType &pos,CoordType &new_point,int nsteps)$/;"	f	class:vcg::tetra::TetraEdgeCollapse
_WRAP_EIGEN_XPR	vcglib/wrap/gl/deprecated_space.h	/^#define _WRAP_EIGEN_XPR(/;"	d
_WRAP_EIGEN_XPR	vcglib/wrap/gl/space.h	/^#define _WRAP_EIGEN_XPR(/;"	d
_X	vcglib/wrap/math/system_interface_ldl.h	/^	std::vector<double> _X;$/;"	m	class:SystemLDL
_XML_DOCUMENT_MANAGING_H	vcglib/wrap/dae/xmldocumentmanaging.h	/^#define _XML_DOCUMENT_MANAGING_H$/;"	d
_XprTypeNested	vcglib/eigenlib/Eigen/src/Core/Block.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits
_XprTypeNested	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits
__DEPRECATED	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^#define __DEPRECATED$/;"	d
__DEPRECATED	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^#undef __DEPRECATED /;"	d
__DEPRECATED	vcglib/vcg/space/index/spatial_hashing.h	/^  #undef __DEPRECATED /;"	d
__DEPRECATED	vcglib/vcg/space/index/spatial_hashing.h	/^#define __DEPRECATED$/;"	d
__EXTRS_IMPLICIT	vcglib/apps/unsupported/extractors/extractor/Implicit.h	/^#define __EXTRS_IMPLICIT$/;"	d
__FBO_H__	vcglib/wrap/gl/fbo.h	/^#define __FBO_H__$/;"	d
__GLWRAPTETRA__	vcglib/wrap/gl/tetramesh.h	/^#define __GLWRAPTETRA__$/;"	d
__GL_CAMERA	vcglib/wrap/gl/camera.h	/^#define __GL_CAMERA$/;"	d
__GL_OBJECT_H__	vcglib/wrap/gl/gl_object.h	/^#define __GL_OBJECT_H__$/;"	d
__MIQ__	vcglib/wrap/miq/MIQ.h	/^#define __MIQ__$/;"	d
__MPREAL_H__	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^#define __MPREAL_H__$/;"	d
__PICK______H	vcglib/wrap/gl/pick.h	/^#define __PICK______H$/;"	d
__RASTERIZED_OUTLINE2_PACKER_H__	vcglib/vcg/space/rasterized_outline2_packer.h	/^#define __RASTERIZED_OUTLINE2_PACKER_H__$/;"	d
__SHADERS_H__	vcglib/wrap/gl/shaders.h	/^#define __SHADERS_H__$/;"	d
__SPARSE_SYSTEM_DATA_H__	vcglib/wrap/miq/core/sparsesystemdata.h	/^#define __SPARSE_SYSTEM_DATA_H__$/;"	d
__SetVN	vcglib/vcg/simplex/face/component_polygon.h	/^  inline void __SetVN(const int & n) {$/;"	f	class:vcg::face::PolyInfo
__USE_GNU	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define __USE_GNU /;"	d	file:
__USE_GNU	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#undef __USE_GNU$/;"	d	file:
__VCGLIB_AABBBINARYTREEBASE_H	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^#define __VCGLIB_AABBBINARYTREEBASE_H$/;"	d
__VCGLIB_AABBBINARYTREEINDEX_H	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^#define __VCGLIB_AABBBINARYTREEINDEX_H$/;"	d
__VCGLIB_AABBBINARYTREE_CLOSEST_H	vcglib/vcg/space/index/aabb_binary_tree/closest.h	/^#define __VCGLIB_AABBBINARYTREE_CLOSEST_H$/;"	d
__VCGLIB_AABBBINARYTREE_FRUSTUMCULL_H	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^#define __VCGLIB_AABBBINARYTREE_FRUSTUMCULL_H$/;"	d
__VCGLIB_AABBBINARYTREE_KCLOSEST_H	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^#define __VCGLIB_AABBBINARYTREE_KCLOSEST_H$/;"	d
__VCGLIB_AABBBINARYTREE_RAY_H	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^#define __VCGLIB_AABBBINARYTREE_RAY_H$/;"	d
__VCGLIB_ADDITIONAL_INFO	vcglib/wrap/io_trimesh/additionalinfo.h	/^#define __VCGLIB_ADDITIONAL_INFO$/;"	d
__VCGLIB_APPEND	vcglib/vcg/complex/append.h	/^#define __VCGLIB_APPEND$/;"	d
__VCGLIB_BOX	vcglib/vcg/space/box.h	/^#define __VCGLIB_BOX$/;"	d
__VCGLIB_BOX2	vcglib/vcg/space/box2.h	/^#define __VCGLIB_BOX2$/;"	d
__VCGLIB_BOX3	vcglib/vcg/space/box3.h	/^#define __VCGLIB_BOX3$/;"	d
__VCGLIB_CALLBACK	vcglib/wrap/callback.h	/^#define __VCGLIB_CALLBACK$/;"	d
__VCGLIB_CAMERA	vcglib/vcg/math/camera.h	/^#define __VCGLIB_CAMERA$/;"	d
__VCGLIB_CAT__	vcglib/vcg/container/container_allocation_table.h	/^#define __VCGLIB_CAT__$/;"	d
__VCGLIB_CLEAN	vcglib/vcg/complex/algorithms/clean.h	/^#define __VCGLIB_CLEAN$/;"	d
__VCGLIB_CLUSTERING	vcglib/vcg/complex/algorithms/clustering.h	/^#define __VCGLIB_CLUSTERING$/;"	d
__VCGLIB_COLOR4	vcglib/vcg/space/color4.h	/^#define __VCGLIB_COLOR4$/;"	d
__VCGLIB_COLORSPACE	vcglib/vcg/space/colorspace.h	/^#define __VCGLIB_COLORSPACE$/;"	d
__VCGLIB_EDGE_DISTANCE	vcglib/vcg/simplex/edge/distance.h	/^#define __VCGLIB_EDGE_DISTANCE$/;"	d
__VCGLIB_ENTRIES__	vcglib/vcg/container/entries_allocation_table.h	/^#define __VCGLIB_ENTRIES__$/;"	d
__VCGLIB_EXPORTERFIELD	vcglib/wrap/io_trimesh/export_field.h	/^#define __VCGLIB_EXPORTERFIELD$/;"	d
__VCGLIB_EXPORTERIDTF	vcglib/wrap/io_trimesh/export_idtf.h	/^#define __VCGLIB_EXPORTERIDTF$/;"	d
__VCGLIB_EXPORTERSMF	vcglib/wrap/io_tetramesh/export_ts.h	/^#define __VCGLIB_EXPORTERSMF$/;"	d
__VCGLIB_EXPORTERU3D	vcglib/wrap/io_trimesh/export_u3d.h	/^#define __VCGLIB_EXPORTERU3D$/;"	d
__VCGLIB_EXPORT_3DS	vcglib/wrap/io_trimesh/export_3ds.h	/^#define __VCGLIB_EXPORT_3DS$/;"	d
__VCGLIB_EXPORT_DXF	vcglib/wrap/io_trimesh/export_dxf.h	/^#define __VCGLIB_EXPORT_DXF$/;"	d
__VCGLIB_EXPORT_GTS	vcglib/wrap/io_trimesh/export_gts.h	/^#define __VCGLIB_EXPORT_GTS$/;"	d
__VCGLIB_EXPORT_OBJ	vcglib/wrap/io_trimesh/export_obj.h	/^#define __VCGLIB_EXPORT_OBJ$/;"	d
__VCGLIB_EXPORT_OFF	vcglib/wrap/io_trimesh/export_off.h	/^#define __VCGLIB_EXPORT_OFF$/;"	d
__VCGLIB_EXPORT_PLY	vcglib/wrap/io_trimesh/export_ply.h	/^#define __VCGLIB_EXPORT_PLY$/;"	d
__VCGLIB_EXPORT_SMF	vcglib/wrap/io_trimesh/export_smf.h	/^#define __VCGLIB_EXPORT_SMF$/;"	d
__VCGLIB_EXPORT_STL	vcglib/wrap/io_trimesh/export_stl.h	/^#define __VCGLIB_EXPORT_STL$/;"	d
__VCGLIB_EXPORT_VMI	vcglib/wrap/io_trimesh/export_vmi.h	/^#define __VCGLIB_EXPORT_VMI$/;"	d
__VCGLIB_EXPORT_WRL	vcglib/wrap/io_trimesh/export_vrml.h	/^#define __VCGLIB_EXPORT_WRL$/;"	d
__VCGLIB_FACE_DISTANCE	vcglib/vcg/simplex/face/distance.h	/^#define __VCGLIB_FACE_DISTANCE$/;"	d
__VCGLIB_FACTORIAL_H	vcglib/vcg/math/factorial.h	/^#define __VCGLIB_FACTORIAL_H$/;"	d
__VCGLIB_FITTING3	vcglib/vcg/space/fitting3.h	/^#define __VCGLIB_FITTING3$/;"	d
__VCGLIB_GEODESIC	vcglib/vcg/complex/algorithms/geodesic.h	/^#define __VCGLIB_GEODESIC$/;"	d
__VCGLIB_GLSHOT	vcglib/wrap/gl/shot.h	/^#define __VCGLIB_GLSHOT$/;"	d
__VCGLIB_GLU_TESSELATOR_H	vcglib/wrap/gl/glu_tesselator.h	/^#define __VCGLIB_GLU_TESSELATOR_H$/;"	d
__VCGLIB_GRID_CLOSEST	vcglib/vcg/space/index/grid_closest.h	/^#define __VCGLIB_GRID_CLOSEST$/;"	d
__VCGLIB_GRID_CLOSEST	vcglib/vcg/space/index/index2D/grid_closest_2D.h	/^#define __VCGLIB_GRID_CLOSEST$/;"	d
__VCGLIB_GRID_UTIL	vcglib/vcg/space/index/grid_util.h	/^#define __VCGLIB_GRID_UTIL$/;"	d
__VCGLIB_GRID_UTIL_2D	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^#define __VCGLIB_GRID_UTIL_2D$/;"	d
__VCGLIB_HALFEDGE_	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^#define __VCGLIB_HALFEDGE_$/;"	d
__VCGLIB_HARMONIC_FIELD	vcglib/vcg/complex/algorithms/harmonic.h	/^#define __VCGLIB_HARMONIC_FIELD$/;"	d
__VCGLIB_IMPORT	vcglib/wrap/io_trimesh/import.h	/^#define __VCGLIB_IMPORT$/;"	d
__VCGLIB_IMPORTERBUNDLER	vcglib/wrap/io_trimesh/import_out.h	/^#define __VCGLIB_IMPORTERBUNDLER$/;"	d
__VCGLIB_IMPORTERDAE	vcglib/wrap/io_trimesh/import_dae.h	/^#define __VCGLIB_IMPORTERDAE$/;"	d
__VCGLIB_IMPORTERFIELD	vcglib/wrap/io_trimesh/import_field.h	/^#define __VCGLIB_IMPORTERFIELD$/;"	d
__VCGLIB_IMPORTERNVM	vcglib/wrap/io_trimesh/import_nvm.h	/^#define __VCGLIB_IMPORTERNVM$/;"	d
__VCGLIB_IMPORTERPLY	vcglib/wrap/io_trimesh/import_ply.h	/^#define __VCGLIB_IMPORTERPLY$/;"	d
__VCGLIB_IMPORTERTS	vcglib/wrap/io_tetramesh/import_ts.h	/^#define __VCGLIB_IMPORTERTS$/;"	d
__VCGLIB_IMPORTER_SMF	vcglib/wrap/io_trimesh/import_smf.h	/^#define __VCGLIB_IMPORTER_SMF$/;"	d
__VCGLIB_IMPORT_ASC	vcglib/wrap/io_trimesh/import_asc.h	/^#define __VCGLIB_IMPORT_ASC$/;"	d
__VCGLIB_IMPORT_CTM	vcglib/wrap/io_trimesh/import_ctm.h	/^#define __VCGLIB_IMPORT_CTM$/;"	d
__VCGLIB_IMPORT_GTS	vcglib/wrap/io_trimesh/import_gts.h	/^#define __VCGLIB_IMPORT_GTS$/;"	d
__VCGLIB_IMPORT_OBJ	vcglib/wrap/io_trimesh/import_obj.h	/^#define __VCGLIB_IMPORT_OBJ$/;"	d
__VCGLIB_IMPORT_OFF	vcglib/wrap/io_trimesh/import_off.h	/^#define __VCGLIB_IMPORT_OFF$/;"	d
__VCGLIB_IMPORT_PTX	vcglib/wrap/io_trimesh/import_ptx.h	/^#define __VCGLIB_IMPORT_PTX$/;"	d
__VCGLIB_IMPORT_RAW	vcglib/wrap/io_trimesh/import_raw.h	/^#define __VCGLIB_IMPORT_RAW$/;"	d
__VCGLIB_IMPORT_STL	vcglib/wrap/io_trimesh/import_stl.h	/^#define __VCGLIB_IMPORT_STL$/;"	d
__VCGLIB_IMPORT_VMI	vcglib/wrap/io_trimesh/import_vmi.h	/^#define __VCGLIB_IMPORT_VMI$/;"	d
__VCGLIB_INTERSECTIONTRITRI3	vcglib/vcg/space/intersection/triangle_triangle3.h	/^#define __VCGLIB_INTERSECTIONTRITRI3$/;"	d
__VCGLIB_INTERSECTION_2	vcglib/vcg/space/intersection2.h	/^#define __VCGLIB_INTERSECTION_2$/;"	d
__VCGLIB_INTERSECTION_3	vcglib/vcg/space/intersection3.h	/^#define __VCGLIB_INTERSECTION_3$/;"	d
__VCGLIB_INTERSECTION_TRI_MESH	vcglib/vcg/complex/algorithms/intersection.h	/^#define __VCGLIB_INTERSECTION_TRI_MESH$/;"	d
__VCGLIB_IOTRIMESH_IO_MASK	vcglib/wrap/io_trimesh/io_mask.h	/^#define __VCGLIB_IOTRIMESH_IO_MASK$/;"	d
__VCGLIB_IOTRIMESH_IO_PLY	vcglib/wrap/io_tetramesh/io_ply.h	/^#define __VCGLIB_IOTRIMESH_IO_PLY$/;"	d
__VCGLIB_IOTRIMESH_IO_PLY	vcglib/wrap/io_trimesh/io_ply.h	/^#define __VCGLIB_IOTRIMESH_IO_PLY$/;"	d
__VCGLIB_LEGENDRE_H	vcglib/vcg/math/legendre.h	/^#define __VCGLIB_LEGENDRE_H$/;"	d
__VCGLIB_LINALGEBRA_H	vcglib/vcg/math/old_lin_algebra.h	/^#define __VCGLIB_LINALGEBRA_H$/;"	d
__VCGLIB_LINE2	vcglib/vcg/space/line2.h	/^#define __VCGLIB_LINE2$/;"	d
__VCGLIB_LINE3	vcglib/vcg/space/line3.h	/^#define __VCGLIB_LINE3$/;"	d
__VCGLIB_LINEAR	vcglib/vcg/math/linear.h	/^#define __VCGLIB_LINEAR$/;"	d
__VCGLIB_LOCALOPTIMIZATION	vcglib/vcg/complex/algorithms/local_optimization.h	/^#define __VCGLIB_LOCALOPTIMIZATION$/;"	d
__VCGLIB_MATERIAL	vcglib/wrap/io_trimesh/io_material.h	/^#define __VCGLIB_MATERIAL$/;"	d
__VCGLIB_MATH_BASE	vcglib/vcg/math/base.h	/^#define __VCGLIB_MATH_BASE$/;"	d
__VCGLIB_MATRIX33_H	vcglib/vcg/math/matrix33.h	/^#define __VCGLIB_MATRIX33_H$/;"	d
__VCGLIB_MATRIX33_H	vcglib/vcg/math/old_matrix33.h	/^#define __VCGLIB_MATRIX33_H$/;"	d
__VCGLIB_MATRIX44	vcglib/vcg/math/matrix44.h	/^#define __VCGLIB_MATRIX44$/;"	d
__VCGLIB_MATRIX44	vcglib/vcg/math/old_matrix44.h	/^#define __VCGLIB_MATRIX44$/;"	d
__VCGLIB_OBOX3	vcglib/vcg/space/obox3.h	/^#define __VCGLIB_OBOX3$/;"	d
__VCGLIB_PERLIN_NOISE	vcglib/vcg/math/perlin_noise.h	/^#define __VCGLIB_PERLIN_NOISE$/;"	d
__VCGLIB_PLANAR_POLYGON_TESSELLATOR	vcglib/vcg/space/planar_polygon_tessellation.h	/^#define __VCGLIB_PLANAR_POLYGON_TESSELLATOR$/;"	d
__VCGLIB_PLATONIC	vcglib/vcg/complex/algorithms/create/platonic.h	/^#define __VCGLIB_PLATONIC$/;"	d
__VCGLIB_POINT	vcglib/vcg/space/deprecated_point.h	/^#define __VCGLIB_POINT$/;"	d
__VCGLIB_POINT	vcglib/vcg/space/point.h	/^#define __VCGLIB_POINT$/;"	d
__VCGLIB_POINT2	vcglib/vcg/space/deprecated_point2.h	/^#define __VCGLIB_POINT2$/;"	d
__VCGLIB_POINT2	vcglib/vcg/space/point2.h	/^#define __VCGLIB_POINT2$/;"	d
__VCGLIB_POINT3	vcglib/vcg/space/deprecated_point3.h	/^#define __VCGLIB_POINT3$/;"	d
__VCGLIB_POINT3	vcglib/vcg/space/point3.h	/^#define __VCGLIB_POINT3$/;"	d
__VCGLIB_POINT4	vcglib/vcg/space/deprecated_point4.h	/^#define __VCGLIB_POINT4$/;"	d
__VCGLIB_POINT4	vcglib/vcg/space/point4.h	/^#define __VCGLIB_POINT4$/;"	d
__VCGLIB_POINT_SAMPLING	vcglib/vcg/complex/algorithms/point_sampling.h	/^#define __VCGLIB_POINT_SAMPLING$/;"	d
__VCGLIB_POLYGON_SUPPORT	vcglib/vcg/complex/algorithms/polygon_support.h	/^#define __VCGLIB_POLYGON_SUPPORT$/;"	d
__VCGLIB_QUADRIC	vcglib/vcg/math/quadric.h	/^#define __VCGLIB_QUADRIC$/;"	d
__VCGLIB_QUADRIC5	vcglib/vcg/math/quadric5.h	/^#define __VCGLIB_QUADRIC5$/;"	d
__VCGLIB_RAY2	vcglib/vcg/space/ray2.h	/^#define __VCGLIB_RAY2$/;"	d
__VCGLIB_RAY3	vcglib/vcg/space/ray3.h	/^#define __VCGLIB_RAY3$/;"	d
__VCGLIB_REFINE	vcglib/vcg/complex/algorithms/refine.h	/^#define __VCGLIB_REFINE$/;"	d
__VCGLIB_REFINE_LOOP	vcglib/vcg/complex/algorithms/refine_loop.h	/^#define __VCGLIB_REFINE_LOOP$/;"	d
__VCGLIB_SEGMENT2	vcglib/vcg/space/segment2.h	/^#define __VCGLIB_SEGMENT2$/;"	d
__VCGLIB_SEGMENT3	vcglib/vcg/space/segment3.h	/^#define __VCGLIB_SEGMENT3$/;"	d
__VCGLIB_SHOT	vcglib/vcg/math/shot.h	/^#define __VCGLIB_SHOT$/;"	d
__VCGLIB_SIMPLE__	vcglib/vcg/container/simple_temporary_data.h	/^#define __VCGLIB_SIMPLE__$/;"	d
__VCGLIB_SPACE	vcglib/vcg/space/space.h	/^#define __VCGLIB_SPACE$/;"	d
__VCGLIB_SPATIALINDEX_2DH	vcglib/vcg/space/index/index2D/base_2d.h	/^#define __VCGLIB_SPATIALINDEX_2DH$/;"	d
__VCGLIB_SPATIALINDEX_H	vcglib/vcg/space/index/base.h	/^#define __VCGLIB_SPATIALINDEX_H$/;"	d
__VCGLIB_SPATIAL_ITERATORS	vcglib/vcg/space/index/space_iterators.h	/^#define __VCGLIB_SPATIAL_ITERATORS$/;"	d
__VCGLIB_SPHERICAL_HARMONICS_H	vcglib/vcg/math/spherical_harmonics.h	/^#define __VCGLIB_SPHERICAL_HARMONICS_H$/;"	d
__VCGLIB_TETRAEXPORT_PLY	vcglib/wrap/io_tetramesh/export_ply.h	/^#define __VCGLIB_TETRAEXPORT_PLY$/;"	d
__VCGLIB_TETRAHEDRON	vcglib/vcg/simplex/tetrahedron/tetrahedron.h	/^#define __VCGLIB_TETRAHEDRON$/;"	d
__VCGLIB_TETRAIMPORTERPLY	vcglib/wrap/io_tetramesh/import_ply.h	/^#define __VCGLIB_TETRAIMPORTERPLY$/;"	d
__VCGLIB_TEXCOORD2__	vcglib/vcg/space/texcoord2.h	/^#define __VCGLIB_TEXCOORD2__$/;"	d
__VCGLIB_TRACED_VECTOR__	vcglib/vcg/container/vector_occ.h	/^#define __VCGLIB_TRACED_VECTOR__ /;"	d
__VCGLIB_TRIALLOCATOR	vcglib/vcg/complex/allocate.h	/^#define __VCGLIB_TRIALLOCATOR$/;"	d
__VCGLIB_TRIMESH_GENERIC_EXPORT	vcglib/wrap/io_trimesh/export.h	/^#define __VCGLIB_TRIMESH_GENERIC_EXPORT$/;"	d
__VCGLIB_TRIMESH_STAT	vcglib/vcg/complex/algorithms/stat.h	/^#define __VCGLIB_TRIMESH_STAT$/;"	d
__VCGLIB_TRI_CLIP	vcglib/vcg/complex/algorithms/clip.h	/^#define __VCGLIB_TRI_CLIP$/;"	d
__VCGLIB_UGRID	vcglib/vcg/space/index/grid_static_ptr.h	/^#define __VCGLIB_UGRID$/;"	d
__VCGLIB_UGRID_OBJ	vcglib/vcg/space/index/grid_static_obj.h	/^#define __VCGLIB_UGRID_OBJ$/;"	d
__VCGLIB_UTILDAE	vcglib/wrap/dae/util_dae.h	/^#define __VCGLIB_UTILDAE$/;"	d
__VCGLIB_VERTEX_DISTANCE	vcglib/vcg/simplex/vertex/distance.h	/^#define __VCGLIB_VERTEX_DISTANCE$/;"	d
__VCGLIB_WRAPUTILS_H	vcglib/wrap/utils.h	/^#define __VCGLIB_WRAPUTILS_H$/;"	d
__VCGLIB_WRAP_GUI_VIEW_H	vcglib/wrap/gui/view.h	/^#define __VCGLIB_WRAP_GUI_VIEW_H$/;"	d
__VCGLIB_ZONOHEDRON	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^#define __VCGLIB_ZONOHEDRON$/;"	d
__VCGLIB__SAMPLING	vcglib/apps/metro/sampling.h	/^#define __VCGLIB__SAMPLING$/;"	d
__VCGLIB__SMOOTH	vcglib/vcg/complex/algorithms/smooth.h	/^#define __VCGLIB__SMOOTH$/;"	d
__VCGLIB__TEXTCOOORD_OPTIMIZATION	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^#define __VCGLIB__TEXTCOOORD_OPTIMIZATION$/;"	d
__VCGTEST_IMPLICITSPHERE	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^#define __VCGTEST_IMPLICITSPHERE$/;"	d
__VCGTEST_SPHEREDIFFERENCE	vcglib/apps/unsupported/extractors/extractor/SphereDifference.h	/^#define __VCGTEST_SPHEREDIFFERENCE$/;"	d
__VCGTEST_SPHEREUNION	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^#define __VCGTEST_SPHEREUNION$/;"	d
__VCGTEST_VOLUME	vcglib/apps/unsupported/extractors/extractor/Volume.h	/^#define __VCGTEST_VOLUME$/;"	d
__VCGTEST_WALKER	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^#define __VCGTEST_WALKER$/;"	d
__VCG_COMPLEX_BASE	vcglib/vcg/complex/base.h	/^#define __VCG_COMPLEX_BASE$/;"	d
__VCG_CREASE_CUT	vcglib/vcg/complex/algorithms/crease_cut.h	/^#define __VCG_CREASE_CUT$/;"	d
__VCG_DECIMATION_COLLAPSE	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^#define __VCG_DECIMATION_COLLAPSE$/;"	d
__VCG_DECIMATION_TRICOLLAPSE	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^#define __VCG_DECIMATION_TRICOLLAPSE$/;"	d
__VCG_DECIMATION_TRIFLIP	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^#define __VCG_DECIMATION_TRIFLIP$/;"	d
__VCG_DERIVATION_CHAIN	vcglib/vcg/container/derivation_chain.h	/^#define __VCG_DERIVATION_CHAIN$/;"	d
__VCG_DISTANCE2	vcglib/vcg/space/distance2.h	/^#define __VCG_DISTANCE2$/;"	d
__VCG_DISTANCE3	vcglib/vcg/space/distance3.h	/^#define __VCG_DISTANCE3$/;"	d
__VCG_EDGE_PLUS	vcglib/vcg/simplex/edge/base.h	/^#define __VCG_EDGE_PLUS$/;"	d
__VCG_EDGE_PLUS_COMPONENT	vcglib/vcg/simplex/edge/component.h	/^#define __VCG_EDGE_PLUS_COMPONENT$/;"	d
__VCG_EDGE_POS	vcglib/vcg/simplex/edge/pos.h	/^#define __VCG_EDGE_POS$/;"	d
__VCG_EMC_LOOK_UP_TABLE	vcglib/vcg/complex/algorithms/create/emc_lookup_table.h	/^#define __VCG_EMC_LOOK_UP_TABLE$/;"	d
__VCG_EXCEPTION_H	vcglib/vcg/complex/exception.h	/^#define __VCG_EXCEPTION_H$/;"	d
__VCG_EXTENDED_MARCHING_CUBES	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^#define __VCG_EXTENDED_MARCHING_CUBES$/;"	d
__VCG_FACE_PLUS	vcglib/vcg/simplex/face/base.h	/^#define __VCG_FACE_PLUS$/;"	d
__VCG_FACE_PLUS_COMPONENT	vcglib/vcg/simplex/face/component.h	/^#define __VCG_FACE_PLUS_COMPONENT$/;"	d
__VCG_FACE_PLUS_COMPONENT_OCC	vcglib/vcg/simplex/face/component_occ.h	/^#define __VCG_FACE_PLUS_COMPONENT_OCC$/;"	d
__VCG_FACE_PLUS_COMPONENT_OCF	vcglib/vcg/simplex/face/component_ocf.h	/^#define __VCG_FACE_PLUS_COMPONENT_OCF$/;"	d
__VCG_FACE_PLUS_COMPONENT_RT	vcglib/vcg/simplex/face/component_ep.h	/^#define __VCG_FACE_PLUS_COMPONENT_RT$/;"	d
__VCG_FACE_POS	vcglib/vcg/simplex/face/pos.h	/^#define __VCG_FACE_POS$/;"	d
__VCG_GEN_NORMAL	vcglib/vcg/math/gen_normal.h	/^#define __VCG_GEN_NORMAL$/;"	d
__VCG_GLADDONS	vcglib/wrap/gl/addons.h	/^#define __VCG_GLADDONS$/;"	d
__VCG_GLTRIMESH	vcglib/wrap/gl/trimesh.h	/^#define __VCG_GLTRIMESH$/;"	d
__VCG_HEDGE_	vcglib/vcg/connectors/hedge.h	/^#define __VCG_HEDGE_ /;"	d
__VCG_HEDGE_COMPONENT	vcglib/vcg/connectors/hedge_component.h	/^#define __VCG_HEDGE_COMPONENT$/;"	d
__VCG_HISTOGRAM	vcglib/vcg/math/histogram.h	/^#define __VCG_HISTOGRAM$/;"	d
__VCG_JUMPING_FACE_POS	vcglib/vcg/simplex/face/jumping_pos.h	/^#define __VCG_JUMPING_FACE_POS$/;"	d
__VCG_LIB_EXPORTER_DXF	vcglib/wrap/io_edgemesh/export_dxf.h	/^#define __VCG_LIB_EXPORTER_DXF$/;"	d
__VCG_LIB_EXPORTER_SVG	vcglib/wrap/io_edgemesh/export_svg.h	/^#define __VCG_LIB_EXPORTER_SVG$/;"	d
__VCG_MARCHING_CUBES	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^#define __VCG_MARCHING_CUBES$/;"	d
__VCG_MC_LOOK_UP_TABLE	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^#define __VCG_MC_LOOK_UP_TABLE$/;"	d
__VCG_MESH	vcglib/vcg/complex/complex.h	/^#define __VCG_MESH$/;"	d
__VCG_MESH	vcglib/vcg/complex/complex.h	/^#undef __VCG_MESH$/;"	d
__VCG_MESH_H	vcglib/vcg/complex/complex.h	/^#define __VCG_MESH_H$/;"	d
__VCG_MESH_RESAMPLER	vcglib/vcg/complex/algorithms/create/resampler.h	/^#define __VCG_MESH_RESAMPLER$/;"	d
__VCG_MESH_VISIBILITY	vcglib/apps/unsupported/shadevis/visshader.h	/^#define __VCG_MESH_VISIBILITY$/;"	d
__VCG_OSG_VERTEX_PLUS_COMPONENT	vcglib/wrap/opensg/vertex_component.h	/^#define __VCG_OSG_VERTEX_PLUS_COMPONENT$/;"	d
__VCG_OUTLINE2_PACKER_H__	vcglib/vcg/space/outline2_packer.h	/^#define __VCG_OUTLINE2_PACKER_H__$/;"	d
__VCG_PLYLIB	vcglib/wrap/ply/plylib.h	/^#define __VCG_PLYLIB /;"	d
__VCG_PLYLIB_STUFF	vcglib/wrap/ply/plystuff.h	/^#define __VCG_PLYLIB_STUFF /;"	d
__VCG_POLYGON_COMPONENT	vcglib/vcg/simplex/face/component_polygon.h	/^#define __VCG_POLYGON_COMPONENT$/;"	d
__VCG_RandomGenerator	vcglib/vcg/math/random_generator.h	/^#define __VCG_RandomGenerator$/;"	d
__VCG_RectPacker__	vcglib/vcg/space/rect_packer.h	/^#define __VCG_RectPacker__$/;"	d
__VCG_SIMILARITY2_H	vcglib/vcg/math/similarity2.h	/^#define __VCG_SIMILARITY2_H$/;"	d
__VCG_SIMPLE_PIC	vcglib/apps/unsupported/shadevis/simplepic.h	/^#define __VCG_SIMPLE_PIC$/;"	d
__VCG_SIMPLE_VOLUME	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^#define __VCG_SIMPLE_VOLUME$/;"	d
__VCG_TETRA3	vcglib/vcg/space/tetra3.h	/^#define __VCG_TETRA3$/;"	d
__VCG_TETRAHEDRON_PLUS_COMPONENT	vcglib/vcg/simplex/tetrahedron/component.h	/^#define __VCG_TETRAHEDRON_PLUS_COMPONENT /;"	d
__VCG_TETRA_PLUS	vcglib/vcg/simplex/tetrahedron/base.h	/^#define __VCG_TETRA_PLUS$/;"	d
__VCG_TETRA_POS	vcglib/vcg/simplex/tetrahedron/pos.h	/^#define __VCG_TETRA_POS$/;"	d
__VCG_TETRA_TRI_COLLAPSE	vcglib/vcg/complex/algorithms/edge_collapse.h	/^#define __VCG_TETRA_TRI_COLLAPSE$/;"	d
__VCG_TRIANGLE2	vcglib/vcg/space/triangle2.h	/^#define __VCG_TRIANGLE2$/;"	d
__VCG_TRIANGLE3	vcglib/vcg/space/triangle3.h	/^#define __VCG_TRIANGLE3$/;"	d
__VCG_TRIMESHCOLLAPSE_QUADRIC_TEX_	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^#define __VCG_TRIMESHCOLLAPSE_QUADRIC_TEX_$/;"	d
__VCG_TRIMESHCOLLAPSE_QUADRIC__	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^#define __VCG_TRIMESHCOLLAPSE_QUADRIC__$/;"	d
__VCG_TRIMESH_CLOSEST	vcglib/vcg/complex/algorithms/closest.h	/^#define __VCG_TRIMESH_CLOSEST$/;"	d
__VCG_TRIVIAL_WALKER	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^#define __VCG_TRIVIAL_WALKER$/;"	d
__VCG_TRI_UPDATE_BOUNDING	vcglib/vcg/complex/algorithms/update/bounding.h	/^#define __VCG_TRI_UPDATE_BOUNDING$/;"	d
__VCG_TRI_UPDATE_COLOR	vcglib/vcg/complex/algorithms/update/color.h	/^#define __VCG_TRI_UPDATE_COLOR$/;"	d
__VCG_TRI_UPDATE_EDGES	vcglib/vcg/complex/algorithms/update/component_ep.h	/^#define __VCG_TRI_UPDATE_EDGES$/;"	d
__VCG_TRI_UPDATE_FLAGS	vcglib/vcg/complex/algorithms/update/flag.h	/^#define __VCG_TRI_UPDATE_FLAGS$/;"	d
__VCG_TRI_UPDATE_HOLE	vcglib/vcg/complex/algorithms/hole.h	/^#define __VCG_TRI_UPDATE_HOLE$/;"	d
__VCG_TRI_UPDATE_NORMALS	vcglib/vcg/complex/algorithms/update/normal.h	/^#define __VCG_TRI_UPDATE_NORMALS$/;"	d
__VCG_TRI_UPDATE_POSITION	vcglib/vcg/complex/algorithms/update/position.h	/^#define __VCG_TRI_UPDATE_POSITION$/;"	d
__VCG_TRI_UPDATE_QUALITY	vcglib/vcg/complex/algorithms/update/quality.h	/^#define __VCG_TRI_UPDATE_QUALITY$/;"	d
__VCG_TRI_UPDATE_SELECTION	vcglib/vcg/complex/algorithms/update/selection.h	/^#define __VCG_TRI_UPDATE_SELECTION$/;"	d
__VCG_TRI_UPDATE_TEXTURE	vcglib/vcg/complex/algorithms/update/texture.h	/^#define __VCG_TRI_UPDATE_TEXTURE$/;"	d
__VCG_TRI_UPDATE_TOPOLOGY	vcglib/vcg/complex/algorithms/update/topology.h	/^#define __VCG_TRI_UPDATE_TOPOLOGY$/;"	d
__VCG_VERTEX_PLUS	vcglib/vcg/simplex/vertex/base.h	/^#define __VCG_VERTEX_PLUS$/;"	d
__VCG_VERTEX_PLUS_COMPONENT	vcglib/vcg/simplex/vertex/component.h	/^#define __VCG_VERTEX_PLUS_COMPONENT$/;"	d
__VCG_VERTEX_PLUS_COMPONENT_OCC	vcglib/vcg/simplex/vertex/component_occ.h	/^#define __VCG_VERTEX_PLUS_COMPONENT_OCC$/;"	d
__VCG_VERTEX_PLUS_COMPONENT_OCF	vcglib/vcg/simplex/vertex/component_ocf.h	/^#define __VCG_VERTEX_PLUS_COMPONENT_OCF$/;"	d
___	vcglib/vcg/complex/algorithms/bitquad_support.h	/^typedef enum { VALENCY_FLAGS = 24 } ___; \/\/ this bit and the 4 successive one are devoted to store valency$/;"	t	class:vcg::tri::BitQuad	typeref:enum:vcg::tri::BitQuad::__anon480
___DEFINITIONS	vcglib/apps/unsupported/extractors/extractor/Definitions.h	/^#define ___DEFINITIONS$/;"	d
___WE_UNDEFINED_DEPRECATED__	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^#define ___WE_UNDEFINED_DEPRECATED__$/;"	d
___WE_UNDEFINED_DEPRECATED__	vcglib/vcg/space/index/spatial_hashing.h	/^  #define ___WE_UNDEFINED_DEPRECATED__$/;"	d
__cdecl	vcglib/vcg/space/index/grid_util.h	/^#define __cdecl /;"	d
__cdecl	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^#define __cdecl /;"	d
__gnu_cxx	vcglib/vcg/math/disjoint_set.h	/^namespace __gnu_cxx$/;"	n
__int64	vcglib/vcg/space/index/grid_util.h	/^#define __int64 /;"	d
__int64	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^#define __int64 /;"	d
__pld	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^#define __pld(/;"	d
_a	vcglib/vcg/math/matrix44.h	/^	T _a[16];$/;"	m	class:vcg::Matrix44
_approx_geodesic_dist	vcg_mesh.hpp	/^    bool _approx_geodesic_dist;$/;"	m	struct:vcg::MyAlgorithms::Poison_setup
_attributes	vcglib/wrap/dae/xmldocumentmanaging.h	/^	TagAttributes _attributes;$/;"	m	class:XMLTag
_back	vcglib/vcg/simplex/tetrahedron/pos.h	/^	short int _back;$/;"	m	class:vcg::tetra::PosJump
_bbox	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	BoundingBox		_bbox;$/;"	m	class:Walker
_bbox	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    Box3i		_bbox;$/;"	m	class:vcg::tri::TrivialWalker
_cam_fov_angle	vcglib/wrap/io_trimesh/export_u3d.h	/^			float _cam_fov_angle;$/;"	m	class:vcg::tri::io::u3dparametersclasses::Movie15Parameters::CameraParameters
_cam_roll_angle	vcglib/wrap/io_trimesh/export_u3d.h	/^			float _cam_roll_angle;$/;"	m	class:vcg::tri::io::u3dparametersclasses::Movie15Parameters::CameraParameters
_campar	vcglib/wrap/io_trimesh/export_u3d.h	/^		CameraParameters* _campar;$/;"	m	struct:vcg::tri::io::u3dparametersclasses::Movie15Parameters
_case	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            unsigned char _case;$/;"	m	class:vcg::tri::MarchingCubes
_cell_size	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	vcg::Point3i	_cell_size;$/;"	m	class:Walker
_center	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	vcg::Point3f	_center;$/;"	m	class:ImplicitSphere
_center	vcglib/vcg/space/sphere3.h	/^  Point3<T> _center;$/;"	m	class:vcg::Sphere3
_check_template_params	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::PlainObjectBase
_check_template_params	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::Quaternion
_close	vcglib/wrap/gcache/door.h	/^  mt::semaphore _close;$/;"	m	class:QDoor
_color	vcglib/vcg/simplex/edge/component.h	/^  ColorType _color;$/;"	m	class:vcg::edge::Color
_color	vcglib/vcg/simplex/face/component.h	/^  ColorType _color;$/;"	m	class:vcg::face::Color
_color	vcglib/vcg/simplex/face/component.h	/^  ColorType _color[3];$/;"	m	class:vcg::face::WedgeColor
_color	vcglib/vcg/simplex/vertex/component.h	/^  ColorType _color;$/;"	m	class:vcg::vertex::Color
_color_size	vcglib/wrap/bmt/strip_mesh.h	/^  unsigned short _color_size;$/;"	m	class:vcg::StripMesh
_color_start	vcglib/wrap/bmt/strip_mesh.h	/^  unsigned char  *_color_start;  $/;"	m	class:vcg::StripMesh
_colorspace	vcglib/img/img_attributes.h	/^  COLORSPACE _colorspace;$/;"	m	class:img::ImgAttributes
_columns	vcglib/vcg/math/old_deprecated_matrix.h	/^			unsigned int _columns;$/;"	m	class:vcg::ndim::Matrix
_compute	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^void HessenbergDecomposition<MatrixType>::_compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)$/;"	f	class:Eigen::HessenbergDecomposition
_config	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            unsigned char _config;$/;"	m	class:vcg::tri::MarchingCubes
_controlEnd	vcglib/vcg/space/index/space_iterators.h	/^		bool _controlEnd()$/;"	f	class:vcg::RayIterator
_converter_loc	vcglib/wrap/io_trimesh/export_u3d.h	/^		const QString _converter_loc;$/;"	m	struct:vcg::tri::io::u3dparametersclasses::IDTFConverterParameters
_coord	vcglib/vcg/simplex/vertex/component.h	/^  CoordType _coord;$/;"	m	class:vcg::vertex::Coord
_corep	vcglib/wrap/opensg/vertex_component.h	/^	CoreType * _corep;$/;"	m	class:vcg::vert::OSGColor
_corep	vcglib/wrap/opensg/vertex_component.h	/^	CoreType * _corep;$/;"	m	class:vcg::vert::OSGCoord
_corep	vcglib/wrap/opensg/vertex_component.h	/^	CoreType * _corep;$/;"	m	class:vcg::vert::OSGNormal
_corners	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            vcg::Point3i _corners[8];$/;"	m	class:vcg::tri::ExtendedMarchingCubes
_corners	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            vcg::Point3i _corners[8];$/;"	m	class:vcg::tri::MarchingCubes
_currentChord	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_Chord                *_currentChord;$/;"	m	class:vcg::tri::PolychordCollapse::PC_Chords
_current_slice	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	int	_current_slice;$/;"	m	class:Walker
_current_slice	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    int	_current_slice;$/;"	m	class:vcg::tri::TrivialWalker
_curv	vcglib/vcg/simplex/face/component.h	/^  CurvatureDirType _curv;$/;"	m	class:vcg::face::CurvatureDir
_curv	vcglib/vcg/simplex/vertex/component.h	/^  CurvatureDirType _curv;$/;"	m	class:vcg::vertex::CurvatureDir
_data	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    internal::CompressedStorage<Scalar,Index>& _data() const { return m_data; }$/;"	f	class:Eigen::SparseVector
_data	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    internal::CompressedStorage<Scalar,Index>& _data() { return m_data; }$/;"	f	class:Eigen::SparseVector
_data	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    const std::vector<internal::CompressedStorage<Scalar,Index> >& _data() const { return m_data; }$/;"	f	class:Eigen::DynamicSparseMatrix
_data	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    std::vector<internal::CompressedStorage<Scalar,Index> >& _data() { return m_data; }$/;"	f	class:Eigen::DynamicSparseMatrix
_data	vcglib/img/img_image.h	/^  ScalarType *_data; $/;"	m	class:img::Image
_data	vcglib/vcg/math/old_deprecated_matrix.h	/^			ScalarType *_data;$/;"	m	class:vcg::ndim::Matrix
_diagPtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar* _diagPtr() {$/;"	f	class:Eigen::SkylineMatrix
_diagPtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline const Scalar* _diagPtr() const {$/;"	f	class:Eigen::SkylineMatrix
_dimension	vcglib/wrap/math/sparse_matrix.h	/^	int _dimension;	$/;"	m	class:SparseMatrix
_dir	vcglib/vcg/space/line2.h	/^	PointType _dir;$/;"	m	class:vcg::Line2
_dir	vcglib/vcg/space/line3.h	/^	PointType _dir;$/;"	m	class:vcg::Line3
_dir	vcglib/vcg/space/plane3.h	/^  PointType _dir;$/;"	m	class:vcg::Plane3
_dir	vcglib/vcg/space/ray2.h	/^	PointType _dir;$/;"	m	class:vcg::Ray2
_dir	vcglib/vcg/space/ray3.h	/^	PointType _dir;$/;"	m	class:vcg::Ray3
_e	vcglib/vcg/simplex/tetrahedron/pos.h	/^	char _e;$/;"	m	class:vcg::tetra::Pos
_efi	vcglib/vcg/simplex/face/component.h	/^  char _efi[3] ;$/;"	m	class:vcg::face::EFAdj
_efp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer _efp[3] ;$/;"	m	class:vcg::face::EFAdj
_ep	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer _ep[2] ;$/;"	m	class:vcg::hedge::HHAdj
_ep	vcglib/vcg/connectors/hedge_component.h	/^   typename T::EdgePointer	 _ep ;$/;"	m	class:vcg::hedge::HEAdj
_ep	vcglib/vcg/simplex/edge/component.h	/^	typename T::EdgePointer _ep[2] ;$/;"	m	class:vcg::edge::VEAdj
_ep	vcglib/vcg/simplex/edge/component.h	/^  typename T::EdgePointer _ep[2] ;$/;"	m	class:vcg::edge::EEAdj
_ep	vcglib/vcg/simplex/face/component_ep.h	/^EdgePlaneType _ep;$/;"	m	class:vcg::face::EdgePlane
_ep	vcglib/vcg/simplex/vertex/component.h	/^  typename T::EdgePointer _ep ;$/;"	m	class:vcg::vertex::VEAdj
_error	vcglib/wrap/dae/xmldocumentmanaging.h	/^	bool _error;$/;"	m	class:XMLDocumentWriter
_expression	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Flagged
_expression	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& _expression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView
_expression	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::VectorwiseOp
_expression	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Cwise
_f	vcglib/vcg/simplex/tetrahedron/pos.h	/^	char _f;$/;"	m	class:vcg::tetra::Pos
_face	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    std::vector<Face> _face;$/;"	m	class:vcg::tri::Zonohedron
_facenormals	vcglib/vcg/simplex/tetrahedron/component.h	/^  NormalType  _facenormals[4];    $/;"	m	class:vcg::tetra::FaceNormal
_featureAngle	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            ScalarType _featureAngle;$/;"	m	class:vcg::tri::ExtendedMarchingCubes
_featureFlag	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            int				_featureFlag;$/;"	m	class:vcg::tri::ExtendedMarchingCubes
_fei	vcglib/vcg/simplex/face/component.h	/^  char _fei[3] ;$/;"	m	class:vcg::face::FEAdj
_fep	vcglib/vcg/simplex/face/component.h	/^  typename T::EdgePointer _fep[3] ;$/;"	m	class:vcg::face::FEAdj
_fepP	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::EdgePointer *_fepP ;$/;"	m	class:vcg::face::PFEAdj
_ffi	vcglib/vcg/simplex/face/component.h	/^  char _ffi[3] ;$/;"	m	class:vcg::face::FFAdj
_ffi	vcglib/vcg/simplex/face/component_occ.h	/^		char _ffi[3];$/;"	m	struct:vcg::face::FFAdjTypeSup
_ffiP	vcglib/vcg/simplex/face/component_polygon.h	/^  char *_ffiP ;$/;"	m	class:vcg::face::PFFAdj
_ffp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer _ffp[3] ;$/;"	m	class:vcg::face::FFAdj
_ffp	vcglib/vcg/simplex/face/component_occ.h	/^		FP  _ffp[3]; $/;"	m	struct:vcg::face::FFAdjTypeSup
_ffpP	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::FacePointer *_ffpP ;$/;"	m	class:vcg::face::PFFAdj
_fh	vcglib/vcg/simplex/face/component.h	/^  typename T::HEdgePointer _fh ;$/;"	m	class:vcg::face::FHAdj
_fhP	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::HEdgePointer  _fhP ;$/;"	m	class:vcg::face::PFHAdj
_field	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            ScalarType	 _field[8];$/;"	m	class:vcg::tri::ExtendedMarchingCubes
_field	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            ScalarType _field[8];$/;"	m	class:vcg::tri::MarchingCubes
_file	vcglib/wrap/dae/xmldocumentmanaging.h	/^	QFile _file;$/;"	m	class:XMLDocumentWriter
_file	vcglib/wrap/io_trimesh/export_idtf.h	/^	std::ofstream _file;$/;"	m	class:Output_File
_finalized	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            bool	_finalized;$/;"	m	class:vcg::tri::ExtendedMarchingCubes
_flags	vcglib/vcg/connectors/hedge_component.h	/^  int  _flags;    $/;"	m	class:vcg::hedge::BitFlags
_flags	vcglib/vcg/simplex/edge/component.h	/^  int  _flags;$/;"	m	class:vcg::edge::BitFlags
_flags	vcglib/vcg/simplex/face/component.h	/^  int  _flags;$/;"	m	class:vcg::face::BitFlags
_flags	vcglib/vcg/simplex/tetrahedron/component.h	/^  int  _flags;    $/;"	m	class:vcg::tetra::BitFlags
_flags	vcglib/vcg/simplex/vertex/component.h	/^  int  _flags;$/;"	m	class:vcg::vertex::BitFlags
_flipH	vcglib/wrap/gui/trackmode.h	/^	int _flipH, _flipV;$/;"	m	class:vcg::NavigatorWasdMode
_flipV	vcglib/wrap/gui/trackmode.h	/^	int _flipH, _flipV;$/;"	m	class:vcg::NavigatorWasdMode
_fp	vcglib/vcg/connectors/hedge_component.h	/^  typename T::FacePointer _fp ;    $/;"	m	class:vcg::hedge::HFAdj
_fp	vcglib/vcg/simplex/edge/component.h	/^  typename T::FacePointer _fp ;$/;"	m	class:vcg::edge::EFAdj
_fp	vcglib/vcg/simplex/face/component_ocf.h	/^  typename VALUE_TYPE::FacePointer _fp[3] ;$/;"	m	struct:vcg::face::vector_ocf::AdjTypePack
_fp	vcglib/vcg/simplex/vertex/component.h	/^    typename T::FacePointer _fp ;$/;"	m	class:vcg::vertex::VFAdj
_fp	vcglib/vcg/simplex/vertex/component_occ.h	/^  typename T::FacePointer _fp ;    $/;"	m	class:vcg::vertex::VFAdjOcc
_fp	vcglib/vcg/simplex/vertex/component_ocf.h	/^	typename VALUE_TYPE::FacePointer _fp ;$/;"	m	struct:vcg::vertex::vector_ocf::VFAdjType
_g	vcglib/vcg/complex/algorithms/create/resampler.h	/^		GridType _g;$/;"	m	class:vcg::tri::Resampler::Walker
_gamma	vcglib/img/img_attributes.h	/^  ScalarType _gamma;$/;"	m	class:img::ImgAttributes
_gaussian	vcglib/img/img_filter.h	/^inline void _gaussian(const int &radius,const ScalarType &sigma,ScalarType * &matrix,int &matrix_side)$/;"	f	namespace:img
_geop	vcglib/wrap/opensg/vertex_component.h	/^	OSG::GeometryPtr _geop;				\/\/\/ Maybe we can use pointers to buffers directly but now we really don't now if these pointers change in time ... !!!$/;"	m	class:vcg::vert::OSGInfo
_geopointer	vcglib/wrap/opensg/vertex_component.h	/^	OSG::GeometryPtr _geopointer;$/;"	m	class:vcg::vert::OSGColorCore
_geopointer	vcglib/wrap/opensg/vertex_component.h	/^	OSG::GeometryPtr _geopointer;$/;"	m	class:vcg::vert::OSGCoordCore
_geopointer	vcglib/wrap/opensg/vertex_component.h	/^	OSG::GeometryPtr _geopointer;$/;"	m	class:vcg::vert::OSGNormalCore
_getNodes	vcglib/vcg/space/index/kdtree/kdtree.h	/^	inline const NodeList& _getNodes(void) { return mNodes; }$/;"	f	class:KdTree
_getPoints	vcglib/vcg/space/index/kdtree/kdtree.h	/^	inline const std::vector<VectorType>& _getPoints(void) { return mPoints; }$/;"	f	class:KdTree
_getopt_internal	vcglib/wrap/system/getopt.cpp	/^_getopt_internal (int argc, char *const *argv, const char *optstring,$/;"	f
_gm_	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static struct malloc_state _gm_;$/;"	v	typeref:struct:malloc_state	file:
_handle	vcglib/vcg/complex/base.h	/^        Attribute<ATTR_TYPE> * _handle;$/;"	m	class:vcg::tri::TriMesh::PerMeshAttributeHandle
_handle	vcglib/vcg/complex/base.h	/^        SimpleTempData<CONT,ATTR_TYPE> * _handle;$/;"	m	class:vcg::tri::TriMesh::AttributeHandle
_handle	vcglib/vcg/complex/base.h	/^    SimpleTempDataBase * _handle;		\/\/ pointer to the SimpleTempData that stores the attribute$/;"	m	class:vcg::PointerToAttribute
_harmonics	vcglib/vcg/simplex/vertex/component_sph.h	/^  SphType _harmonics;$/;"	m	class:vcg::vertex::Sph
_height	vcglib/img/img_image.h	/^  int _height; $/;"	m	class:img::Image
_hk	vcglib/vcg/simplex/vertex/component.h	/^    Point2<A> _hk;$/;"	m	class:vcg::vertex::Curvature
_hp	vcglib/vcg/simplex/edge/component.h	/^  typename T::HEdgePointer _hp ;$/;"	m	class:vcg::edge::EHAdj
_hp	vcglib/vcg/simplex/vertex/component.h	/^	typename T::HEdgePointer _hp ;$/;"	m	class:vcg::vertex::VHAdj
_imark	vcglib/vcg/connectors/hedge_component.h	/^	int _imark;$/;"	m	class:vcg::hedge::Mark
_imark	vcglib/vcg/simplex/edge/component.h	/^	int _imark;$/;"	m	class:vcg::edge::Mark
_imark	vcglib/vcg/simplex/face/component.h	/^  int _imark;$/;"	m	class:vcg::face::Mark
_imark	vcglib/vcg/simplex/tetrahedron/component.h	/^	int _imark;$/;"	m	class:vcg::tetra::Mark
_imark	vcglib/vcg/simplex/vertex/component.h	/^    int _imark;$/;"	m	class:vcg::vertex::Mark
_init2	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase
_init2	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(const Scalar& x, const Scalar& y, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase
_initialized	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            bool	_initialized;;$/;"	m	class:vcg::tri::ExtendedMarchingCubes
_input_file	vcglib/wrap/io_trimesh/export_u3d.h	/^		const QString _input_file;$/;"	m	struct:vcg::tri::io::u3dparametersclasses::IDTFConverterParameters
_jump	vcglib/vcg/simplex/tetrahedron/pos.h	/^	bool _jump;$/;"	m	class:vcg::tetra::PosLoop
_laplacian_of_gaussian	vcglib/img/img_filter.h	/^inline void _laplacian_of_gaussian(const int &radius,const ScalarType &sigma,ScalarType * &matrix,int &matrix_side)$/;"	f	namespace:img
_lcVertices	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    std::vector<LCVertex> _lcVertices;$/;"	m	class:vcg::tri::PolychordCollapse::LinkConditions
_localMark	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	int _localMark;$/;"	m	class:vcg::tri::PlanarEdgeFlip
_loop	vcglib/vcg/simplex/tetrahedron/pos.h	/^  bool _loop;$/;"	m	class:vcg::tetra::PosLoop
_lowerProfilePtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index* _lowerProfilePtr() {$/;"	f	class:Eigen::SkylineMatrix
_lowerProfilePtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline const Index* _lowerProfilePtr() const {$/;"	f	class:Eigen::SkylineMatrix
_lowerPtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar* _lowerPtr() {$/;"	f	class:Eigen::SkylineMatrix
_lowerPtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline const Scalar* _lowerPtr() const {$/;"	f	class:Eigen::SkylineMatrix
_m	vcglib/vcg/complex/algorithms/update/selection.h	/^  ComputeMeshType *_m;$/;"	m	class:vcg::tri::SelectionStack
_max	vcglib/vcg/space/box.h	/^	Point3<S> _max;$/;"	m	class:vcg::Box
_mesh	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	Mesh		*_mesh;$/;"	m	class:Walker
_mesh	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            TRIMESH_TYPE	*_mesh;$/;"	m	class:vcg::tri::ExtendedMarchingCubes
_mesh	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            TRIMESH_TYPE	*_mesh;$/;"	m	class:vcg::tri::MarchingCubes
_mesh	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    MeshType		*_mesh;$/;"	m	class:vcg::tri::TrivialWalker
_min	vcglib/vcg/space/box.h	/^  Point3<S> _min;$/;"	m	class:vcg::Box
_montecarlo_rate	vcg_mesh.hpp	/^    int _montecarlo_rate;$/;"	m	struct:vcg::MyAlgorithms::Poison_setup
_n	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  vcg::Point3f _n;$/;"	m	class:vcg::SimpleVoxelWithNormal
_n	vcglib/vcg/space/texcoord2.h	/^    short     _n[NMAX];$/;"	m	class:vcg::TexCoord2
_name	vcglib/vcg/complex/base.h	/^    std::string _name;					\/\/ name of the attribute$/;"	m	class:vcg::PointerToAttribute
_nb_samples	vcg_mesh.hpp	/^    int _nb_samples;            \/\/\/< Max number of samples$/;"	m	struct:vcg::MyAlgorithms::Poison_setup
_nep	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer _nep ;$/;"	m	class:vcg::hedge::HNextAdj
_newM	vcglib/vcg/complex/algorithms/create/resampler.h	/^		New_Mesh	*_newM;$/;"	m	class:vcg::tri::Resampler::Walker
_norm	vcglib/vcg/simplex/face/component.h	/^  NormalType _norm;$/;"	m	class:vcg::face::NormalAbs
_norm	vcglib/vcg/simplex/vertex/component.h	/^  NormalType _norm;$/;"	m	class:vcg::vertex::Normal
_norm_size	vcglib/wrap/bmt/strip_mesh.h	/^  unsigned short _norm_size;$/;"	m	class:vcg::StripMesh
_norm_start	vcglib/wrap/bmt/strip_mesh.h	/^  short          *_norm_start;  $/;"	m	class:vcg::StripMesh
_ns	vcglib/vcg/simplex/face/component_polygon.h	/^  int _ns;$/;"	m	class:vcg::face::PolyInfo
_nvert	vcglib/wrap/dae/poly_triangulator.h	/^		int _nvert;$/;"	m	class:vcg::tri::io::MyPolygon
_obj_bbox_diag	vcglib/wrap/io_trimesh/export_u3d.h	/^			float _obj_bbox_diag;$/;"	m	class:vcg::tri::io::u3dparametersclasses::Movie15Parameters::CameraParameters
_obj_pos	vcglib/wrap/io_trimesh/export_u3d.h	/^			vcg::Point3f _obj_pos;$/;"	m	class:vcg::tri::io::u3dparametersclasses::Movie15Parameters::CameraParameters
_obj_to_cam_dir	vcglib/wrap/io_trimesh/export_u3d.h	/^			vcg::Point3f _obj_to_cam_dir;$/;"	m	class:vcg::tri::io::u3dparametersclasses::Movie15Parameters::CameraParameters
_obj_to_cam_dist	vcglib/wrap/io_trimesh/export_u3d.h	/^			float _obj_to_cam_dist;$/;"	m	class:vcg::tri::io::u3dparametersclasses::Movie15Parameters::CameraParameters
_oep	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer _oep ;$/;"	m	class:vcg::hedge::HOppAdj
_offset	vcglib/vcg/space/plane3.h	/^  ScalarType _offset;$/;"	m	class:vcg::Plane3
_oldM	vcglib/vcg/complex/algorithms/create/resampler.h	/^		Old_Mesh	*_oldM;$/;"	m	class:vcg::tri::Resampler::Walker
_open	vcglib/wrap/gcache/door.h	/^  mt::semaphore _open;$/;"	m	class:QDoor
_ori	vcglib/vcg/space/line2.h	/^	PointType _ori;$/;"	m	class:vcg::Line2
_ori	vcglib/vcg/space/line3.h	/^	PointType _ori;$/;"	m	class:vcg::Line3
_ori	vcglib/vcg/space/ray2.h	/^	PointType _ori;$/;"	m	class:vcg::Ray2
_ori	vcglib/vcg/space/ray3.h	/^	PointType _ori;$/;"	m	class:vcg::Ray3
_output_file	vcglib/wrap/io_trimesh/export_u3d.h	/^		const QString _output_file;$/;"	m	struct:vcg::tri::io::u3dparametersclasses::IDTFConverterParameters
_ovp	vcglib/vcg/simplex/face/component_ocf.h	/^  vector_ocf<typename T::FaceType> *_ovp;$/;"	m	class:vcg::face::InfoOcf
_ovp	vcglib/vcg/simplex/vertex/component_ocf.h	/^	vector_ocf<typename T::VertexType> *_ovp;$/;"	m	class:vcg::vertex::InfoOcf
_p0	vcglib/vcg/space/segment2.h	/^	PointType _p0,_p1;$/;"	m	class:vcg::Segment2
_p0	vcglib/vcg/space/segment3.h	/^	PointType _p0,_p1;$/;"	m	class:vcg::Segment3
_p1	vcglib/vcg/space/segment2.h	/^	PointType _p0,_p1;$/;"	m	class:vcg::Segment2
_p1	vcglib/vcg/space/segment3.h	/^	PointType _p0,_p1;$/;"	m	class:vcg::Segment3
_padding	vcglib/vcg/complex/base.h	/^    int _padding;						\/\/ padding 	(used only with VMI loading)$/;"	m	class:vcg::PointerToAttribute
_pep	vcglib/vcg/connectors/hedge_component.h	/^  typename T::HEdgePointer _pep ;$/;"	m	class:vcg::hedge::HPrevAdj
_pols	vcglib/wrap/dae/poly_triangulator.h	/^		std::vector<FaceType> _pols;$/;"	m	class:vcg::tri::io::PolygonalMesh
_pos	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	PosType _pos;$/;"	m	class:vcg::tri::PlanarEdgeFlip
_priority	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            ScalarType _priority;$/;"	m	class:vcg::tri::QuadDiagonalCollapseBase
_priority	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^ScalarType _priority;$/;"	m	class:vcg::tetra::TetraEdgeCollapse
_priority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	ScalarType _priority;$/;"	m	class:vcg::tri::TriEdgeCollapse
_priority	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	ScalarType _priority;$/;"	m	class:vcg::tri::PlanarEdgeFlip
_pv	vcglib/wrap/dae/poly_triangulator.h	/^		std::vector<VERTEX_TYPE*> _pv;$/;"	m	class:vcg::tri::io::MyPolygon
_q_value	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^    volatile int _q_value;$/;"	m	class:mt::atomicInt
_q_value	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  volatile int _q_value;$/;"	m	class:mt::atomicInt
_quality	vcglib/vcg/simplex/edge/component.h	/^  QualityType _quality;$/;"	m	class:vcg::edge::Quality
_quality	vcglib/vcg/simplex/face/component.h	/^  Quality3Type _quality;$/;"	m	class:vcg::face::Quality3
_quality	vcglib/vcg/simplex/face/component.h	/^  QualityType _quality;$/;"	m	class:vcg::face::Quality
_quality	vcglib/vcg/simplex/vertex/component.h	/^  QualityType _quality;$/;"	m	class:vcg::vertex::Quality
_radius	vcg_mesh.hpp	/^    float _radius;              \/\/\/< Min radius$/;"	m	struct:vcg::MyAlgorithms::Poison_setup
_radius	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	float					_radius;$/;"	m	class:ImplicitSphere
_radius	vcglib/vcg/simplex/vertex/component.h	/^    RadiusType _radius;$/;"	m	class:vcg::vertex::Radius
_radius	vcglib/vcg/space/sphere3.h	/^  T _radius;$/;"	m	class:vcg::Sphere3
_range_max	vcglib/img/img_attributes.h	/^  ScalarType _range_max;$/;"	m	class:img::ImgAttributes
_range_min	vcglib/img/img_attributes.h	/^  ScalarType _range_min;$/;"	m	class:img::ImgAttributes
_reference_white_x	vcglib/img/img_attributes.h	/^  ScalarType _reference_white_x;$/;"	m	class:img::ImgAttributes
_reference_white_y	vcglib/img/img_attributes.h	/^  ScalarType _reference_white_y;$/;"	m	class:img::ImgAttributes
_reference_white_z	vcglib/img/img_attributes.h	/^  ScalarType _reference_white_z;$/;"	m	class:img::ImgAttributes
_refine	vcg_mesh.hpp	/^    bool _refine;               \/\/\/< use existing vertices to sample$/;"	m	struct:vcg::MyAlgorithms::Poison_setup
_resize_to_match	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_resolution	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	vcg::Point3i	_resolution;$/;"	m	class:Walker
_root	vcglib/wrap/dae/xmldocumentmanaging.h	/^	XMLInteriorNode* _root;$/;"	m	class:XMLDocument
_rows	vcglib/vcg/math/old_deprecated_matrix.h	/^			unsigned int _rows;$/;"	m	class:vcg::ndim::Matrix
_set	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_set_noalias	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_set_selector	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }$/;"	f	class:Eigen::PlainObjectBase
_set_selector	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }$/;"	f	class:Eigen::PlainObjectBase
_sin_theta	vcglib/vcg/math/legendre.h	/^	ScalarType _sin_theta;$/;"	m	class:vcg::math::DynamicLegendre
_sizeof	vcglib/vcg/complex/base.h	/^    int _sizeof;						\/\/ size of the attribute type (used only with VMI loading)$/;"	m	class:vcg::PointerToAttribute
_slice_dimension	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	int _slice_dimension;$/;"	m	class:Walker
_slice_dimension	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    int _slice_dimension;$/;"	m	class:vcg::tri::TrivialWalker
_solve	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::CholmodBase
_solve	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve(const SparseMatrix<RhsScalar,RhsOptions,RhsIndex> &b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::CholmodBase
_solve	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::DiagonalPreconditioner
_solve	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB
_solve	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient
_solve	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteLUT
_solve	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^bool PastixBase<Base>::_solve (const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const$/;"	f	class:Eigen::PastixBase
_solve	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^bool PardisoImpl<Base>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const$/;"	f	class:Eigen::PardisoImpl
_solve	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholesky
_solve	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase
_solve	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperILU
_solve	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperLU
_solve	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^bool UmfPackLU<MatrixType>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const$/;"	f	class:Eigen::UmfPackLU
_solve	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::GMRES
_solve	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteLU
_solveWithGuess	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB
_solveWithGuess	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient
_solveWithGuess	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::GMRES
_solve_sparse	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::IterativeSolverBase
_solve_sparse	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::PastixBase
_solve_sparse	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::PardisoImpl
_solve_sparse	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase
_sons	vcglib/wrap/dae/xmldocumentmanaging.h	/^	QVector< XMLNode* > _sons; $/;"	m	class:XMLInteriorNode
_sphere	vcglib/apps/unsupported/extractors/extractor/SphereDifference.h	/^	ImplicitSphere	_sphere;$/;"	m	class:SphereDifference
_sphere1	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^	ImplicitSphere _sphere1;$/;"	m	class:SphereUnion
_sphere2	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^	ImplicitSphere _sphere2;$/;"	m	class:SphereUnion
_sphere_diff	vcglib/apps/unsupported/extractors/extractor/Volume.h	/^  SphereDifference _sphere_diff;$/;"	m	class:Volume
_sqr_radius	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	float					_sqr_radius;$/;"	m	class:ImplicitSphere
_stream	vcglib/wrap/dae/xmldocumentmanaging.h	/^	QXmlStreamWriter _stream;$/;"	m	class:XMLDocumentWriter
_strip_size	vcglib/wrap/bmt/strip_mesh.h	/^  unsigned short _strip_size;$/;"	m	class:vcg::StripMesh
_strip_start	vcglib/wrap/bmt/strip_mesh.h	/^  unsigned short *_strip_start;  $/;"	m	class:vcg::StripMesh
_sub_sampling	vcg_mesh.hpp	/^    bool _sub_sampling;$/;"	m	struct:vcg::MyAlgorithms::Poison_setup
_subconfig	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            unsigned char _subconfig;$/;"	m	class:vcg::tri::MarchingCubes
_swap	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    void _swap(DenseBase<OtherDerived> const & other)$/;"	f	class:Eigen::PlainObjectBase
_t	vcglib/vcg/simplex/tetrahedron/pos.h	/^	TetraType *_t;$/;"	m	class:vcg::tetra::Pos
_t	vcglib/vcg/simplex/vertex/component.h	/^  TexCoordType _t;$/;"	m	class:vcg::vertex::TexCoord
_t	vcglib/vcg/space/texcoord2.h	/^    Point2<T> _t;$/;"	m	class:vcg::TexCoord2Simple
_t	vcglib/vcg/space/texcoord2.h	/^    PointType _t[NMAX];$/;"	m	class:vcg::TexCoord2
_t_initial	vcglib/vcg/simplex/tetrahedron/pos.h	/^	MTTYPE *_t_initial;$/;"	m	class:vcg::tetra::PosJump
_t_initial	vcglib/vcg/simplex/tetrahedron/pos.h	/^	MTTYPE *_t_initial;$/;"	m	class:vcg::tetra::PosLoop
_tab	vcglib/wrap/io_trimesh/export_idtf.h	/^	std::string _tab;$/;"	m	class:Output_File
_tag	vcglib/wrap/dae/xmldocumentmanaging.h	/^	XMLTag* _tag;$/;"	m	class:XMLNode
_tagname	vcglib/wrap/dae/xmldocumentmanaging.h	/^	QString _tagname;$/;"	m	class:XMLTag
_text	vcglib/wrap/dae/xmldocumentmanaging.h	/^		QVector<QString> _text;$/;"	m	class:XMLLeafTag
_thr	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  float _thr;$/;"	m	class:vcg::tri::TrivialWalker
_tp	vcglib/vcg/simplex/vertex/component.h	/^	typename T::TetraPointer _tp ;$/;"	m	class:vcg::vertex::VTAdj
_transformVector	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::_transformVector(Vector3 v) const$/;"	f	class:Eigen::QuaternionBase
_transformVector	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    inline VectorType _transformVector(const OtherVectorType& v) const$/;"	f	class:Eigen::RotationBase
_tti	vcglib/vcg/simplex/tetrahedron/component.h	/^  char _tti[4] ;    $/;"	m	class:vcg::tetra::TTAdj
_ttp	vcglib/vcg/simplex/tetrahedron/component.h	/^  typename T::TetraPointer _ttp[4] ;    $/;"	m	class:vcg::tetra::TTAdj
_txc	vcglib/wrap/dae/poly_triangulator.h	/^		std::vector< vcg::TexCoord2<float> > _txc;$/;"	m	class:vcg::tri::io::MyPolygon
_union	vcglib/apps/unsupported/extractors/extractor/SphereDifference.h	/^	SphereUnion			_union;$/;"	m	class:SphereDifference
_updateOVP	vcglib/vcg/simplex/face/component_ocf.h	/^ void _updateOVP(ThisTypeIterator lbegin, ThisTypeIterator lend)$/;"	f	class:vcg::face::vector_ocf
_updateOVP	vcglib/vcg/simplex/vertex/component_ocf.h	/^	void _updateOVP(ThisTypeIterator lbegin, ThisTypeIterator lend)$/;"	f	class:vcg::vertex::vector_ocf
_upperProfilePtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index* _upperProfilePtr() {$/;"	f	class:Eigen::SkylineMatrix
_upperProfilePtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline const Index* _upperProfilePtr() const {$/;"	f	class:Eigen::SkylineMatrix
_upperPtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar* _upperPtr() {$/;"	f	class:Eigen::SkylineMatrix
_upperPtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline const Scalar* _upperPtr() const {$/;"	f	class:Eigen::SkylineMatrix
_v	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  float _v;$/;"	m	class:vcg::SimpleVoxel
_v	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  float _v;$/;"	m	class:vcg::SimpleVoxel
_v	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  float _v;$/;"	m	class:vcg::SimpleVoxelWithNormal
_v	vcglib/vcg/simplex/tetrahedron/pos.h	/^	char _v;$/;"	m	class:vcg::tetra::Pos
_v	vcglib/vcg/space/deprecated_point.h	/^    S _v[N];$/;"	m	class:vcg::ndim::Point
_v	vcglib/vcg/space/deprecated_point2.h	/^	P2ScalarType _v[2];$/;"	m	class:vcg::Point2
_v	vcglib/vcg/space/deprecated_point3.h	/^    P3ScalarType _v[3];$/;"	m	class:vcg::Point3
_v	vcglib/vcg/space/deprecated_point4.h	/^    T _v[4];$/;"	m	class:vcg::Point4
_v	vcglib/vcg/space/tetra3.h	/^	CoordType _v[4];$/;"	m	class:vcg::Tetra3
_v	vcglib/vcg/space/triangle2.h	/^	Point2<ScalarType> _v[3];$/;"	m	class:vcg::Triangle2
_v	vcglib/vcg/space/triangle3.h	/^	Point3<ScalarType> _v[3];$/;"	m	class:vcg::Triangle3
_v_cs	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	float *_v_cs; \/\/ il valore del campo campionato nella fetta di volumecorrente $/;"	m	class:Walker
_v_cs	vcglib/vcg/complex/algorithms/create/resampler.h	/^		field_value* _v_cs;$/;"	m	class:vcg::tri::Resampler::Walker
_v_ns	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	float *_v_ns; \/\/ il valore del campo campionato nella prossima fetta di volume$/;"	m	class:Walker
_v_ns	vcglib/vcg/complex/algorithms/create/resampler.h	/^		field_value* _v_ns;$/;"	m	class:vcg::tri::Resampler::Walker
_vert_size	vcglib/wrap/bmt/strip_mesh.h	/^  unsigned short _vert_size;$/;"	m	class:vcg::StripMesh
_vert_start	vcglib/wrap/bmt/strip_mesh.h	/^  Point3f        *_vert_start;  $/;"	m	class:vcg::StripMesh
_vertexi	vcglib/wrap/opensg/vertex_component.h	/^	int _vertexi;								\/\/\/ OSG vertex index$/;"	m	class:vcg::vert::OSGInfo
_vertexindex	vcglib/wrap/opensg/vertex_component.h	/^	int _vertexindex;$/;"	m	class:vcg::vert::OSGColorCore
_vertexindex	vcglib/wrap/opensg/vertex_component.h	/^	int _vertexindex;$/;"	m	class:vcg::vert::OSGCoordCore
_vertexindex	vcglib/wrap/opensg/vertex_component.h	/^	int _vertexindex;$/;"	m	class:vcg::vert::OSGNormalCore
_vfi	vcglib/vcg/simplex/face/component.h	/^  char _vfi[3] ;$/;"	m	class:vcg::face::VFAdj
_vfi	vcglib/vcg/simplex/face/component_occ.h	/^		char _vfi[3];$/;"	m	struct:vcg::face::VFAdjTypeSup
_vfiP	vcglib/vcg/simplex/face/component_polygon.h	/^  char *_vfiP ;$/;"	m	class:vcg::face::PVFAdj
_vfp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer _vfp[3] ;$/;"	m	class:vcg::face::VFAdj
_vfp	vcglib/vcg/simplex/face/component_occ.h	/^		FP  _vfp[3]; $/;"	m	struct:vcg::face::VFAdjTypeSup
_vfpP	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::FacePointer *_vfpP ;$/;"	m	class:vcg::face::PVFAdj
_vi	vcglib/vcg/simplex/tetrahedron/pos.h	/^	int _vi;$/;"	m	class:vcg::tetra::VTIterator
_volume	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	Volume	*_volume;$/;"	m	class:Walker
_volume	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    VolumeType	*_volume;$/;"	m	class:vcg::tri::TrivialWalker
_vp	vcglib/vcg/connectors/hedge_component.h	/^   typename T::VertexPointer	 _vp ;    $/;"	m	class:vcg::hedge::HVAdj
_vpoly	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::VertexPointer *_vpoly;$/;"	m	class:vcg::face::PFVAdj
_vt	vcglib/vcg/simplex/tetrahedron/pos.h	/^	TetraType *_vt;$/;"	m	class:vcg::tetra::VTIterator
_vti	vcglib/vcg/simplex/tetrahedron/component.h	/^	char _vti[4];$/;"	m	class:vcg::tetra::VTAdj
_vtp	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer _vtp[4];$/;"	m	class:vcg::tetra::VTAdj
_walker	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            WALKER_TYPE		*_walker;$/;"	m	class:vcg::tri::ExtendedMarchingCubes
_walker	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            WALKER_TYPE		*_walker;$/;"	m	class:vcg::tri::MarchingCubes
_width	vcglib/img/img_image.h	/^  int _width; $/;"	m	class:img::Image
_wn	vcglib/vcg/simplex/face/component.h	/^  NormalType _wn[3];$/;"	m	class:vcg::face::WedgeRealNormal
_wnorm	vcglib/vcg/simplex/face/component.h	/^  NormalType _wnorm[3];$/;"	m	class:vcg::face::WedgeNormal
_wt	vcglib/vcg/simplex/face/component.h	/^  TexCoordType _wt[3];$/;"	m	class:vcg::face::WedgeTexCoord
_x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double _x[11];$/;"	m	struct:MGH09_functor	file:
_x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double _x[37];$/;"	m	struct:thurber_functor	file:
_x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double MGH09_functor::_x[11] = { 4., 2., 1., 5.E-1 , 2.5E-01, 1.670000E-01, 1.250000E-01,  1.E-01, 8.330000E-02, 7.140000E-02, 6.250000E-02 };$/;"	m	class:MGH09_functor	file:
_x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double thurber_functor::_x[37] = { -3.067E0, -2.981E0, -2.921E0, -2.912E0, -2.840E0, -2.797E0, -2.702E0, -2.699E0, -2.633E0, -2.481E0, -2.363E0, -2.322E0, -1.501E0, -1.460E0, -1.274E0, -1.212E0, -1.100E0, -1.046E0, -0.915E0, -0.714E0, -0.566E0, -0.545E0, -0.400E0, -0.309E0, -0.109E0, -0.103E0, 0.010E0, 0.119E0, 0.377E0, 0.790E0, 0.963E0, 1.006E0, 1.115E0, 1.572E0, 1.841E0, 2.047E0, 2.200E0 };$/;"	m	class:thurber_functor	file:
_x	vcglib/vcg/math/legendre.h	/^	ScalarType _x; \/\/table is conserved only across consistent x invocations$/;"	m	class:vcg::math::DynamicLegendre
_x_cs	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	VertexIndex *_x_cs; \/\/ indici dell'intersezioni della superficie lungo gli Xedge della fetta corrente$/;"	m	class:Walker
_x_cs	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    VertexIndex *_x_cs; \/\/ indici dell'intersezioni della superficie lungo gli Xedge della fetta corrente$/;"	m	class:vcg::tri::TrivialWalker
_x_cs	vcglib/vcg/complex/algorithms/create/resampler.h	/^		VertexIndex *_x_cs; \/\/ indici dell'intersezioni della superficie lungo gli Xedge della fetta corrente$/;"	m	class:vcg::tri::Resampler::Walker
_x_ns	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	VertexIndex *_x_ns; \/\/ indici dell'intersezioni della superficie lungo gli Xedge della prossima fetta $/;"	m	class:Walker
_x_ns	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    VertexIndex *_x_ns; \/\/ indici dell'intersezioni della superficie lungo gli Xedge della prossima fetta$/;"	m	class:vcg::tri::TrivialWalker
_x_ns	vcglib/vcg/complex/algorithms/create/resampler.h	/^		VertexIndex *_x_ns; \/\/ indici dell'intersezioni della superficie lungo gli Xedge della prossima fetta$/;"	m	class:vcg::tri::Resampler::Walker
_y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double _y[37];$/;"	m	struct:thurber_functor	file:
_y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double thurber_functor::_y[37] = { 80.574E0, 84.248E0, 87.264E0, 87.195E0, 89.076E0, 89.608E0, 89.868E0, 90.101E0, 92.405E0, 95.854E0, 100.696E0, 101.060E0, 401.672E0, 390.724E0, 567.534E0, 635.316E0, 733.054E0, 759.087E0, 894.206E0, 990.785E0, 1090.109E0, 1080.914E0, 1122.643E0, 1178.351E0, 1260.531E0, 1273.514E0, 1288.339E0, 1327.543E0, 1353.863E0, 1414.509E0, 1425.208E0, 1421.384E0, 1442.962E0, 1464.350E0, 1468.705E0, 1447.894E0, 1457.628E0};$/;"	m	class:thurber_functor	file:
_y_cs	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	VertexIndex	*_y_cs; \/\/ indici dell'intersezioni della superficie lungo gli Yedge della fetta corrente$/;"	m	class:Walker
_y_cs	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    VertexIndex	*_y_cs; \/\/ indici dell'intersezioni della superficie lungo gli Yedge della fetta corrente$/;"	m	class:vcg::tri::TrivialWalker
_y_cs	vcglib/vcg/complex/algorithms/create/resampler.h	/^		VertexIndex	*_y_cs; \/\/ indici dell'intersezioni della superficie lungo gli Yedge della fetta corrente$/;"	m	class:vcg::tri::Resampler::Walker
_z_cs	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	VertexIndex *_z_cs; \/\/ indici dell'intersezioni della superficie lungo gli Zedge della fetta corrente$/;"	m	class:Walker
_z_cs	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    VertexIndex *_z_cs; \/\/ indici dell'intersezioni della superficie lungo gli Zedge della fetta corrente$/;"	m	class:vcg::tri::TrivialWalker
_z_cs	vcglib/vcg/complex/algorithms/create/resampler.h	/^		VertexIndex *_z_cs; \/\/ indici dell'intersezioni della superficie lungo gli Zedge della fetta corrente$/;"	m	class:vcg::tri::Resampler::Walker
_z_ns	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	VertexIndex *_z_ns; \/\/ indici dell'intersezioni della superficie lungo gli Zedge della prossima fetta $/;"	m	class:Walker
_z_ns	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    VertexIndex *_z_ns; \/\/ indici dell'intersezioni della superficie lungo gli Zedge della prossima fetta$/;"	m	class:vcg::tri::TrivialWalker
_z_ns	vcglib/vcg/complex/algorithms/create/resampler.h	/^		VertexIndex *_z_ns; \/\/ indici dell'intersezioni della superficie lungo gli Zedge della prossima fetta$/;"	m	class:vcg::tri::Resampler::Walker
_zp	vcglib/vcg/connectors/hedge_component.h	/^  int _zp ;    $/;"	m	class:vcg::hedge::HFAdj
_zp	vcglib/vcg/connectors/hedge_component.h	/^  int _zp[2] ;    $/;"	m	class:vcg::hedge::HHAdj
_zp	vcglib/vcg/simplex/edge/component.h	/^	int _zp[2] ;$/;"	m	class:vcg::edge::VEAdj
_zp	vcglib/vcg/simplex/edge/component.h	/^  int _zp ;$/;"	m	class:vcg::edge::EFAdj
_zp	vcglib/vcg/simplex/edge/component.h	/^  int _zp[2] ;$/;"	m	class:vcg::edge::EEAdj
_zp	vcglib/vcg/simplex/face/component_ocf.h	/^  char _zp[3] ;$/;"	m	struct:vcg::face::vector_ocf::AdjTypePack
_zp	vcglib/vcg/simplex/vertex/component.h	/^	int _zp ;$/;"	m	class:vcg::vertex::VHAdj
_zp	vcglib/vcg/simplex/vertex/component.h	/^	int _zp ;$/;"	m	class:vcg::vertex::VTAdj
_zp	vcglib/vcg/simplex/vertex/component.h	/^    int _zp ;$/;"	m	class:vcg::vertex::VFAdj
_zp	vcglib/vcg/simplex/vertex/component.h	/^  int _zp ;$/;"	m	class:vcg::vertex::VEAdj
_zp	vcglib/vcg/simplex/vertex/component_occ.h	/^  int _zp ;    $/;"	m	class:vcg::vertex::VFAdjOcc
_zp	vcglib/vcg/simplex/vertex/component_ocf.h	/^	int _zp ;$/;"	m	struct:vcg::vertex::vector_ocf::VFAdjType
a	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	m	struct:Eigen::internal::has_none
a	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	m	struct:Eigen::internal::has_std_result_type
a	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	m	struct:Eigen::internal::has_tr1_result
a	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  enum { a = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon437
a	vcglib/vcg/complex/algorithms/smooth.h	/^    unsigned int a;$/;"	m	class:vcg::tri::Smooth::ColorSmoothInfo
a	vcglib/vcg/complex/algorithms/update/color.h	/^    unsigned int a;$/;"	m	class:vcg::tri::UpdateColor::ColorAvgInfo
a	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double& a() { return data[0];}$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
a	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double& a() { return data[0];}$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
a	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& a() { return data[0];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
a	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  ScalarType a;$/;"	m	struct:vcg::tri::VoronoiProcessing::QuadricSumDistance
a	vcglib/vcg/math/matrix33.h	/^    S a[9];$/;"	m	class:vcg::Matrix33
a	vcglib/vcg/math/quadric.h	/^	ScalarType a[6];		\/\/ Matrice 3x3 simmetrica: a11 a12 a13 a22 a23 a33$/;"	m	class:vcg::math::Quadric
a	vcglib/vcg/math/quadric5.h	/^	ScalarType a[15];$/;"	m	class:vcg::Quadric5
abort	vcglib/wrap/gcache/cache.h	/^    virtual void abort() {}$/;"	f	class:vcg::Cache
abs	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs, Scalar) abs(const Scalar& x)$/;"	f	namespace:Eigen::internal
abs	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs() const$/;"	f	class:Eigen::Cwise
abs	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^abs() const$/;"	f
abs	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal abs(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
abs2	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs2, Scalar) abs2(const Scalar& x)$/;"	f	namespace:Eigen::internal
abs2	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs2() const$/;"	f	class:Eigen::Cwise
abs2	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^abs2() const$/;"	f
abs2_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct abs2_impl$/;"	s	namespace:Eigen::internal
abs2_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct abs2_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
abs2_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct abs2_retval$/;"	s	namespace:Eigen::internal
absDeterminant	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR
absDeterminant	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR
absDeterminant	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::HouseholderQR
absDiagIndex	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index absDiagIndex() const { return m_index.value()>0 ? m_index.value() : -m_index.value(); }$/;"	f	class:Eigen::Diagonal
absDistance	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { return ei_abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane
absDistance	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { return internal::abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane
absGreatestRealRoot	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& absGreatestRealRoot($/;"	f	class:Eigen::PolynomialSolverBase
absSmallestRealRoot	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& absSmallestRealRoot($/;"	f	class:Eigen::PolynomialSolverBase
abs_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct abs_impl$/;"	s	namespace:Eigen::internal
abs_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct abs_retval$/;"	s	namespace:Eigen::internal
acc	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits
acc	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits
acc	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const Scalar& c, const Scalar& alpha, Scalar& r) const { r += alpha * c; }$/;"	f	class:Eigen::internal::gebp_traits
accX	vcglib/wrap/gui/trackmode.h	/^	float accX, accY, accZ, dumping, topSpeedH, topSpeedV;$/;"	m	class:vcg::NavigatorWasdMode
accY	vcglib/wrap/gui/trackmode.h	/^	float accX, accY, accZ, dumping, topSpeedH, topSpeedV;$/;"	m	class:vcg::NavigatorWasdMode
accZ	vcglib/wrap/gui/trackmode.h	/^	float accX, accY, accZ, dumping, topSpeedH, topSpeedV;$/;"	m	class:vcg::NavigatorWasdMode
accessors_level	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct accessors_level$/;"	s	namespace:Eigen::internal
acos	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^acos() const$/;"	f
acos	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal acos (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
acosf	vcglib/vcg/math/base.h	/^    float acosf  (float v) {return acos(v);}$/;"	f
acosh	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal acosh  (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
acot	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal acot (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
acoth	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal acoth (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
acquire	vcglib/wrap/glw/context.h	/^		bool acquire(void)$/;"	f	class:glw::Context
acquire	vcglib/wrap/system/multithreading/semaphore.h	/^  void acquire(int n=1)$/;"	f	class:mt::semaphore
acsc	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal acsc (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
acsch	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal acsch (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
active	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  bool active; \/\/keep tracks of wether it is in front or in deads$/;"	m	class:vcg::tri::FrontEdge
active	vcglib/wrap/gl/tetramesh.h	/^			bool active;$/;"	m	class:vcg::tetra::GlTetramesh::ClipPlane
actred	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar actred, prered;$/;"	m	class:Eigen::HybridNonLinearSolver
actred	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
actual_df	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^    int actual_df(const VectorXd &x, MatrixXd &fjac) const$/;"	f	struct:my_functor
adaptiveRadiusFlag	vcglib/vcg/complex/algorithms/point_sampling.h	/^  bool adaptiveRadiusFlag;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
add1000Faces	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::add1000Faces() { $/;"	f	class:GLArea
add100Faces	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::add100Faces() { $/;"	f	class:GLArea
add10Faces	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::add10Faces() { $/;"	f	class:GLArea
addAll	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::addAll() { $/;"	f	class:GLArea
addArgument	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addArgument(const QString &name, const QString &description, Option option) {$/;"	f	class:GetOpt
addArgument	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addArgument(const QString &name, const QString &description, QString *v) {$/;"	f	class:GetOpt
addArgument	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addArgument(const QString &name, const QString &description, QVariant *v) {$/;"	f	class:GetOpt
addArgument	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addArgument(const QString &name, const QString &description, bool *v) {$/;"	f	class:GetOpt
addArgument	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addArgument(const QString &name, const QString &description, double *v) {$/;"	f	class:GetOpt
addArgument	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addArgument(const QString &name, const QString &description, int *v) {$/;"	f	class:GetOpt
addCache	vcglib/wrap/gcache/controller.h	/^  void addCache(Cache<Token> *cache) {$/;"	f	class:vcg::Controller
addClass	vcglib/apps/trimeshinfo/ClassesNode.h	/^void ClassesNode::addClass(ClassNode* cn)$/;"	f	class:ClassesNode
addClasses	vcglib/apps/trimeshinfo/XMLTree.h	/^void XMLTree::addClasses(ClassNode* cn)$/;"	f	class:XMLTree
addEntry	vcglib/apps/trimeshinfo/SlotsNode.h	/^void OwnSlotNode::addEntry(EntryNode en)$/;"	f	class:OwnSlotNode
addEntryCmplx	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void addEntryCmplx(unsigned int i, unsigned int j, Cmplx val) {         $/;"	f	class:SparseMatrixData
addEntryReal	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void addEntryReal(unsigned int i, unsigned int j, double val) {         $/;"	f	class:SparseMatrixData
addFace	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::addFace() { $/;"	f	class:GLArea
addFace	vcglib/apps/pivoting/pivot.h	/^    int addFace() {$/;"	f	class:vcg::tri::Pivot
addFace	vcglib/apps/pivoting/pivot.h	/^    void addFace(int a, int b, int c) {$/;"	f	class:vcg::tri::Pivot
addHeaders	vcglib/apps/trimeshinfo/XMLTree.h	/^void MainNode::addHeaders(const char* str, const char*val)$/;"	f	class:MainNode
addHeaders	vcglib/apps/trimeshinfo/XMLTree.h	/^void XMLTree::addHeaders(const char* str, const char*val)$/;"	f	class:XMLTree
addInstance	vcglib/apps/trimeshinfo/InstancesNode.h	/^void InstancesNode::addInstance(InstanceNode* in)$/;"	f	class:InstancesNode
addInstances	vcglib/apps/trimeshinfo/XMLTree.h	/^void XMLTree::addInstances(InstanceNode* in)$/;"	f	class:XMLTree
addNewEdge	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  std::list<FrontEdge>::iterator addNewEdge(FrontEdge e) {$/;"	f	class:vcg::tri::AdvancingFront
addNode	vcglib/apps/trimeshinfo/Node.h	/^void NodeGroup::addNode(Node* nd)$/;"	f	class:NodeGroup
addNode	vcglib/apps/trimeshinfo/XMLTree.h	/^void XMLTree::addNode(const char* s, int value_type, const char* name)$/;"	f	class:XMLTree
addOption	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addOption(char s, const QString &longname, const QString &description, QString *v) {$/;"	f	class:GetOpt
addOption	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addOption(char s, const QString &longname, const QString &description, bool *v) {$/;"	f	class:GetOpt
addOption	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addOption(char s, const QString &longname, const QString &description, double *v) {$/;"	f	class:GetOpt
addOption	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addOption(char s, const QString &longname, const QString &description, int *v) {$/;"	f	class:GetOpt
addOption	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addOption(char s, const QString &name, const QString &description, QVariant *v ) {$/;"	f	class:GetOpt
addOptionalArgument	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addOptionalArgument(const QString &name, const QString &description, QVariant *v) {$/;"	f	class:GetOpt
addOwnSlot	vcglib/apps/trimeshinfo/ClassesNode.h	/^void OwnSlotsNode::addOwnSlot(NodeGroup* ng)$/;"	f	class:OwnSlotsNode
addOwnSlot	vcglib/apps/trimeshinfo/ClassesNode.h	/^void OwnSlotsNode::addOwnSlot(OwnSlotNode* os)$/;"	f	class:OwnSlotsNode
addOwnSlot	vcglib/apps/trimeshinfo/SlotsNode.h	/^void SlotNode::addOwnSlot(OwnSlotNode* os)$/;"	f	class:SlotNode
addOwnSlots	vcglib/apps/trimeshinfo/ClassesNode.h	/^void ClassNode::addOwnSlots(OwnSlotsNode* sn)$/;"	f	class:ClassNode
addOwnSlots	vcglib/apps/trimeshinfo/InstancesNode.h	/^void InstanceNode::addOwnSlots(OwnSlotsNode* sn)$/;"	f	class:InstanceNode
addPoint	vcglib/vcg/space/rasterized_outline2_packer.h	/^    void addPoint(Point2f& newpoint) { points.push_back(newpoint); }$/;"	f	class:vcg::RasterizedOutline2
addRHSCmplx	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void addRHSCmplx(unsigned int i, Cmplx val) { $/;"	f	class:SparseSystemData
addSlot	vcglib/apps/trimeshinfo/SlotsNode.h	/^void SlotsNode::addSlot(SlotNode* sn)$/;"	f	class:SlotsNode
addSlots	vcglib/apps/trimeshinfo/XMLTree.h	/^void XMLTree::addSlots(SlotNode* sn)$/;"	f	class:XMLTree
addSwitch	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::addSwitch(char s, const QString &name, const QString &description, bool *b ) {$/;"	f	class:GetOpt
addTo	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    void addTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase
addTo	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void addTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
addTo	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    inline void addTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:Eigen::ScaledProduct
addTo	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    inline void addTo(Dest& dst) const { scaleAndAddTo(dst,Scalar(1)); }$/;"	f	class:Eigen::ProductBase
addToken	vcglib/wrap/gcache/controller.h	/^  bool addToken(Token *token) {$/;"	f	class:vcg::Controller
addTot	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::addTot() { $/;"	f	class:GLArea
addValue	vcglib/apps/trimeshinfo/SlotsNode.h	/^void EntryNode::addValue(ValueNode vn)$/;"	f	class:EntryNode
addVector	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^void Zonohedron<Scalar>::addVector(Scalar x, Scalar y, Scalar z) {$/;"	f	class:vcg::tri::Zonohedron
addVector	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^void Zonohedron<Scalar>::addVector(Zonohedron<Scalar>::Vec3 v){$/;"	f	class:vcg::tri::Zonohedron
addVectors	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^void Zonohedron<Scalar>::addVectors(std::vector< Zonohedron<Scalar>::Vec3 > input){$/;"	f	class:vcg::tri::Zonohedron
addVertex	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline void addVertex(const typename MESH_TYPE::VertexType &v, LScalar w) {$/;"	f	struct:vcg::tri::Centroid
addVertex	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline void addVertex(const typename MESH_TYPE::VertexType &v, LScalar w) {$/;"	f	struct:vcg::tri::LS3Projection
add_const	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	s	namespace:Eigen::internal
add_const	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type_if_arithmetic	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^template<typename T> struct add_const_on_value_type_if_arithmetic$/;"	s	namespace:Eigen::internal
add_face	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static FacePointer add_face(MeshType &m, vector<VertexPointer> &vps)$/;"	f	class:vcg::tri::HalfEdgeTopology
add_face_unsafe	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static FacePointer add_face_unsafe(MeshType &m, vector<VertexPointer> &vps)$/;"	f	class:vcg::tri::HalfEdgeTopology
add_face_unsafe	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static FacePointer add_face_unsafe(MeshType &m, vector<VertexPointer> &vps, vector<HEdgePointer> &hps, vector<bool> &non_manifold_vertices)$/;"	f	class:vcg::tri::HalfEdgeTopology
add_faces	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static void add_faces(queue<FacePointer> &q, VertexPointer vp)$/;"	f	class:vcg::tri::HalfedgeQuadClean
add_segment	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {$/;"	f	file:
address	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    const_pointer address( const_reference value ) const$/;"	f	class:Eigen::aligned_allocator
address	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    pointer address( reference value ) const$/;"	f	class:Eigen::aligned_allocator
adjoint	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^MatrixBase<Derived>::adjoint() const$/;"	f	class:Eigen::MatrixBase
adjoint	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<const typename MatrixType::AdjointReturnType,TransposeMode> adjoint() const$/;"	f	class:Eigen::TriangularView
adjoint	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType adjoint() const$/;"	f	class:Eigen::HouseholderSequence
adjoint	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation adjoint() const { return JacobiRotation(internal::conj(m_c), -m_s); }$/;"	f	class:Eigen::JacobiRotation
adjoint	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const AdjointReturnType adjoint() const { return transpose(); }$/;"	f	class:Eigen::SparseMatrixBase
adjointInPlace	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^inline void MatrixBase<Derived>::adjointInPlace()$/;"	f	class:Eigen::MatrixBase
adjust_range_and_save_PGM	vcglib/wrap/qt/img_qt_io.h	/^inline bool adjust_range_and_save_PGM(const Image<1,ScalarType,Safe> &range_0_1_image, const QString filename)$/;"	f	namespace:img
adjust_range_and_save_RGB	vcglib/wrap/qt/img_qt_io.h	/^inline bool adjust_range_and_save_RGB(const Image<3,ScalarType,Safe> &range_0_1_image, const QString filename)$/;"	f	namespace:img
adjust_range_and_save_Y	vcglib/wrap/qt/img_qt_io.h	/^inline bool adjust_range_and_save_Y(const Image<1,ScalarType,Safe> &range_0_1_image, const QString filename)$/;"	f	namespace:img
adolc_forward_jacobian	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^template<typename Func> void adolc_forward_jacobian(const Func& f)$/;"	f
affine	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline AffinePart affine() { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform
affine	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline ConstAffinePart affine() const { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform
agm	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^const mpreal agm (const mpreal& v1, const mpreal& v2, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
ai	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal ai(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
align_as_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define align_as_chunk(/;"	d	file:
align_offset	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define align_offset(/;"	d	file:
aligned_allocator	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    aligned_allocator( const aligned_allocator& )$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    aligned_allocator( const aligned_allocator<U>& )$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    aligned_allocator()$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^class aligned_allocator$/;"	c	namespace:Eigen
aligned_allocator_indirection	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<T>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection& ) : EIGEN_ALIGNED_ALLOCATOR<T>() {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^  class aligned_allocator_indirection : public EIGEN_ALIGNED_ALLOCATOR<T>$/;"	c	namespace:Eigen
aligned_delete	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T> inline void aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal
aligned_free	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
aligned_malloc	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void* aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal
aligned_new	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T> inline T* aligned_new(size_t size)$/;"	f	namespace:Eigen::internal
aligned_realloc	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal
aligned_stack_memory_handler	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    aligned_stack_memory_handler(T* ptr, size_t size, bool dealloc)$/;"	f	class:Eigen::internal::aligned_stack_memory_handler
aligned_stack_memory_handler	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T> class aligned_stack_memory_handler$/;"	c	namespace:Eigen::internal
alignedvector3	vcglib/eigenlib/unsupported/test/alignedvector3.cpp	/^void alignedvector3()$/;"	f
alignment	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    alignment = (Derived::Flags & AlignedBit) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon231
all	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::all() const$/;"	f	class:Eigen::DenseBase
all	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_all>::Type all() const$/;"	f	class:Eigen::VectorwiseOp
allF	vcglib/vcg/complex/algorithms/nring.h	/^    std::vector<FaceType*> allF;$/;"	m	class:vcg::tri::Nring
allTr	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    std::vector<vcg::Matrix44f> allTr;\/\/ tutte le trasformazioni provate$/;"	m	class:vcg::tri::FourPCS
allV	vcglib/vcg/complex/algorithms/nring.h	/^    std::vector<VertexType*> allV;$/;"	m	class:vcg::tri::Nring
all_unroller	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller$/;"	s	namespace:Eigen::internal
all_unroller	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, 1>$/;"	s	namespace:Eigen::internal
all_unroller	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
allocate	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    pointer allocate( size_type num, const void* hint = 0 )$/;"	f	class:Eigen::aligned_allocator
allocate	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, QRPreconditioner>&) {}$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD
allocateA	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateA() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateA	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateA()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateAll	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateAll() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateAll	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateAll()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateB	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateB() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateB	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateB()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateW	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateW() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateW	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateW()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocatedSize	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline size_t allocatedSize() const { return m_allocatedSize; }$/;"	f	class:Eigen::internal::CompressedStorage
allocatedSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index allocatedSize() const {$/;"	f	class:Eigen::SkylineStorage
alloclist	vcglib/wrap/ply/plylib.h	/^	int alloclist;		  \/\/ 1 se alloca lista, 0 se preallocata$/;"	m	class:vcg::ply::PropDescriptor
allowUnlimitedArguments	vcglib/wrap/system/qgetopt.h	/^  void allowUnlimitedArguments(bool allow) { unlimitedArgs = allow; }$/;"	f	class:GetOpt
almostEqual	vcglib/img/img_scalar.h	/^inline bool almostEqual(ScalarType a, ScalarType b, ScalarType EPSILON=ScalarType(10e-5))$/;"	f	namespace:img
alpha	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    const Scalar& alpha() const { return m_alpha; }$/;"	f	class:Eigen::ScaledProduct
alpha	vcglib/wrap/gui/trackmode.h	/^  float alpha, beta; \/\/rotation in y and x axis$/;"	m	class:vcg::NavigatorWasdMode
alpha	vcglib/wrap/gui/trackmode.h	/^ float alpha, beta; \/\/rotation in y and x axis$/;"	m	class:vcg::PolarMode
alpha	vcglib/wrap/miq/quadrangulator.h	/^        ScalarType alpha;$/;"	m	struct:Quadrangulator::SplitMidPoint
altVec	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    static Vec3 altVec(int i) {$/;"	f	class:vcg::tri::Zonohedron
always_void	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	s	namespace:Eigen::internal
ambi	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^float ambi=.2;$/;"	v
amd_flip	vcglib/eigenlib/Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_flip(const T& i) { return -i-2; }$/;"	f	namespace:Eigen::internal
amd_mark	vcglib/eigenlib/Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline void amd_mark(const T0* w, const T1& j) { return w[j] = amd_flip(w[j]); }$/;"	f	namespace:Eigen::internal
amd_marked	vcglib/eigenlib/Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline bool amd_marked(const T0* w, const T1& j) { return w[j]<0; }$/;"	f	namespace:Eigen::internal
amd_unflip	vcglib/eigenlib/Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_unflip(const T& i) { return i<0 ? amd_flip(i) : i; }$/;"	f	namespace:Eigen::internal
analyzePattern	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
analyzePattern	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& analyzePattern(const MatType& )$/;"	f	class:Eigen::DiagonalPreconditioner
analyzePattern	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& analyzePattern(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
analyzePattern	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::analyzePattern(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
analyzePattern	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& analyzePattern(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase
analyzePattern	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
analyzePattern	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
analyzePattern	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
analyzePattern	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::analyzePattern(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
analyzePattern	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
analyzePattern	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky
analyzePattern	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT
analyzePattern	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT
analyzePattern	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase
analyzePattern	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& \/*matrix*\/)$/;"	f	class:Eigen::SuperLUBase
analyzePattern	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperILU
analyzePattern	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLU
analyzePattern	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
analyzePattern_preordered	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::analyzePattern_preordered(const CholMatrixType& ap, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase
ang	vcglib/vcg/complex/algorithms/hole.h	/^            float ang;$/;"	m	class:vcg::tri::Hole::Weight
angle	vcglib/apps/pivoting/pivot.h	/^    float angle(Point3f p, Point3f q, Point3f &axis) {$/;"	f	class:vcg::tri::Pivot
angle	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  float			angle;				\/\/ angle treshold for face deletion$/;"	v
angle	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angle	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angle	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angle	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angle	vcglib/vcg/complex/algorithms/hole.h	/^            float angle() const { return ang; }$/;"	f	class:vcg::tri::Hole::Weight
angle	vcglib/wrap/io_trimesh/import_ptx.h	/^			float angle;$/;"	m	class:vcg::tri::io::ImporterPTX::Info
angle	vcglib/wrap/qt/gl_label.h	/^      float angle;$/;"	m	class:vcg::glLabel::Mode
angleRad	vcglib/vcg/complex/algorithms/hole.h	/^  ScalarType angleRad;$/;"	m	class:vcg::tri::TrivialEar
anglecull	vcglib/wrap/io_trimesh/import_ptx.h	/^			bool anglecull;$/;"	m	class:vcg::tri::io::ImporterPTX::Info
angularDistance	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Scalar Quaternion<Scalar>::angularDistance(const Quaternion& other) const$/;"	f	class:Eigen::Quaternion
angularDistance	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::angularDistance(const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
any	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::any() const$/;"	f	class:Eigen::DenseBase
any	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_any>::Type any() const$/;"	f	class:Eigen::VectorwiseOp
any_unroller	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller$/;"	s	namespace:Eigen::internal
any_unroller	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, 1>$/;"	s	namespace:Eigen::internal
any_unroller	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
append	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    void append(const Scalar& v, Index i)$/;"	f	class:Eigen::internal::CompressedStorage
applicationName	vcglib/wrap/system/qgetopt.cpp	/^QString &GetOpt::applicationName() {$/;"	f	class:GetOpt
applyHouseholderOnTheLeft	vcglib/eigenlib/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheLeft($/;"	f	class:Eigen::MatrixBase
applyHouseholderOnTheRight	vcglib/eigenlib/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheRight($/;"	f	class:Eigen::MatrixBase
applyOnTheLeft	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
applyOnTheLeft	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase
applyOnTheRight	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^inline void MatrixBase<Derived>::applyOnTheRight(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
applyOnTheRight	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase
applyProcedure	vcglib/wrap/dae/xmldocumentmanaging.cpp	/^void XMLInteriorNode::applyProcedure(XMLVisitor& v)$/;"	f	class:XMLInteriorNode
applyProcedure	vcglib/wrap/dae/xmldocumentmanaging.cpp	/^void XMLLeafNode::applyProcedure(XMLVisitor& v)$/;"	f	class:XMLLeafNode
applyProjOnPlane	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static void applyProjOnPlane (CoordType ppn, std::vector<VertexType*> &vin, std::vector<VertexType*> *vout)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
applyThisOnTheLeft	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
applyThisOnTheLeft	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheLeft(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheLeft	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheRight	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
applyThisOnTheRight	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheRight(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheRight	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence
applyTranspositionOnTheLeft	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheLeft(Index i, Index j)$/;"	f	class:Eigen::PermutationBase
applyTranspositionOnTheRight	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheRight(Index i, Index j)$/;"	f	class:Eigen::PermutationBase
apply_block_householder_on_the_left	vcglib/eigenlib/Eigen/src/Householder/BlockHouseholder.h	/^void apply_block_householder_on_the_left(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal
apply_rotation_in_the_plane	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^void \/*EIGEN_DONT_INLINE*\/ apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)$/;"	f	namespace:Eigen::internal
appname	vcglib/wrap/system/qgetopt.h	/^  QString appname;          \/\/application name$/;"	m	class:GetOpt
ar	vcglib/vcg/complex/algorithms/hole.h	/^            float ar;$/;"	m	class:vcg::tri::Hole::Weight
area	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static float area(vector<VertexPointer> &vertices)$/;"	f	class:vcg::tri::Homeometry
area	vcglib/vcg/complex/algorithms/hole.h	/^            float area()  const { return ar; }$/;"	f	class:vcg::tri::Hole::Weight
areaThresholdPerc	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  float areaThresholdPerc;$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
area_S1	vcglib/apps/metro/sampling.h	/^    double          area_S1;$/;"	m	class:vcg::Sampling
arena	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MALLINFO_FIELD_TYPE arena;    \/* non-mmapped space allocated from system *\/$/;"	m	struct:mallinfo	file:
arena	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^  MALLINFO_FIELD_TYPE arena;    \/* non-mmapped space allocated from system *\/$/;"	m	struct:mallinfo
argc	vcglib/wrap/system/getopt.cpp	/^     int argc;$/;"	v
args	vcglib/wrap/system/qgetopt.h	/^  QStringList args;         \/\/original argument vector$/;"	m	class:GetOpt
arguments	vcglib/wrap/glw/framebuffer.h	/^		const FramebufferArguments & arguments(void) const$/;"	f	class:glw::Framebuffer
arguments	vcglib/wrap/glw/framebuffer.h	/^		const FramebufferArguments & arguments(void) const$/;"	f	class:glw::SafeFramebuffer
arguments	vcglib/wrap/glw/program.h	/^		const ProgramArguments & arguments(void) const$/;"	f	class:glw::Program
arguments	vcglib/wrap/glw/program.h	/^		const ProgramArguments & arguments(void) const$/;"	f	class:glw::SafeProgram
arguments	vcglib/wrap/system/qgetopt.h	/^  QStringList arguments;    \/\/arbitrary long list of arguments if unlimitedArgs is true$/;"	m	class:GetOpt
argv	vcglib/wrap/system/getopt.cpp	/^     char **argv;$/;"	v
array	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    ArrayBase<Derived>& array() { return *this; }$/;"	f	class:Eigen::ArrayBase
array	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    const ArrayBase<Derived>& array() const { return *this; }$/;"	f	class:Eigen::ArrayBase
array	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[1];$/;"	m	struct:Eigen::internal::plain_array
array	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^  T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    ArrayWrapper<Derived> array() { return derived(); }$/;"	f	class:Eigen::MatrixBase
array	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    const ArrayWrapper<const Derived> array() const { return derived(); }$/;"	f	class:Eigen::MatrixBase
array_buffers	vcglib/wrap/gl/trimesh.h	/^    unsigned int array_buffers[3];$/;"	m	class:vcg::GlTrimesh
asDiagonal	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^MatrixBase<Derived>::asDiagonal() const$/;"	f	class:Eigen::MatrixBase
asPermutation	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^const PermutationWrapper<const Derived> MatrixBase<Derived>::asPermutation() const$/;"	f	class:Eigen::MatrixBase
asSluMatrix	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^SluMatrix asSluMatrix(MatrixType& mat)$/;"	f	namespace:Eigen::internal
asec	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal asec (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
asech	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal asech (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
asin	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^asin() const$/;"	f
asin	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal asin (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
asinf	vcglib/vcg/math/base.h	/^    float asinf  (float v) {return asin(v);}$/;"	f
asinh	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal asinh  (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
aspectRatio	vcglib/vcg/complex/algorithms/hole.h	/^  typename MESH::ScalarType aspectRatio;$/;"	m	class:vcg::tri::MinimumWeightEar
assert	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define assert(/;"	d	file:
assert	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#undef assert$/;"	d	file:
assert	vcglib/wrap/ply/plylib.cpp	/^#define assert /;"	d	file:
assign	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& assign(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase
assign	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DONT_INLINE SparseVector& assign(const SparseMatrixBase<OtherDerived>& _other)$/;"	f	class:Eigen::SparseVector
assignGeneric	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline void assignGeneric(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase
assignGeneric	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline void assignGeneric(const OtherDerived& other) {$/;"	f	class:Eigen::SkylineMatrixBase
assignProduct	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    void assignProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationBase
assignProduct	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^TriangularView<MatrixType,UpLo>& TriangularView<MatrixType,UpLo>::assignProduct(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)$/;"	f	class:Eigen::TriangularView
assignTranspose	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    void assignTranspose(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase
assign_DefaultTraversal_CompleteUnrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_CompleteUnrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_InnerUnrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_InnerUnrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_LinearTraversal_CompleteUnrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_LinearTraversal_CompleteUnrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_conj_scalar_eig2mkl	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_conj_scalar_eig2mkl	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_conj_scalar_eig2mkl	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^static inline void assign_conj_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InvalidTraversal, Unrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, SliceVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_innervec_CompleteUnrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_innervec_CompleteUnrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_innervec_InnerUnrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling$/;"	s	namespace:Eigen::internal
assign_innervec_InnerUnrolling	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_scalar_eig2mkl	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_scalar_eig2mkl	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_scalar_eig2mkl	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^static inline void assign_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_selector	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,false> {$/;"	s	namespace:Eigen::internal
assign_selector	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,true> {$/;"	s	namespace:Eigen::internal
assign_selector	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,false> {$/;"	s	namespace:Eigen::internal
assign_selector	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,true> {$/;"	s	namespace:Eigen::internal
assign_traits	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct assign_traits$/;"	s	namespace:Eigen::internal
at	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar at(Index key, Scalar defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage
at	vcglib/wrap/gcache/dheap.h	/^  Item &at(int i) { return heap[i]; }$/;"	f	class:PtrDHeap
at	vcglib/wrap/gcache/dheap.h	/^  T &at(int n) { return std::vector<T>::at(n); }$/;"	f	class:DHeap
atInRange	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar atInRange(size_t start, size_t end, Index key, Scalar defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage
atWithInsertion	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& atWithInsertion(Index key, Scalar defaultValue = Scalar(0))$/;"	f	class:Eigen::internal::CompressedStorage
atan	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal atan (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
atan2	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(atan2, Scalar) atan2(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal
atan2	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^atan2(const AutoDiffScalar<DerTypeA>& a, const AutoDiffScalar<DerTypeB>& b)$/;"	f	namespace:Eigen
atan2	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal atan2 (const mpreal& y, const mpreal& x, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
atan2_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct atan2_default_impl$/;"	s	namespace:Eigen::internal
atan2_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct atan2_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
atan2_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct atan2_impl : atan2_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
atan2_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct atan2_retval$/;"	s	namespace:Eigen::internal
atan2f	vcglib/vcg/math/base.h	/^    float atan2f (float v0, float v1) {return atan2(v0,v1);}$/;"	f
atanh	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^typename MatrixType::Scalar MatrixLogarithmAtomic<MatrixType>::atanh(typename MatrixType::Scalar x)$/;"	f	class:Eigen::MatrixLogarithmAtomic
atanh	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal atanh  (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
atomicInt	vcglib/wrap/system/multithreading/atomic_int.h	/^  	typedef QAtomicInt atomicInt;$/;"	t	namespace:mt
atomicInt	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  atomicInt( int value )$/;"	f	class:mt::atomicInt
atomicInt	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  atomicInt()$/;"	f	class:mt::atomicInt
atomicInt	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^class atomicInt$/;"	c	namespace:mt
atomicInt	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  atomicInt( int value )$/;"	f	class:mt::atomicInt
atomicInt	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  atomicInt()$/;"	f	class:mt::atomicInt
atomicInt	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^class atomicInt$/;"	c	namespace:mt
attach	vcglib/wrap/glw/bookkeeping.h	/^		void attach(RefCountedObjectType * reObject)$/;"	f	class:glw::detail::ObjectSharedPointer
attachTarget	vcglib/wrap/glw/framebuffer.h	/^		bool attachTarget(GLenum target, GLenum attachment, const RenderTarget & renderTarget)$/;"	f	class:glw::Framebuffer
attachment	vcglib/wrap/gl/fbo.h	/^	GLenum attachment;$/;"	m	class:ColorRenderTarget
attr_type	vcglib/vcg/container/entries_allocation_table.h	/^typedef ATTR_TYPE attr_type;$/;"	t	struct:vcg::EntryCAT
attribute	vcglib/vcg/container/simple_temporary_data.h	/^    AttrType * attribute;$/;"	m	class:vcg::Attribute
attributeSourcePerSimplex	vcglib/wrap/dae/util_dae.h	/^		inline static QDomNode attributeSourcePerSimplex(const QDomNode n,const QDomDocument startpoint,const QString& sem)$/;"	f	class:vcg::tri::io::UtilDAE
attributes	vcglib/img/img_image.h	/^  ImgAttributes<ScalarType> attributes;$/;"	m	class:img::Image
attributes	vcglib/vcg/container/vector_occ.h	/^	std::list < CATBase<ThisType>* > attributes;$/;"	m	class:vcg::vector_occ
attrn	vcglib/vcg/complex/base.h	/^    int attrn;	\/\/ total numer of attribute created$/;"	m	class:vcg::tri::TriMesh
auto_diff_special_op	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct auto_diff_special_op<_DerType, false>$/;"	s	namespace:Eigen::internal
auto_diff_special_op	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct auto_diff_special_op<_DerType, true>$/;"	s	namespace:Eigen::internal
auxData	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^				NodeAuxDataType auxData;$/;"	m	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
aux_evalSolver	vcglib/eigenlib/unsupported/test/polynomialsolver.cpp	/^bool aux_evalSolver( const POLYNOMIAL& pols, SOLVER& psolve )$/;"	f
av0	vcglib/vcg/complex/algorithms/edge_collapse.h	/^     VFIVec av0,av1,av01;$/;"	m	struct:vcg::tri::EdgeCollapser::EdgeSet
av01	vcglib/vcg/complex/algorithms/edge_collapse.h	/^     VFIVec av0,av1,av01;$/;"	m	struct:vcg::tri::EdgeCollapser::EdgeSet
av1	vcglib/vcg/complex/algorithms/edge_collapse.h	/^     VFIVec av0,av1,av01;$/;"	m	struct:vcg::tri::EdgeCollapser::EdgeSet
available	vcglib/wrap/system/multithreading/semaphore.h	/^  int available()$/;"	f	class:mt::semaphore
avg	vcglib/vcg/math/histogram.h	/^	ScalarType avg;	\/\/! Average.$/;"	m	class:vcg::Histogram
avg	vcglib/vcg/math/histogram.h	/^	double avg;$/;"	m	class:vcg::Distribution
axis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	vcglib/wrap/gui/trackmode.h	/^  Line3fN axis;$/;"	m	class:vcg::AxisMode
axis	vcglib/wrap/gui/trackmode.h	/^  Line3fN axis;$/;"	m	class:vcg::CylinderMode
b	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^         b = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon437
b	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    Eigen::VectorXd b,x;\/\/ x and b$/;"	m	class:vcg::tri::PoissonSolver
b	vcglib/vcg/complex/algorithms/smooth.h	/^    unsigned int b;$/;"	m	class:vcg::tri::Smooth::ColorSmoothInfo
b	vcglib/vcg/complex/algorithms/update/color.h	/^    unsigned int b;$/;"	m	class:vcg::tri::UpdateColor::ColorAvgInfo
b	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double& b() { return data[1];}$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
b	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double& b() { return data[1];}$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
b	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& b() { return data[1];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
b	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  CoordType b;$/;"	m	struct:vcg::tri::VoronoiProcessing::QuadricSumDistance
b	vcglib/vcg/math/quadric.h	/^	ScalarType b[3];		\/\/ Vettore r3$/;"	m	class:vcg::math::Quadric
b	vcglib/vcg/math/quadric5.h	/^	ScalarType b[5];$/;"	m	class:vcg::Quadric5
b	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char b;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
b	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char b;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_VertAux
b	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char b;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
b	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char b;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
b	vcglib/wrap/miq/core/sparsesystemdata.h	/^  double*        b()        { return m_b       ; }$/;"	f	class:SparseSystemData
backgroundColor	vcglib/wrap/qt/Outline2ToQImage.h	/^      vcg::Color4b backgroundColor;$/;"	m	class:Outline2Dumper::Param
balance	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^void companion<_Scalar,_Deg>::balance()$/;"	f	class:Eigen::internal::companion
balanced	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^bool companion<_Scalar,_Deg>::balanced( Scalar colNorm, Scalar rowNorm,$/;"	f	class:Eigen::internal::companion
balancedR	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^bool companion<_Scalar,_Deg>::balancedR( Scalar colNorm, Scalar rowNorm,$/;"	f	class:Eigen::internal::companion
bar	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^TwBar *bar;$/;"	v
baricenter	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  Point3x baricenter;\/\/used for the first seed.  $/;"	m	class:vcg::tri::BallPivoting
base	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    Base& base() { return *static_cast<Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase
base	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    const Base& base() const { return *static_cast<const Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase
base	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  char*        base;             \/* base address *\/$/;"	m	struct:malloc_segment	file:
base	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    int base; \/\/ debug: for which base$/;"	m	struct:vcg::tri::FourPCS::Candidate
base_type	vcglib/wrap/system/multithreading/condition.h	/^		typedef void      base_type;$/;"	t	class:mt::condition
base_type	vcglib/wrap/system/multithreading/mutex.h	/^		typedef void  base_type;$/;"	t	class:mt::mutex
base_type	vcglib/wrap/system/multithreading/rw_lock.h	/^		typedef void    base_type;$/;"	t	class:mt::rw_lock
base_type	vcglib/wrap/system/multithreading/scoped_mutex_lock.h	/^            typedef void              base_type;$/;"	t	class:mt::scoped_mutex_lock
base_type	vcglib/wrap/system/multithreading/scoped_read_lock.h	/^		typedef void             base_type;$/;"	t	class:mt::scoped_read_lock
base_type	vcglib/wrap/system/multithreading/scoped_write_lock.h	/^		typedef void             base_type;$/;"	t	class:mt::scoped_write_lock
base_type	vcglib/wrap/system/multithreading/semaphore.h	/^  typedef void      base_type;$/;"	t	class:mt::semaphore
base_type	vcglib/wrap/system/multithreading/thread.h	/^            typedef void   base_type;$/;"	t	class:mt::thread
basecolor	vcglib/wrap/gui/coordinateframe.h	/^  Color4b basecolor;$/;"	m	class:vcg::CoordinateFrame
bases	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  std::vector<FourPoints> bases;		\/\/ used bases$/;"	m	class:vcg::tri::FourPCS
basisFunctionDerivatives	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    Spline<_Scalar, _Dim, _Degree>::basisFunctionDerivatives(Scalar u, DenseIndex order) const$/;"	f	class:Eigen::Spline
basisFunctionDerivativesImpl	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^  void basisFunctionDerivativesImpl(const SplineType& spline, typename SplineType::Scalar u, DenseIndex order, DerivativeType& N_)$/;"	f	namespace:Eigen
basisFunctions	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    Spline<_Scalar, _Dim, _Degree>::basisFunctions(Scalar u) const$/;"	f	class:Eigen::Spline
bb	vcglib/vcg/complex/algorithms/hole.h	/^            Box3Type  bb;$/;"	m	class:vcg::tri::Hole::Info
bbox	vcglib/vcg/complex/base.h	/^    Box3<ScalarType> bbox;$/;"	m	class:vcg::tri::TriMesh
bbox	vcglib/vcg/space/index/grid_util.h	/^	Box3x bbox;$/;"	m	class:vcg::BasicGrid
bbox	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		Box2x bbox;$/;"	m	class:vcg::BasicGrid2D
bbox	vcglib/wrap/dae/poly_triangulator.h	/^		vcg::Box3<float> bbox;$/;"	m	class:vcg::tri::io::PolygonalMesh
bbox_factor	vcglib/apps/metro/sampling.h	/^		float bbox_factor                  ;$/;"	m	class:vcg::Sampling
bboxcacheext	vcglib/wrap/ply/plystuff.h	/^const char * bboxcacheext = ".bbox_cache";$/;"	m	namespace:vcg::ply
bboxheader	vcglib/wrap/ply/plystuff.h	/^const char * bboxheader = "BBOXCACH";$/;"	m	namespace:vcg::ply
begin	vcglib/apps/pivoting/ring.h	/^  iterator begin() {$/;"	f	class:ring
begin	vcglib/vcg/container/simple_temporary_data.h	/^    bool * begin() const {return data;}$/;"	f	class:vcg::VectorNBW
begin	vcglib/vcg/space/index/octree.h	/^        int begin;$/;"	m	struct:vcg::Voxel
begin	vcglib/wrap/gcache/cache.h	/^    virtual void begin() {}$/;"	f	class:vcg::Cache
begin_action	vcglib/wrap/gui/trackmode.h	/^  bool begin_action;$/;"	m	class:vcg::AreaMode
begin_cb	vcglib/wrap/gl/glu_tesselator.h	/^        static void CALLBACK begin_cb(GLenum type, void * polygon_data)$/;"	f	class:vcg::glu_tesselator
begin_read_color	vcglib/wrap/gl/gl_surface.h	/^		bool begin_read_color(int attachment)$/;"	f	class:vcg::gl_surface
begin_read_depth	vcglib/wrap/gl/gl_surface.h	/^		bool begin_read_depth(void)$/;"	f	class:vcg::gl_surface
begin_write	vcglib/wrap/gl/gl_surface.h	/^		bool begin_write(void)$/;"	f	class:vcg::gl_surface
besselj0	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal besselj0 (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
besselj1	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal besselj1 (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
besseljn	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal besseljn (long n, const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
bessely0	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal bessely0 (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
bessely1	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal bessely1 (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
besselyn	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal besselyn (long n, const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
bestDist	vcglib/vcg/complex/algorithms/clustering.h	/^  ScalarType bestDist;$/;"	m	class:vcg::tri::NearestToCenter
bestN	vcglib/vcg/complex/algorithms/clustering.h	/^  CoordType bestN;$/;"	m	class:vcg::tri::NearestToCenter
bestPos	vcglib/vcg/complex/algorithms/clustering.h	/^  CoordType bestPos;$/;"	m	class:vcg::tri::NearestToCenter
bestSampleChoiceFlag	vcglib/vcg/complex/algorithms/point_sampling.h	/^  bool bestSampleChoiceFlag; \/\/ In poisson disk pruning when we choose a sample in a cell, we choose the sample that remove the minimal number of other samples. This previlege the "on boundary" samples.$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
bestSamplePoolSize	vcglib/vcg/complex/algorithms/point_sampling.h	/^  int bestSamplePoolSize;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
bestScore	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        int bestScore;                                  \/\/\/< Score to overcome to paint \\c mMov . If overlap estimation is called many times inside a loop, you can set this value in each iteration to paint \\c mMov and see only the best overlap achived.$/;"	m	class:OverlapEstimation::Parameters
best_flip	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static FlipType best_flip( HEdgePointer hp)$/;"	f	class:vcg::tri::Homeometry
best_flip	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static FlipType best_flip( HEdgePointer hp)$/;"	f	class:vcg::tri::VertReg
bestored	vcglib/wrap/ply/plylib.h	/^	int	   bestored;			\/\/ 1 se va storata$/;"	m	class:vcg::ply::PlyProperty
beta	vcglib/vcg/complex/algorithms/refine_loop.h	/^	Scalar beta;$/;"	m	struct:vcg::tri::LS3Projection
beta	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE beta(int k) {$/;"	f	struct:vcg::tri::ContinuityLoopWeight
beta	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE beta(int k) {$/;"	f	struct:vcg::tri::LoopWeight
beta	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE beta(int k) {$/;"	f	struct:vcg::tri::RegularLoopWeight
beta	vcglib/wrap/gui/trackmode.h	/^  float alpha, beta; \/\/rotation in y and x axis$/;"	m	class:vcg::NavigatorWasdMode
beta	vcglib/wrap/gui/trackmode.h	/^ float alpha, beta; \/\/rotation in y and x axis$/;"	m	class:vcg::PolarMode
bfly2	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void bfly2( Complex * Fout, const size_t fstride, int m)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
bfly3	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void bfly3( Complex * Fout, const size_t fstride, const size_t m)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
bfly4	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void bfly4( Complex * Fout, const size_t fstride, const size_t m)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
bfly5	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void bfly5( Complex * Fout, const size_t fstride, const size_t m)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
bfly_generic	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void bfly_generic($/;"	f	struct:Eigen::internal::kiss_cpx_fft
bicgstab	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^bool bicgstab(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
bidiagonal	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    const BidiagonalType& bidiagonal() const { return m_bidiagonal; }$/;"	f	class:Eigen::internal::UpperBidiagonalization
bin_find	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static int bin_find(mstate m, mchunkptr x) {$/;"	f	file:
binaryExpr	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseBinaryOps.h	/^binaryExpr(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other, const CustomBinaryOp& func = CustomBinaryOp()) const$/;"	f
binary_result_of_select	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	s	namespace:Eigen::internal
binary_result_of_select	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_std_result_type)>$/;"	s	namespace:Eigen::internal
binary_result_of_select	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_tr1_result)>$/;"	s	namespace:Eigen::internal
bind	vcglib/wrap/glw/buffer.h	/^		virtual void bind(void)$/;"	f	class:glw::BoundBuffer
bind	vcglib/wrap/glw/buffer.h	/^		virtual void bind(void)$/;"	f	class:glw::BoundFeedbackBuffer
bind	vcglib/wrap/glw/buffer.h	/^		virtual void bind(void)$/;"	f	class:glw::BoundUniformBuffer
bind	vcglib/wrap/glw/context.h	/^		typename BindingHandleFromBinding<TBinding>::Type bind(typename SafeHandleFromBinding<TBinding>::Type & h, const typename detail::ParamsOf<TBinding>::Type & params = typename detail::ParamsOf<TBinding>::Type())$/;"	f	class:glw::Context
bind	vcglib/wrap/glw/framebuffer.h	/^		virtual void bind(void)$/;"	f	class:glw::BoundFramebuffer
bind	vcglib/wrap/glw/program.h	/^		virtual void bind(void)$/;"	f	class:glw::BoundProgram
bind	vcglib/wrap/glw/renderbuffer.h	/^		virtual void bind(void)$/;"	f	class:glw::BoundRenderbuffer
bind	vcglib/wrap/glw/shader.h	/^		virtual void bind(void)$/;"	f	class:glw::BoundShader
bind	vcglib/wrap/glw/texture.h	/^		virtual void bind(void)$/;"	f	class:glw::BoundTexture
bindDrawFramebuffer	vcglib/wrap/glw/context.h	/^		BoundDrawFramebufferHandle bindDrawFramebuffer(FramebufferHandle & handle)$/;"	f	class:glw::Context
bindFeedbackBuffer	vcglib/wrap/glw/context.h	/^		BoundFeedbackBufferHandle bindFeedbackBuffer(BufferHandle & handle, GLuint index, GLintptr offset, GLsizeiptr size)$/;"	f	class:glw::Context
bindFragmentShader	vcglib/wrap/glw/context.h	/^		BoundFragmentShaderHandle bindFragmentShader(FragmentShaderHandle & handle)$/;"	f	class:glw::Context
bindGeometryShader	vcglib/wrap/glw/context.h	/^		BoundGeometryShaderHandle bindGeometryShader(GeometryShaderHandle & handle)$/;"	f	class:glw::Context
bindIndexBuffer	vcglib/wrap/glw/context.h	/^		BoundIndexBufferHandle bindIndexBuffer(BufferHandle & handle)$/;"	f	class:glw::Context
bindPixelPackBuffer	vcglib/wrap/glw/context.h	/^		BoundPixelPackBufferHandle bindPixelPackBuffer(BufferHandle & handle)$/;"	f	class:glw::Context
bindPixelUnpackBuffer	vcglib/wrap/glw/context.h	/^		BoundPixelUnpackBufferHandle bindPixelUnpackBuffer(BufferHandle & handle)$/;"	f	class:glw::Context
bindProgram	vcglib/wrap/glw/context.h	/^		BoundProgramHandle bindProgram(ProgramHandle & handle)$/;"	f	class:glw::Context
bindReadDrawFramebuffer	vcglib/wrap/glw/context.h	/^		BoundReadDrawFramebufferHandle bindReadDrawFramebuffer(FramebufferHandle & handle)$/;"	f	class:glw::Context
bindReadFramebuffer	vcglib/wrap/glw/context.h	/^		BoundReadFramebufferHandle bindReadFramebuffer(FramebufferHandle & handle)$/;"	f	class:glw::Context
bindRenderbuffer	vcglib/wrap/glw/context.h	/^		BoundRenderbufferHandle bindRenderbuffer(RenderbufferHandle & handle)$/;"	f	class:glw::Context
bindTexture2D	vcglib/wrap/glw/context.h	/^		BoundTexture2DHandle bindTexture2D(Texture2DHandle & handle, GLint unit)$/;"	f	class:glw::Context
bindTextureCube	vcglib/wrap/glw/context.h	/^		BoundTextureCubeHandle bindTextureCube(TextureCubeHandle & handle, GLint unit)$/;"	f	class:glw::Context
bindUniformBuffer	vcglib/wrap/glw/context.h	/^		BoundUniformBufferHandle bindUniformBuffer(BufferHandle & handle, GLuint index, GLintptr offset, GLsizeiptr size)$/;"	f	class:glw::Context
bindVertexBuffer	vcglib/wrap/glw/context.h	/^		BoundVertexBufferHandle bindVertexBuffer(BufferHandle & handle)$/;"	f	class:glw::Context
bindVertexShader	vcglib/wrap/glw/context.h	/^		BoundVertexShaderHandle bindVertexShader(VertexShaderHandle & handle)$/;"	f	class:glw::Context
bindex_t	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef unsigned int bindex_t;         \/* Described below *\/$/;"	t	file:
bindings	vcglib/wrap/glw/framebuffer.h	/^		Map bindings;$/;"	m	class:glw::RenderTargetBinding
bindings	vcglib/wrap/glw/framebuffer.h	/^		Map bindings;$/;"	m	class:glw::RenderTargetMapping
bindings	vcglib/wrap/glw/program.h	/^		Map bindings;$/;"	m	class:glw::FragmentOutputBinding
bindings	vcglib/wrap/glw/program.h	/^		Map bindings;$/;"	m	class:glw::VertexAttributeBinding
binmap_t	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef unsigned int binmap_t;         \/* Described below *\/$/;"	t	file:
binom	vcglib/eigenlib/unsupported/test/matrix_exponential.cpp	/^double binom(int n, int k)$/;"	f
bit_for_tree_index	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define bit_for_tree_index(/;"	d	file:
bits	vcglib/wrap/io_trimesh/export_idtf.h	/^		unsigned char  bits;               $/;"	m	struct:vcg::tri::io::TGA_Exporter::TGAHeader
bits2digits	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int bits2digits(mp_prec_t b)$/;"	f	namespace:mpfr
bk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  struct malloc_chunk* bk;$/;"	m	struct:malloc_chunk	typeref:struct:malloc_chunk::malloc_chunk	file:
bk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  struct malloc_tree_chunk* bk;$/;"	m	struct:malloc_tree_chunk	typeref:struct:malloc_tree_chunk::malloc_tree_chunk	file:
blas_data_mapper	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    blas_data_mapper(Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::blas_data_mapper
blas_data_mapper	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^class blas_data_mapper$/;"	c	namespace:Eigen::internal
blas_traits	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct blas_traits<SelfCwiseBinaryOp<BinOp,NestedXpr,Rhs> >$/;"	s	namespace:Eigen::internal
blas_traits	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_multiple_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<Transpose<NestedXpr> >$/;"	s	namespace:Eigen::internal
blas_traits	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<const T>$/;"	s	namespace:Eigen::internal
blas_traits	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<typename XprType> struct blas_traits$/;"	s	namespace:Eigen::internal
block	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, BlockRows, BlockCols> block(Index startRow, Index startCol)$/;"	f
block	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> block(Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f
block	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, BlockRows, BlockCols> block(Index startRow, Index startCol) const$/;"	f
block	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> block(Index startRow, Index startCol, Index blockRows, Index blockCols) const$/;"	f
block	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^Block<MatrixType> MatrixFunction<MatrixType,AtomicType,1>::block(MatrixType& A, Index i, Index j)$/;"	f	class:Eigen::MatrixFunction
blockA	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline LhsScalar* blockA() { return m_blockA; }$/;"	f	class:Eigen::internal::level3_blocking
blockB	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockB() { return m_blockB; }$/;"	f	class:Eigen::internal::level3_blocking
blockW	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockW() { return m_blockW; }$/;"	f	class:Eigen::internal::level3_blocking
blocked	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index blocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
blocked	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index blocked(MatrixType& m)$/;"	f	struct:Eigen::internal::llt_inplace
blocked_lu	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^  static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)$/;"	f	struct:Eigen::internal::partial_lu_impl
blueNorm	vcglib/eigenlib/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::MatrixBase
blueNorm	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_blueNorm,RealScalar>::Type blueNorm() const$/;"	f	class:Eigen::VectorwiseOp
boolean_value	vcglib/wrap/system/qgetopt.h	/^    bool *boolean_value;$/;"	m	struct:GetOpt::Option
bottom	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector< std::vector<int> > bottom;$/;"	m	class:vcg::RasterizedOutline2
bottomHorizon	vcglib/vcg/space/rasterized_outline2_packer.h	/^      std::vector<int>& bottomHorizon() { return mBottomHorizon; }$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
bottomLeftCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomLeftCorner()$/;"	f
bottomLeftCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> bottomLeftCorner(Index cRows, Index cCols)$/;"	f
bottomLeftCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomLeftCorner() const$/;"	f
bottomLeftCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> bottomLeftCorner(Index cRows, Index cCols) const$/;"	f
bottomRightCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomRightCorner()$/;"	f
bottomRightCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> bottomRightCorner(Index cRows, Index cCols)$/;"	f
bottomRightCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomRightCorner() const$/;"	f
bottomRightCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> bottomRightCorner(Index cRows, Index cCols) const$/;"	f
bottomRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr bottomRows(Index n) const$/;"	f
bottomRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr bottomRows(Index n)$/;"	f
bottomRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type bottomRows() const$/;"	f
bottomRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type bottomRows()$/;"	f
bound	vcglib/wrap/gl/gl_object.h	/^	bool bound;$/;"	m	class:Bindable
boundary_e	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int count_e,boundary_e,count_fd,count_uv,numholes;$/;"	m	struct:MeshInfo	file:
boundingBox	vcglib/vcg/space/index/octree_template.h	/^	BoundingBoxType				boundingBox;$/;"	m	class:vcg::OctreeTemplate
bounding_box	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^        Box2d bounding_box(const Vector2d &v) { return Box2d(v, v); } \/\/compute the bounding box of a single point$/;"	f	namespace:Eigen::internal
bounding_box	vcglib/eigenlib/unsupported/test/BVH.cpp	/^template<int Dim> AlignedBox<double, Dim> bounding_box(const Ball<Dim> &b)$/;"	f
bounding_box	vcglib/eigenlib/unsupported/test/BVH.cpp	/^template<typename Scalar, int Dim> AlignedBox<Scalar, Dim> bounding_box(const Matrix<Scalar, Dim, 1> &v) { return AlignedBox<Scalar, Dim>(v); }$/;"	f	namespace:Eigen
box	vcglib/apps/pivoting/glarea.h	/^    vcg::Box3f box;$/;"	m	class:GLArea
box	vcglib/apps/pivoting/pivot.h	/^    Box3f box;$/;"	m	class:vcg::tri::Pivot
boxCenter	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^				CoordType boxCenter;$/;"	m	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
boxFilter	vcglib/img/img_filter.h	/^inline void boxFilter(const Image<Channels,SrcScalarType,SrcSafe> &source,Image<Channels,DestScalarType,DestSafe> &destination,int radius)$/;"	f	namespace:img
boxHalfDims	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^				CoordType boxHalfDims;$/;"	m	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
box_muller	vcglib/vcg/math/random_generator.h	/^inline double box_muller(RandomGenerator &generator, double m, double s) \/* normal random variate generator *\/$/;"	f	namespace:vcg::math
boxes	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  VolumeList boxes;$/;"	m	class:Eigen::KdBVH
broadcast	vcglib/wrap/system/multithreading/condition.h	/^		void broadcast(void)$/;"	f	class:mt::condition
bruteforce_det3_helper	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^inline const typename Derived::Scalar bruteforce_det3_helper$/;"	f	namespace:Eigen::internal
bruteforce_det4_helper	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^const typename Derived::Scalar bruteforce_det4_helper$/;"	f	namespace:Eigen::internal
bubbleUp	vcglib/wrap/gcache/dheap.h	/^  void bubbleUp(int i) {$/;"	f	class:DHeap
bubbleUpMax	vcglib/wrap/gcache/dheap.h	/^  void bubbleUpMax(int i) {$/;"	f	class:DHeap
bubbleUpMin	vcglib/wrap/gcache/dheap.h	/^  void bubbleUpMin(int i) {$/;"	f	class:DHeap
bucket_size	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^			bucket_size = 4, \/\/ 0 < bucket_size$/;"	e	enum:vcg::HashFunctor2D::__anon506
bucket_size	vcglib/vcg/space/index/spatial_hashing.h	/^				bucket_size = 4, \/\/ 0 < bucket_size$/;"	e	enum:vcg::HashFunctor::__anon510
bufferMode	vcglib/wrap/glw/program.h	/^		GLenum        bufferMode;$/;"	m	class:glw::TransformFeedbackStream
build	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  void build(VIPairList &objCenters, int from, int to, const VolumeList &objBoxes, int dim)$/;"	f	class:Eigen::KdBVH
buildRandRectSet	vcglib/apps/sample/space_packer/space_packer.cpp	/^static void buildRandRectSet(int rectNum, vector<Box2f> &rectVec)$/;"	f	file:
button_mask	vcglib/wrap/gui/trackball.h	/^  int button_mask;$/;"	m	class:vcg::Trackball
byFace	vcglib/vcg/math/quadric5.h	/^  void byFace(FaceType &f, math::Quadric<double> &q1, math::Quadric<double> &q2, math::Quadric<double> &q3, bool QualityQuadric, ScalarType BorderWeight)$/;"	f	class:vcg::Quadric5
byFace	vcglib/vcg/math/quadric5.h	/^  void byFace(FaceType &fi, bool onlygeo)$/;"	f	class:vcg::Quadric5
c	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar c() const { return m_c; }$/;"	f	class:Eigen::JacobiRotation
c	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar& c() { return m_c; }$/;"	f	class:Eigen::JacobiRotation
c	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  unsigned int c;$/;"	m	struct:pthread_mlock_t	file:
c	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  unsigned int c;$/;"	m	struct:win32_mlock_t	file:
c	vcglib/vcg/complex/algorithms/clustering.h	/^  CoordType c;$/;"	m	class:vcg::tri::AverageColorCell
c	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double& c() { return data[2];}$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
c	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double& c() { return data[2];}$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
c	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& c() { return data[2];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
c	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  ScalarType c;$/;"	m	struct:vcg::tri::VoronoiProcessing::QuadricSumDistance
c	vcglib/vcg/complex/base.h	/^    Color4b c;$/;"	m	class:vcg::tri::TriMesh
c	vcglib/vcg/container/entries_allocation_table.h	/^	STL_CONT & c;$/;"	m	class:vcg::EntryCATBase
c	vcglib/vcg/container/simple_temporary_data.h	/^    STL_CONT& c;$/;"	m	class:vcg::SimpleTempData
c	vcglib/vcg/math/quadric.h	/^	ScalarType c;			\/\/ Fattore scalare (se -1 quadrica nulla)$/;"	m	class:vcg::math::Quadric
c	vcglib/vcg/math/quadric5.h	/^	ScalarType c;$/;"	m	class:vcg::Quadric5
c	vcglib/wrap/gcache/door.h	/^  QWaitCondition c;$/;"	m	class:QDoor
c	vcglib/wrap/io_trimesh/import_obj.h	/^                    Color4b c;$/;"	m	struct:vcg::tri::io::ImporterOBJ::ObjIndexedFace
c	vcglib/wrap/system/multithreading/condition.h	/^		pthread_cond_t c;$/;"	m	class:mt::condition
cC	vcglib/vcg/complex/base.h	/^    inline       Color4b cC() const { return c;  }$/;"	f	class:vcg::tri::TriMesh
cC	vcglib/vcg/simplex/edge/component.h	/^	ColorType cC() const { static ColorType dumcolor(vcg::Color4b::White);  assert(0); return dumcolor; }$/;"	f	class:vcg::edge::EmptyCore
cC	vcglib/vcg/simplex/edge/component.h	/^  const ColorType &cC() const { return _color; }$/;"	f	class:vcg::edge::Color
cC	vcglib/vcg/simplex/face/component.h	/^  ColorType cC() const { return _color; }$/;"	f	class:vcg::face::Color
cC	vcglib/vcg/simplex/face/component.h	/^  ColorType cC() const { static ColorType dumcolor(vcg::Color4b::White);  assert(0); return dumcolor; }$/;"	f	class:vcg::face::EmptyCore
cC	vcglib/vcg/simplex/face/component_ocf.h	/^  ColorType cC() const  {$/;"	f	class:vcg::face::ColorOcf
cC	vcglib/vcg/simplex/vertex/component.h	/^  ColorType cC() const { static ColorType dumcolor(vcg::Color4b::White);  assert(0); return dumcolor; }$/;"	f	class:vcg::vertex::EmptyCore
cC	vcglib/vcg/simplex/vertex/component.h	/^  inline       ColorType cC() const { return _color; }$/;"	f	class:vcg::vertex::Color
cC	vcglib/vcg/simplex/vertex/component_ocf.h	/^        ColorType cC() const { assert((*this).Base().ColorEnabled); return (*this).Base().CV[(*this).Index()]; }$/;"	f	class:vcg::vertex::ColorOcf
cEEi	vcglib/vcg/simplex/edge/component.h	/^    int cEEi(const int &) const {static int z=0; assert(0); return z;}$/;"	f	class:vcg::edge::EmptyCore
cEEi	vcglib/vcg/simplex/edge/component.h	/^  int cEEi(const int &i )const {return _zp[i];}$/;"	f	class:vcg::edge::EEAdj
cEEp	vcglib/vcg/simplex/edge/component.h	/^    typename T::EdgePointer cEEp(const int & ) const { static typename T::EdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::edge::EmptyCore
cEEp	vcglib/vcg/simplex/edge/component.h	/^  typename T::EdgePointer cEEp(const int & i) const {return _ep[i]; }$/;"	f	class:vcg::edge::EEAdj
cEFi	vcglib/vcg/simplex/edge/component.h	/^    int &cEFi() const {static int z=0; return z;}$/;"	f	class:vcg::edge::EmptyCore
cEFi	vcglib/vcg/simplex/edge/component.h	/^  int cEFi() const  {return _zp; }$/;"	f	class:vcg::edge::EFAdj
cEFp	vcglib/vcg/simplex/edge/component.h	/^    typename T::FacePointer cEFp() const  { static typename T::FacePointer fp=0;  assert(0); return fp; }$/;"	f	class:vcg::edge::EmptyCore
cEFp	vcglib/vcg/simplex/edge/component.h	/^  typename T::FacePointer cEFp() const {return _fp; }$/;"	f	class:vcg::edge::EFAdj
cEFp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer cEFp(const int j) const { assert(j>=0 && j<3);  return _efp[j]; }$/;"	f	class:vcg::face::EFAdj
cEHp	vcglib/vcg/simplex/edge/component.h	/^	const typename T::HEdgePointer cEHp( ) const {return _hp ; }$/;"	f	class:vcg::edge::EHAdj
cEHp	vcglib/vcg/simplex/edge/component.h	/^    typename T::HEdgePointer cEHp(  ) const { static typename T::HEdgePointer hp=0;  assert(0); return hp; }$/;"	f	class:vcg::edge::EmptyCore
cEdge	vcglib/vcg/simplex/face/component_ep.h	/^  typename T::VertexType::CoordType  cEdge(const int j)const {$/;"	f	class:vcg::face::EdgePlane
cEdge	vcglib/vcg/simplex/face/component_ep.h	/^typename T::VertexType::CoordType &cEdge(const int ) const { assert(0);  static typename T::VertexType::CoordType dum; return dum;}$/;"	f	class:vcg::face::EmptyEdgePlane
cFEp	vcglib/vcg/simplex/face/component.h	/^  typename T::EdgePointer cFEp( int j) const  { assert(j>=0 && j<3);  return _fep[j]; }$/;"	f	class:vcg::face::FEAdj
cFEp	vcglib/vcg/simplex/face/component.h	/^  typename T::EdgePointer cFEp(int) const { static typename T::EdgePointer fp=0; assert(0); return fp; }$/;"	f	class:vcg::face::EmptyCore
cFEp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::EdgePointer const cFEp(const int j) const  { assert(j>=0 && j<this->VN());  return _fepP[j]; }$/;"	f	class:vcg::face::PFEAdj::T
cFFi	vcglib/vcg/simplex/face/component.h	/^  char cFFi(const int j) const { return _ffi[j]; }$/;"	f	class:vcg::face::FFAdj
cFFi	vcglib/vcg/simplex/face/component.h	/^  char cFFi(int) const { static char z=0; assert(0); return z;}$/;"	f	class:vcg::face::EmptyCore
cFFi	vcglib/vcg/simplex/face/component_occ.h	/^  	char cFFi(const int j) const{$/;"	f	class:vcg::face::FFAdjOccBase
cFFi	vcglib/vcg/simplex/face/component_ocf.h	/^  char cFFi(const int j) const {$/;"	f	class:vcg::face::FFAdjOcf
cFFi	vcglib/vcg/simplex/face/component_polygon.h	/^  char  cFFi(const int j) const { return _ffiP[j]; }$/;"	f	class:vcg::face::PFFAdj
cFFp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer cFFp(const int j) const  { assert(j>=0 && j<3);  return _ffp[j]; }$/;"	f	class:vcg::face::FFAdj
cFFp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer cFFp(int) const { static typename T::FacePointer fp=0; assert(0); return fp; }$/;"	f	class:vcg::face::EmptyCore
cFFp	vcglib/vcg/simplex/face/component_occ.h	/^	FacePointer const cFFp(const int j) const {$/;"	f	class:vcg::face::FFAdjOccBase
cFFp	vcglib/vcg/simplex/face/component_ocf.h	/^  typename T::FacePointer cFFp(const int j) const {$/;"	f	class:vcg::face::FFAdjOcf
cFFp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::FacePointer  cFFp(const int j) const  { assert(j>=0 && j<this->VN());  return _ffpP[j]; }$/;"	f	class:vcg::face::PFFAdj
cFFp1	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer cFFp1( const int j ) const { return FFp((j+1)%3);}$/;"	f	class:vcg::face::FFAdj
cFFp1	vcglib/vcg/simplex/face/component_ocf.h	/^  typename T::FacePointer  cFFp1( const int j ) const { return FFp((j+1)%3);}$/;"	f	class:vcg::face::FFAdjOcf
cFFp2	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer cFFp2( const int j ) const { return FFp((j+2)%3);}$/;"	f	class:vcg::face::FFAdj
cFFp2	vcglib/vcg/simplex/face/component_ocf.h	/^  typename T::FacePointer  cFFp2( const int j ) const { return FFp((j+2)%3);}$/;"	f	class:vcg::face::FFAdjOcf
cFHp	vcglib/vcg/simplex/face/component.h	/^  typename T::HEdgePointer cFHp( ) const { return _fh; }$/;"	f	class:vcg::face::FHAdj
cFHp	vcglib/vcg/simplex/face/component.h	/^  typename T::HEdgePointer cFHp() const { static typename T::HEdgePointer fp=0; assert(0); return fp; }$/;"	f	class:vcg::face::EmptyCore
cFHp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::HEdgePointer const cFHp() const  {  return _fhP; }$/;"	f	class:vcg::face::PFHAdj::T
cFVp	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType * cFVp( const int i ) const {	return this->cV(i); }$/;"	f	class:vcg::face::EmptyCore
cFlags	vcglib/vcg/simplex/face/component.h	/^  int cFlags() const { return 0; }$/;"	f	class:vcg::face::EmptyCore
cFlags	vcglib/vcg/simplex/face/component.h	/^  int cFlags() const {return _flags; }$/;"	f	class:vcg::face::BitFlags
cFlags	vcglib/vcg/simplex/vertex/component.h	/^  inline       int cFlags() const {return _flags; }$/;"	f	class:vcg::vertex::BitFlags
cFlags	vcglib/vcg/simplex/vertex/component.h	/^  int cFlags() const { assert(0); return 0; }$/;"	f	class:vcg::vertex::EmptyCore
cH	vcglib/vcg/simplex/vertex/component_occ.h	/^	const ScalarType &cH() const { return CAT< vector_occ<VertType>,CurvatureTypeOcc>::Instance()->Get((VertType*)this)[0];}$/;"	f	class:vcg::vertex::CurvatureOcc
cHEp	vcglib/vcg/connectors/hedge_component.h	/^				const typename T::EdgePointer cHEp() const { static typename T::EdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHEAdj
cHEp	vcglib/vcg/connectors/hedge_component.h	/^        const typename T::EdgePointer cHEp() const {return _ep ; }$/;"	f	class:vcg::hedge::HEAdj
cHFp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::FacePointer cHFp() {return _fp; }$/;"	f	class:vcg::hedge::HFAdj
cHFp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::FacePointer const cHFp() const  { static typename T::FacePointer fp=0;  assert(0); return fp; }$/;"	f	class:vcg::hedge::EmptyHFAdj::T
cHHp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::EdgePointer cHHp(const int & i) {return _ep[i]; }$/;"	f	class:vcg::hedge::HHAdj
cHHp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer cHHp(const int & ) { static typename T::EdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHHAdj
cHNp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer const cHNp( ) const  { static typename T::HEdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHNextAdj::T
cHNp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer const cHNp() const {return _nep; }$/;"	f	class:vcg::hedge::HNextAdj::T
cHOp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer cHOp() {return _oep; }$/;"	f	class:vcg::hedge::HOppAdj
cHOp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer const cHOp() const { static typename T::HEdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHOppAdj::T
cHPp	vcglib/vcg/connectors/hedge_component.h	/^	typename T::HEdgePointer const cHPp() const { static typename T::HEdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHPrevAdj::T
cHPp	vcglib/vcg/connectors/hedge_component.h	/^        typename T::HEdgePointer cHPp() {return _pep; }$/;"	f	class:vcg::hedge::HPrevAdj
cHVp	vcglib/vcg/connectors/hedge_component.h	/^	const typename T::VertexPointer cHVp() const { static typename T::VertexPointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::hedge::EmptyHVAdj
cHVp	vcglib/vcg/connectors/hedge_component.h	/^	const typename T::VertexPointer cHVp() const {return _vp ; }$/;"	f	class:vcg::hedge::HVAdj
cIMark	vcglib/vcg/simplex/edge/component.h	/^    inline int cIMark() const { assert(0); static int tmp=-1; return tmp;}$/;"	f	class:vcg::edge::EmptyCore
cIMark	vcglib/vcg/simplex/face/component.h	/^  inline int cIMark() const { return 0;}$/;"	f	class:vcg::face::EmptyCore
cIMark	vcglib/vcg/simplex/face/component.h	/^  inline int cIMark() const { return _imark;}$/;"	f	class:vcg::face::Mark
cIMark	vcglib/vcg/simplex/face/component_ocf.h	/^  inline int cIMark() const {$/;"	f	class:vcg::face::MarkOcf
cIMark	vcglib/vcg/simplex/vertex/component.h	/^  inline       int cIMark() const { return _imark;}$/;"	f	class:vcg::vertex::Mark
cIMark	vcglib/vcg/simplex/vertex/component.h	/^  int cIMark()  const { assert(0); static int tmp=-1; return tmp;}$/;"	f	class:vcg::vertex::EmptyCore
cIMark	vcglib/vcg/simplex/vertex/component_ocf.h	/^  inline       int cIMark() const {  assert((*this).Base().MarkEnabled); return (*this).Base().MV[(*this).Index()]; }$/;"	f	class:vcg::vertex::MarkOcf
cK	vcglib/vcg/simplex/vertex/component_occ.h	/^	const ScalarType &cK() const { return CAT< vector_occ<VertType>,CurvatureTypeOcc>::Instance()->Get((VertType*)this)[1];}$/;"	f	class:vcg::vertex::CurvatureOcc
cK1	vcglib/vcg/simplex/face/component.h	/^  ScalarType cK1() const {return _curv.k1;}$/;"	f	class:vcg::face::CurvatureDir
cK1	vcglib/vcg/simplex/face/component.h	/^  float cK1() const { static float dummy(0); assert(0); return dummy;}$/;"	f	class:vcg::face::EmptyCore
cK1	vcglib/vcg/simplex/face/component_ocf.h	/^  ScalarType cK1() const {$/;"	f	class:vcg::face::CurvatureDirOcf
cK1	vcglib/vcg/simplex/vertex/component.h	/^	const ScalarType &cK1() const {return _curv.k1;}$/;"	f	class:vcg::vertex::CurvatureDir
cK1	vcglib/vcg/simplex/vertex/component.h	/^  ScalarType cK1() const {static ScalarType v = 0.0;assert(0);return v;}$/;"	f	class:vcg::vertex::EmptyCore
cK1	vcglib/vcg/simplex/vertex/component_occ.h	/^	const ScalarType &cK1() const {return CAT< vector_occ<VertType>,CurvatureDirTypeOcc>::Instance()->Get((VertType*)this).k1;}$/;"	f	class:vcg::vertex::CurvatureDirOcc
cK1	vcglib/vcg/simplex/vertex/component_ocf.h	/^  ScalarType cK1() const { assert((*this).Base().CurvatureDirEnabled); return (*this).Base().CuDV[(*this).Index()].k1;}$/;"	f	class:vcg::vertex::CurvatureDirOcf
cK2	vcglib/vcg/simplex/face/component.h	/^  ScalarType cK2() const {return _curv.k2;}$/;"	f	class:vcg::face::CurvatureDir
cK2	vcglib/vcg/simplex/face/component.h	/^  float cK2() const { static float dummy(0); assert(0); return dummy;}$/;"	f	class:vcg::face::EmptyCore
cK2	vcglib/vcg/simplex/face/component_ocf.h	/^  ScalarType cK2() const {$/;"	f	class:vcg::face::CurvatureDirOcf
cK2	vcglib/vcg/simplex/vertex/component.h	/^	const ScalarType &cK2() const {return _curv.k2;}$/;"	f	class:vcg::vertex::CurvatureDir
cK2	vcglib/vcg/simplex/vertex/component.h	/^  ScalarType cK2() const  {static ScalarType v = 0.0;assert(0);return v;}$/;"	f	class:vcg::vertex::EmptyCore
cK2	vcglib/vcg/simplex/vertex/component_occ.h	/^	const ScalarType &cK2()const  {return CAT< vector_occ<VertType>,CurvatureDirTypeOcc>::Instance()->Get((VertType*)this).k2;}$/;"	f	class:vcg::vertex::CurvatureDirOcc
cK2	vcglib/vcg/simplex/vertex/component_ocf.h	/^  ScalarType cK2() const { assert((*this).Base().CurvatureDirEnabled); return (*this).Base().CuDV[(*this).Index()].k2;}$/;"	f	class:vcg::vertex::CurvatureDirOcf
cKg	vcglib/vcg/simplex/vertex/component.h	/^          ScalarType cKg() const { return _hk[1];}$/;"	f	class:vcg::vertex::Curvature
cKg	vcglib/vcg/simplex/vertex/component.h	/^  float cKg() const { static float dummy = 0.f; assert(0); return dummy;}$/;"	f	class:vcg::vertex::EmptyCore
cKg	vcglib/vcg/simplex/vertex/component_ocf.h	/^  ScalarType cKg() const { assert((*this).Base().CurvatureEnabled); return (*this).Base().CuV[(*this).Index()][1];}$/;"	f	class:vcg::vertex::CurvatureOcf
cKh	vcglib/vcg/simplex/vertex/component.h	/^          ScalarType cKh() const { return _hk[0];}$/;"	f	class:vcg::vertex::Curvature
cKh	vcglib/vcg/simplex/vertex/component.h	/^  float cKh() const { static float dummy = 0.f; assert(0); return dummy;}$/;"	f	class:vcg::vertex::EmptyCore
cKh	vcglib/vcg/simplex/vertex/component_ocf.h	/^  ScalarType cKh() const { assert((*this).Base().CurvatureEnabled); return (*this).Base().CuV[(*this).Index()][0];}$/;"	f	class:vcg::vertex::CurvatureOcf
cN	vcglib/vcg/simplex/face/component.h	/^  NormalType cN() const { static NormalType dummy_normal(0, 0, 0); return dummy_normal; }$/;"	f	class:vcg::face::EmptyCore
cN	vcglib/vcg/simplex/face/component.h	/^  inline NormalType cN() const { return _norm; }$/;"	f	class:vcg::face::NormalAbs
cN	vcglib/vcg/simplex/face/component_ocf.h	/^  NormalType cN() const {$/;"	f	class:vcg::face::NormalOcf
cN	vcglib/vcg/simplex/tetrahedron/component.h	/^  const NormalType cN(const int & ) const { return 0; }$/;"	f	class:vcg::tetra::EmptyFaceNormal
cN	vcglib/vcg/simplex/tetrahedron/component.h	/^  const NormalType cN(const int & i) const { assert((i>=0)&&(i < 4)); return _facenormals[i]; }$/;"	f	class:vcg::tetra::FaceNormal
cN	vcglib/vcg/simplex/vertex/component.h	/^  NormalType cN() const { assert(0); static NormalType dummy_normal(0, 0, 0); return dummy_normal; }$/;"	f	class:vcg::vertex::EmptyCore
cN	vcglib/vcg/simplex/vertex/component.h	/^  inline       NormalType cN() const { return _norm; }$/;"	f	class:vcg::vertex::Normal
cN	vcglib/vcg/simplex/vertex/component_ocf.h	/^        NormalType cN() const { assert((*this).Base().NormalEnabled); return (*this).Base().NV[(*this).Index()];  }$/;"	f	class:vcg::vertex::NormalOcf
cN	vcglib/wrap/opensg/vertex_component.h	/^	const NormalType cN()const { assert(0); return NormalType(); }$/;"	f	class:vcg::vert::EmptyOSGNormal
cNeigh	vcglib/vcg/simplex/face/component_ocf.h	/^  typename T::FacePointer  cNeigh( const int j ) const { return cFFp(j);}$/;"	f	class:vcg::face::FFAdjOcf
cNext	vcglib/vcg/connectors/hedge_component.h	/^        const typename T::HEdgePointer &  cNext()       const   { return this->HNp();}$/;"	f	class:vcg::hedge::HEdgeData
cOpposite	vcglib/vcg/connectors/hedge_component.h	/^        const typename T::HEdgePointer & cOpposite()    const   { return this->cHOp();}$/;"	f	class:vcg::hedge::HEdgeData
cP	vcglib/vcg/complex/algorithms/hole.h	/^  const CoordType &cP(int i) const {return P(i);}$/;"	f	class:vcg::tri::TrivialEar
cP	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::CoordType &          cP( const int j ) const { (void)j; assert(0);  static typename T::CoordType coord(0, 0, 0); return coord; }$/;"	f	class:vcg::edge::EmptyCore
cP	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::CoordType &cP( const int j ) const	{	assert(j>=0 && j<2);		return v[j]->cP(); }$/;"	f	class:vcg::edge::VertexRef
cP	vcglib/vcg/simplex/face/component.h	/^  inline CoordType cP( const int j ) const	{	assert(j>=0 && j<3);		return v[j]->cP(); }$/;"	f	class:vcg::face::VertexRef
cP	vcglib/vcg/simplex/face/component.h	/^  inline typename T::CoordType cP( const int ) const { assert(0);		static typename T::CoordType coord(0, 0, 0); return coord;	}$/;"	f	class:vcg::face::EmptyCore
cP	vcglib/vcg/simplex/face/component_occ.h	/^	inline const typename T::CoordType &cP( const int j ) const	{	assert(j>=0 && j<3);	return  V(j)->cP(); }$/;"	f	class:vcg::face::VertexRefOcc
cP	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        CoordType cP( const int j ) const {	assert(j>=0 && j<this->VN());		return _vpoly[j]->cP(); }$/;"	f	class:vcg::face::PFVAdj
cP	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::CoordType &cP( const int j ) const	{	assert(0);		static typename T::CoordType coord(0, 0, 0); return coord;	}$/;"	f	class:vcg::tetra::EmptyVertexRef
cP	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::CoordType &cP( const int j ) const	{	assert(j>=0 && j<4);		return v[j]->cP(); }$/;"	f	class:vcg::tetra::VertexRef
cP	vcglib/vcg/simplex/vertex/component.h	/^  CoordType cP() const { assert(0); static CoordType coord(0, 0, 0);  assert(0); return coord; }$/;"	f	class:vcg::vertex::EmptyCore
cP	vcglib/vcg/simplex/vertex/component.h	/^  inline       CoordType cP() const { return _coord; }$/;"	f	class:vcg::vertex::Coord
cP	vcglib/vcg/space/tetra3.h	/^	inline CoordType const & cP( const int j )const { return _v[j];}$/;"	f	class:vcg::Tetra3
cP	vcglib/vcg/space/triangle3.h	/^  inline const CoordType & cP( const int j ) const { return _v[j];}$/;"	f	class:vcg::Triangle3
cP	vcglib/wrap/opensg/vertex_component.h	/^	const CoordType & cP() const { assert(0); return CoordType(); }$/;"	f	class:vcg::vert::EmptyOSGCoord
cP0	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::CoordType & cP0( const int j ) const { return cV(j)->P();}$/;"	f	class:vcg::edge::VertexRef
cP0	vcglib/vcg/simplex/face/component.h	/^  inline const CoordType & cP0( const int j ) const { return cV(j)->P();}$/;"	f	class:vcg::face::VertexRef
cP0	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	CoordType & cP0( const int j ) const { return cV(j)->P();}$/;"	f	class:vcg::face::VertexRefOcc
cP0	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        CoordType  cP0( const int j ) const { return cV(j)->P();}$/;"	f	class:vcg::face::PFVAdj
cP0	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::CoordType & cP0( const int j ) const { return cV(j)->P();}$/;"	f	class:vcg::tetra::VertexRef
cP0	vcglib/vcg/space/tetra3.h	/^	inline const CoordType & cP0( const int j ) const { return _v[j];}$/;"	f	class:vcg::Tetra3
cP0	vcglib/vcg/space/triangle2.h	/^	inline const CoordType & cP0( const int j ) const { return _v[j];}$/;"	f	class:vcg::Triangle2
cP0	vcglib/vcg/space/triangle3.h	/^  inline const CoordType & cP0( const int j ) const { return _v[j];}$/;"	f	class:vcg::Triangle3
cP1	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::CoordType & cP1( const int j ) const { return cV((j+1)%2)->P();}$/;"	f	class:vcg::edge::VertexRef
cP1	vcglib/vcg/simplex/face/component.h	/^  inline const CoordType & cP1( const int j ) const { return cV((j+1)%3)->P();}$/;"	f	class:vcg::face::VertexRef
cP1	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	CoordType & cP1( const int j ) const { return cV((j+1)%3)->P();}$/;"	f	class:vcg::face::VertexRefOcc
cP1	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        CoordType  cP1( const int j ) const { return cV((j+1)%this->VN())->P();}$/;"	f	class:vcg::face::PFVAdj
cP1	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::CoordType & cP1( const int j ) const { return cV((j+1)%4)->P();}$/;"	f	class:vcg::tetra::VertexRef
cP1	vcglib/vcg/space/tetra3.h	/^	inline const CoordType & cP1( const int j ) const { return _v[(j+1)%4];}$/;"	f	class:vcg::Tetra3
cP1	vcglib/vcg/space/triangle2.h	/^	inline const CoordType & cP1( const int j ) const { return _v[(j+1)%3];}$/;"	f	class:vcg::Triangle2
cP1	vcglib/vcg/space/triangle3.h	/^  inline const CoordType & cP1( const int j ) const { return _v[(j+1)%3];}$/;"	f	class:vcg::Triangle3
cP2	vcglib/vcg/simplex/face/component.h	/^  inline const CoordType & cP2( const int j ) const { return cV((j+2)%3)->P();}$/;"	f	class:vcg::face::VertexRef
cP2	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	CoordType & cP2( const int j ) const { return cV((j+2)%3)->P();}$/;"	f	class:vcg::face::VertexRefOcc
cP2	vcglib/vcg/simplex/face/component_polygon.h	/^  inline        CoordType  cP2( const int j ) const { return cV((j+2)%this->VN())->P();}$/;"	f	class:vcg::face::PFVAdj
cP2	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::CoordType & cP2( const int j ) const { return cV((j+2)%4)->P();}$/;"	f	class:vcg::tetra::VertexRef
cP2	vcglib/vcg/space/tetra3.h	/^	inline const CoordType & cP2( const int j ) const { return _v[(j+2)%4];}$/;"	f	class:vcg::Tetra3
cP2	vcglib/vcg/space/triangle2.h	/^	inline const CoordType & cP2( const int j ) const { return _v[(j+2)%3];}$/;"	f	class:vcg::Triangle2
cP2	vcglib/vcg/space/triangle3.h	/^  inline const CoordType & cP2( const int j ) const { return _v[(j+2)%3];}$/;"	f	class:vcg::Triangle3
cP3	vcglib/vcg/space/tetra3.h	/^  inline const CoordType & cP3( const int j ) const { return _v[(j+3)%4];}$/;"	f	class:vcg::Tetra3
cPD1	vcglib/vcg/simplex/face/component.h	/^  Point3f cPD1() const { static Point3f dummy(0,0,0); assert(0); return dummy;}$/;"	f	class:vcg::face::EmptyCore
cPD1	vcglib/vcg/simplex/face/component.h	/^  VecType cPD1() const { return _curv.max_dir;}$/;"	f	class:vcg::face::CurvatureDir
cPD1	vcglib/vcg/simplex/face/component_ocf.h	/^  VecType cPD1() const {$/;"	f	class:vcg::face::CurvatureDirOcf
cPD1	vcglib/vcg/simplex/vertex/component.h	/^	const VecType &cPD1() const {return _curv.max_dir;}$/;"	f	class:vcg::vertex::CurvatureDir
cPD1	vcglib/vcg/simplex/vertex/component.h	/^  VecType cPD1() const {static VecType v(0,0,0); assert(0);return v;}$/;"	f	class:vcg::vertex::EmptyCore
cPD1	vcglib/vcg/simplex/vertex/component_occ.h	/^	const VecType &cPD1() const {return CAT< vector_occ<VertType>,CurvatureDirTypeOcc>::Instance()->Get((VertType*)this).max_dir;}$/;"	f	class:vcg::vertex::CurvatureDirOcc
cPD1	vcglib/vcg/simplex/vertex/component_ocf.h	/^  VecType cPD1() const { assert((*this).Base().CurvatureDirEnabled); return (*this).Base().CuDV[(*this).Index()].max_dir;}$/;"	f	class:vcg::vertex::CurvatureDirOcf
cPD2	vcglib/vcg/simplex/face/component.h	/^  Point3f cPD2() const { static Point3f dummy(0,0,0); assert(0); return dummy;}$/;"	f	class:vcg::face::EmptyCore
cPD2	vcglib/vcg/simplex/face/component.h	/^  VecType cPD2() const { return _curv.min_dir;}$/;"	f	class:vcg::face::CurvatureDir
cPD2	vcglib/vcg/simplex/face/component_ocf.h	/^  VecType cPD2() const {$/;"	f	class:vcg::face::CurvatureDirOcf
cPD2	vcglib/vcg/simplex/vertex/component.h	/^	const VecType &cPD2() const {return _curv.min_dir;}$/;"	f	class:vcg::vertex::CurvatureDir
cPD2	vcglib/vcg/simplex/vertex/component.h	/^  VecType cPD2() const {static VecType v(0,0,0); assert(0);return v;}$/;"	f	class:vcg::vertex::EmptyCore
cPD2	vcglib/vcg/simplex/vertex/component_occ.h	/^	const VecType &cPD2() const {return CAT< vector_occ<VertType>,CurvatureDirTypeOcc>::Instance()->Get((VertType*)this).min_dir;}$/;"	f	class:vcg::vertex::CurvatureDirOcc
cPD2	vcglib/vcg/simplex/vertex/component_ocf.h	/^  VecType cPD2() const { assert((*this).Base().CurvatureDirEnabled); return (*this).Base().CuDV[(*this).Index()].min_dir;}$/;"	f	class:vcg::vertex::CurvatureDirOcf
cPlane	vcglib/vcg/simplex/face/component_ep.h	/^  typename vcg::Plane3<typename T::VertexType::CoordType::ScalarType>  cPlane()const {$/;"	f	class:vcg::face::EdgePlane
cPlane	vcglib/vcg/simplex/face/component_ep.h	/^typename vcg::Plane3<typename T::VertexType::CoordType::ScalarType> &cPlane() const {assert(0);  static typename vcg::Plane3<typename T::VertexType::CoordType::ScalarType> dum; return dum;}$/;"	f	class:vcg::face::EmptyEdgePlane
cQ	vcglib/vcg/simplex/edge/component.h	/^    QualityType cQ() const { static QualityType dummyQuality(0);  assert(0); return dummyQuality; }$/;"	f	class:vcg::edge::EmptyCore
cQ	vcglib/vcg/simplex/edge/component.h	/^  const QualityType & cQ() const {return _quality; }$/;"	f	class:vcg::edge::Quality
cQ	vcglib/vcg/simplex/face/component.h	/^  QualityType cQ() const { return _quality; }$/;"	f	class:vcg::face::Quality
cQ	vcglib/vcg/simplex/face/component.h	/^  QualityType cQ() const { static QualityType dummyQuality(0);  assert(0); return dummyQuality; }$/;"	f	class:vcg::face::EmptyCore
cQ	vcglib/vcg/simplex/face/component_ocf.h	/^  QualityType cQ() const  {$/;"	f	class:vcg::face::QualityOcf
cQ	vcglib/vcg/simplex/vertex/component.h	/^  QualityType cQ() const { assert(0); static QualityType dummyQuality(0); return dummyQuality; }$/;"	f	class:vcg::vertex::EmptyCore
cQ	vcglib/vcg/simplex/vertex/component.h	/^  inline       QualityType cQ() const {return _quality; }$/;"	f	class:vcg::vertex::Quality
cQ	vcglib/vcg/simplex/vertex/component_ocf.h	/^        QualityType cQ() const { assert((*this).Base().QualityEnabled); return (*this).Base().QV[(*this).Index()]; }$/;"	f	class:vcg::vertex::QualityOcf
cQ3	vcglib/vcg/simplex/face/component.h	/^  Quality3Type cQ3() const { return _quality; }$/;"	f	class:vcg::face::Quality3
cQ3	vcglib/vcg/simplex/face/component.h	/^  Quality3Type cQ3() const { static Quality3Type dummyQuality3(0,0,0);  assert(0); return dummyQuality3; }$/;"	f	class:vcg::face::EmptyCore
cR	vcglib/vcg/simplex/vertex/component.h	/^          RadiusType cR() const {return _radius; }$/;"	f	class:vcg::vertex::Radius
cR	vcglib/vcg/simplex/vertex/component.h	/^  RadiusType cR() const { static const ScalarType v = 0.0; assert(0 && "the radius component is not available"); return v; }$/;"	f	class:vcg::vertex::EmptyCore
cR	vcglib/vcg/simplex/vertex/component_occ.h	/^  const RadiusType &cR() const { return CAT< vector_occ<VertType>,RadiusType>::Instance()->Get((VertType*)this);}$/;"	f	class:vcg::vertex::RadiusOcc
cR	vcglib/vcg/simplex/vertex/component_ocf.h	/^        RadiusType cR() const { assert((*this).Base().RadiusEnabled); return (*this).Base().RadiusV[(*this).Index()];}$/;"	f	class:vcg::vertex::RadiusOcf
cSH	vcglib/vcg/simplex/vertex/component_sph.h	/^	const SphType &cSH() const { return _harmonics; }$/;"	f	class:vcg::vertex::Sph
cT	vcglib/vcg/simplex/vertex/component.h	/^        TexCoordType cT() const { return _t; }$/;"	f	class:vcg::vertex::TexCoord
cT	vcglib/vcg/simplex/vertex/component.h	/^  TexCoordType cT() const { static TexCoordType dummy_texcoord;  assert(0); return dummy_texcoord; }$/;"	f	class:vcg::vertex::EmptyCore
cT	vcglib/vcg/simplex/vertex/component_ocf.h	/^        TexCoordType cT() const { assert((*this).Base().TexCoordEnabled); return (*this).Base().TV[(*this).Index()]; }$/;"	f	class:vcg::vertex::TexCoordOcf
cTTi	vcglib/vcg/simplex/tetrahedron/component.h	/^  const char &cTTi(const int j) const { return _tti[j]; }$/;"	f	class:vcg::tetra::TTAdj
cTTp	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer const cTTp( const int ) const { static typename T::TetraPointer const tp=0; return tp; }$/;"	f	class:vcg::tetra::EmptyAdj::T
cTTp	vcglib/vcg/simplex/tetrahedron/component.h	/^  typename T::TetraPointer const cTTp(const int j) const  { assert(j>=0 && j<4);  return _ttp[j]; }$/;"	f	class:vcg::tetra::TTAdj::T
cV	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^	const VOX_TYPE &cV(const int &x,const int &y,const int &z) const {$/;"	f	class:vcg::SimpleVolume
cV	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  const VertexType* cV() const {return f->V(e);}$/;"	f	class:vcg::tri::BitQuad::Pos
cV	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    const VOX_TYPE &cV(const int &x,const int &y,const int &z) const {$/;"	f	class:vcg::SimpleVolume
cV	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  VERTEX_TYPE *cV(int i) const { return v[i]; }$/;"	f	class:vcg::tri::BasicVertexPair
cV	vcglib/vcg/simplex/edge/component.h	/^		inline typename T::VertexType *  cV( const int j ) const { assert(j>=0 && j<2);	return v[j]; }$/;"	f	class:vcg::edge::VertexRef
cV	vcglib/vcg/simplex/edge/component.h	/^	inline       typename T::VertexType *         cV( const int j ) const { (void)j; assert(0);  static typename T::VertexType *vp=0;         return vp;    }$/;"	f	class:vcg::edge::EmptyCore
cV	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType * cV( const int ) const { assert(0);		static typename T::VertexType *vp=0; return vp;	}$/;"	f	class:vcg::face::EmptyCore
cV	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType * cV( const int j ) const { assert(j>=0 && j<3);	return v[j]; }$/;"	f	class:vcg::face::VertexRef
cV	vcglib/vcg/simplex/face/component_occ.h	/^	inline typename T::VertexType * const  cV( const int j ) const { assert(j>=0 && j<3);	$/;"	f	class:vcg::face::VertexRefOcc::T
cV	vcglib/vcg/simplex/face/component_polygon.h	/^  inline typename T::VertexType *        cV( const int j ) const { assert(j>=0 && j<this->VN()); return _vpoly[j]; }$/;"	f	class:vcg::face::PFVAdj
cV	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline typename T::VertexType * const  cV( const int j ) const {	assert(0);		static typename T::VertexType *vp=0; return vp;	}$/;"	f	class:vcg::tetra::EmptyVertexRef::T
cV	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline typename T::VertexType * const  cV( const int j ) const { assert(j>=0 && j<4);	return v[j]; }$/;"	f	class:vcg::tetra::VertexRef::T
cV0	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::VertexType * const & cV0( const int j ) const { return cV(j);}$/;"	f	class:vcg::edge::VertexRef::T
cV0	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType *  cV0( const int j ) const { return cV(j);}$/;"	f	class:vcg::face::VertexRef
cV0	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	VertexType * const & cV0( const int j ) const { return cV(j);}$/;"	f	class:vcg::face::VertexRefOcc
cV0	vcglib/vcg/simplex/face/component_polygon.h	/^  inline const  VertexType * const & cV0( const int j ) const { return cV(j);}$/;"	f	class:vcg::face::PFVAdj
cV0	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::VertexType * const & cV0( const int j ) const { return cV(j);}$/;"	f	class:vcg::tetra::VertexRef::T
cV1	vcglib/vcg/simplex/edge/component.h	/^	inline const typename T::VertexType * const & cV1( const int j ) const { return cV((j+1)%2);}$/;"	f	class:vcg::edge::VertexRef::T
cV1	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType *  cV1( const int j ) const { return cV((j+1)%3);}$/;"	f	class:vcg::face::VertexRef
cV1	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	VertexType * const & cV1( const int j ) const { return cV((j+1)%3);}$/;"	f	class:vcg::face::VertexRefOcc
cV1	vcglib/vcg/simplex/face/component_polygon.h	/^  inline const  VertexType * const & cV1( const int j ) const { return cV((j+1)%this->VN());}$/;"	f	class:vcg::face::PFVAdj
cV1	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::VertexType * const & cV1( const int j ) const { return cV((j+1)%4);}$/;"	f	class:vcg::tetra::VertexRef::T
cV2	vcglib/vcg/simplex/face/component.h	/^  inline typename T::VertexType *  cV2( const int j ) const { return cV((j+2)%3);}$/;"	f	class:vcg::face::VertexRef
cV2	vcglib/vcg/simplex/face/component_occ.h	/^	inline const 	VertexType * const & cV2( const int j ) const { return cV((j+2)%3);}$/;"	f	class:vcg::face::VertexRefOcc
cV2	vcglib/vcg/simplex/face/component_polygon.h	/^  inline const  VertexType * const & cV2( const int j ) const { return cV((j+2)%this->VN());}$/;"	f	class:vcg::face::PFVAdj
cV2	vcglib/vcg/simplex/tetrahedron/component.h	/^	inline const typename T::VertexType * const & cV2( const int j ) const { return cV((j+2)%4);}$/;"	f	class:vcg::tetra::VertexRef::T
cVEi	vcglib/vcg/simplex/edge/component.h	/^	int cVEi(const int &i )const {return _zp[i];}$/;"	f	class:vcg::edge::VEAdj
cVEi	vcglib/vcg/simplex/edge/component.h	/^    int cVEi(const int &) const {static int z=0; assert(0); return z;}$/;"	f	class:vcg::edge::EmptyCore
cVEi	vcglib/vcg/simplex/vertex/component.h	/^  int cVEi() const { static int z=0; return z;}$/;"	f	class:vcg::vertex::EmptyCore
cVEi	vcglib/vcg/simplex/vertex/component.h	/^  int cVEi() const {return _zp; }$/;"	f	class:vcg::vertex::VEAdj
cVEp	vcglib/vcg/simplex/edge/component.h	/^	typename T::EdgePointer cVEp(const int & i) const {return _ep[i]; }$/;"	f	class:vcg::edge::VEAdj
cVEp	vcglib/vcg/simplex/edge/component.h	/^    typename T::EdgePointer cVEp(const int & ) const { static typename T::EdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::edge::EmptyCore
cVEp	vcglib/vcg/simplex/vertex/component.h	/^  typename T::EdgePointer cVEp() const {return _ep; }$/;"	f	class:vcg::vertex::VEAdj
cVEp	vcglib/vcg/simplex/vertex/component.h	/^  typename TT::EdgePointer cVEp() const { static typename TT::EdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::vertex::EmptyCore
cVFi	vcglib/vcg/simplex/face/component.h	/^  char cVFi(const int j)const {return _vfi[j]; }$/;"	f	class:vcg::face::VFAdj
cVFi	vcglib/vcg/simplex/face/component.h	/^  char cVFi(int) const { static char z=0; assert(0); return z;}$/;"	f	class:vcg::face::EmptyCore
cVFi	vcglib/vcg/simplex/face/component_ocf.h	/^  char cVFi(const int j) const {$/;"	f	class:vcg::face::VFAdjOcf
cVFi	vcglib/vcg/simplex/vertex/component.h	/^    int cVFi() const { return _zp; }$/;"	f	class:vcg::vertex::VFAdj
cVFi	vcglib/vcg/simplex/vertex/component.h	/^  int cVFi() const { static int z=-1; assert(0); return z;}$/;"	f	class:vcg::vertex::EmptyCore
cVFi	vcglib/vcg/simplex/vertex/component_ocf.h	/^    int cVFi() const {$/;"	f	class:vcg::vertex::VFAdjOcf
cVFp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer cVFp(const int j) const  { assert(j>=0 && j<3);  return _vfp[j]; }$/;"	f	class:vcg::face::VFAdj
cVFp	vcglib/vcg/simplex/face/component.h	/^  typename T::FacePointer cVFp(int) const { static typename T::FacePointer fp=0; assert(0); return fp; }$/;"	f	class:vcg::face::EmptyCore
cVFp	vcglib/vcg/simplex/face/component_occ.h	/^   	FacePointer cVFp(const int j) const {$/;"	f	class:vcg::face::VFAdjOccBase
cVFp	vcglib/vcg/simplex/face/component_ocf.h	/^  typename T::FacePointer cVFp(const int j) const {$/;"	f	class:vcg::face::VFAdjOcf
cVFp	vcglib/vcg/simplex/face/component_polygon.h	/^  typename T::FacePointer const cVFp(const int j) const  { assert(j>=0 && j<this->VN());  return _vfpP[j]; }$/;"	f	class:vcg::face::PVFAdj::T
cVFp	vcglib/vcg/simplex/vertex/component.h	/^    typename T::FacePointer cVFp() const  { return _fp; }$/;"	f	class:vcg::vertex::VFAdj
cVFp	vcglib/vcg/simplex/vertex/component.h	/^  typename TT::FacePointer cVFp() const { static typename TT::FacePointer fp=0;  assert(0); return fp; }$/;"	f	class:vcg::vertex::EmptyCore
cVFp	vcglib/vcg/simplex/vertex/component_ocf.h	/^	typename T::FacePointer cVFp() const {$/;"	f	class:vcg::vertex::VFAdjOcf
cVHi	vcglib/vcg/simplex/vertex/component.h	/^  int cVHi() const { static int z=0; return z;}$/;"	f	class:vcg::vertex::EmptyCore
cVHp	vcglib/vcg/simplex/vertex/component.h	/^	typename T::HEdgePointer cVHp() const {return _hp; }$/;"	f	class:vcg::vertex::VHAdj
cVHp	vcglib/vcg/simplex/vertex/component.h	/^  typename TT::HEdgePointer cVHp() const { static typename TT::HEdgePointer ep=0;  assert(0); return ep; }$/;"	f	class:vcg::vertex::EmptyCore
cVTi	vcglib/vcg/simplex/tetrahedron/component.h	/^	const char & cVTi( const int j ) const { return _vti[j]; }$/;"	f	class:vcg::tetra::VTAdj
cVTp	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer const cVTp( const int ) const { static typename T::TetraPointer const tp=0; return tp; }$/;"	f	class:vcg::tetra::EmptyAdj::T
cVTp	vcglib/vcg/simplex/tetrahedron/component.h	/^	typename T::TetraPointer const cVTp( const int j ) const { assert( j >= 0 && j < 4 ); return _vtp[j]; }$/;"	f	class:vcg::tetra::VTAdj::T
cVTp	vcglib/vcg/simplex/vertex/component.h	/^	typename T::TetraPointer cVTp() const { return _tp; }$/;"	f	class:vcg::vertex::VTAdj
cVTp	vcglib/vcg/simplex/vertex/component.h	/^  typename TT::TetraPointer cVTp() const  { static typename TT::TetraPointer tp = 0;  assert(0); return tp; }$/;"	f	class:vcg::vertex::EmptyCore
cVertex	vcglib/vcg/connectors/hedge_component.h	/^        const typename T::VertexPointer &  cVertex()    const   { return this->cHVp();}$/;"	f	class:vcg::hedge::HEdgeData
cWC	vcglib/vcg/simplex/face/component.h	/^  ColorType cWC(const int) const { static ColorType dumcolor(vcg::Color4b::White);  assert(0); return dumcolor; }$/;"	f	class:vcg::face::EmptyCore
cWC	vcglib/vcg/simplex/face/component.h	/^  ColorType cWC(int i) const { return _color[i]; }$/;"	f	class:vcg::face::WedgeColor
cWC	vcglib/vcg/simplex/face/component_ocf.h	/^  const ColorType cWC(const int i) const { assert((*this).Base().WedgeColorEnabled); return (*this).Base().WCV[(*this).Index()].wc[i]; }$/;"	f	class:vcg::face::WedgeColorOcf
cWN	vcglib/vcg/simplex/face/component.h	/^  NormalType cWN(int) const { static NormalType dummy_normal(0, 0, 0); return dummy_normal; }$/;"	f	class:vcg::face::EmptyCore
cWN	vcglib/vcg/simplex/face/component.h	/^  inline NormalType cWN(int i) const { return _wn[i]; }$/;"	f	class:vcg::face::WedgeRealNormal
cWN	vcglib/vcg/simplex/face/component.h	/^  inline NormalType cWN(int j) const { return _wnorm[j]; }$/;"	f	class:vcg::face::WedgeNormal
cWN	vcglib/vcg/simplex/face/component_ocf.h	/^  NormalType const &cWN(const int i) const { assert((*this).Base().WedgeNormalEnabled); return (*this).Base().WNV[(*this).Index()].wn[i]; }$/;"	f	class:vcg::face::WedgeNormalOcf
cWT	vcglib/vcg/simplex/face/component.h	/^  TexCoordType cWT(const int i) const { return _wt[i]; }$/;"	f	class:vcg::face::WedgeTexCoord
cWT	vcglib/vcg/simplex/face/component.h	/^  TexCoordType const &cWT(const int) const { static TexCoordType dummy_texture; return dummy_texture;}$/;"	f	class:vcg::face::EmptyCore
cWT	vcglib/vcg/simplex/face/component_ocf.h	/^  TexCoordType cWT(const int i) const { assert((*this).Base().WedgeTexEnabled); return (*this).Base().WTV[(*this).Index()].wt[i]; }$/;"	f	class:vcg::face::WedgeTexCoordOcf
c_to_fortran_numbering	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void c_to_fortran_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal
cachedir	vcglib/wrap/ply/plystuff.h	/^const char * cachedir = "vcg_cache";$/;"	m	namespace:vcg::ply
caches	vcglib/wrap/gcache/controller.h	/^  std::vector<Cache<Token> *> caches;$/;"	m	class:vcg::Controller
calcSlope	vcglib/wrap/gui/coordinateframe.cpp	/^float CoordinateFrame::calcSlope(const Point3d &a,const Point3d &b,float dim,int spacing,double *mm,double *mp,GLint *vp)$/;"	f	class:CoordinateFrame
calculateMinimumWeightTriangulation	vcglib/vcg/complex/algorithms/hole.h	/^    static void calculateMinimumWeightTriangulation(MESH &m, FaceIterator f,std::vector<PosType > vv )$/;"	f	class:vcg::tri::Hole
calibrate	vcglib/wrap/tsai/tsaimethods.cpp	/^bool TsaiMethods::calibrate( vcg::Shot<double>* shot,std::list<TsaiCorrelation>* corr, bool p_foc)$/;"	f	class:TsaiMethods
callback	vcglib/apps/sample/trimesh_ball_pivoting/trimesh_ball_pivoting.cpp	/^bool callback(int percent, const char *str) {$/;"	f
callback	vcglib/apps/sample/trimesh_hole/trimesh_hole.cpp	/^bool callback(int percent, const char *str) {$/;"	f
callback	vcglib/wrap/gcache/cache.h	/^    void (*callback)(void *data);$/;"	m	class:vcg::Cache
calloc_must_clear	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define calloc_must_clear(/;"	d	file:
calls	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^  int calls;$/;"	m	struct:PointPointMinimizer	file:
calls	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  int calls;$/;"	m	struct:BallPointStuff	file:
camera	vcglib/wrap/gui/trackball.h	/^  View<float> camera;$/;"	m	class:vcg::Trackball
cameraType	vcglib/vcg/math/camera.h	/^    int cameraType;					\/\/\/ Type of camera: PERSPECTIVE,ORTHO,ISOMETRIC,CAVALIERI$/;"	m	class:vcg::Camera
can_add_hedge	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static bool can_add_hedge( vector<VertexPointer> &vps, vector<HEdgePointer> &hps )$/;"	f	class:vcg::tri::HalfEdgeTopology
can_remove_face	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static bool can_remove_face(FacePointer fp)$/;"	f	class:vcg::tri::HalfEdgeTopology
capacity	vcglib/wrap/gcache/cache.h	/^    uint64_t capacity() { return s_max; }$/;"	f	class:vcg::Cache
cardinality	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				int									cardinality;	\/*!< The cardinality of the pre-image.								*\/$/;"	m	struct:vcg::PerfectSpatialHashing::OffsetTable::PreImage
cast	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline NewType cast(const OldType& x)$/;"	f	namespace:Eigen::internal
cast	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox
cast	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis
cast	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::Hyperplane
cast	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine
cast	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Quaternion,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Quaternion
cast	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D
cast	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline typename internal::cast_return_type<Scaling,Scaling<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Scaling
cast	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Transform
cast	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation
cast	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox
cast	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis
cast	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::Hyperplane
cast	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine
cast	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::QuaternionBase
cast	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D
cast	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling<NewScalarType> cast() const$/;"	f	class:Eigen::UniformScaling
cast	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim,Mode,Options> >::type cast() const$/;"	f	class:Eigen::Transform
cast	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation
cast	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^cast() const$/;"	f
cast_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct cast_impl$/;"	s	namespace:Eigen::internal
cast_to_pointer_type	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return const_cast<PointerType>(ptr); }$/;"	f	class:Eigen::Map
cast_to_pointer_type	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }$/;"	f	class:Eigen::Map
cauchy_max_bound	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^typename NumTraits<typename Polynomial::Scalar>::Real cauchy_max_bound( const Polynomial& poly )$/;"	f	namespace:Eigen
cauchy_min_bound	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^typename NumTraits<typename Polynomial::Scalar>::Real cauchy_min_bound( const Polynomial& poly )$/;"	f	namespace:Eigen
cb	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^bool cb(const char *buf)$/;"	f
cb	vcglib/wrap/io_tetramesh/io_ply.h	/^  CallBackPos *cb;$/;"	m	class:vcg::tetra::io::PlyInfo
cb	vcglib/wrap/io_trimesh/import_fbx.h	/^		vcg::CallBackPos *cb;$/;"	m	class:ImporterFBX::Info
cb	vcglib/wrap/io_trimesh/import_obj.h	/^                    CallBackPos *cb;$/;"	m	class:vcg::tri::io::ImporterOBJ::Info
cb	vcglib/wrap/io_trimesh/io_ply.h	/^  CallBackPos *cb;$/;"	m	class:vcg::tri::io::PlyInfo
cb	vcglib/wrap/ply/plylib.h	/^	readelemcb	cb;				\/\/ Callback di lettura$/;"	m	class:vcg::ply::PlyProperty
cb_read_ascii	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_ascii( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_chch	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_chch( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_chdo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_chdo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_chfl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_chfl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_chin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_chin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_chsh	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_chsh( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_chuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_chuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_chui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_chui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_chus	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_chus( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_dodo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_dodo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_dofl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_dofl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_fldo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_fldo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_flfl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_flfl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_inch	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_inch( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_indo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_indo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_infl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_infl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_inin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_inin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_insh	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_insh( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_inuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_inuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_inui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_inui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_inus	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_inus( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_ascii	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_ascii( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_chch	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_chch( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_chdo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_chdo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_chfl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_chfl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_chin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_chin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_chsh	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_chsh( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_chuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_chuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_chui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_chui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_chus	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_chus( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_dodo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_dodo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_dofl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_dofl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_fldo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_fldo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_flfl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_flfl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_inch	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_inch( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_indo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_indo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_infl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_infl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_inin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_inin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_insh	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_insh( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_inuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_inuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_inui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_inui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_inus	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_inus( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_shch	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_shch( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_shdo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_shdo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_shfl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_shfl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_shin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_shin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_shsh	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_shsh( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_shuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_shuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_shui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_shui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_shus	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_shus( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_ucch	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_ucch( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_ucdo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_ucdo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_ucfl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_ucfl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_ucin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_ucin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_ucsh	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_ucsh( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_ucuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_ucuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_ucui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_ucui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_ucus	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_ucus( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_uich	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_uich( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_uido	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_uido( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_uifl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_uifl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_uiin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_uiin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_uish	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_uish( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_uiuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_uiuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_uiui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_uiui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_uius	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_uius( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_usch	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_usch( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_usdo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_usdo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_usfl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_usfl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_usin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_usin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_ussh	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_ussh( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_usuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_usuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_usui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_usui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_list_usus	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_list_usus( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_shch	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_shch( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_shdo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_shdo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_shfl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_shfl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_shin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_shin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_shsh	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_shsh( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_shuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_shuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_shui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_shui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_shus	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_shus( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_ucch	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_ucch( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_ucdo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_ucdo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_ucfl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_ucfl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_ucin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_ucin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_ucsh	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_ucsh( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_ucuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_ucuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_ucui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_ucui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_ucus	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_ucus( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_uich	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_uich( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_uido	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_uido( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_uifl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_uifl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_uiin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_uiin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_uish	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_uish( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_uiuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_uiuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_uiui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_uiui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_uius	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_uius( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_usch	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_usch( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_usdo	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_usdo( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_usfl	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_usfl( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_usin	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_usin( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_ussh	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_ussh( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_usuc	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_usuc( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_usui	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_usui( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_read_usus	vcglib/wrap/ply/plylib.cpp	/^static bool cb_read_usus( GZFILE fp, void * mem, PropDescriptor * d )$/;"	f	namespace:vcg::ply
cb_skip_bin1	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_bin1( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cb_skip_bin2	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_bin2( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cb_skip_bin4	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_bin4( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cb_skip_bin8	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_bin8( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cb_skip_float_ascii	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_float_ascii( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cb_skip_int_ascii	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_int_ascii( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cb_skip_list_ascii	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_list_ascii ( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cb_skip_list_bin1	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_list_bin1( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cb_skip_list_bin2	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_list_bin2( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cb_skip_list_bin4	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_list_bin4( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cb_skip_list_bin8	vcglib/wrap/ply/plylib.cpp	/^static bool cb_skip_list_bin8( GZFILE fp, void * \/*mem*\/, PropDescriptor * \/*d*\/ )$/;"	f	namespace:vcg::ply
cbrt	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal cbrt(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
ccm	vcglib/wrap/gl/trimesh.h	/^    ColorMode ccm; \/\/ Current ColorMode$/;"	m	class:vcg::GlTrimesh
cdiv	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^std::complex<Scalar> cdiv(Scalar xr, Scalar xi, Scalar yr, Scalar yi)$/;"	f	namespace:Eigen
cdm	vcglib/wrap/gl/trimesh.h	/^    DrawMode cdm; \/\/ Current DrawMode$/;"	m	class:vcg::GlTrimesh
ceil	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal ceil(const mpreal& v)$/;"	f	namespace:mpfr
cellSize	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int cellSize;$/;"	m	class:vcg::RasterizedOutline2Packer::Parameters
cell_size	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        ScalarType cell_size;$/;"	m	class:vcg::SpatialHashTable2D
center	vcglib/apps/pivoting/pivot.h	/^      Point3f center;  \/\/center of the sphere touching the face$/;"	m	struct:vcg::tri::Hinge
center	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  center() const$/;"	f	class:Eigen::AlignedBox
center	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  VectorType center;$/;"	m	struct:Ball	file:
center	vcglib/vcg/space/index/octree_template.h	/^		CenterType	center;$/;"	m	struct:vcg::OctreeTemplate::Node
center	vcglib/wrap/gui/trackball.h	/^  Point3f center; $/;"	m	class:vcg::Transform
centerx	vcglib/wrap/io_trimesh/import_ply.h	/^	float centerx;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
centery	vcglib/wrap/io_trimesh/import_ply.h	/^	float centery;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
change_mparam	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static int change_mparam(int param_number, int value) {$/;"	f	file:
change_vertex	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static void change_vertex(VertexPointer old_vp, VertexPointer new_vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
channels	vcglib/img/img_image.h	/^  inline int channels() const$/;"	f	class:img::Image
channels_mean	vcglib/img/img_filter.h	/^inline void channels_mean(const img::Image<Channels,ScalarType1,Safe1> &channels_image, img::Image<1,ScalarType2,Safe2> &mean_image)$/;"	f	namespace:img
checkGLError	vcglib/wrap/qt/checkGLError.h	/^class checkGLError$/;"	c
checkHinge	vcglib/apps/pivoting/pivot.h	/^    bool checkHinge(int v0, int v1) {$/;"	f	class:vcg::tri::Pivot
checkIdentity	vcglib/apps/test/camerashot/camerashot_test.cpp	/^double checkIdentity(vcg::Matrix44d M)$/;"	f
checkPoissonDisk	vcglib/vcg/complex/algorithms/point_sampling.h	/^static bool checkPoissonDisk(SampleSHT & sht, const Point3<ScalarType> & p, ScalarType radius)$/;"	f	class:vcg::tri::SurfaceSampling
checkSanity	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    void checkSanity() const$/;"	f	class:Eigen::MapBase
checkTransposeAliasing	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^void DenseBase<Derived>::checkTransposeAliasing(const OtherDerived& other) const$/;"	f	class:Eigen::DenseBase
checkTransposeAliasing_impl	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl$/;"	s	namespace:Eigen::internal
checkTransposeAliasing_impl	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl<Derived, OtherDerived, false>$/;"	s	namespace:Eigen::internal
check_coordinates	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
check_coordinates_internal	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index , Index ) const {}$/;"	f	class:Eigen::TriangularBase
check_coordinates_internal	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
check_diagonal_collapse_quad	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static bool check_diagonal_collapse_quad(HEdgePointer hp)$/;"	f	class:vcg::tri::HalfEdgeTopology
check_dimension	vcglib/eigenlib/unsupported/test/kronecker_product.cpp	/^void check_dimension(const MatrixType& ab, const unsigned int rows,  const unsigned int cols)$/;"	f
check_feasible	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            static bool check_feasible(HEdgePointer hp, CoordType &V1, CoordType &V2, TriMeshType &tm, GRID &grid)$/;"	f	class:vcg::tri::FitmapsCollapse
check_free_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define check_free_chunk(/;"	d	file:
check_global_interpolation2d	vcglib/eigenlib/unsupported/test/splines.cpp	/^void check_global_interpolation2d()$/;"	f
check_inuse_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define check_inuse_chunk(/;"	d	file:
check_kronecker_product	vcglib/eigenlib/unsupported/test/kronecker_product.cpp	/^void check_kronecker_product(const MatrixType& ab)$/;"	f
check_malloc_state	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define check_malloc_state(/;"	d	file:
check_malloced_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define check_malloced_chunk(/;"	d	file:
check_mmapped_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define check_mmapped_chunk(/;"	d	file:
check_queue	vcglib/wrap/gcache/provider.h	/^  QDoor check_queue;$/;"	m	class:vcg::Provider
check_range	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int mpreal::check_range (int t, mp_rnd_t rnd_mode)$/;"	f	class:mpfr::mpreal
check_rows_cols_for_overflow	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^EIGEN_ALWAYS_INLINE void check_rows_cols_for_overflow(Index rows, Index cols)$/;"	f	namespace:Eigen::internal
check_size_for_overflow	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)$/;"	f	namespace:Eigen::internal
check_sparse_kronecker_product	vcglib/eigenlib/unsupported/test/kronecker_product.cpp	/^void check_sparse_kronecker_product(const MatrixType& ab)$/;"	f
check_template_parameters	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^  static void check_template_parameters()$/;"	f	class:Eigen::SparseMatrix
check_template_params	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    static EIGEN_STRONG_INLINE void check_template_params()$/;"	f	class:Eigen::Transform
check_that_malloc_is_allowed	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void check_that_malloc_is_allowed()$/;"	f	namespace:Eigen::internal
check_top_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define check_top_chunk(/;"	d	file:
check_transpose_aliasing_compile_time_selector	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_compile_time_selector	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
child	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  struct malloc_tree_chunk* child[2];$/;"	m	struct:malloc_tree_chunk	typeref:struct:malloc_tree_chunk::malloc_tree_chunk	file:
children	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  std::vector<int> children; \/\/children of x are children[2x] and children[2x+1], indices bigger than boxes.size() index into objects.$/;"	m	class:Eigen::KdBVH
children	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^				AABBBinaryTreeNode * children[2];$/;"	m	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
chkder	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/chkder.h	/^void chkder($/;"	f	namespace:Eigen::internal
chkder_factor	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/chkder.h	/^#define chkder_factor /;"	d
chkder_log10e	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/chkder.h	/^#define chkder_log10e /;"	d
cholmod	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_common& cholmod() { return m_cholmod; }$/;"	f	class:Eigen::CholmodBase
cholmod_configure_matrix	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^void cholmod_configure_matrix(CholmodType& mat)$/;"	f	namespace:Eigen::internal
chooseMesh	vcglib/apps/sample/trimesh_QT/mainwindow.cpp	/^void MainWindow::chooseMesh()$/;"	f	class:MainWindow
chromaticAdaptation	vcglib/vcg/space/colorspace.h	/^	static Color4<T> chromaticAdaptation(const Color4<T> & color, Illuminant src, $/;"	f	class:vcg::ColorSpace
chromaticAdaptation	vcglib/vcg/space/colorspace.h	/^	static void chromaticAdaptation(double Xi, double Yi, double Zi, Illuminant src,$/;"	f	class:vcg::ColorSpace
chunk2mem	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define chunk2mem(/;"	d	file:
chunk_minus_offset	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define chunk_minus_offset(/;"	d	file:
chunk_plus_offset	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define chunk_plus_offset(/;"	d	file:
chunksize	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define chunksize(/;"	d	file:
chwirut2_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    chwirut2_functor(void) : Functor<double>(3,54) {}$/;"	f	struct:chwirut2_functor
chwirut2_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct chwirut2_functor : Functor<double>$/;"	s	file:
cinuse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define cinuse(/;"	d	file:
cj	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<LhsScalar,RhsScalar,ConjLhs,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits
cj	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,ConjLhs,false> cj;$/;"	m	class:Eigen::internal::gebp_traits
cj	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,false,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits
clamp	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
clamp	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
clampValue	vcglib/img/img_scalar.h	/^inline ScalarType clampValue(ScalarType value, ScalarType minval=ScalarType(0.0), ScalarType maxval=ScalarType(255.0))$/;"	f	namespace:img
classn	vcglib/apps/trimeshinfo/ClassesNode.h	/^	NodeGroup classn;$/;"	m	class:ClassesNode
clean	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void clean()$/;"	f	class:Eigen::PastixBase
cleanMem	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void cleanMem() {$/;"	f	class:SparseSystemData
clean_dir	vcglib/apps/sample/img_filters/img_filters.cpp	/^bool clean_dir(QDir dir){ \/\/ utility, unrelated with the sample$/;"	f
cleanup	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void cleanup(){ $/;"	f	class:SparseMatrixData
clear	vcglib/apps/pivoting/ring.h	/^  void clear() { lst.clear(); }$/;"	f	class:ring
clear	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline void clear() { m_size = 0; }$/;"	f	class:Eigen::internal::CompressedStorage
clear	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void clear() $/;"	f	struct:Eigen::internal::fftw_impl
clear	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  void clear() $/;"	f	struct:Eigen::internal::kissfft_impl
clear	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline void clear() {$/;"	f	class:Eigen::SkylineStorage
clear	vcglib/vcg/complex/algorithms/nring.h	/^    void clear()$/;"	f	class:vcg::tri::Nring
clear	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^     void clear() { iterNum=totalTime=unwrapTime=voronoiTime=samplingTime=0;}$/;"	f	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam::Stat
clear	vcglib/vcg/container/simple_temporary_data.h	/^    void clear(){ datasize = 0;}$/;"	f	class:vcg::VectorNBW
clear	vcglib/vcg/space/rect_packer.h	/^    void clear() {$/;"	f	class:vcg::RectPacker::Stat
clear	vcglib/wrap/gcache/dheap.h	/^  void clear() { heap.clear(); }$/;"	f	class:PtrDHeap
clear	vcglib/wrap/gl/gl_surface.h	/^		bool clear(void)$/;"	f	class:vcg::gl_surface
clear	vcglib/wrap/glw/buffer.h	/^		void clear(void)$/;"	f	class:glw::BufferArguments
clear	vcglib/wrap/glw/fragmentshader.h	/^		void clear(void)$/;"	f	class:glw::FragmentShaderArguments
clear	vcglib/wrap/glw/framebuffer.h	/^		void clear(void)$/;"	f	class:glw::FramebufferArguments
clear	vcglib/wrap/glw/framebuffer.h	/^		void clear(void)$/;"	f	class:glw::RenderTarget
clear	vcglib/wrap/glw/framebuffer.h	/^		void clear(void)$/;"	f	class:glw::RenderTargetBinding
clear	vcglib/wrap/glw/framebuffer.h	/^		void clear(void)$/;"	f	class:glw::RenderTargetMapping
clear	vcglib/wrap/glw/geometryshader.h	/^		void clear(void)$/;"	f	class:glw::GeometryShaderArguments
clear	vcglib/wrap/glw/object.h	/^		void clear(void)$/;"	f	class:glw::ObjectArguments
clear	vcglib/wrap/glw/program.h	/^		void clear(void)$/;"	f	class:glw::FragmentOutputBinding
clear	vcglib/wrap/glw/program.h	/^		void clear(void)$/;"	f	class:glw::GeometryStage
clear	vcglib/wrap/glw/program.h	/^		void clear(void)$/;"	f	class:glw::ProgramArguments
clear	vcglib/wrap/glw/program.h	/^		void clear(void)$/;"	f	class:glw::RasterizerSettings
clear	vcglib/wrap/glw/program.h	/^		void clear(void)$/;"	f	class:glw::TransformFeedbackStream
clear	vcglib/wrap/glw/program.h	/^		void clear(void)$/;"	f	class:glw::VertexAttributeBinding
clear	vcglib/wrap/glw/renderable.h	/^		void clear(void)$/;"	f	class:glw::RenderableArguments
clear	vcglib/wrap/glw/renderbuffer.h	/^		void clear(void)$/;"	f	class:glw::RenderbufferArguments
clear	vcglib/wrap/glw/shader.h	/^		void clear(void)$/;"	f	class:glw::ShaderArguments
clear	vcglib/wrap/glw/texture.h	/^		void clear(void)$/;"	f	class:glw::TextureArguments
clear	vcglib/wrap/glw/texture.h	/^		void clear(void)$/;"	f	class:glw::TextureSampleMode
clear	vcglib/wrap/glw/texture2d.h	/^		void clear(void)$/;"	f	class:glw::Texture2DArguments
clear	vcglib/wrap/glw/texturecube.h	/^		void clear(void)$/;"	f	class:glw::TextureCubeArguments
clear	vcglib/wrap/glw/utility.h	/^		void clear(void)$/;"	f	class:glw::ShaderHeaderBuilder
clear	vcglib/wrap/glw/vertexshader.h	/^		void clear(void)$/;"	f	class:glw::VertexShaderArguments
clearFactors	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void clearFactors()$/;"	f	class:Eigen::SuperLUBase
clearFlags	vcglib/vcg/complex/algorithms/nring.h	/^    static void clearFlags(MeshType* m)$/;"	f	class:vcg::tri::Nring
clear_pinuse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define clear_pinuse(/;"	d	file:
clear_smallmap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define clear_smallmap(/;"	d	file:
clear_treemap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define clear_treemap(/;"	d	file:
close	vcglib/wrap/gcache/door.h	/^  void close() {$/;"	f	class:QDoor
closed_spline2d	vcglib/eigenlib/unsupported/test/splines.cpp	/^Spline<double, 2, Dynamic> closed_spline2d()$/;"	f
closestPt	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^			CoordType closestPt;$/;"	m	class:vcg::AABBBinaryTreeKClosest::ClosestObjType
cluster	vcglib/apps/pivoting/pivot.h	/^    void Pivot::cluster(int v) {$/;"	f	class:vcg::tri::Pivot::Pivot
cmpabs	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int cmpabs(const mpreal& a,const mpreal& b)$/;"	f	namespace:mpfr
cnm	vcglib/wrap/gl/trimesh.h	/^    NormalMode cnm; \/\/ Current NormalMode$/;"	m	class:vcg::GlTrimesh
cnt	vcglib/vcg/complex/algorithms/clustering.h	/^  int cnt;$/;"	m	class:vcg::tri::AverageColorCell
cnt	vcglib/vcg/complex/algorithms/smooth.h	/^    ScalarType cnt;$/;"	m	class:vcg::tri::Smooth::LaplacianInfo
cnt	vcglib/vcg/complex/algorithms/smooth.h	/^    int cnt;$/;"	m	class:vcg::tri::Smooth::ColorSmoothInfo
cnt	vcglib/vcg/complex/algorithms/smooth.h	/^    int cnt;$/;"	m	class:vcg::tri::Smooth::HCSmoothInfo
cnt	vcglib/vcg/complex/algorithms/smooth.h	/^    int cnt;$/;"	m	class:vcg::tri::Smooth::QualitySmoothInfo
cnt	vcglib/vcg/complex/algorithms/update/color.h	/^    int cnt;$/;"	m	class:vcg::tri::UpdateColor::ColorAvgInfo
cnt	vcglib/vcg/math/histogram.h	/^  ScalarType cnt;	\/\/! Number of accumulated samples.$/;"	m	class:vcg::Histogram
coeff	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ArrayWrapper
coeff	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::MatrixWrapper
coeff	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ArrayWrapper
coeff	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::MatrixWrapper
coeff	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Block
coeff	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Block
coeff	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl
coeff	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseBinaryOpImpl
coeff	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp
coeff	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rows, Index cols) const$/;"	f	class:Eigen::CwiseNullaryOp
coeff	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl
coeff	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryOpImpl
coeff	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryViewImpl
coeff	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryViewImpl
coeff	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
coeff	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    coeff(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
coeff	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Diagonal
coeff	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index row, Index) const$/;"	f	class:Eigen::Diagonal
coeff	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct
coeff	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Flagged
coeff	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Flagged
coeff	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess
coeff	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess
coeff	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index index) const$/;"	f	class:Eigen::MapBase
coeff	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index row, Index col) const$/;"	f	class:Eigen::MapBase
coeff	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::NestByValue
coeff	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::NestByValue
coeff	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const$/;"	f	class:Eigen::PlainObjectBase
coeff	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index row, Index col) const$/;"	f	class:Eigen::PlainObjectBase
coeff	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typename Base::CoeffReturnType coeff(Index i) const$/;"	f	class:Eigen::ProductBase
coeff	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    typename Base::CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ProductBase
coeff	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Replicate
coeff	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeff	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index,Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeff	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Reverse
coeff	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Reverse
coeff	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i) const$/;"	f	class:Eigen::Select
coeff	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::Select
coeff	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SelfAdjointView
coeff	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::TransposeImpl
coeff	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::TransposeImpl
coeff	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline const Index& coeff(Index i) const { return indices().coeff(i); }$/;"	f	class:Eigen::TranspositionsBase
coeff	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const  { return derived().coeff(row,col); }$/;"	f	class:Eigen::TriangularBase
coeff	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::TriangularView
coeff	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::PartialReduxExpr
coeff	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const Scalar coeff(Index index) const$/;"	f	class:Eigen::PartialReduxExpr
coeff	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct
coeff	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct
coeff	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    inline const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Minor
coeff	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Homogeneous
coeff	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeff(_Index i)$/;"	f	class:Eigen::internal::AmbiVector
coeff	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::MappedSparseMatrix
coeff	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseMatrix
coeff	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index i) const { return m_data.at(i); }$/;"	f	class:Eigen::SparseVector
coeff	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseVector
coeff	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar coeff(Index row, Index col) const {$/;"	f	class:Eigen::SkylineMatrix
coeff	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::DynamicSparseMatrix
coeffByOuterInner	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeffByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
coeffDiag	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar coeffDiag(Index idx) const {$/;"	f	class:Eigen::SkylineMatrix
coeffExistLower	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline bool coeffExistLower(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
coeffExistUpper	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline bool coeffExistUpper(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
coeffLower	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar coeffLower(Index row, Index col) const {$/;"	f	class:Eigen::SkylineMatrix
coeffRef	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ArrayWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::MatrixWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ArrayWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MatrixWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::ArrayWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MatrixWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::ArrayWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::MatrixWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Block
coeffRef	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Block
coeffRef	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::Block
coeffRef	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::Block
coeffRef	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::CwiseUnaryViewImpl
coeffRef	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::CwiseUnaryViewImpl
coeffRef	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRef(Index index)$/;"	f	class:Eigen::DenseCoeffsBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Diagonal
coeffRef	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index row, Index)$/;"	f	class:Eigen::Diagonal
coeffRef	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::Diagonal
coeffRef	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index row, Index) const$/;"	f	class:Eigen::Diagonal
coeffRef	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Flagged
coeffRef	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Flagged
coeffRef	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::Flagged
coeffRef	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::Flagged
coeffRef	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ForceAlignedAccess
coeffRef	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ForceAlignedAccess
coeffRef	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::MapBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MapBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MapBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::MapBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::NestByValue
coeffRef	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::NestByValue
coeffRef	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::PlainObjectBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::PlainObjectBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::PlainObjectBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::PlainObjectBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index i) const$/;"	f	class:Eigen::ProductBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::ProductBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeffRef	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index,Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeffRef	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Reverse
coeffRef	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Reverse
coeffRef	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfAdjointView
coeffRef	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SelfCwiseBinaryOp
coeffRef	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfCwiseBinaryOp
coeffRef	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SelfCwiseBinaryOp
coeffRef	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::SelfCwiseBinaryOp
coeffRef	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SwapWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SwapWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::SwapWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SwapWrapper
coeffRef	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::TransposeImpl
coeffRef	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TransposeImpl
coeffRef	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::TransposeImpl
coeffRef	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::TransposeImpl
coeffRef	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Index& coeffRef(Index i) { return indices().coeffRef(i); }$/;"	f	class:Eigen::TranspositionsBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col) { return derived().coeffRef(row,col); }$/;"	f	class:Eigen::TriangularBase
coeffRef	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TriangularView
coeffRef	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Minor
coeffRef	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeffRef(_Index i)$/;"	f	class:Eigen::internal::AmbiVector
coeffRef	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MappedSparseMatrix
coeffRef	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
coeffRef	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index i)$/;"	f	class:Eigen::SparseVector
coeffRef	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseVector
coeffRef	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    CoeffType coeffRef(Index i) { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
coeffRef	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    const CoeffType coeffRef(Index i) const { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
coeffRef	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
coeffRef	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::DynamicSparseMatrix
coeffRefByOuterInner	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRefByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::DenseCoeffsBase
coeffRefDiag	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& coeffRefDiag(Index idx) {$/;"	f	class:Eigen::SkylineMatrix
coeffRefLower	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& coeffRefLower(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
coeffRefUpper	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& coeffRefUpper(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
coeffSeparator	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  std::string coeffSeparator;$/;"	m	struct:Eigen::IOFormat
coeffUpper	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar coeffUpper(Index row, Index col) const {$/;"	f	class:Eigen::SkylineMatrix
coeff_visitor	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^struct coeff_visitor$/;"	s	namespace:Eigen::internal
coefficients	vcglib/vcg/math/spherical_harmonics.h	/^	ScalarType coefficients[MAX_BAND * MAX_BAND];$/;"	m	class:vcg::math::SphericalHarmonics
coeffs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
coeffs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix
coeffs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
coeffs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix
coeffs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrixWrapper
coeffs	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Quaternion
coeffs	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Quaternion
coeffs	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  VectorType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Scaling
coeffs	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  const VectorType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Scaling
coeffs	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Map
coeffs	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Map
coeffs	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Map
coeffs	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs;}$/;"	f	class:Eigen::Quaternion
coeffs	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Quaternion
coeffs	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline const typename internal::traits<Derived>::Coefficients& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase
coeffs	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline typename internal::traits<Derived>::Coefficients& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase
cofactor_3x3	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_3x3(const MatrixType& m)$/;"	f	namespace:Eigen::internal
cofactor_4x4	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_4x4(const MatrixType& matrix)$/;"	f	namespace:Eigen::internal
coherentAdjNum	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    int coherentAdjNum; \/\/\/ number of nodes used in the coherency pass$/;"	m	struct:vcg::tri::PointCloudNormal::Param
col	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,Dynamic,1> col(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase
col	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::all_unroller::__anon51
col	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::any_unroller::__anon52
col	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon241
col	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon242
col	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon254
col	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::visitor_impl::__anon326
col	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor
col	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::DenseBase::InnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::col(Index i)$/;"	f	class:Eigen::SparseMatrixBase
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::col(Index i) const$/;"	f	class:Eigen::SparseMatrixBase
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return Lhs::IsRowMajor ? index() : m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_rhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index col() const { return Transpose ? m_outer : Base::row(); }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index col() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return Base::col(); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return Base::col(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^  const Index& col() const { return m_col; }$/;"	f	class:Eigen::Triplet
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::InnerIterator
col	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
col	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ColXpr col(Index i)$/;"	f
col	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ConstColXpr col(Index i) const$/;"	f
col	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index col() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
col	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index col() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
col	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator
col	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? Base::index() : m_outer; }$/;"	f	class:Eigen::DynamicSparseMatrix::InnerIterator
col	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? Base::index() : m_outer; }$/;"	f	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
colIndexByOuterInner	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
colOffset	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value()>0 ? m_index.value() : 0; }$/;"	f	class:Eigen::Diagonal
colPivHouseholderQr	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^MatrixBase<Derived>::colPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase
colStride	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index colStride() const$/;"	f	class:Eigen::DenseCoeffsBase
colind	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int*  colind()   { return m_colind  ; }$/;"	f	class:SparseMatrixData
collapseShortEdge	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  bool collapseShortEdge;$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
collapseShortEdgePerc	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  float collapseShortEdgePerc;$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
color	vcglib/apps/pivoting/cmesh.h	/^   float color;$/;"	m	class:CVertex
color	vcglib/vcg/space/index/octree.h	/^        vcg::Color4b	color;$/;"	m	struct:vcg::OcreeRenderingSetting
color	vcglib/wrap/bmt/strip_mesh.h	/^  std::vector<unsigned char> color;$/;"	m	class:vcg::StripMeshBuilder
color	vcglib/wrap/gui/rubberband.h	/^  Color4b color;$/;"	m	class:vcg::Rubberband
color	vcglib/wrap/gui/trackutils.h	/^  Color4b color;$/;"	m	class:vcg::trackutils::DrawingHint
color	vcglib/wrap/io_trimesh/import_fbx.h	/^			ColorType color;$/;"	m	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
color	vcglib/wrap/qt/gl_label.h	/^      vcg::Color4b color;$/;"	m	class:vcg::glLabel::Mode
colorByStiffening	vcglib/wrap/miq/core/stiffening.h	/^    static void colorByStiffening(MeshType & mesh,$/;"	f	class:StiffeningInitializer
colorStrategy	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  int colorStrategy;$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
colorTargets	vcglib/wrap/glw/framebuffer.h	/^		RenderTargetMapping  colorTargets;$/;"	m	class:glw::FramebufferArguments
color_attachments_count	vcglib/wrap/gl/gl_surface.h	/^		int color_attachments_count(void) const$/;"	f	class:vcg::gl_surface
color_formats	vcglib/wrap/gl/gl_surface.h	/^		std::vector<GLenum> color_formats;$/;"	m	class:vcg::gl_surface
color_func_tetra	vcglib/wrap/gl/tetramesh.h	/^	typedef Color4b (*color_func_tetra)(TetraType&v);$/;"	t	class:vcg::tetra::GlTetramesh
color_func_vertex	vcglib/wrap/gl/tetramesh.h	/^  typedef Color4b (*color_func_vertex)(VertexType&v);$/;"	t	class:vcg::tetra::GlTetramesh
color_tetra	vcglib/wrap/gl/tetramesh.h	/^	color_func_tetra  color_tetra;$/;"	m	class:vcg::tetra::GlTetramesh
color_texs	vcglib/wrap/gl/gl_surface.h	/^		std::vector<GLuint> color_texs;$/;"	m	class:vcg::gl_surface
color_vertex	vcglib/wrap/gl/tetramesh.h	/^	color_func_vertex  color_vertex;$/;"	m	class:vcg::tetra::GlTetramesh
colormapspecs	vcglib/wrap/io_trimesh/export_idtf.h	/^		unsigned char colormapspecs[5];$/;"	m	struct:vcg::tri::io::TGA_Exporter::TGAHeader
colors	vcglib/wrap/io_tetramesh/import_ply.h	/^	float colors[32];$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
colors	vcglib/wrap/io_trimesh/import_ply.h	/^	float colors[32];$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
colourmaptype	vcglib/wrap/io_trimesh/export_idtf.h	/^		unsigned char  colourmaptype;      $/;"	m	struct:vcg::tri::io::TGA_Exporter::TGAHeader
cols	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LDLT
cols	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LLT
cols	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline Index cols() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase
cols	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ArrayWrapper
cols	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::MatrixWrapper
cols	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrix
cols	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
cols	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline Index cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::Block
cols	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::CwiseBinaryOp
cols	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::CwiseNullaryOp
cols	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::CwiseUnaryOp
cols	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::CwiseUnaryView
cols	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex cols(void) const {return _Cols;}$/;"	f	class:Eigen::DenseStorage
cols	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex cols(void) const {return m_cols;}$/;"	f	class:Eigen::DenseStorage
cols	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    static inline DenseIndex cols(void) {return _Cols;}$/;"	f	class:Eigen::DenseStorage
cols	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline Index cols() const { return 1; }$/;"	f	class:Eigen::Diagonal
cols	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline Index cols() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase
cols	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::DiagonalProduct
cols	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  inline Index cols() const { return derived().cols(); }$/;"	f	struct:Eigen::EigenBase
cols	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Flagged
cols	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ForceAlignedAccess
cols	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::MapBase
cols	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::NestByValue
cols	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline Index cols() const { return indices().size(); }$/;"	f	class:Eigen::PermutationBase
cols	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval
cols	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline int cols() const { return m_permutation.cols(); }$/;"	f	class:Eigen::Transpose
cols	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }$/;"	f	class:Eigen::PlainObjectBase
cols	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    inline Index cols() const { return m_rhs.cols(); }$/;"	f	class:Product
cols	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    inline Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::ProductBase
cols	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    inline Index cols() const { return m_matrix.cols() * m_colFactor.value(); }$/;"	f	class:Eigen::Replicate
cols	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    inline Index cols() const { return static_cast<const Derived*>(this)->cols(); }$/;"	f	class:Eigen::ReturnByValue
cols	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Reverse
cols	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    Index cols() const { return m_condition.cols(); }$/;"	f	class:Eigen::Select
cols	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfAdjointView
cols	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp
cols	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval
cols	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::SwapWrapper
cols	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline Index cols() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Transpose
cols	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval
cols	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::TriangularBase
cols	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::TriangularView
cols	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    Index cols() const { return (Direction==Horizontal ? 1 : m_matrix.cols()); }$/;"	f	class:Eigen::PartialReduxExpr
cols	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::CoeffBasedProduct
cols	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    inline Index cols() const { return m_matrix.cols() - 1; }$/;"	f	class:Eigen::Minor
cols	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index cols() const { return m_hess.packedMatrix().cols(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
cols	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
cols	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    inline Index cols() const { return m_matrix.cols() + (int(Direction)==Horizontal ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous
cols	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
cols	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
cols	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    Index cols() const { return rows(); }$/;"	f	class:Eigen::HouseholderSequence
cols	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index cols() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner
cols	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::IncompleteLUT
cols	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index cols() const { return mp_matrix ? mp_matrix->cols() : 0; }$/;"	f	class:Eigen::IterativeSolverBase
cols	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::FullPivLU
cols	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::inverse_impl
cols	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::PartialPivLU
cols	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PastixBase
cols	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl
cols	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::ColPivHouseholderQR
cols	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index cols() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
cols	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::FullPivHouseholderQR
cols	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::HouseholderQR
cols	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    inline Index cols() const { return m_cols; }$/;"	f	class:Eigen::JacobiSVD
cols	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SimplicialCholeskyBase
cols	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::SparseInnerVectorSet
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return Tr ? m_lhs.cols() : m_rhs.cols(); }$/;"	f	class:Eigen::SparseDenseOuterProduct
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseDiagonalProduct
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::SparseMatrix
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::SparseMatrixBase
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseSparseProduct
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSelfAdjointView
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseTriangularView
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsColVector ? 1 : m_size; }$/;"	f	class:Eigen::SparseVector
cols	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseView
cols	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SuperLUBase
cols	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index cols() const { return m_copyMatrix.cols(); }$/;"	f	class:Eigen::UmfPackLU
cols	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::image_retval_base
cols	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::kernel_retval_base
cols	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base
cols	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess
cols	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
cols	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::IncompleteLU
cols	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    Index cols() const { return m_src.cols(); }$/;"	f	struct:Eigen::MatrixExponentialReturnValue
cols	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    Index cols() const { return m_A.cols(); }$/;"	f	class:Eigen::MatrixFunctionReturnValue
cols	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  Index cols() const { return m_A.cols(); }$/;"	f	class:Eigen::MatrixLogarithmReturnValue
cols	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    Index cols() const { return m_src.cols(); }$/;"	f	class:Eigen::MatrixSquareRootReturnValue
cols	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index cols() const {$/;"	f	class:Eigen::SkylineMatrix
cols	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Index cols() const {$/;"	f	class:Eigen::SkylineMatrixBase
cols	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::internal::SkylineProduct
cols	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::SparseInnerVectorSet
cols	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : outerSize(); }$/;"	f	class:Eigen::DynamicSparseMatrix
colsPermutation	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::ColPivHouseholderQR
colsPermutation	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::FullPivHouseholderQR
cols_select	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    cols_select = product_size_category<Cols,MaxCols>::value,$/;"	e	enum:Eigen::internal::product_type::__anon143
colwise	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise() const$/;"	f	class:Eigen::DenseBase
colwise	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise()$/;"	f	class:Eigen::DenseBase
comments	vcglib/wrap/ply/plylib.h	/^	std::vector<std::string>  comments;	\/\/ Vettore dei commenti$/;"	m	class:vcg::ply::PlyFile
compProjectionIntegrals	vcglib/vcg/complex/algorithms/inertia.h	/^ void compProjectionIntegrals(FaceType &f)$/;"	f	class:vcg::tri::Inertia
companion	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    companion( const VectorType& poly ){$/;"	f	class:Eigen::internal::companion
companion	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^class companion$/;"	c	namespace:Eigen::internal
compile	vcglib/wrap/glw/shader.h	/^		void compile(const std::string & source)$/;"	f	class:glw::Shader
compile	vcglib/wrap/ply/plylib.cpp	/^void PlyFile::compile( PlyElement * e )$/;"	f	class:vcg::ply::PlyFile
compile	vcglib/wrap/ply/plylib.cpp	/^void PlyFile::compile( PlyProperty * p )$/;"	f	class:vcg::ply::PlyFile
compiled	vcglib/wrap/gl/shaders.h	/^	bool compiled;$/;"	m	class:Shader
completed	vcglib/vcg/complex/algorithms/clean.h	/^  bool completed() {$/;"	f	class:vcg::tri::ConnectedComponentIterator
complex_schur_reduce_to_hessenberg	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg$/;"	s	namespace:Eigen::internal
complex_schur_reduce_to_hessenberg	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg<MatrixType, false>$/;"	s	namespace:Eigen::internal
complex_spherical_harmonic_im	vcglib/vcg/math/spherical_harmonics.h	/^	inline static ScalarType complex_spherical_harmonic_im(unsigned l, unsigned m, ScalarType theta, ScalarType phi)$/;"	f	class:vcg::math::SphericalHarmonics
complex_spherical_harmonic_re	vcglib/vcg/math/spherical_harmonics.h	/^	inline static ScalarType complex_spherical_harmonic_re(unsigned l, unsigned m, ScalarType theta, ScalarType phi)$/;"	f	class:vcg::math::SphericalHarmonics
complex_type	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef fftw_complex complex_type;$/;"	t	struct:Eigen::internal::fftw_plan
complex_type	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef fftwf_complex complex_type;$/;"	t	struct:Eigen::internal::fftw_plan
complex_type	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef fftwl_complex complex_type;$/;"	t	struct:Eigen::internal::fftw_plan
compute	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LDLT
compute	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^LLT<MatrixType,_UpLo>& LLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LLT
compute	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& compute(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
compute	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::SVD
compute	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^ComplexEigenSolver<MatrixType>& ComplexEigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver
compute	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::ComplexSchur
compute	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^EigenSolver<MatrixType>& EigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::EigenSolver
compute	vcglib/eigenlib/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^compute(const MatrixType& matA, const MatrixType& matB, int options)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
compute	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition& compute(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition
compute	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::RealSchur
compute	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver
compute	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver
compute	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::compute(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver
compute	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization& compute(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization
compute	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& compute(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner
compute	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& compute(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
compute	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT<Scalar>& compute(const MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
compute	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& compute(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase
compute	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>& FullPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU
compute	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>& PartialPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU
compute	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
compute	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
compute	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
compute	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::compute(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
compute	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::compute(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
compute	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^ColPivHouseholderQR<MatrixType>& ColPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR
compute	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^FullPivHouseholderQR<MatrixType>& FullPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR
compute	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^HouseholderQR<MatrixType>& HouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR
compute	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix)$/;"	f	class:Eigen::JacobiSVD
compute	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType& matrix, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD
compute	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::compute(const _MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization
compute	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky
compute	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT
compute	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT
compute	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase
compute	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLUBase
compute	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
compute	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    IncompleteLU& compute(const MatrixType& mat)$/;"	f	class:Eigen::IncompleteLU
compute	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    void compute (const MatrixType& mat)$/;"	f	class:Scaling
compute	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void MatrixExponential<MatrixType>::compute(ResultType &result)$/;"	f	class:Eigen::MatrixExponential
compute	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    void compute(ResultType& result) $/;"	f	class:Eigen::MatrixFunction
compute	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void MatrixFunction<MatrixType,AtomicType,1>::compute(ResultType& result) $/;"	f	class:Eigen::MatrixFunction
compute	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^MatrixType MatrixFunctionAtomic<MatrixType>::compute(const MatrixType& A)$/;"	f	class:Eigen::MatrixFunctionAtomic
compute	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^MatrixType MatrixLogarithmAtomic<MatrixType>::compute(const MatrixType& A)$/;"	f	class:Eigen::MatrixLogarithmAtomic
compute	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    template <typename ResultType> void compute(ResultType &result)$/;"	f	class:Eigen::MatrixSquareRoot
compute	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void MatrixSquareRootQuasiTriangular<MatrixType>::compute(ResultType &result)$/;"	f	class:Eigen::MatrixSquareRootQuasiTriangular
compute	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void MatrixSquareRootTriangular<MatrixType>::compute(ResultType &result)$/;"	f	class:Eigen::MatrixSquareRootTriangular
compute	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    void compute( const OtherPolynomial& poly )$/;"	f	class:Eigen::PolynomialSolver
compute	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^void SkylineInplaceLU<MatrixType>::compute() {$/;"	f	class:Eigen::SkylineInplaceLU
compute1x1offDiagonalBlock	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^     ::compute1x1offDiagonalBlock(MatrixType& sqrtT, const MatrixType& T, $/;"	f	class:Eigen::MatrixSquareRootQuasiTriangular
compute1x2offDiagonalBlock	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^     ::compute1x2offDiagonalBlock(MatrixType& sqrtT, const MatrixType& T, $/;"	f	class:Eigen::MatrixSquareRootQuasiTriangular
compute2x1offDiagonalBlock	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^     ::compute2x1offDiagonalBlock(MatrixType& sqrtT, const MatrixType& T, $/;"	f	class:Eigen::MatrixSquareRootQuasiTriangular
compute2x2	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::compute2x2(const MatrixType& A, MatrixType& result)$/;"	f	class:Eigen::MatrixLogarithmAtomic
compute2x2diagonalBlock	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^     ::compute2x2diagonalBlock(MatrixType& sqrtT, const MatrixType& T, typename MatrixType::Index i)$/;"	f	class:Eigen::MatrixSquareRootQuasiTriangular
compute2x2offDiagonalBlock	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^     ::compute2x2offDiagonalBlock(MatrixType& sqrtT, const MatrixType& T, $/;"	f	class:Eigen::MatrixSquareRootQuasiTriangular
computeBig	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computeBig(const MatrixType& A, MatrixType& result)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computeBlockAtomic	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void MatrixFunction<MatrixType,AtomicType,1>::computeBlockAtomic()$/;"	f	class:Eigen::MatrixFunction
computeBlockStart	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void MatrixFunction<MatrixType,AtomicType,1>::computeBlockStart()$/;"	f	class:Eigen::MatrixFunction
computeClusterSize	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void MatrixFunction<MatrixType,AtomicType,1>::computeClusterSize()$/;"	f	class:Eigen::MatrixFunction
computeCurvature	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static void computeCurvature(MeshType & m)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
computeDiagonalPartOfSqrt	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void MatrixSquareRootQuasiTriangular<MatrixType>::computeDiagonalPartOfSqrt(MatrixType& sqrtT, $/;"	f	class:Eigen::MatrixSquareRootQuasiTriangular
computeDirect	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::computeDirect(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver
computeImage	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    void computeImage(ImageMatrixType *result) const$/;"	f	class:Eigen::LU
computeInverse	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    void computeInverse(MatrixBase<ResultType> *result) const {$/;"	f	class:Eigen::MatrixBase
computeInverse	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    inline void computeInverse(ResultType *result) const$/;"	f	class:Eigen::LU
computeInverseAndDetWithCheck	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseAndDetWithCheck($/;"	f	class:Eigen::MatrixBase
computeInverseWithCheck	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseWithCheck($/;"	f	class:Eigen::MatrixBase
computeKernel	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    void computeKernel(KernelMatrixType *result) const$/;"	f	class:Eigen::LU
computeMFitmap	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    static void computeMFitmap(MeshType& m, float perc, int ringMax = 50)$/;"	f	class:vcg::tri::Fitmaps
computeMu	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^void MatrixFunctionAtomic<MatrixType>::computeMu()$/;"	f	class:Eigen::MatrixFunctionAtomic
computeNormOfT	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Scalar RealSchur<MatrixType>::computeNormOfT()$/;"	f	class:Eigen::RealSchur
computeOffDiagonal	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void MatrixFunction<MatrixType,AtomicType,1>::computeOffDiagonal()$/;"	f	class:Eigen::MatrixFunction
computeOffDiagonalPartOfSqrt	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^void MatrixSquareRootQuasiTriangular<MatrixType>::computeOffDiagonalPartOfSqrt(MatrixType& sqrtT, $/;"	f	class:Eigen::MatrixSquareRootQuasiTriangular
computePade	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computePade(MatrixType& result, const MatrixType& T, int degree)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computePade10	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computePade10(MatrixType& result, const MatrixType& T)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computePade11	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computePade11(MatrixType& result, const MatrixType& T)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computePade3	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computePade3(MatrixType& result, const MatrixType& T)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computePade4	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computePade4(MatrixType& result, const MatrixType& T)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computePade5	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computePade5(MatrixType& result, const MatrixType& T)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computePade6	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computePade6(MatrixType& result, const MatrixType& T)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computePade7	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computePade7(MatrixType& result, const MatrixType& T)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computePade8	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computePade8(MatrixType& result, const MatrixType& T)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computePade9	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^void MatrixLogarithmAtomic<MatrixType>::computePade9(MatrixType& result, const MatrixType& T)$/;"	f	class:Eigen::MatrixLogarithmAtomic
computePositiveUnitary	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computePositiveUnitary(UnitaryType *positive,$/;"	f	class:Eigen::SVD
computeProductBlockingSizes	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void computeProductBlockingSizes(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)$/;"	f	namespace:Eigen::internal
computeProductBlockingSizes	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^void computeProductBlockingSizes(std::ptrdiff_t& k, std::ptrdiff_t& m, std::ptrdiff_t& n)$/;"	f	namespace:Eigen::internal
computeRef	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    void computeRef (MatrixType& mat)$/;"	f	class:Scaling
computeReferenceFrames	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static std::vector<CoordType> computeReferenceFrames(VertexTypeP vi)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
computeReferenceFramesLocal	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static void computeReferenceFramesLocal (VertexType *v, CoordType ppn, std::vector<CoordType> *ref)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
computeRoots	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void computeRoots(const MatrixType& m, VectorType& roots)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
computeRotationScaling	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform
computeRotationScaling	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeRotationScaling(RotationType *rotation, ScalingType *scaling) const$/;"	f	class:Eigen::SVD
computeRotationScaling	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform
computeRowMajor	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^void SkylineInplaceLU<MatrixType>::computeRowMajor() {$/;"	f	class:Eigen::SkylineInplaceLU
computeSFitmap	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    static void computeSFitmap(MeshType& m)\/\/, float target = 1000)$/;"	f	class:vcg::tri::Fitmaps
computeScalingRotation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform
computeScalingRotation	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeScalingRotation(ScalingType *scaling, RotationType *rotation) const$/;"	f	class:Eigen::SVD
computeScalingRotation	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform
computeSchurDecomposition	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void MatrixFunction<MatrixType,AtomicType,1>::computeSchurDecomposition()$/;"	f	class:Eigen::MatrixFunction
computeShift	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^typename ComplexSchur<MatrixType>::ComplexScalar ComplexSchur<MatrixType>::computeShift(Index iu, Index iter)$/;"	f	class:Eigen::ComplexSchur
computeShift	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)$/;"	f	class:Eigen::RealSchur
computeU	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    inline bool computeU() const { return m_computeFullU || m_computeThinU; }$/;"	f	class:Eigen::JacobiSVD
computeUV	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void MatrixExponential<MatrixType>::computeUV(double)$/;"	f	class:Eigen::MatrixExponential
computeUV	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void MatrixExponential<MatrixType>::computeUV(float)$/;"	f	class:Eigen::MatrixExponential
computeUV	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^void MatrixExponential<MatrixType>::computeUV(long double)$/;"	f	class:Eigen::MatrixExponential
computeUnitaryPositive	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeUnitaryPositive(UnitaryType *unitary,$/;"	f	class:Eigen::SVD
computeV	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    inline bool computeV() const { return m_computeFullV || m_computeThinV; }$/;"	f	class:Eigen::JacobiSVD
computeWeight	vcglib/vcg/complex/algorithms/hole.h	/^    static Weight computeWeight( int i, int j, int k,$/;"	f	class:vcg::tri::Hole
compute_bit2idx	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define compute_bit2idx(/;"	d	file:
compute_fitmap	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            static float compute_fitmap(HEdgePointer hp, CoordType &P, TriMeshType &tm, GRID &grid, Fitmap_attr &attr)$/;"	f	class:vcg::tri::FitmapsCollapse
compute_intervals_isectline	vcglib/vcg/space/intersection/triangle_triangle3.h	/^inline int compute_intervals_isectline(Point3<T> VERT0,Point3<T> VERT1,Point3<T> VERT2,$/;"	f	namespace:vcg
compute_inverse	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse$/;"	s	namespace:Eigen::internal
compute_inverse	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check { \/* nothing! general case not supported. *\/ };$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
compute_inverse_size2_helper	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^inline void compute_inverse_size2_helper($/;"	f	namespace:Eigen::internal
compute_inverse_size3_helper	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^inline void compute_inverse_size3_helper($/;"	f	namespace:Eigen::internal
compute_inverse_size4	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct compute_inverse_size4$/;"	s	namespace:Eigen::internal
compute_inverse_size4	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, double, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
compute_inverse_size4	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, float, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
compute_tree_index	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define compute_tree_index(/;"	d	file:
compute_weight	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            static float compute_weight(HEdgePointer hp, CoordType &P, TriMeshType &tm, GRID &grid)$/;"	f	class:vcg::tri::FitmapsCollapse
concat	vcg_mesh.cpp	/^void MyMesh::concat(const float* verts,$/;"	f	class:vcg::MyMesh
condition	vcglib/wrap/system/multithreading/condition.h	/^		condition(void)$/;"	f	class:mt::condition
condition	vcglib/wrap/system/multithreading/condition.h	/^class condition$/;"	c	namespace:mt
conditionMatrix	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    const ConditionMatrixType& conditionMatrix() const$/;"	f	class:Eigen::Select
conditional	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	s	namespace:Eigen::internal
conditional	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	s	namespace:Eigen::internal
conditional_aligned_delete	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_delete_auto	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete_auto(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_free	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<> inline void conditional_aligned_free<false>(void *ptr)$/;"	f	namespace:Eigen::internal
conditional_aligned_free	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
conditional_aligned_malloc	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_malloc<false>(size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_malloc	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_new	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new(size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_new_auto	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new_auto(size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc_new	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc_new_auto	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new_auto(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal
configure	vcglib/wrap/glw/framebuffer.h	/^		void configure(GLenum target, const FramebufferArguments & args)$/;"	f	class:glw::Framebuffer
configureShaders	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>::configureShaders()$/;"	f	class:SplatRenderer
configureTargetInputs	vcglib/wrap/glw/framebuffer.h	/^		void configureTargetInputs(const RenderTargetBinding & targetInputs)$/;"	f	class:glw::Framebuffer
conj	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(conj, Scalar) conj(const Scalar& x)$/;"	f	namespace:Eigen::internal
conj	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline const AutoDiffScalar<DerType>& conj(const AutoDiffScalar<DerType>& x)  { return x; }$/;"	f	namespace:Eigen
conj_expr_if	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^template<bool Cond, typename T> struct conj_expr_if$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet2d, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet4f, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2d, Packet1cd, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet4f, Packet2cf, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<RealScalar, std::complex<RealScalar>, false,Conj>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<std::complex<RealScalar>, RealScalar, Conj,false>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct conj_helper<Scalar,Scalar,false,false>$/;"	s	namespace:Eigen::internal
conj_if	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<false> {$/;"	s	namespace:Eigen::internal
conj_if	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<true> {$/;"	s	namespace:Eigen::internal
conj_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct conj_impl$/;"	s	namespace:Eigen::internal
conj_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct conj_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
conj_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct conj_retval$/;"	s	namespace:Eigen::internal
conjugate	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView<MatrixConjugateReturnType,Mode> conjugate()$/;"	f	class:Eigen::TriangularView
conjugate	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<MatrixConjugateReturnType,Mode> conjugate() const$/;"	f	class:Eigen::TriangularView
conjugate	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::conjugate() const$/;"	f	class:Eigen::Quaternion
conjugate	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::conjugate() const$/;"	f	class:Eigen::QuaternionBase
conjugate	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType conjugate() const$/;"	f	class:Eigen::HouseholderSequence
conjugate	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^conjugate() const$/;"	f
conjugate_gradient	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^void conjugate_gradient(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
connectHierarchyNode	vcglib/wrap/dae/colladaformat.h	/^	static void connectHierarchyNode(XMLInteriorNode* node0,XMLInteriorNode* node1,XMLInteriorNode* node2)$/;"	f	class:Collada::DocumentManager
connectHierarchyNode	vcglib/wrap/dae/colladaformat.h	/^	static void connectHierarchyNode(XMLInteriorNode* node0,XMLInteriorNode* node1,XMLInteriorNode* node2,XMLInteriorNode* node3)$/;"	f	class:Collada::DocumentManager
connectHierarchyNode	vcglib/wrap/dae/colladaformat.h	/^	static void connectHierarchyNode(XMLInteriorNode* node0,XMLInteriorNode* node1,XMLInteriorNode* node2,XMLInteriorNode* node3,XMLNode* node4)$/;"	f	class:Collada::DocumentManager
connectHierarchyNode	vcglib/wrap/dae/colladaformat.h	/^	static void connectHierarchyNode(XMLInteriorNode* node0,XMLInteriorNode* node1,XMLLeafNode* leaf)$/;"	f	class:Collada::DocumentManager
consensusDist	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        float consensusDist;                            \/\/\/< Consensus distance. Lower values should gat more accurancy; high values can lead to performance hit.$/;"	m	class:OverlapEstimation::Parameters
consensusNormalsAngle	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        float consensusNormalsAngle;                    \/\/\/< Holds the the consensus angle for normals, in gradients. Lower values decrease accurancy, particulary for range maps with many peaks and high frequencies.$/;"	m	class:OverlapEstimation::Parameters
conservativeResize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex size, DenseIndex rows, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage
conservativeResize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex size, DenseIndex rows, DenseIndex)$/;"	f	class:Eigen::DenseStorage
conservativeResize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex size, DenseIndex, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage
conservativeResize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex, DenseIndex rows, DenseIndex cols) { m_rows = rows; m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex, DenseIndex rows, DenseIndex) { m_rows = rows; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex, DenseIndex, DenseIndex cols) { m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void conservativeResize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage
conservativeResize	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index rows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index size)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(NoChange_t, Index cols)$/;"	f	class:Eigen::PlainObjectBase
conservativeResizeLike	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
conservative_resize_like_impl	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl<Derived,OtherDerived,true>$/;"	s	namespace:Eigen::internal
conservative_resize_like_impl	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^struct internal::conservative_resize_like_impl$/;"	s	class:Eigen::internal
conservative_sparse_sparse_product_impl	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^static void conservative_sparse_sparse_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
const	vcglib/wrap/system/getopt.cpp	/^#define const$/;"	d	file:
const_blas_data_mapper	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    const_blas_data_mapper(const Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::const_blas_data_mapper
const_blas_data_mapper	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^class const_blas_data_mapper$/;"	c	namespace:Eigen::internal
const_cast_derived	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  inline Derived& const_cast_derived() const$/;"	f	struct:Eigen::EigenBase
const_cast_derived	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& const_cast_derived() const$/;"	f	class:Eigen::SparseMatrixBase
const_cast_derived	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Derived& const_cast_derived() const {$/;"	f	class:Eigen::SkylineMatrixBase
const_catalan	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal const_catalan (mp_prec_t prec, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
const_derived	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  inline const Derived& const_derived() const$/;"	f	struct:Eigen::EigenBase
const_euler	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal const_euler (mp_prec_t prec, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
const_infinity	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal const_infinity (int sign, mp_prec_t prec, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
const_log2	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal const_log2 (mp_prec_t prec, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
const_pi	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal const_pi (mp_prec_t prec, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
const_pointer	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator
const_pointer	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator_indirection
const_reference	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator
const_reference	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator_indirection
constrainSelectedSeed	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  bool constrainSelectedSeed;   \/\/\/ If true the selected vertexes define a constraining domain:$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
constrained_cg	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h	/^void constrained_cg(const TMatrix& A, const CMatrix& C, VectorX& x,$/;"	f	namespace:Eigen::internal
construct	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    void  construct(pointer p, Args&&... args)$/;"	f	class:Eigen::aligned_allocator
construct	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    void construct( pointer p, const T& value )$/;"	f	class:Eigen::aligned_allocator
constructPermutation	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void MatrixFunction<MatrixType,AtomicType,1>::constructPermutation()$/;"	f	class:Eigen::MatrixFunction
construct_elements_of_array	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal
construct_from_matrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  struct construct_from_matrix$/;"	s	class:Eigen::Transform
construct_from_matrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  template<typename OtherDerived> struct construct_from_matrix<OtherDerived, true>$/;"	s	class:Eigen::Transform
constructor	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^    typedef vcg::tri::QuadDiagonalCollapse< MyPolyMesh, MyCollapseAdaptive, CMesh , vcg::tri::VertReg<MyPolyMesh>, vcg::tri::FitmapsCollapse<MyPolyMesh, CMesh> , vcg::tri::FitmapsCollapse<MyPolyMesh, CMesh> > constructor;$/;"	t	class:MyCollapseAdaptive	file:
constructor	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^    typedef vcg::tri::QuadDiagonalCollapseBase< MyPolyMesh, MyCollapse, CMesh , vcg::tri::VertReg<MyPolyMesh> > constructor;$/;"	t	class:MyCollapse	file:
constructor_without_unaligned_array_assert	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^struct constructor_without_unaligned_array_assert {};$/;"	s	namespace:Eigen::internal
contains	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
contains	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox
contains	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
contains	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline bool contains(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox
context	vcglib/wrap/glw/object.h	/^		Context * context(void)$/;"	f	class:glw::Object
context	vcglib/wrap/glw/object.h	/^		Context * context(void)$/;"	f	class:glw::SafeObject
context	vcglib/wrap/glw/object.h	/^		const Context * context(void) const$/;"	f	class:glw::Object
context	vcglib/wrap/glw/object.h	/^		const Context * context(void) const$/;"	f	class:glw::SafeObject
control	vcglib/wrap/minpack/minpack.h	/^lm_control_type control; \/\/ control of this object$/;"	m	class:LMDiff
converged	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool converged() const { return m_res <= m_rhsn * m_resmax; }$/;"	f	class:Eigen::IterationController
converged	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool converged(double nr)$/;"	f	class:Eigen::IterationController
converged	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    template<typename VectorType> bool converged(const VectorType &v)$/;"	f	class:Eigen::IterationController
conversion_overflow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^class conversion_overflow : public std::exception {$/;"	c	namespace:mpfr
convert	vcglib/wrap/io_trimesh/export_idtf.h	/^	static void convert(const QString& outfile,const QImage& im)$/;"	f	class:vcg::tri::io::TGA_Exporter
convertInTGATextures	vcglib/wrap/io_trimesh/export_idtf.h	/^	static QStringList convertInTGATextures(SaveMeshType& m,const QString& path,QStringList& textures_to_be_restored)$/;"	f	class:vcg::tri::io::ExporterIDTF
convertTexturesFiles	vcglib/wrap/io_trimesh/export_idtf.h	/^	static void convertTexturesFiles(SaveMeshType& m,const QString& file_path,QStringList& conv_file)$/;"	f	class:vcg::tri::io::TGA_Exporter
convert_QImage_to_RGB	vcglib/wrap/qt/img_qt_convert.h	/^inline void convert_QImage_to_RGB(const QImage &source, Image<3,ScalarType,Safe> &destination)$/;"	f	namespace:img
convert_QImage_to_RGBA	vcglib/wrap/qt/img_qt_convert.h	/^inline void convert_QImage_to_RGBA(const QImage &source, Image<4,ScalarType,Safe> &destination)$/;"	f	namespace:img
convert_QImage_to_Y	vcglib/wrap/qt/img_qt_convert.h	/^inline void convert_QImage_to_Y(const QImage &source, Image<1,ScalarType,Safe> &destination)$/;"	f	namespace:img
convert_RGBA_to_QImage	vcglib/wrap/qt/img_qt_convert.h	/^inline void convert_RGBA_to_QImage(const Image<4,ScalarType,Safe> &source, QImage &destination)$/;"	f	namespace:img
convert_RGBA_to_RGB	vcglib/img/img_convert.h	/^inline void convert_RGBA_to_RGB(const Image<4,SrcScalarType,SrcSafe> &source, Image<3,DestScalarType,DestSafe> &destination)$/;"	f	namespace:img
convert_RGBA_to_Y	vcglib/img/img_convert.h	/^inline void convert_RGBA_to_Y(const Image<4,SrcScalarType,SrcSafe> &source, Image<1,DestScalarType,DestSafe> &destination)$/;"	f	namespace:img
convert_RGB_to_QImage	vcglib/wrap/qt/img_qt_convert.h	/^inline void convert_RGB_to_QImage(const Image<3,ScalarType,Safe> &source, QImage &destination)$/;"	f	namespace:img
convert_RGB_to_RGBA	vcglib/img/img_convert.h	/^inline void convert_RGB_to_RGBA(const Image<3,SrcScalarType,SrcSafe> &source, Image<4,DestScalarType,DestSafe> &destination, DestScalarType alpha_value=255.0f )$/;"	f	namespace:img
convert_RGB_to_Y	vcglib/img/img_convert.h	/^inline void convert_RGB_to_Y(const Image<3,SrcScalarType,SrcSafe> &source, Image<1,DestScalarType,DestSafe> &destination)$/;"	f	namespace:img
convert_Y_to_QImage	vcglib/wrap/qt/img_qt_convert.h	/^inline void convert_Y_to_QImage(const Image<1,ScalarType,Safe> &source, QImage &destination)$/;"	f	namespace:img
convert_Y_to_RGB	vcglib/img/img_convert.h	/^inline void convert_Y_to_RGB(const Image<1,SrcScalarType,SrcSafe> &source, Image<3,DestScalarType,DestSafe> &destination)$/;"	f	namespace:img
convert_Y_to_RGBA	vcglib/img/img_convert.h	/^inline void convert_Y_to_RGBA(const Image<1,SrcScalarType,SrcSafe> &source, Image<4,DestScalarType,DestSafe> &destination, DestScalarType alpha_value=255.0f )$/;"	f	namespace:img
convert_gamma_precompensated_rgb_to_linear_rgb	vcglib/img/img_cs_base.h	/^inline void convert_gamma_precompensated_rgb_to_linear_rgb(const img::Image<Channels,ScalarType1,Safe1> &gamma_precompensated_rgb_image, img::Image<Channels,ScalarType2,Safe2> &linear_rgb_image)$/;"	f	namespace:img
convert_gamma_precompensated_srgb_to_linear_srgb	vcglib/img/img_cs_base.h	/^inline void convert_gamma_precompensated_srgb_to_linear_srgb(const img::Image<Channels,ScalarType1,Safe1> &gamma_precompensated_srgb_image, img::Image<Channels,ScalarType2,Safe2> &linear_srgb_image)$/;"	f	namespace:img
convert_linear_rgb_to_gamma_precompensated_rgb	vcglib/img/img_cs_base.h	/^inline void convert_linear_rgb_to_gamma_precompensated_rgb(const img::Image<Channels,ScalarType1,Safe1> &linear_rgb_image, img::Image<Channels,ScalarType2,Safe2> &gamma_precompensated_rgb_image, ScalarType2 gamma=ScalarType2(1.0\/2.2))$/;"	f	namespace:img
convert_linear_srgb_to_gamma_precompensated_srgb	vcglib/img/img_cs_base.h	/^inline void convert_linear_srgb_to_gamma_precompensated_srgb(const img::Image<Channels,ScalarType1,Safe1> &linear_srgb_image, img::Image<Channels,ScalarType2,Safe2> &gamma_precompensated_srgb_image)$/;"	f	namespace:img
convert_range_0_1_to_0_255	vcglib/img/img_convert.h	/^inline void convert_range_0_1_to_0_255(const Image<Channels,SrcScalarType,SrcSafe> &source, Image<Channels,DestScalarType,DestSafe> &destination)$/;"	f	namespace:img
convert_range_0_255_to_0_1	vcglib/img/img_convert.h	/^inline void convert_range_0_255_to_0_1(const Image<Channels,SrcScalarType,SrcSafe> &source, Image<Channels,DestScalarType,DestSafe> &destination)$/;"	f	namespace:img
convert_srgb_to_xyz	vcglib/img/img_cs_base.h	/^inline void convert_srgb_to_xyz(const img::Image<3,ScalarType1,Safe1> &rgb_image, img::Image<3,ScalarType2,Safe2> &xyz_image)$/;"	f	namespace:img
convert_xyz_to_rgb	vcglib/img/img_cs_base.h	/^inline void convert_xyz_to_rgb(const img::Image<3,ScalarType1,Safe1> &xyz_image, img::Image<3,ScalarType2,Safe2> &rgb_image)$/;"	f	namespace:img
convolution	vcglib/img/img_filter.h	/^inline void convolution(const Image<Channels,SrcScalarType,SrcSafe> &source,Image<Channels,DestScalarType,DestSafe> &destination,const DestScalarType *matrix,int matrix_width,int matrix_height)$/;"	f	namespace:img
coord	vcglib/wrap/dae/colladaformat.h	/^struct CoordNumber{public:	static unsigned int coord()	{		return 0; 	}};$/;"	f	struct:CoordNumber
coord	vcglib/wrap/dae/colladaformat.h	/^template<> struct CoordNumber<vcg::Color4b> { public:	static unsigned int coord() { return 4;	} };$/;"	f	struct:CoordNumber
coord	vcglib/wrap/dae/colladaformat.h	/^template<> struct CoordNumber<vcg::Point2f> { public:	static unsigned int coord() { return 2;	} };$/;"	f	struct:CoordNumber
coord	vcglib/wrap/dae/colladaformat.h	/^template<> struct CoordNumber<vcg::Point3f> { public:	static unsigned int coord() {	return 3;	} };$/;"	f	struct:CoordNumber
coord	vcglib/wrap/dae/colladaformat.h	/^template<> struct CoordNumber<vcg::Point4f> { public: static unsigned int coord() {	return 4;	} };$/;"	f	struct:CoordNumber
coplanar_tri_tri	vcglib/vcg/space/intersection/triangle_triangle3.h	/^bool coplanar_tri_tri(const Point3<T> N, const Point3<T> V0, const Point3<T> V1,const Point3<T> V2,$/;"	f	namespace:vcg
copyCoeff	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copyCoeff	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copyCoeff	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp
copyCoeff	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp
copyCoeff	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper
copyCoeff	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper
copyCoeff	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, Other& other)$/;"	f	class:Eigen::TriangularBase
copyCoeffByOuterInner	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeffByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copyPacket	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copyPacket	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copyPacket	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp
copyPacket	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp
copyPacket	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper
copyPacket	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper
copyPacketByOuterInner	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacketByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copy_bool	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^    inline bool copy_bool(bool b) { return b; }$/;"	f	namespace:Eigen::internal
corner	vcglib/eigenlib/Eigen/src/Eigen2Support/Block.h	/^  ::corner(CornerType type, Index cRows, Index cCols)$/;"	f	class:Eigen::DenseBase
corner	vcglib/eigenlib/Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type) const$/;"	f	class:Eigen::DenseBase
corner	vcglib/eigenlib/Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type)$/;"	f	class:Eigen::DenseBase
corner	vcglib/eigenlib/Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type, Index cRows, Index cCols) const$/;"	f	class:Eigen::DenseBase
corner	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType corner(CornerType corner) const$/;"	f	class:Eigen::AlignedBox
correct_fixed	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    bool use_direction_field,fix_selected,correct_fixed;$/;"	m	class:vcg::tri::PoissonSolver
cos	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cos() const$/;"	f	class:Eigen::Cwise
cos	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cos() const$/;"	f
cos	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^const MatrixFunctionReturnValue<Derived> MatrixBase<Derived>::cos() const$/;"	f	class:Eigen::MatrixBase
cos	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^    static Scalar cos(Scalar x, int n)$/;"	f	class:Eigen::StdStemFunctions
cos	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal cos(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
cosf	vcglib/vcg/math/base.h	/^    float cosf  (float v) {return cos(v);}$/;"	f
cosh	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^const MatrixFunctionReturnValue<Derived> MatrixBase<Derived>::cosh() const$/;"	f	class:Eigen::MatrixBase
cosh	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^    static Scalar cosh(Scalar x, int n)$/;"	f	class:Eigen::StdStemFunctions
cosh	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal cosh (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
costFuncEnum	vcglib/vcg/space/rasterized_outline2_packer.h	/^      enum costFuncEnum {$/;"	g	class:vcg::RasterizedOutline2Packer::Parameters
costFunction	vcglib/vcg/space/rasterized_outline2_packer.h	/^      costFuncEnum costFunction;$/;"	m	class:vcg::RasterizedOutline2Packer::Parameters
costXWithPenaltyOnY	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int costXWithPenaltyOnY(RasterizedOutline2& poly, Point2i pos, int rast_i) {$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
costYWithPenaltyOnX	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int costYWithPenaltyOnX(RasterizedOutline2& poly, Point2i pos, int rast_i) {$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
cot	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal cot(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
cot	vcglib/wrap/miq/core/auxmath.h	/^inline double cot( const double x ){$/;"	f
coth	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal coth (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
count	vcglib/apps/pivoting/pivot.h	/^      int count;   \/\/test delay touch Hinges.  $/;"	m	struct:vcg::tri::Hinge
count	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^inline typename DenseBase<Derived>::Index DenseBase<Derived>::count() const$/;"	f	class:Eigen::DenseBase
count	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const PartialReduxExpr<ExpressionType, internal::member_count<Index>, Direction> count() const$/;"	f	class:Eigen::VectorwiseOp
count	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  int count;$/;"	m	struct:BallPointStuff	file:
count	vcglib/vcg/space/index/octree.h	/^        int count;$/;"	m	struct:vcg::Voxel
count	vcglib/wrap/gcache/token.h	/^    mt::atomicInt count;$/;"	m	class:vcg::Token
count_e	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int count_e,boundary_e,count_fd,count_uv,numholes;$/;"	m	struct:MeshInfo	file:
count_fd	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int count_e,boundary_e,count_fd,count_uv,numholes;$/;"	m	struct:MeshInfo	file:
count_uv	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int count_e,boundary_e,count_fd,count_uv,numholes;$/;"	m	struct:MeshInfo	file:
covar	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/covar.h	/^void covar($/;"	f	namespace:Eigen::internal
cpuid_is_vendor	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline bool cpuid_is_vendor(int abcd[4], const char* vendor)$/;"	f	namespace:Eigen::internal
crease	vcglib/apps/pivoting/pivot.h	/^    float crease;  \/\/ -0.5 $/;"	m	class:vcg::tri::Pivot
create	vcglib/wrap/glw/buffer.h	/^		bool create(const BufferArguments & args)$/;"	f	class:glw::Buffer
create	vcglib/wrap/glw/fragmentshader.h	/^		bool create(const FragmentShaderArguments & args)$/;"	f	class:glw::FragmentShader
create	vcglib/wrap/glw/framebuffer.h	/^		bool create(const FramebufferArguments & args)$/;"	f	class:glw::Framebuffer
create	vcglib/wrap/glw/geometryshader.h	/^		bool create(const GeometryShaderArguments & args)$/;"	f	class:glw::GeometryShader
create	vcglib/wrap/glw/program.h	/^		bool create(const ProgramArguments & args)$/;"	f	class:glw::Program
create	vcglib/wrap/glw/renderbuffer.h	/^		bool create(const RenderbufferArguments & args)$/;"	f	class:glw::Renderbuffer
create	vcglib/wrap/glw/shader.h	/^		bool create(const ShaderArguments & args)$/;"	f	class:glw::Shader
create	vcglib/wrap/glw/texture2d.h	/^		bool create(const Texture2DArguments & args)$/;"	f	class:glw::Texture2D
create	vcglib/wrap/glw/texturecube.h	/^		bool create(const TextureCubeArguments & args)$/;"	f	class:glw::TextureCube
create	vcglib/wrap/glw/vertexshader.h	/^		bool create(const VertexShaderArguments & args)$/;"	f	class:glw::VertexShader
createBuffer	vcglib/wrap/glw/context.h	/^		BufferHandle createBuffer(const BufferArguments & args)$/;"	f	class:glw::Context
createBuffer	vcglib/wrap/glw/utility.h	/^inline BufferHandle createBuffer(Context & ctx, GLsizeiptr size, const void * data = 0, GLenum usage = GL_STATIC_DRAW)$/;"	f	namespace:glw
createBuffer	vcglib/wrap/glw/utility.h	/^inline BufferHandle createBuffer(Context & ctx, const std::vector<TValue, TAllocator> & data, GLenum usage = GL_STATIC_DRAW)$/;"	f	namespace:glw
createButton	vcglib/apps/sample/trimesh_pos_demo/window.cpp	/^QPushButton *Window::createButton(const char *text, const char *setterSlot)$/;"	f	class:Window
createColladaDocument	vcglib/wrap/dae/colladaformat.h	/^	static XMLDocument* createColladaDocument(const MESHMODELTYPE& m,const int mask)$/;"	f	class:Collada::DocumentManager
createDataSet	vcglib/wrap/tsai/tsaimethods.cpp	/^bool TsaiMethods::createDataSet(std::list<TsaiCorrelation>* corr,vcg::Shot<double>* s)$/;"	f	class:TsaiMethods
createFragmentShader	vcglib/wrap/glw/context.h	/^		FragmentShaderHandle createFragmentShader(const FragmentShaderArguments & args)$/;"	f	class:glw::Context
createFramebuffer	vcglib/wrap/glw/context.h	/^		FramebufferHandle createFramebuffer(const FramebufferArguments & args)$/;"	f	class:glw::Context
createFramebuffer	vcglib/wrap/glw/utility.h	/^inline FramebufferHandle createFramebuffer$/;"	f	namespace:glw
createFramebufferWithDepthStencil	vcglib/wrap/glw/utility.h	/^inline FramebufferHandle createFramebufferWithDepthStencil$/;"	f	namespace:glw
createGeometryShader	vcglib/wrap/glw/context.h	/^		GeometryShaderHandle createGeometryShader(const GeometryShaderArguments & args)$/;"	f	class:glw::Context
createHandle	vcglib/wrap/glw/context.h	/^		typename SafeHandleFromObject<TObject>::Type createHandle(void)$/;"	f	class:glw::Context
createImgAttributes	vcglib/img/img_attributes.h	/^  static ImgAttributes createImgAttributes(COLORSPACE arg_colorspace = ScalarType(UNDEFINED),$/;"	f	class:img::ImgAttributes
createInternalMesh	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    void createInternalMesh() {$/;"	f	class:vcg::tri::Zonohedron
createMesh	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^void Zonohedron<Scalar>::createMesh(MeshType &m){$/;"	f	class:vcg::tri::Zonohedron
createName	vcglib/wrap/io_trimesh/export_fbx.h	/^	static std::string	createName(const char* base,const int ind)$/;"	f	class:ExporterFBX
createObject	vcglib/wrap/glw/context.h	/^		TObject * createObject(void)$/;"	f	class:glw::Context
createProgram	vcglib/wrap/glw/context.h	/^		ProgramHandle createProgram(const ProgramArguments & args)$/;"	f	class:glw::Context
createProgram	vcglib/wrap/glw/utility.h	/^inline ProgramHandle createProgram(Context & ctx, const std::string & srcPrefix, const std::string & vertexSrc, const std::string & fragmentSrc, const ProgramArguments & args = ProgramArguments())$/;"	f	namespace:glw
createProgram	vcglib/wrap/glw/utility.h	/^inline ProgramHandle createProgram(Context & ctx, const std::string & srcPrefix, const std::string & vertexSrc, const std::string & geometrySrc, const std::string & fragmentSrc, const ProgramArguments & args = ProgramArguments())$/;"	f	namespace:glw
createRenderbuffer	vcglib/wrap/glw/context.h	/^		RenderbufferHandle createRenderbuffer(const RenderbufferArguments & args)$/;"	f	class:glw::Context
createRenderbuffer	vcglib/wrap/glw/utility.h	/^inline RenderbufferHandle createRenderbuffer(Context & ctx, GLenum format, GLsizei width, GLsizei height)$/;"	f	namespace:glw
createShader	vcglib/eigenlib/unsupported/test/openglsupport.cpp	/^GLint createShader(const char* vtx, const char* frg)$/;"	f
createTexture2D	vcglib/wrap/glw/context.h	/^		Texture2DHandle createTexture2D(const Texture2DArguments & args)$/;"	f	class:glw::Context
createTexture2D	vcglib/wrap/glw/utility.h	/^inline Texture2DHandle createTexture2D(Context & ctx, GLenum format, GLsizei width, GLsizei height, GLenum dataFormat, GLenum dataType, const void * data = 0, const TextureSampleMode & sampler = TextureSampleMode())$/;"	f	namespace:glw
createTextureCube	vcglib/wrap/glw/context.h	/^		TextureCubeHandle createTextureCube(const TextureCubeArguments & args)$/;"	f	class:glw::Context
createTextureCube	vcglib/wrap/glw/utility.h	/^inline TextureCubeHandle createTextureCube(Context & ctx, GLenum format, GLsizei size, GLenum dataFormat, GLenum dataType, const void * data = 0, const TextureSampleMode & sampler = TextureSampleMode())$/;"	f	namespace:glw
createTree	vcglib/vcg/space/index/kdtree/kdtree.h	/^void KdTree<Scalar>::createTree(unsigned int nodeId, unsigned int start, unsigned int end, unsigned int level, unsigned int targetCellSize, unsigned int targetMaxDepth)$/;"	f	class:KdTree
createVertexShader	vcglib/wrap/glw/context.h	/^		VertexShaderHandle createVertexShader(const VertexShaderArguments & args)$/;"	f	class:glw::Context
create_mspace	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^mspace create_mspace(size_t capacity, int locked) {$/;"	f
create_mspace_with_base	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^mspace create_mspace_with_base(void* base, size_t capacity, int locked) {$/;"	f
created	vcglib/wrap/mt/mt.h	/^    std::vector<Cell *> created;    $/;"	m	class:vcg::MT::Update
creation	vcglib/wrap/bmt/bmt.h	/^  std::vector<std::vector<unsigned int > > creation;$/;"	m	class:vcg::BmtBuilder
cross	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
cross	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^VectorwiseOp<ExpressionType,Direction>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
cross	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    Vec3 cross(VecIndex i, VecIndex j){$/;"	f	class:vcg::tri::Zonohedron
cross3	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross3(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
cross3_impl	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^struct cross3_impl {$/;"	s	namespace:Eigen::internal
cross3_impl	vcglib/eigenlib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct cross3_impl<Architecture::SSE,VectorLhs,VectorRhs,float,true>$/;"	s	namespace:Eigen::internal
cross_product_return_type	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> struct cross_product_return_type {$/;"	s	class:Eigen::MatrixBase
cs_tdfs	vcglib/eigenlib/Eigen/src/OrderingMethods/Amd.h	/^Index cs_tdfs(Index j, Index k, Index *head, const Index *next, Index *post, Index *stack)$/;"	f	namespace:Eigen::internal
cs_wclear	vcglib/eigenlib/Eigen/src/OrderingMethods/Amd.h	/^static int cs_wclear (Index mark, Index lemax, Index *w, Index n)$/;"	f	namespace:Eigen::internal
csc	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal csc(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
csch	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal csch (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
ctrls	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    const ControlPointVectorType& ctrls() const { return m_ctrls; }$/;"	f	class:Eigen::Spline
cube	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cube() const$/;"	f	class:Eigen::Cwise
cube	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cube() const$/;"	f
cur	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  Pos  start, cur;$/;"	m	class:vcg::tri::BitQuad::Iterator
cure	vcglib/wrap/ply/plylib.h	/^	PlyElement * cure;			\/\/ Elemento da leggere$/;"	m	class:vcg::ply::PlyFile
currMetric	vcglib/vcg/complex/algorithms/local_optimization.h	/^	ScalarType currMetric;$/;"	m	class:vcg::LocalOptimization
curr_hints	vcglib/wrap/gl/trimesh.h	/^    int curr_hints;      \/\/ the current hints$/;"	m	class:vcg::GlTrimesh
current_button	vcglib/wrap/gui/trackball.h	/^  int current_button;$/;"	m	class:vcg::Trackball
current_mode	vcglib/wrap/gui/trackball.h	/^  TrackMode *current_mode;$/;"	m	class:vcg::Trackball
current_speed	vcglib/wrap/gui/trackmode.h	/^	Point3f current_speed;$/;"	m	class:vcg::NavigatorWasdMode
current_state	vcglib/wrap/gui/trackmode.h	/^  float current_state;$/;"	m	class:vcg::PathMode
currentmesh	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  MyMesh		currentmesh;		\/\/ current mesh, read from stream and saved one completed$/;"	v
currentmeshC	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  MyMeshC		currentmeshC;		\/\/ current mesh, read from stream and saved one completed$/;"	v
currentphase	vcglib/wrap/gui/rubberband.h	/^  RubberPhase currentphase;$/;"	m	class:vcg::Rubberband
currtrasf	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  Matrix44f		currtrasf;$/;"	v
cwise	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^inline Cwise<Derived> MatrixBase<Derived>::cwise()$/;"	f	class:Eigen::MatrixBase
cwise	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^inline const Cwise<Derived> MatrixBase<Derived>::cwise() const$/;"	f	class:Eigen::MatrixBase
cwiseAbs	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs() const { return derived(); }$/;"	f
cwiseAbs2	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs2() const { return derived(); }$/;"	f
cwiseEqual	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseEqual	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseEqual(const Scalar& s) const$/;"	f
cwiseInverse	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseInverse() const { return derived(); }$/;"	f
cwiseMax	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseMax	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const Scalar &other) const$/;"	f
cwiseMin	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseMin	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const Scalar &other) const$/;"	f
cwiseNotEqual	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseNotEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseProduct	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::cwiseProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
cwiseProduct	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseProduct(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseQuotient	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseQuotient(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseSqrt	vcglib/eigenlib/Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseSqrt() const { return derived(); }$/;"	f
d	vcglib/vcg/complex/algorithms/geodesic.h	/^    ScalarType d;$/;"	m	struct:vcg::tri::Geodesic::TempData
d	vcglib/vcg/complex/algorithms/geodesic.h	/^    ScalarType d;$/;"	m	struct:vcg::tri::Geodesic::VertDist
d	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double& d() { return data[3];}$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
d	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double& d() { return data[3];}$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
d	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& d() { return data[3];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
d	vcglib/vcg/math/matrix44.h	/^	T d;$/;"	m	class:vcg::LinearSolve
d	vcglib/wrap/io_trimesh/io_material.h	/^		float d;\/\/alpha$/;"	m	struct:vcg::tri::io::Material
data	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper
data	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper
data	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper
data	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper
data	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline T *data() { return 0; }$/;"	f	class:Eigen::DenseStorage
data	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline T *data() { return m_data.array; }$/;"	f	class:Eigen::DenseStorage
data	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline T *data() { return m_data; }$/;"	f	class:Eigen::DenseStorage
data	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline const T *data() const { return 0; }$/;"	f	class:Eigen::DenseStorage
data	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline const T *data() const { return m_data.array; }$/;"	f	class:Eigen::DenseStorage
data	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline const T *data() const { return m_data; }$/;"	f	class:Eigen::DenseStorage
data	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline ScalarWithConstIfNotLvalue* data() { return &(m_matrix.const_cast_derived().coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal
data	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline const Scalar* data() const { return &(m_matrix.const_cast_derived().coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal
data	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE  Scalar* data() { eigen_internal_assert(false && "should never be called"); return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return m_data.array; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue* data() { return this->m_data; } \/\/ no const-cast here so non-const-correct code will give a compile error$/;"	f	class:Eigen::MapBase
data	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline const Scalar* data() const { return m_data; }$/;"	f	class:Eigen::MapBase
data	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline const Scalar* data() const { return this->m_data; }$/;"	f	class:Eigen::MapBase
data	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar *data()$/;"	f	class:Eigen::PlainObjectBase
data	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar *data() const$/;"	f	class:Eigen::PlainObjectBase
data	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp
data	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper
data	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper
data	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl
data	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline const Scalar* data() const { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl
data	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseMatrix
data	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseMatrix
data	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  SimpleTempData<typename MESH_TYPE::FaceContainer, Point4<ScalarType> > data;$/;"	m	class:vcg::tri::AreaPreservingTextureOptimizer
data	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double data[5];$/;"	m	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
data	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double data[5];$/;"	m	class:vcg::tri::UpdateCurvatureFitting::Quadric
data	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        vector<double> data;$/;"	m	class:vcg::tri::Fitmaps::Bicubic
data	vcglib/vcg/container/entries_allocation_table.h	/^std::vector<ATTR_TYPE> data;$/;"	m	struct:vcg::EntryCAT
data	vcglib/vcg/container/simple_temporary_data.h	/^    VectorNBW<ATTR_TYPE> data;$/;"	m	class:vcg::SimpleTempData
data	vcglib/vcg/container/simple_temporary_data.h	/^    bool * data ;$/;"	m	class:vcg::VectorNBW
data	vcglib/wrap/glw/buffer.h	/^		const void * data;$/;"	m	class:glw::BufferArguments
data	vcglib/wrap/glw/texture2d.h	/^		const void *      data;$/;"	m	class:glw::Texture2DArguments
data	vcglib/wrap/glw/texturecube.h	/^		const void *      data;$/;"	m	class:glw::TextureCubeArguments
data	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char data[MAX_USER_DATA];  $/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
data	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char data[MAX_USER_DATA];  $/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_VertAux
data	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char data[MAX_USER_DATA];$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_EdgeAux
data	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char data[MAX_USER_DATA];$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
data	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char data[MAX_USER_DATA];$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_TristripAux
data	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char data[MAX_USER_DATA];$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
dataFormat	vcglib/wrap/glw/texture2d.h	/^		GLenum            dataFormat;$/;"	m	class:glw::Texture2DArguments
dataFormat	vcglib/wrap/glw/texturecube.h	/^		GLenum            dataFormat;$/;"	m	class:glw::TextureCubeArguments
dataType	vcglib/wrap/glw/texture2d.h	/^		GLenum            dataType;$/;"	m	class:glw::Texture2DArguments
dataType	vcglib/wrap/glw/texturecube.h	/^		GLenum            dataType;$/;"	m	class:glw::TextureCubeArguments
dataValues	vcglib/img/img_image.h	/^  inline ScalarType* dataValues() const$/;"	f	class:img::Image
dataValuesSize	vcglib/img/img_image.h	/^  inline int dataValuesSize() const$/;"	f	class:img::Image
datareserve	vcglib/vcg/container/simple_temporary_data.h	/^    int datareserve;$/;"	m	class:vcg::VectorNBW
datasize	vcglib/vcg/container/simple_temporary_data.h	/^    int datasize;$/;"	m	class:vcg::VectorNBW
db	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    FILE * db;$/;"	m	class:vcg::tri::FourPCS
dcomplex	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<double> dcomplex;$/;"	t	namespace:Eigen
deads	vcglib/apps/pivoting/pivot.h	/^    std::list<Hinge> deads;$/;"	m	class:vcg::tri::Pivot
deads	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  std::list<FrontEdge> deads;$/;"	m	class:vcg::tri::AdvancingFront
deallocate	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    void deallocate( pointer p, size_type \/*num*\/ )$/;"	f	class:Eigen::aligned_allocator
debug	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static void debug()$/;"	f	struct:Eigen::internal::assign_traits
debug	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  static void debug()$/;"	f	struct:Eigen::internal::product_type
debugInfo	vcglib/wrap/qt/checkGLError.h	/^  static void debugInfo(const char* m) {$/;"	f	class:checkGLError
dec	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::image_retval_base
dec	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::kernel_retval_base
dec	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::solve_retval_base
dec	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
decrement_if_fixed_size	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^struct decrement_if_fixed_size$/;"	s	namespace:Eigen::internal
decrement_size	vcglib/eigenlib/Eigen/src/Householder/Householder.h	/^template<int n> struct decrement_size$/;"	s	namespace:Eigen::internal
default_base	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^int		   mpreal::default_base = 10;$/;"	m	class:mpfr::mpreal	file:
default_base	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	static int				default_base;$/;"	m	class:mpfr::mpreal
default_mflags	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  flag_t default_mflags;$/;"	m	struct:malloc_params	file:
default_packet_traits	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^struct default_packet_traits$/;"	s	namespace:Eigen::internal
default_prec	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mp_prec_t  mpreal::default_prec = 64;			\/\/(mpfr_get_default_prec)();	$/;"	m	class:mpfr::mpreal	file:
default_prec	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	static mp_prec_t		default_prec;	$/;"	m	class:mpfr::mpreal
default_prunning_func	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    default_prunning_func(Scalar ref, RealScalar eps) : reference(ref), epsilon(eps) {}$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func
default_prunning_func	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^  struct default_prunning_func {$/;"	s	class:Eigen::SparseMatrix
default_rnd	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mp_rnd_t   mpreal::default_rnd  = MPFR_RNDN;	\/\/(mpfr_get_default_rounding_mode)();	$/;"	m	class:mpfr::mpreal	file:
default_rnd	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	static mp_rnd_t			default_rnd;	$/;"	m	class:mpfr::mpreal
define	vcglib/wrap/glw/utility.h	/^		ThisType & define(const std::string & name, const std::string & value)$/;"	f	class:glw::ShaderHeaderBuilder
degree	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^  DenseIndex Spline<_Scalar, _Dim, _Degree>::degree() const$/;"	f	class:Eigen::Spline
deleteData	vcglib/img/img_image.h	/^  inline void deleteData()$/;"	f	class:img::Image
deleteUnreachedRegionFlag	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  bool deleteUnreachedRegionFlag;$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
deleted	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^    bool deleted;$/;"	m	class:MySegmentType	file:
deleter	vcglib/wrap/glw/bookkeeping.h	/^		DeleterType & deleter(void)$/;"	f	class:glw::detail::RefCountedObject
deleter	vcglib/wrap/glw/bookkeeping.h	/^		const DeleterType & deleter(void) const$/;"	f	class:glw::detail::RefCountedObject
deletion	vcglib/wrap/bmt/bmt.h	/^  std::vector<std::vector<unsigned int > > deletion;$/;"	m	class:vcg::BmtBuilder
delta	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar delta;$/;"	m	class:Eigen::HybridNonLinearSolver
delta	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar delta;$/;"	m	class:Eigen::LevenbergMarquardt
delta	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    ScalarType delta;   \/\/ Approximation Level$/;"	m	struct:vcg::tri::FourPCS::Param
deltaX	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector< std::vector<int> > deltaX;$/;"	m	class:vcg::RasterizedOutline2
deltaY	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector< std::vector<int> > deltaY;$/;"	m	class:vcg::RasterizedOutline2
delta_mouse	vcglib/wrap/gui/trackmode.h	/^  Point3f delta_mouse;$/;"	m	class:vcg::AreaMode
demo_all_types	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^void demo_all_types(int nfft)$/;"	f
denseMatrix	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    DenseCompanionMatrixType denseMatrix() const$/;"	f	class:Eigen::internal::companion
dense_xpr_base_dispatcher_for_doxygen	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
dense_xpr_base_dispatcher_for_doxygen	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
depthOffset	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		float depthOffset;$/;"	m	struct:SplatRenderer::UniformParameters
depthParameterCast	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		vcg::Point2f depthParameterCast;$/;"	m	struct:SplatRenderer::UniformParameters
depthTarget	vcglib/wrap/glw/framebuffer.h	/^		RenderTarget         depthTarget;$/;"	m	class:glw::FramebufferArguments
depth_format	vcglib/wrap/gl/gl_surface.h	/^		GLenum depth_format;$/;"	m	class:vcg::gl_surface
depth_select	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    depth_select = product_size_category<Depth,MaxDepth>::value$/;"	e	enum:Eigen::internal::product_type::__anon143
depth_tex	vcglib/wrap/gl/gl_surface.h	/^		GLuint depth_tex;$/;"	m	class:vcg::gl_surface
deque	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^  class deque<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
deque_base	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^                Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > deque_base;$/;"	t	class:std::deque
deref	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline bool deref()$/;"	f	class:mt::atomicInt
deref	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline bool deref()$/;"	f	class:mt::atomicInt
derivatives	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline DerType& derivatives() { return m_derivatives; }$/;"	f	class:Eigen::AutoDiffScalar
derivatives	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline const DerType& derivatives() const { return m_derivatives; }$/;"	f	class:Eigen::AutoDiffScalar
derivatives	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    Spline<_Scalar, _Dim, _Degree>::derivatives(Scalar u, DenseIndex order) const$/;"	f	class:Eigen::Spline
derivativesImpl	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^  void derivativesImpl(const SplineType& spline, typename SplineType::Scalar u, DenseIndex order, DerivativeType& der)$/;"	f	namespace:Eigen
derived	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::CholmodBase
derived	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::CholmodBase
derived	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase
derived	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase
derived	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	struct:Eigen::EigenBase
derived	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	struct:Eigen::EigenBase
derived	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase
derived	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase
derived	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TriangularBase
derived	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TriangularBase
derived	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase
derived	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase
derived	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PastixBase
derived	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PastixBase
derived	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PardisoImpl
derived	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PardisoImpl
derived	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase
derived	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase
derived	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase
derived	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase
derived	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase
derived	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase
derived	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  AutoDiffScalar<_DerType>& derived() { return *static_cast<AutoDiffScalar<_DerType>*>(this); }$/;"	f	struct:Eigen::internal::auto_diff_special_op
derived	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  const AutoDiffScalar<_DerType>& derived() const { return *static_cast<const AutoDiffScalar<_DerType>*>(this); }$/;"	f	struct:Eigen::internal::auto_diff_special_op
derived	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Derived& derived() {$/;"	f	class:Eigen::SkylineMatrixBase
derived	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline const Derived& derived() const {$/;"	f	class:Eigen::SkylineMatrixBase
desc	vcglib/wrap/ply/plylib.h	/^	PropDescriptor desc;		\/\/ Descrittore di memorizzazione$/;"	m	class:vcg::ply::PlyProperty
description	vcglib/wrap/system/qgetopt.h	/^    QString description;$/;"	m	struct:GetOpt::Option
descriptor	vcglib/wrap/io_trimesh/export_idtf.h	/^		unsigned char  descriptor;         $/;"	m	struct:vcg::tri::io::TGA_Exporter::TGAHeader
destroy	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    void destroy( pointer p )$/;"	f	class:Eigen::aligned_allocator
destroy	vcglib/wrap/glw/object.h	/^		void destroy(void)$/;"	f	class:glw::Object
destroyColladaDocument	vcglib/wrap/dae/colladaformat.h	/^	static void destroyColladaDocument(XMLDocument* doc)$/;"	f	class:Collada::DocumentManager
destroyObject	vcglib/wrap/glw/bookkeeping.h	/^		void destroyObject(void)$/;"	f	class:glw::detail::RefCountedObject
destroyObject	vcglib/wrap/glw/context.h	/^		void destroyObject(Object * object)$/;"	f	class:glw::Context
destroy_mspace	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^size_t destroy_mspace(mspace msp) {$/;"	f
destruct_elements_of_array	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal
detach	vcglib/apps/pivoting/pivot.h	/^    void Pivot::detach(int v) {$/;"	f	class:vcg::tri::Pivot::Pivot
detach	vcglib/wrap/glw/bookkeeping.h	/^		void detach(void)$/;"	f	class:glw::detail::ObjectSharedPointer
detail	vcglib/wrap/glw/bookkeeping.h	/^namespace detail$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf      <BoundBuffer> { typedef BoundObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundFeedbackBuffer> { typedef BoundBuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundIndexBuffer> { typedef BoundBuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundPixelPackBuffer> { typedef BoundBuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundPixelUnpackBuffer> { typedef BoundBuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundUniformBuffer> { typedef BoundBuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <BoundVertexBuffer> { typedef BoundBuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf     <SafeBuffer> { typedef SafeObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct BaseOf <Buffer> { typedef Object Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase  <BoundBuffer> { typedef Buffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundFeedbackBuffer> { typedef Buffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundIndexBuffer> { typedef Buffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundPixelPackBuffer> { typedef Buffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundPixelUnpackBuffer> { typedef Buffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundUniformBuffer> { typedef Buffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <BoundVertexBuffer> { typedef Buffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBase <SafeBuffer> { typedef Buffer     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectBound <Buffer     > { typedef BoundBuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ObjectSafe <Buffer    > { typedef SafeBuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf    <BoundBuffer> { typedef BufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundFeedbackBuffer> { typedef FeedbackBufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundIndexBuffer> { typedef IndexBufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundPixelPackBuffer> { typedef PixelPackBufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundPixelUnpackBuffer> { typedef PixelUnpackBufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundUniformBuffer> { typedef UniformBufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/buffer.h	/^namespace detail { template <> struct ParamsOf   <BoundVertexBuffer> { typedef VertexBufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/common.h	/^namespace detail$/;"	n	namespace:glw
detail	vcglib/wrap/glw/context.h	/^namespace detail$/;"	n	namespace:glw
detail	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct BaseOf      <BoundFragmentShader> { typedef BoundShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct BaseOf     <SafeFragmentShader> { typedef SafeShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct BaseOf <FragmentShader> { typedef Shader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectBase  <BoundFragmentShader> { typedef FragmentShader      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectBase <SafeFragmentShader> { typedef FragmentShader     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectBound <FragmentShader     > { typedef BoundFragmentShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ObjectSafe <FragmentShader    > { typedef SafeFragmentShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/fragmentshader.h	/^namespace detail { template <> struct ParamsOf    <BoundFragmentShader> { typedef FragmentShaderBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf      <BoundFramebuffer> { typedef BoundObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <BoundDrawFramebuffer> { typedef BoundFramebuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <BoundReadDrawFramebuffer> { typedef BoundFramebuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <BoundReadFramebuffer> { typedef BoundFramebuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf     <SafeFramebuffer> { typedef SafeObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct BaseOf <Framebuffer> { typedef Object Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase  <BoundFramebuffer> { typedef Framebuffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <BoundDrawFramebuffer> { typedef Framebuffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <BoundReadDrawFramebuffer> { typedef Framebuffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <BoundReadFramebuffer> { typedef Framebuffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBase <SafeFramebuffer> { typedef Framebuffer     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectBound <Framebuffer     > { typedef BoundFramebuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ObjectSafe <Framebuffer    > { typedef SafeFramebuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf    <BoundFramebuffer> { typedef FramebufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf   <BoundDrawFramebuffer> { typedef DrawFramebufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf   <BoundReadDrawFramebuffer> { typedef ReadDrawFramebufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/framebuffer.h	/^namespace detail { template <> struct ParamsOf   <BoundReadFramebuffer> { typedef ReadFramebufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct BaseOf      <BoundGeometryShader> { typedef BoundShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct BaseOf     <SafeGeometryShader> { typedef SafeShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct BaseOf <GeometryShader> { typedef Shader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectBase  <BoundGeometryShader> { typedef GeometryShader      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectBase <SafeGeometryShader> { typedef GeometryShader     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectBound <GeometryShader     > { typedef BoundGeometryShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ObjectSafe <GeometryShader    > { typedef SafeGeometryShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/geometryshader.h	/^namespace detail { template <> struct ParamsOf    <BoundGeometryShader> { typedef GeometryShaderBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/noncopyable.h	/^namespace detail$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct BaseOf      <BoundObject> { typedef NoType                      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct BaseOf     <SafeObject> { typedef NoType                     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct BaseOf    <Object> { typedef NoType        Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct DeleterOf   <BoundObject> { typedef DefaultDeleter<BoundObject> Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct DeleterOf  <SafeObject> { typedef DefaultDeleter<SafeObject> Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct DeleterOf <Object> { typedef ObjectDeleter Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectBase  <BoundObject> { typedef Object                      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectBase <SafeObject> { typedef Object                     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectBound <Object     > { typedef BoundObject                 Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ObjectSafe <Object    > { typedef SafeObject                 Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <> struct ParamsOf    <BoundObject> { typedef ObjectBindingParams         Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ObjectBase  { typedef NoType        Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ObjectBound { typedef NoType        Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ObjectSafe  { typedef NoType        Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/object.h	/^namespace detail { template <typename T> struct ParamsOf { typedef NoType Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/objectdeleter.h	/^namespace detail$/;"	n	namespace:glw
detail	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct BaseOf      <BoundProgram> { typedef BoundObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct BaseOf     <SafeProgram> { typedef SafeObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct BaseOf <Program> { typedef Object Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectBase  <BoundProgram> { typedef Program      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectBase <SafeProgram> { typedef Program     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectBound <Program     > { typedef BoundProgram Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ObjectSafe <Program    > { typedef SafeProgram Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/program.h	/^namespace detail { template <> struct ParamsOf    <BoundProgram> { typedef ProgramBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct BaseOf      <BoundRenderable> { typedef BoundObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct BaseOf     <SafeRenderable> { typedef SafeObject     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct BaseOf <Renderable> { typedef Object Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectBase  <BoundRenderable> { typedef Renderable      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectBase <SafeRenderable> { typedef Renderable     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectBound <Renderable     > { typedef BoundRenderable Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ObjectSafe <Renderable    > { typedef SafeRenderable Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderable.h	/^namespace detail { template <> struct ParamsOf    <BoundRenderable> { typedef RenderableBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct BaseOf      <BoundRenderbuffer> { typedef BoundObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct BaseOf     <SafeRenderbuffer> { typedef SafeRenderable   Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct BaseOf <Renderbuffer> { typedef Renderable Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectBase  <BoundRenderbuffer> { typedef Renderbuffer      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectBase <SafeRenderbuffer> { typedef Renderbuffer     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectBound <Renderbuffer     > { typedef BoundRenderbuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ObjectSafe <Renderbuffer    > { typedef SafeRenderbuffer Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/renderbuffer.h	/^namespace detail { template <> struct ParamsOf    <BoundRenderbuffer> { typedef RenderbufferBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct BaseOf      <BoundShader> { typedef BoundObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct BaseOf     <SafeShader> { typedef SafeObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct BaseOf <Shader> { typedef Object Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectBase  <BoundShader> { typedef Shader      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectBase <SafeShader> { typedef Shader     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectBound <Shader     > { typedef BoundShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ObjectSafe <Shader    > { typedef SafeShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/shader.h	/^namespace detail { template <> struct ParamsOf    <BoundShader> { typedef ShaderBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct BaseOf      <BoundTexture> { typedef BoundObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct BaseOf     <SafeTexture> { typedef SafeRenderable   Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct BaseOf <Texture> { typedef Renderable Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectBase  <BoundTexture> { typedef Texture      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectBase <SafeTexture> { typedef Texture     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectBound <Texture     > { typedef BoundTexture Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ObjectSafe <Texture    > { typedef SafeTexture Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture.h	/^namespace detail { template <> struct ParamsOf    <BoundTexture> { typedef TextureBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct BaseOf      <BoundTexture2D> { typedef BoundObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct BaseOf     <SafeTexture2D> { typedef SafeTexture   Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct BaseOf <Texture2D> { typedef Texture Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectBase  <BoundTexture2D> { typedef Texture2D      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectBase <SafeTexture2D> { typedef Texture2D     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectBound <Texture2D     > { typedef BoundTexture2D Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ObjectSafe <Texture2D    > { typedef SafeTexture2D Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texture2d.h	/^namespace detail { template <> struct ParamsOf    <BoundTexture2D> { typedef Texture2DBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct BaseOf      <BoundTextureCube> { typedef BoundObject Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct BaseOf     <SafeTextureCube> { typedef SafeTexture   Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct BaseOf <TextureCube> { typedef Texture Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectBase  <BoundTextureCube> { typedef TextureCube      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectBase <SafeTextureCube> { typedef TextureCube     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectBound <TextureCube     > { typedef BoundTextureCube Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ObjectSafe <TextureCube    > { typedef SafeTextureCube Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/texturecube.h	/^namespace detail { template <> struct ParamsOf    <BoundTextureCube> { typedef TextureCubeBindingParams Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct BaseOf      <BoundVertexShader> { typedef BoundShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct BaseOf     <SafeVertexShader> { typedef SafeShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct BaseOf <VertexShader> { typedef Shader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectBase  <BoundVertexShader> { typedef VertexShader      Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectBase <SafeVertexShader> { typedef VertexShader     Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectBound <VertexShader     > { typedef BoundVertexShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ObjectSafe <VertexShader    > { typedef SafeVertexShader Type; }; };$/;"	n	namespace:glw
detail	vcglib/wrap/glw/vertexshader.h	/^namespace detail { template <> struct ParamsOf    <BoundVertexShader> { typedef VertexShaderBindingParams Type; }; };$/;"	n	namespace:glw
determinant	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    Scalar determinant() const$/;"	f	class:Eigen::TriangularView
determinant	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^inline typename internal::traits<Derived>::Scalar MatrixBase<Derived>::determinant() const$/;"	f	class:Eigen::MatrixBase
determinant	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^typename internal::traits<MatrixType>::Scalar FullPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::FullPivLU
determinant	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^typename internal::traits<MatrixType>::Scalar PartialPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::PartialPivLU
determinant	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialCholesky
determinant	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLDLT
determinant	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLLT
determinant	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^typename SuperLU<MatrixType>::Scalar SuperLU<MatrixType>::determinant() const$/;"	f	class:Eigen::SuperLU
determinant	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^typename UmfPackLU<MatrixType>::Scalar UmfPackLU<MatrixType>::determinant() const$/;"	f	class:Eigen::UmfPackLU
determinant_impl	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^> struct determinant_impl$/;"	s	namespace:Eigen::internal
determinant_impl	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 1>$/;"	s	namespace:Eigen::internal
determinant_impl	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 2>$/;"	s	namespace:Eigen::internal
determinant_impl	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 3>$/;"	s	namespace:Eigen::internal
determinant_impl	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 4>$/;"	s	namespace:Eigen::internal
dev_zero_fd	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static int dev_zero_fd = -1; \/* Cached file descriptor for \/dev\/zero. *\/$/;"	v	file:
df	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    int df(const InputType& _x, JacobianType &jac) const$/;"	f	class:Eigen::NumericalDiff
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:Bennett5_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:BoxBOD_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:MGH09_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:MGH10_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:MGH17_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:chwirut2_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:eckerle4_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:hahn1_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:lanczos1_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:misra1a_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:misra1d_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:rat42_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:rat43_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &b, MatrixXd &fjac)$/;"	f	struct:thurber_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &x, MatrixXd &fjac) const$/;"	f	struct:lmder_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &x, MatrixXd &fjac)$/;"	f	struct:hybrj_functor
df	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int df(const VectorXd &x, VectorXd &jac_row, VectorXd::Index rownb)$/;"	f	struct:lmstr_functor
diag	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::HybridNonLinearSolver
diag	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::LevenbergMarquardt
diag	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Scalar& diag(Index i) {$/;"	f	class:Eigen::SkylineStorage
diag	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline const Scalar& diag(Index i) const {$/;"	f	class:Eigen::SkylineStorage
diagSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index diagSize() const {$/;"	f	class:Eigen::SkylineStorage
diagonal	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,Dynamic> diagonal(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,SizeAtCompileTime> diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,Dynamic> diagonal(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,SizeAtCompileTime> diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    template<int N> inline const typename DiagonalIntReturnType<N>::Type diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    template<int N> inline typename DiagonalIntReturnType<N>::Type diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal() const$/;"	f	class:Eigen::MatrixBase
diagonal	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal()$/;"	f	class:Eigen::MatrixBase
diagonal	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index) const$/;"	f	class:Eigen::MatrixBase
diagonal	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index)$/;"	f	class:Eigen::MatrixBase
diagonal	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalWrapper
diagonal	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase
diagonal	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix
diagonal	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase
diagonal	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix
diagonal	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    const Diagonal<FullyLazyCoeffBaseProductType,Dynamic> diagonal(Index index) const$/;"	f	class:Eigen::ProductBase
diagonal	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    const Diagonal<FullyLazyCoeffBaseProductType,Index> diagonal() const$/;"	f	class:Eigen::ProductBase
diagonal	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    const Diagonal<const FullyLazyCoeffBaseProductType,0> diagonal() const$/;"	f	class:Eigen::ProductBase
diagonal	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,0> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct
diagonal	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,DiagonalIndex> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct
diagonal	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,Dynamic> diagonal(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct
diagonal	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::diagonal() const$/;"	f	class:Eigen::Tridiagonalization
diagonal	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> diagonal() const$/;"	f	class:Eigen::AlignedBox
diagonal	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    const Diagonal<const SparseMatrix> diagonal() const { return *this; }$/;"	f	class:Eigen::SparseMatrix
diagonalLength	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index diagonalLength(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonalSize	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    inline Index diagonalSize() const { return (std::min)(rows(),cols()); }$/;"	f	class:Eigen::MatrixBase
diagonal_collapse_quad	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static VertexPointer diagonal_collapse_quad(MeshType &m, FacePointer fp, VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
dif	vcglib/vcg/complex/algorithms/smooth.h	/^    CoordType dif;$/;"	m	class:vcg::tri::Smooth::HCSmoothInfo
dif_rmse	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^    long double dif_rmse( const VT1 buf1,const VT2 buf2)$/;"	f
diff	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^float diff=.8;$/;"	v
difference_type	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    typedef std::ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator
difference_type	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator_indirection
digamma	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal digamma(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
digits2bits	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_prec_t digits2bits(int d)$/;"	f	namespace:mpfr
dihedralRad	vcglib/vcg/complex/algorithms/hole.h	/^  typename MESH::ScalarType dihedralRad;$/;"	m	class:vcg::tri::MinimumWeightEar
dim	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline int dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size()-1 : AmbientDimAtCompileTime; }$/;"	f	class:Eigen::AlignedBox
dim	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline int dim() const { return int(AmbientDimAtCompileTime)==Dynamic ? m_coeffs.size()-1 : int(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane
dim	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline int dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine
dim	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size() : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::AlignedBox
dim	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_coeffs.size()-1 : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane
dim	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  inline Index dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine
dim	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^    int dim;$/;"	m	struct:Eigen::KdBVH::VectorComparator
dim	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal dim(const mpreal& a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
dim	vcglib/vcg/space/index/grid_util.h	/^	CoordType dim;		\/\/\/ Spatial Dimention (edge legth) of the bounding box$/;"	m	class:vcg::BasicGrid
dim	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		CoordType dim;		\/\/\/ Spatial Dimention (edge legth) of the bounding box$/;"	m	class:vcg::BasicGrid2D
dim	vcglib/vcg/space/index/kdtree/kdtree.h	/^				unsigned int dim:2;$/;"	m	struct:KdTree::Node::__anon507::__anon508
dimensionOfKernel	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivLU
dimensionOfKernel	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::ColPivHouseholderQR
dimensionOfKernel	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivHouseholderQR
dims	vcglib/wrap/gl/fbo.h	/^	GLsizei dims[1];$/;"	m	class:Texture1D
dims	vcglib/wrap/gl/fbo.h	/^	GLsizei dims[2];$/;"	m	class:Texture2D
dims	vcglib/wrap/gl/fbo.h	/^	GLsizei dims[3];$/;"	m	class:Texture3D
dirder	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
direct_selfadjoint_eigenvalues	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType,int Size,bool IsComplex> struct direct_selfadjoint_eigenvalues$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,2,false>$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,3,false>$/;"	s	namespace:Eigen::internal
direction	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
direction	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
direction	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
direction	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
direction	vcglib/vcg/connectors/halfedge_pos.h	/^            bool direction;$/;"	m	class:vcg::hedge::Pos
dirty	vcglib/vcg/math/histogram.h	/^	bool dirty;$/;"	m	class:vcg::Distribution
disableExtension	vcglib/wrap/glw/utility.h	/^		ThisType & disableExtension(const std::string & ext)$/;"	f	class:glw::ShaderHeaderBuilder
disable_contiguous	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define disable_contiguous(/;"	d	file:
disable_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define disable_lock(/;"	d	file:
disable_mmap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define disable_mmap(/;"	d	file:
discreteAreas	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector<int> discreteAreas;$/;"	m	class:vcg::RasterizedOutline2
display	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^void display(){$/;"	f
display	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^void display(){$/;"	f
dist	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    float dist;$/;"	m	struct:vcg::tri::FourPCS::Couple
dist	vcglib/vcg/space/index/space_iterators.h	/^			ScalarType dist;$/;"	m	struct:vcg::ClosestIterator::Entry_Type
dist	vcglib/vcg/space/index/space_iterators.h	/^			ScalarType dist;$/;"	m	struct:vcg::RayIterator::Entry_Type
dist	vcglib/vcg/space/index/space_iterators.h	/^		ScalarType dist;$/;"	m	class:vcg::RayIterator
dist2	vcglib/apps/test/camerashot/camerashot_test.cpp	/^double dist2(vcg::Point2d p1, vcg::Point2d p2)$/;"	f
dist3	vcglib/apps/test/camerashot/camerashot_test.cpp	/^double dist3(vcg::Point3d p1, vcg::Point3d p2)$/;"	f
dist_funct	vcglib/vcg/space/index/space_iterators.h	/^		DISTFUNCTOR dist_funct;$/;"	m	class:vcg::ClosestIterator
dist_upper_bound	vcglib/apps/metro/sampling.h	/^	double          dist_upper_bound;$/;"	m	class:vcg::Sampling
distance	vcglib/apps/pivoting/pivot.h	/^    float distance(int v0, int v1, Point3f &center) {$/;"	f	class:vcg::tri::Pivot
distance	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { return ei_sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine
distance	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { return internal::sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine
distance	vcglib/vcg/space/index/octree.h	/^            ScalarType			distance;$/;"	m	struct:vcg::Octree::Neighbour
distance	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 ScalarType			distance;$/;"	m	struct:vcg::PerfectSpatialHashing::Neighbor
distanceRMS	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double distanceRMS(std::vector<CoordType>& VV)$/;"	f	class:vcg::tri::Fitmaps::Bicubic
distance_from_homeometry	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static float distance_from_homeometry(vector<VertexPointer> &face1, vector<VertexPointer> &face2, int i)$/;"	f	class:vcg::tri::Homeometry
div_2si	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal div_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
div_2ui	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal div_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
dl	vcglib/wrap/gl/trimesh.h	/^    unsigned int dl;$/;"	m	class:vcg::GlTrimesh
dlcalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlcalloc /;"	d	file:
dlcalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void* dlcalloc(size_t n_elements, size_t elem_size) {$/;"	f
dlcalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlcalloc /;"	d
dlfree	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlfree /;"	d	file:
dlfree	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void dlfree(void* mem) {$/;"	f
dlfree	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlfree /;"	d
dlindependent_calloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlindependent_calloc /;"	d	file:
dlindependent_calloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void** dlindependent_calloc(size_t n_elements, size_t elem_size,$/;"	f
dlindependent_calloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlindependent_calloc /;"	d
dlindependent_comalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlindependent_comalloc /;"	d	file:
dlindependent_comalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void** dlindependent_comalloc(size_t n_elements, size_t sizes[],$/;"	f
dlindependent_comalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlindependent_comalloc /;"	d
dlmallinfo	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlmallinfo /;"	d	file:
dlmallinfo	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^struct mallinfo dlmallinfo(void) {$/;"	f
dlmallinfo	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlmallinfo /;"	d
dlmalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlmalloc /;"	d	file:
dlmalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void* dlmalloc(size_t bytes) {$/;"	f
dlmalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlmalloc /;"	d
dlmalloc_footprint	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlmalloc_footprint /;"	d	file:
dlmalloc_footprint	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^size_t dlmalloc_footprint(void) {$/;"	f
dlmalloc_footprint	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlmalloc_footprint /;"	d
dlmalloc_max_footprint	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlmalloc_max_footprint /;"	d	file:
dlmalloc_max_footprint	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^size_t dlmalloc_max_footprint(void) {$/;"	f
dlmalloc_stats	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlmalloc_stats /;"	d	file:
dlmalloc_stats	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void dlmalloc_stats() {$/;"	f
dlmalloc_stats	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlmalloc_stats /;"	d
dlmalloc_trim	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlmalloc_trim /;"	d	file:
dlmalloc_trim	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^int dlmalloc_trim(size_t pad) {$/;"	f
dlmalloc_trim	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlmalloc_trim /;"	d
dlmalloc_usable_size	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlmalloc_usable_size /;"	d	file:
dlmalloc_usable_size	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^size_t dlmalloc_usable_size(void* mem) {$/;"	f
dlmalloc_usable_size	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlmalloc_usable_size /;"	d
dlmallopt	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlmallopt /;"	d	file:
dlmallopt	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^int dlmallopt(int param_number, int value) {$/;"	f
dlmallopt	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlmallopt /;"	d
dlmemalign	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlmemalign /;"	d	file:
dlmemalign	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void* dlmemalign(size_t alignment, size_t bytes) {$/;"	f
dlmemalign	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlmemalign /;"	d
dlpvalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlpvalloc /;"	d	file:
dlpvalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void* dlpvalloc(size_t bytes) {$/;"	f
dlpvalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlpvalloc /;"	d
dlrealloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlrealloc /;"	d	file:
dlrealloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void* dlrealloc(void* oldmem, size_t bytes) {$/;"	f
dlrealloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlrealloc /;"	d
dlvalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define dlvalloc /;"	d	file:
dlvalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void* dlvalloc(size_t bytes) {$/;"	f
dlvalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^#define dlvalloc /;"	d
doComputeEigenvectors	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::doComputeEigenvectors(RealScalar matrixnorm)$/;"	f	class:Eigen::ComplexEigenSolver
doComputeEigenvectors	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^void EigenSolver<MatrixType>::doComputeEigenvectors()$/;"	f	class:Eigen::EigenSolver
doDestroy	vcglib/wrap/glw/buffer.h	/^		virtual void doDestroy(void)$/;"	f	class:glw::Buffer
doDestroy	vcglib/wrap/glw/framebuffer.h	/^		virtual void doDestroy(void)$/;"	f	class:glw::Framebuffer
doDestroy	vcglib/wrap/glw/program.h	/^		virtual void doDestroy()$/;"	f	class:glw::Program
doDestroy	vcglib/wrap/glw/renderbuffer.h	/^		virtual void doDestroy(void)$/;"	f	class:glw::Renderbuffer
doDestroy	vcglib/wrap/glw/shader.h	/^		virtual void doDestroy(void)$/;"	f	class:glw::Shader
doDestroy	vcglib/wrap/glw/texture.h	/^		virtual void doDestroy(void)$/;"	f	class:glw::Texture
doDestroy	vcglib/wrap/glw/texture2d.h	/^		virtual void doDestroy(void)$/;"	f	class:glw::Texture2D
doDestroy	vcglib/wrap/glw/texturecube.h	/^		virtual void doDestroy(void)$/;"	f	class:glw::TextureCube
doIsValid	vcglib/wrap/glw/buffer.h	/^		virtual bool doIsValid(void) const$/;"	f	class:glw::Buffer
doIsValid	vcglib/wrap/glw/framebuffer.h	/^		virtual bool doIsValid(void) const$/;"	f	class:glw::Framebuffer
doIsValid	vcglib/wrap/glw/program.h	/^		virtual bool doIsValid(void) const$/;"	f	class:glw::Program
doIsValid	vcglib/wrap/glw/renderbuffer.h	/^		virtual bool doIsValid(void) const$/;"	f	class:glw::Renderbuffer
doIsValid	vcglib/wrap/glw/shader.h	/^		virtual bool doIsValid(void) const$/;"	f	class:glw::Shader
doIsValid	vcglib/wrap/glw/texture2d.h	/^		virtual bool doIsValid(void) const$/;"	f	class:glw::Texture2D
doIsValid	vcglib/wrap/glw/texturecube.h	/^		virtual bool doIsValid(void) const$/;"	f	class:glw::TextureCube
doPickPos	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		bool doPickPos,doPickVfIte;$/;"	m	class:GLWidget
doPickVfIte	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		bool doPickPos,doPickVfIte;$/;"	m	class:GLWidget
doQueryK	vcglib/vcg/space/index/kdtree/kdtree.h	/^void KdTree<Scalar>::doQueryK(const VectorType& queryPoint)$/;"	f	class:KdTree
do_check_any_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void do_check_any_chunk(mstate m, mchunkptr p) {$/;"	f	file:
do_check_free_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void do_check_free_chunk(mstate m, mchunkptr p) {$/;"	f	file:
do_check_inuse_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void do_check_inuse_chunk(mstate m, mchunkptr p) {$/;"	f	file:
do_check_malloc_state	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void do_check_malloc_state(mstate m) {$/;"	f	file:
do_check_malloced_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void do_check_malloced_chunk(mstate m, void* mem, size_t s) {$/;"	f	file:
do_check_mmapped_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void do_check_mmapped_chunk(mstate m, mchunkptr p) {$/;"	f	file:
do_check_smallbin	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void do_check_smallbin(mstate m, bindex_t i) {$/;"	f	file:
do_check_top_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void do_check_top_chunk(mstate m, mchunkptr p) {$/;"	f	file:
do_check_tree	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void do_check_tree(mstate m, tchunkptr t) {$/;"	f	file:
do_check_treebin	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void do_check_treebin(mstate m, bindex_t i) {$/;"	f	file:
do_tesselation	vcglib/wrap/gl/glu_tesselator.h	/^        static void do_tesselation(const std::vector< std::vector<point_type> > & outlines, tess_prim_data_vec & t_data)$/;"	f	class:vcg::glu_tesselator
doc	vcglib/wrap/dae/util_dae.h	/^		QDomDocument* doc;		$/;"	m	class:vcg::tri::io::InfoDAE
dogleg	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/dogleg.h	/^void dogleg($/;"	f	namespace:Eigen::internal
domain_data	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				std::vector< ObjectPointer >	*domain_data;$/;"	m	struct:vcg::PerfectSpatialHashing::HashTable::Data
dontCare	vcglib/wrap/glw/texture.h	/^		static TextureSampleMode dontCare(void)$/;"	f	class:glw::TextureSampleMode
door	vcglib/wrap/gcache/door.h	/^  mt::semaphore door;$/;"	m	class:QDoor
doorOpen	vcglib/wrap/gcache/door.h	/^  bool doorOpen;$/;"	m	class:QDoor
dot	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
dot	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> inline Scalar dot(const QuaternionBase<OtherDerived>& other) const { return coeffs().dot(other.coeffs()); }$/;"	f	class:Eigen::QuaternionBase
dot	vcglib/eigenlib/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
dot	vcglib/eigenlib/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
dot	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType dot( const Point2 & p ) const { return (*this) * p; }$/;"	f	class:vcg::Point2
dot	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType dot( const Point3 & p ) const { return (*this) * p; }$/;"	f	class:vcg::Point3
dot	vcglib/vcg/space/deprecated_point4.h	/^	inline T dot( const Point4 & p ) const { return (*this) * p; }$/;"	f	class:vcg::Point4
dot_nocheck	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^struct dot_nocheck$/;"	s	namespace:Eigen::internal
dot_nocheck	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^struct dot_nocheck<T, U, true>$/;"	s	namespace:Eigen::internal
doubleArea	vcglib/vcg/complex/algorithms/update/curvature.h	/^    float doubleArea;$/;"	m	struct:vcg::tri::UpdateCurvature::AdjVertex
doubleHorizon	vcglib/vcg/space/rasterized_outline2_packer.h	/^      bool doubleHorizon;$/;"	m	class:vcg::RasterizedOutline2Packer::Parameters
double_bits	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^int        mpreal::double_bits = -1;$/;"	m	class:mpfr::mpreal	file:
double_bits	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	static int				double_bits;		$/;"	m	class:mpfr::mpreal
double_value	vcglib/wrap/system/qgetopt.h	/^    double *double_value;$/;"	m	struct:GetOpt::Option
doublet_remove_quad	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static FacePointer doublet_remove_quad(MeshType &m, VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
dounpack	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^void dounpack(FILE* fp)$/;"	f
dparm	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<RealScalar,IPARM_SIZE,1>& dparm()$/;"	f	class:Eigen::PastixBase
dparm	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    double& dparm(int idxparam)$/;"	f	class:Eigen::PastixBase
dpi	vcglib/wrap/qt/Outline2ToQImage.h	/^      int dpi;$/;"	m	class:Outline2Dumper::Param
dragging	vcglib/wrap/gui/trackball.h	/^  bool dragging;$/;"	m	class:vcg::Trackball
drainRedrawEvents	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^void drainRedrawEvents(){$/;"	f
drawElements	vcglib/wrap/glw/buffer.h	/^		void drawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices)$/;"	f	class:glw::BoundIndexBuffer
drawElements	vcglib/wrap/glw/buffer.h	/^		void drawElements(GLenum target, GLint unit, GLenum mode, GLsizei count, GLenum type, const GLvoid * indices)$/;"	f	class:glw::Buffer
drawMode	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^int drawMode=2;$/;"	v
drawMode	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^int drawMode;$/;"	v
drawSplats	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>::drawSplats($/;"	f	class:SplatRenderer
drawSplats	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>::drawSplats(std::vector<MeshType*> & meshes, vcg::GLW::ColorMode cm,  vcg::GLW::TextureMode tm)$/;"	f	class:SplatRenderer
drawTickedLine	vcglib/wrap/gui/coordinateframe.cpp	/^void CoordinateFrame::drawTickedLine(const Point3d &a,const Point3d &b, float dim,float tickDist,float linewidth)$/;"	f	class:CoordinateFrame
drawVertex	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void drawVertex(VertexType & v){$/;"	f
draw_color_attachment	vcglib/wrap/gl/gl_surface.h	/^		bool draw_color_attachment(int x, int y, int width, int height, int attachment)$/;"	f	class:vcg::gl_surface
draw_depth_attachment	vcglib/wrap/gl/gl_surface.h	/^		bool draw_depth_attachment(int x, int y, int width, int height)$/;"	f	class:vcg::gl_surface
drawaxis	vcglib/wrap/gui/coordinateframe.h	/^  bool drawaxis;$/;"	m	class:vcg::CoordinateFrame
drawlabels	vcglib/wrap/gui/coordinateframe.h	/^  bool drawlabels;$/;"	m	class:vcg::CoordinateFrame
drawmode	vcglib/apps/sample/trimesh_QT/glarea.h	/^  DrawMode drawmode;$/;"	m	class:GLArea
drawmode	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^DrawMode drawmode;$/;"	v
drawmode	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^GLW::DrawMode drawmode=GLW::DMFlatWire;     \/\/\/ the current drawmode$/;"	v
drawmoves	vcglib/wrap/gui/activecoordinateframe.h	/^  bool drawmoves;$/;"	m	class:vcg::ActiveCoordinateFrame
drawrotations	vcglib/wrap/gui/activecoordinateframe.h	/^  bool drawrotations;$/;"	m	class:vcg::ActiveCoordinateFrame
drawvalues	vcglib/wrap/gui/coordinateframe.h	/^  bool drawvalues;$/;"	m	class:vcg::CoordinateFrame
dropX	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int dropX(RasterizedOutline2& poly, int row, int rast_i) {$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
dropY	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int dropY(RasterizedOutline2& poly, int col, int rast_i) {$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
du	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double du(double u, double v)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
du	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double du(double u, double v)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
dumpMemory	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::CholmodBase
dumpMemory	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SimplicialCholeskyBase
dumpMemory	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SuperLUBase
dumpOutline2VecPNG	vcglib/wrap/qt/Outline2ToQImage.cpp	/^void  Outline2Dumper::dumpOutline2VecPNG(const char * imageName,$/;"	f	class:Outline2Dumper
dumpOutline2VecPNG	vcglib/wrap/qt/Outline2ToQImage.cpp	/^void Outline2Dumper::dumpOutline2VecPNG(const char * imageName, vector< vector< vector<Point2f> > > &polyVecVec, vector<Similarity2f> &trVec, Outline2Dumper::Param &pp)$/;"	f	class:Outline2Dumper
dumpOutline2VecPNG	vcglib/wrap/qt/Outline2ToQImage.cpp	/^void Outline2Dumper::dumpOutline2VecPNG(const char * imageName, vector< vector<Point2f> > &polyVec, vector<Similarity2f> &trVec, Outline2Dumper::Param &pp)$/;"	f	class:Outline2Dumper
dumpOutline2VecSVG	vcglib/wrap/qt/Outline2ToQImage.cpp	/^void Outline2Dumper::dumpOutline2VecSVG(const char * imageName, vector< vector< vector<Point2f> > > &polyVecVec, vector<Similarity2f> &trVec, Outline2Dumper::Param &pp)$/;"	f	class:Outline2Dumper
dumpOutline2VecSVG	vcglib/wrap/qt/Outline2ToQImage.cpp	/^void Outline2Dumper::dumpOutline2VecSVG(const char * imageName,$/;"	f	class:Outline2Dumper
dumping	vcglib/wrap/gui/trackmode.h	/^	float accX, accY, accZ, dumping, topSpeedH, topSpeedV;$/;"	m	class:vcg::NavigatorWasdMode
dumpit	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  bool			dumpit;$/;"	v
duplicated	vcglib/wrap/miq/core/vertex_indexing.h	/^    std::vector<VertexType*> duplicated;$/;"	m	class:VertexIndexing
duu	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double duu(double \/*u*\/, double \/*v*\/)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
duu	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double duu(double \/*u*\/, double \/*v*\/)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
duv	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double duv(double \/*u*\/, double \/*v*\/)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
duv	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double duv(double \/*u*\/, double \/*v*\/)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
dv	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int dv;$/;"	m	struct:MeshInfo	file:
dv	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  mchunkptr  dv;$/;"	m	struct:malloc_state	file:
dv	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double dv(double u, double v)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
dv	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double dv(double u, double v)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
dvsize	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t     dvsize;$/;"	m	struct:malloc_state	file:
dvv	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double dvv(double \/*u*\/, double \/*v*\/)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
dvv	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double dvv(double \/*u*\/, double \/*v*\/)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
e	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  int e;$/;"	m	class:vcg::tri::BitQuad::Pos
e	vcglib/vcg/complex/algorithms/local_optimization.h	/^	double e;$/;"	m	class:vcg::LocalOptimization
e	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double& e() { return data[4];}$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
e	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double& e() { return data[4];}$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
e	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& e() { return data[4];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
e	vcglib/vcg/complex/algorithms/update/topology.h	/^  EdgePointer    e;		  \/\/ the edge where this vertex belong$/;"	m	class:vcg::tri::UpdateTopology::PVertexEdge
e	vcglib/vcg/simplex/edge/pos.h	/^	EDGETYPE *e;$/;"	m	class:vcg::edge::Pos
e	vcglib/vcg/simplex/edge/pos.h	/^	EDGETYPE *e;$/;"	m	class:vcg::edge::VertexStar
e	vcglib/vcg/simplex/edge/pos.h	/^	EdgeType *e;$/;"	m	class:vcg::edge::VEIterator
e0	vcglib/vcg/complex/algorithms/hole.h	/^  PosType e0;$/;"	m	class:vcg::tri::TrivialEar
e1	vcglib/vcg/complex/algorithms/hole.h	/^  PosType e1;$/;"	m	class:vcg::tri::TrivialEar
eckerle4_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    eckerle4_functor(void) : Functor<double>(3,35) {}$/;"	f	struct:eckerle4_functor
eckerle4_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct eckerle4_functor : Functor<double>$/;"	s	file:
edg	vcglib/wrap/io_edgemesh/export_dxf.h	/^	namespace edg {$/;"	n	namespace:vcg
edge	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^                size_t face, edge;$/;"	m	struct:vcg::tri::ExtendedMarchingCubes::LightEdge
edge	vcglib/vcg/complex/append.h	/^        std::vector<int> vert,face,edge, hedge;$/;"	m	struct:vcg::tri::Append::Remap
edge	vcglib/vcg/complex/base.h	/^    EdgeContainer edge;$/;"	m	class:vcg::tri::TriMesh
edge	vcglib/vcg/simplex/edge/component.h	/^  namespace edge {$/;"	n	namespace:vcg
edge	vcglib/vcg/simplex/edge/distance.h	/^	namespace edge{$/;"	n	namespace:vcg
edge	vcglib/vcg/simplex/edge/pos.h	/^namespace edge {$/;"	n	namespace:vcg
edge	vcglib/vcg/simplex/edge/topology.h	/^namespace edge {$/;"	n	namespace:vcg
edge	vcglib/vcg/simplex/face/component_ep.h	/^	CoordType edge[3];$/;"	m	struct:vcg::face::EdgePlaneInfo
edge	vcglib/wrap/gl/trimesh.h	/^        char edge;$/;"	m	class:vcg::GLW::VertToSplit
edge	vcglib/wrap/io_trimesh/import_obj.h	/^                    bool  edge[3];\/\/ useless if the face is a polygon, no need to have variable length array$/;"	m	struct:vcg::tri::io::ImporterOBJ::ObjIndexedFace
edge_attr	vcglib/vcg/complex/base.h	/^    std::set< PointerToAttribute > edge_attr;$/;"	m	class:vcg::tri::TriMesh
edge_collapse	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static VertexPointer edge_collapse(MeshType &m, HEdgePointer hp, VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
edge_collapse_quad	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static VertexPointer edge_collapse_quad(MeshType &m, HEdgePointer hp, VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
edge_rotate_quad	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static HEdgePointer edge_rotate_quad(HEdgePointer hp, bool cw)$/;"	f	class:vcg::tri::HalfEdgeTopology
edges	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^      LCEdgeStar edges;   \/\/ list of edges whose star involves this vertex$/;"	m	struct:vcg::tri::PolychordCollapse::LinkConditions::LCVertex
edgescale	vcglib/vcg/simplex/face/component_ep.h	/^	typename CoordType::ScalarType edgescale;$/;"	m	struct:vcg::face::EdgePlaneInfo
ei_abs	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs (const T& x) { return internal::abs(x); }$/;"	f	namespace:Eigen
ei_abs2	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs2(const T& x) { return internal::abs2(x); }$/;"	f	namespace:Eigen
ei_aligned_delete	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^template<typename T> inline void ei_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen
ei_aligned_free	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^inline void  ei_aligned_free(void *ptr) { internal::aligned_free(ptr); }$/;"	f	namespace:Eigen
ei_aligned_malloc	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_aligned_malloc(size_t size) { return internal::aligned_malloc(size); }$/;"	f	namespace:Eigen
ei_aligned_new	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^template<typename T> inline T* ei_aligned_new(size_t size)$/;"	f	namespace:Eigen
ei_aligned_realloc	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_aligned_realloc(void *ptr, size_t new_size, size_t old_size) { return internal::aligned_realloc(ptr, new_size, old_size); }$/;"	f	namespace:Eigen
ei_assert	vcglib/eigenlib/Eigen/src/Eigen2Support/Macros.h	/^#define ei_assert /;"	d
ei_atan2	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_atan2(const T& x,const T& y) { return internal::atan2(x,y); }$/;"	f	namespace:Eigen
ei_cleantype	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	s	namespace:Eigen
ei_cleantype	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_conditional_aligned_free	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void ei_conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen
ei_conditional_aligned_malloc	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen
ei_conditional_aligned_realloc	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen
ei_conj	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_conj(const T& x) { return internal::conj(x); }$/;"	f	namespace:Eigen
ei_cos	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_cos (const T& x) { return internal::cos(x); }$/;"	f	namespace:Eigen
ei_declare_aligned_stack_constructed_variable	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^  #define ei_declare_aligned_stack_constructed_variable(/;"	d
ei_exp	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_exp (const T& x) { return internal::exp(x); }$/;"	f	namespace:Eigen
ei_handmade_aligned_free	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^inline void  ei_handmade_aligned_free(void *ptr) { internal::handmade_aligned_free(ptr); }$/;"	f	namespace:Eigen
ei_handmade_aligned_malloc	vcglib/eigenlib/Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_handmade_aligned_malloc(size_t size) { return internal::handmade_aligned_malloc(size); }$/;"	f	namespace:Eigen
ei_imag	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_imag(const T& x) { return internal::imag(x); }$/;"	f	namespace:Eigen
ei_import_selector	vcglib/vcg/math/eigen.h	/^struct ei_import_selector<Derived1,Derived2,false,false>$/;"	s	namespace:Eigen
ei_import_selector	vcglib/vcg/math/eigen.h	/^struct ei_import_selector<Derived1,Derived2,false,true>$/;"	s	namespace:Eigen
ei_import_selector	vcglib/vcg/math/eigen.h	/^struct ei_import_selector<Derived1,Derived2,true,true>$/;"	s	namespace:Eigen
ei_internal_assert	vcglib/eigenlib/Eigen/src/Eigen2Support/Macros.h	/^#define ei_internal_assert /;"	d
ei_isApprox	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen
ei_isApproxOrLessThan	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen
ei_isMuchSmallerThan	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen
ei_is_same_type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	s	namespace:Eigen
ei_is_same_type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	s	namespace:Eigen
ei_lexi_comparison	vcglib/vcg/math/eigen.h	/^template<typename Derived1, typename Derived2> struct ei_lexi_comparison<Derived1,Derived2,2>$/;"	s	namespace:Eigen
ei_lexi_comparison	vcglib/vcg/math/eigen.h	/^template<typename Derived1, typename Derived2> struct ei_lexi_comparison<Derived1,Derived2,3>$/;"	s	namespace:Eigen
ei_lexi_comparison	vcglib/vcg/math/eigen.h	/^template<typename Derived1, typename Derived2> struct ei_lexi_comparison<Derived1,Derived2,4>$/;"	s	namespace:Eigen
ei_log	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_log (const T& x) { return internal::log(x); }$/;"	f	namespace:Eigen
ei_matrix44_product_impl	vcglib/vcg/math/old_matrix44.h	/^struct ei_matrix44_product_impl<Other, 3,1>$/;"	s	namespace:vcg
ei_matrix44_product_impl	vcglib/vcg/math/old_matrix44.h	/^struct ei_matrix44_product_impl<Other, 4,OtherCols>$/;"	s	namespace:vcg
ei_meta_false	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	s	namespace:Eigen
ei_meta_if	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	s	namespace:Eigen
ei_meta_if	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	s	namespace:Eigen
ei_meta_sqrt	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^class ei_meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c
ei_meta_true	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	s	namespace:Eigen
ei_pow	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_pow (const T& x,const T& y) { return internal::pow(x,y); }$/;"	f	namespace:Eigen
ei_quaternion_assign_impl	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define ei_quaternion_assign_impl /;"	d
ei_quaternion_assign_impl	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef ei_quaternion_assign_impl$/;"	d
ei_quaternion_assign_impl	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,3,3>$/;"	s	namespace:Eigen
ei_quaternion_assign_impl	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,4,1>$/;"	s	namespace:Eigen
ei_quaternion_product	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^ei_quaternion_product(const Quaternion<Scalar>& a, const Quaternion<Scalar>& b)$/;"	f	namespace:Eigen
ei_random	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random () { return internal::random<T>(); }$/;"	f	namespace:Eigen
ei_random	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random (const T& x, const T& y) { return internal::random(x, y); }$/;"	f	namespace:Eigen
ei_real	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_real(const T& x) { return internal::real(x); }$/;"	f	namespace:Eigen
ei_sin	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sin (const T& x) { return internal::sin(x); }$/;"	f	namespace:Eigen
ei_sqrt	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sqrt(const T& x) { return internal::sqrt(x); }$/;"	f	namespace:Eigen
ei_toRotationMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define ei_toRotationMatrix /;"	d
ei_toRotationMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef ei_toRotationMatrix$/;"	d
ei_toRotationMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> ei_toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen
ei_toRotationMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> ei_toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen
ei_toRotationMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& ei_toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen
ei_to_vcgtype	vcglib/vcg/math/eigen.h	/^struct ei_to_vcgtype { typedef Matrix<typename XprType::Scalar,Rows,Cols,StorageOrder,MRows,MCols> type; };$/;"	s	namespace:Eigen
ei_to_vcgtype	vcglib/vcg/math/old_matrix.h	/^template<typename XprType> struct ei_to_vcgtype<XprType,Dynamic,Dynamic,RowMajor,Dynamic,Dynamic>$/;"	s	namespace:Eigen
ei_to_vcgtype	vcglib/vcg/math/old_matrix33.h	/^template<typename XprType> struct ei_to_vcgtype<XprType,3,3,RowMajor,3,3>$/;"	s	namespace:Eigen
ei_to_vcgtype	vcglib/vcg/math/old_matrix44.h	/^template<typename XprType> struct ei_to_vcgtype<XprType,4,4,RowMajor,4,4>$/;"	s	namespace:Eigen
ei_to_vcgtype	vcglib/vcg/space/point2.h	/^template<typename XprType> struct ei_to_vcgtype<XprType,2,1,0,2,1>$/;"	s	namespace:Eigen
ei_to_vcgtype	vcglib/vcg/space/point3.h	/^template<typename XprType> struct ei_to_vcgtype<XprType,3,1,0,3,1>$/;"	s	namespace:Eigen
ei_to_vcgtype	vcglib/vcg/space/point4.h	/^template<typename XprType> struct ei_to_vcgtype<XprType,4,1,0,4,1>$/;"	s	namespace:Eigen
ei_traits	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^template<typename _Scalar> struct ei_traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^template<typename _Scalar> struct ei_traits<Quaternion<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^template<typename _Scalar> struct ei_traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^struct ei_traits : internal::traits<T>$/;"	s	namespace:Eigen
ei_traits	vcglib/vcg/math/old_matrix.h	/^struct ei_traits<vcg::ndim::Matrix<Scalar> > : ei_traits<Eigen::Matrix<Scalar,Dynamic,Dynamic> > {};$/;"	s	namespace:Eigen
ei_traits	vcglib/vcg/math/old_matrix33.h	/^struct ei_traits<vcg::Matrix33<Scalar> > : ei_traits<Eigen::Matrix<Scalar,3,3,RowMajor> > {};$/;"	s	namespace:Eigen
ei_traits	vcglib/vcg/math/old_matrix44.h	/^struct ei_traits<vcg::Matrix44<Scalar> > : ei_traits<Eigen::Matrix<Scalar,4,4,RowMajor> > {};$/;"	s	namespace:Eigen
ei_traits	vcglib/vcg/space/point2.h	/^template<typename Scalar> struct ei_traits<vcg::Point2<Scalar> > : ei_traits<Eigen::Matrix<Scalar,2,1> > {};$/;"	s	namespace:Eigen
ei_traits	vcglib/vcg/space/point3.h	/^template<typename Scalar> struct ei_traits<vcg::Point3<Scalar> > : ei_traits<Eigen::Matrix<Scalar,3,1> > {};$/;"	s	namespace:Eigen
ei_traits	vcglib/vcg/space/point4.h	/^template<typename Scalar> struct ei_traits<vcg::Point4<Scalar> > : ei_traits<Eigen::Matrix<Scalar,4,1> > {};$/;"	s	namespace:Eigen
ei_transform_product_impl	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#define ei_transform_product_impl /;"	d
ei_transform_product_impl	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/All.h	/^#undef ei_transform_product_impl$/;"	d
ei_transform_product_impl	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,1>$/;"	s	namespace:Eigen
ei_transform_product_impl	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen
ei_transform_product_impl	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,1>$/;"	s	namespace:Eigen
ei_transform_product_impl	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen
ei_unconst	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	s	namespace:Eigen
ei_unconst	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	s	namespace:Eigen
ei_unconst	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	s	namespace:Eigen
ei_unconst	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen
ei_unref	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	s	namespace:Eigen
ei_unref	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	s	namespace:Eigen
eigen2_dot	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::eigen2_dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
eigen2_dot	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar eigen2_dot(const Quaternion& other) const { return m_coeffs.eigen2_dot(other.m_coeffs); }$/;"	f	class:Eigen::Quaternion
eigen2_lu	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^MatrixBase<Derived>::eigen2_lu() const$/;"	f	class:Eigen::MatrixBase
eigen2_part_return_type	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type$/;"	s	namespace:Eigen::internal
eigen2_part_return_type	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type<MatrixType, SelfAdjoint>$/;"	s	namespace:Eigen::internal
eigen2_product_return_type	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    struct eigen2_product_return_type$/;"	s	class:Eigen::TriangularView
eigen_assert	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define eigen_assert(/;"	d
eigen_internal_assert	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^#define eigen_internal_assert(/;"	d
eigen_pastix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_plain_assert	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^    #define eigen_plain_assert(/;"	d
eigen_plain_assert	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^  #define eigen_plain_assert(/;"	d
eigenvalues	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::ComplexEigenSolver
eigenvalues	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::EigenSolver
eigenvalues	vcglib/eigenlib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::eigenvalues() const$/;"	f	class:Eigen::MatrixBase
eigenvalues	vcglib/eigenlib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::eigenvalues() const$/;"	f	class:Eigen::SelfAdjointView
eigenvalues	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const RealVectorType& eigenvalues() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
eigenvalues_selector	vcglib/eigenlib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector$/;"	s	namespace:Eigen::internal
eigenvalues_selector	vcglib/eigenlib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector<Derived, false>$/;"	s	namespace:Eigen::internal
eigenvectors	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvectorType& eigenvectors() const$/;"	f	class:Eigen::ComplexEigenSolver
eigenvectors	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^typename EigenSolver<MatrixType>::EigenvectorsType EigenSolver<MatrixType>::eigenvectors() const$/;"	f	class:Eigen::EigenSolver
eigenvectors	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const MatrixType& eigenvectors() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
eint	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal eint   (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
elem	vcglib/vcg/space/index/space_iterators.h	/^			ObjType* elem;$/;"	m	struct:vcg::ClosestIterator::Entry_Type
elem	vcglib/vcg/space/index/space_iterators.h	/^			ObjType* elem;$/;"	m	struct:vcg::RayIterator::Entry_Type
elements	vcglib/wrap/ply/plylib.h	/^  std::vector<PlyElement>   elements;	\/\/ Vettore degli elementi$/;"	m	class:vcg::ply::PlyFile
elemname	vcglib/wrap/ply/plylib.h	/^	const char * elemname;			\/\/ Nome dell'elemento$/;"	m	class:vcg::ply::PropDescriptor
elseMatrix	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    const ElseMatrixType& elseMatrix() const$/;"	f	class:Eigen::Select
empty	vcglib/vcg/container/simple_temporary_data.h	/^    bool empty() const {return datasize==0;}$/;"	f	class:vcg::VectorNBW
emptyCellBetweenPolyAndBottomHorizon	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int emptyCellBetweenPolyAndBottomHorizon(RasterizedOutline2& poly, Point2i pos, int rast_i)$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
emptyCellBetweenPolyAndLeftHorizon	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int emptyCellBetweenPolyAndLeftHorizon(RasterizedOutline2& poly, Point2i pos, int rast_i)$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
en	vcglib/vcg/complex/base.h	/^    int en;$/;"	m	class:vcg::tri::TriMesh
enableExtension	vcglib/wrap/glw/utility.h	/^		ThisType & enableExtension(const std::string & ext)$/;"	f	class:glw::ShaderHeaderBuilder
enablePass	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>::enablePass(int n)$/;"	f	class:SplatRenderer
enable_if	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct enable_if<true,T>$/;"	s	namespace:Eigen::internal
enable_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define enable_lock(/;"	d	file:
enable_mmap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define enable_mmap(/;"	d	file:
end	vcglib/eigenlib/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end() const$/;"	f	class:Eigen::MatrixBase
end	vcglib/eigenlib/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end()$/;"	f	class:Eigen::MatrixBase
end	vcglib/eigenlib/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size) const$/;"	f	class:Eigen::MatrixBase
end	vcglib/eigenlib/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size)$/;"	f	class:Eigen::MatrixBase
end	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    CoordType origin,end;$/;"	m	class:vcg::tri::CylinderClipping::CylPred
end	vcglib/vcg/space/index/octree.h	/^        int end;$/;"	m	struct:vcg::Voxel
end	vcglib/vcg/space/index/space_iterators.h	/^		bool end;									\/\/true if the scan is terminated$/;"	m	class:vcg::ClosestIterator
end	vcglib/vcg/space/index/space_iterators.h	/^		bool end;								\/\/true if the scan is terminated$/;"	m	class:vcg::RayIterator
end	vcglib/wrap/gcache/cache.h	/^    virtual void end() {}$/;"	f	class:vcg::Cache
end	vcglib/wrap/gui/rubberband.h	/^  Point3f start, end;$/;"	m	class:vcg::Rubberband
endFill	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void endFill() {}$/;"	f	class:Eigen::SparseVector
endFill	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED void endFill() {}$/;"	f	class:Eigen::DynamicSparseMatrix
end_cb	vcglib/wrap/gl/glu_tesselator.h	/^        static void CALLBACK end_cb(void * polygon_data)$/;"	f	class:vcg::glu_tesselator
end_read_color	vcglib/wrap/gl/gl_surface.h	/^		bool end_read_color(int attachment)$/;"	f	class:vcg::gl_surface
end_read_depth	vcglib/wrap/gl/gl_surface.h	/^		bool end_read_depth(void)$/;"	f	class:vcg::gl_surface
end_write	vcglib/wrap/gl/gl_surface.h	/^		bool end_write(void)$/;"	f	class:vcg::gl_surface
enda	vcglib/wrap/gui/trackmode.h	/^ float enda, endb;  \/\/store intermediate values of alpha and beta$/;"	m	class:vcg::PolarMode
endb	vcglib/wrap/gui/trackmode.h	/^ float enda, endb;  \/\/store intermediate values of alpha and beta$/;"	m	class:vcg::PolarMode
ensure_initialization	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ensure_initialization(/;"	d	file:
enter	vcglib/wrap/gcache/door.h	/^  void enter() {$/;"	f	class:QDoor
enter	vcglib/wrap/gcache/door.h	/^  void enter(bool close = false) {$/;"	f	class:QDoor
enter2D	vcglib/wrap/qt/gl_label.h	/^    static void enter2D(QPainter *painter)$/;"	f	class:vcg::glLabel
entry	vcglib/apps/trimeshinfo/SlotsNode.h	/^	EntryNode entry;$/;"	m	class:OwnSlotNode
entry_index	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				EntryCoordinate			entry_index;  \/*!< The index of the entry inside the offset table.	*\/$/;"	m	struct:vcg::PerfectSpatialHashing::OffsetTable::PreImage
ep	vcglib/vcg/complex/algorithms/refine.h	/^        bool ep[3];$/;"	m	class:vcg::tri::RefinedFaceData
ep	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                HEdgePointer ep;$/;"	m	struct:vcg::tri::UpdateHalfEdges::VertexPairEdgePtr
ep	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                HEdgePointer ep;$/;"	m	struct:vcg::tri::UpdateIndexed::VertexPairEdgePtr
epsfcn	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Scalar epsfcn;$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
epsfcn	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Scalar epsfcn;$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
epsfcn	vcglib/eigenlib/unsupported/Eigen/src/NumericalDiff/NumericalDiff.h	/^    Scalar epsfcn;$/;"	m	class:Eigen::NumericalDiff
epsilon	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    RealScalar epsilon;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func
epsilon	vcglib/wrap/minpack/minpack.h	/^	double epsilon; 	\/\/ step used to calculate the jacobian.$/;"	m	struct:LMDiff::__anon525
eqn	vcglib/wrap/gl/tetramesh.h	/^			GLdouble eqn[4];$/;"	m	class:vcg::tetra::GlTetramesh::ClipPlane
erase	vcglib/apps/pivoting/ring.h	/^    iterator erase() {$/;"	f	class:ring::iterator
erase	vcglib/apps/pivoting/ring.h	/^  void erase(iterator &i) { lst.erase(i.it); }$/;"	f	class:ring
erased	vcglib/wrap/mt/mt.h	/^    std::vector<Cell *> erased; $/;"	m	class:vcg::MT::Update
erf	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal erf (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
erfc	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal erfc (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
err	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    ScalarType err;$/;"	m	struct:vcg::tri::FourPCS::Candidate
error	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar error() const$/;"	f	class:Eigen::IterativeSolverBase
error	vcglib/wrap/bmt/bmt.h	/^    float error;$/;"	m	class:vcg::Bmt::Cell
error	vcglib/wrap/mt/mt.h	/^    float error;$/;"	m	struct:vcg::MT::Node
error	vcglib/wrap/mt/mt.h	/^  float error;$/;"	m	class:vcg::DiracPolicy
error	vcglib/wrap/mt/mt.h	/^  float error;$/;"	m	class:vcg::FrustumPolicy
error	vcglib/wrap/ply/plylib.h	/^	int    error;				\/\/ Errore corrente (vedi enum)$/;"	m	class:vcg::ply::PlyFile
esHandle	vcglib/vcg/complex/algorithms/update/selection.h	/^  typedef typename ComputeMeshType::template PerEdgeAttributeHandle< bool >   esHandle;$/;"	t	class:vcg::tri::SelectionStack
esV	vcglib/vcg/complex/algorithms/update/selection.h	/^  std::vector<esHandle> esV;$/;"	m	class:vcg::tri::SelectionStack
essentialVector	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    const EssentialVectorType essentialVector(Index k) const$/;"	f	class:Eigen::HouseholderSequence
essentialVector	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)$/;"	f	struct:Eigen::internal::hseq_side_dependent_impl
eulerAngles	vcglib/eigenlib/Eigen/src/Geometry/EulerAngles.h	/^MatrixBase<Derived>::eulerAngles(Index a0, Index a1, Index a2) const$/;"	f	class:Eigen::MatrixBase
eval	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    EIGEN_STRONG_INLINE EvalReturnType eval() const$/;"	f	class:Eigen::DenseBase
eval	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    PlainPermutationType eval() const { return *this; }$/;"	f	class:Eigen::Transpose
eval	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const typename internal::eval<Derived>::type eval() const$/;"	f	class:Eigen::SparseMatrixBase
eval	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct eval<T,Sparse>$/;"	s	namespace:Eigen::internal
eval	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    EIGEN_STRONG_INLINE const typename internal::eval<Derived, IsSkyline>::type eval() const {$/;"	f	class:Eigen::SkylineMatrixBase
eval	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^template<typename T> class eval<T,IsSkyline>$/;"	c	namespace:Eigen::internal
evalSolver	vcglib/eigenlib/unsupported/test/polynomialsolver.cpp	/^void evalSolver( const POLYNOMIAL& pols )$/;"	f
evalSolverSugarFunction	vcglib/eigenlib/unsupported/test/polynomialsolver.cpp	/^void evalSolverSugarFunction( const POLYNOMIAL& pols, const ROOTS& roots, const REAL_ROOTS& real_roots )$/;"	f
evalTo	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline void evalTo(Dest& dst) const { dst = m_expression; }$/;"	f	class:Eigen::ArrayWrapper
evalTo	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::internal::BandMatrixBase
evalTo	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    template<typename Dest> inline void evalTo(Dest& ) const$/;"	f	class:Eigen::DenseBase
evalTo	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^void DiagonalBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase
evalTo	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
evalTo	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_matrix_product_retval
evalTo	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::PermutationBase
evalTo	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::Transpose
evalTo	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:Eigen::ScaledProduct
evalTo	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst,Scalar(1)); }$/;"	f	class:Eigen::ProductBase
evalTo	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::ReturnByValue
evalTo	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::triangular_solve_retval
evalTo	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval
evalTo	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase
evalTo	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
evalTo	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
evalTo	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
evalTo	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
evalTo	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    template<typename DestType> inline void evalTo(DestType& dst) const$/;"	f	class:Eigen::HouseholderSequence
evalTo	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    void evalTo(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
evalTo	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval
evalTo	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval
evalTo	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::inverse_impl
evalTo	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
evalTo	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result, WorkVectorType& workspace) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
evalTo	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      void evalTo(MatrixBase<DenseDerived>& dst) const$/;"	f	class:Eigen::SparseMatrixBase
evalTo	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval
evalTo	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    void evalTo(Dest& result) const$/;"	f	class:Eigen::SparseSparseProduct
evalTo	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar,int StorageOrder> void evalTo(SparseMatrix<DestScalar,StorageOrder,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView
evalTo	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar> void evalTo(DynamicSparseMatrix<DestScalar,ColMajor,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView
evalTo	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestType,unsigned int DestUpLo> void evalTo(SparseSelfAdjointView<DestType,DestUpLo>& dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
evalTo	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    void evalTo(SparseMatrix<DestScalar,Options,DstIndex>& _dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
evalTo	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval_base
evalTo	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval_base
evalTo	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_base
evalTo	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_with_guess
evalTo	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
evalTo	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::MatrixExponentialReturnValue
evalTo	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    inline void evalTo(ResultType& result) const$/;"	f	class:Eigen::MatrixFunctionReturnValue
evalTo	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  inline void evalTo(ResultType& result) const$/;"	f	class:Eigen::MatrixLogarithmReturnValue
evalTo	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    inline void evalTo(ResultType& result) const$/;"	f	class:Eigen::MatrixSquareRootReturnValue
evalTo	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    void evalTo(MatrixBase<DenseDerived>& dst) const {$/;"	f	class:Eigen::SkylineMatrixBase
evalToLazy	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase
eval_closed_spline2d	vcglib/eigenlib/unsupported/test/splines.cpp	/^void eval_closed_spline2d()$/;"	f
eval_spline3d	vcglib/eigenlib/unsupported/test/splines.cpp	/^void eval_spline3d()$/;"	f
eval_spline3d_onbrks	vcglib/eigenlib/unsupported/test/splines.cpp	/^void eval_spline3d_onbrks()$/;"	f
evaluate	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        double evaluate(double u, double v)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
evaluate	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    double evaluate(double u, double v)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
evaluate	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double evaluate(double u, double v)$/;"	f	class:vcg::tri::Fitmaps::Bicubic
example	vcglib/wrap/gcache/docs/readme.html	/^<h2><a name="example"><\/a>Minimal example<\/h2>$/;"	a
example1	vcglib/apps/sample/polygonmesh_zonohedra/polygonmesh_zonohedra.cpp	/^void example1(){$/;"	f
example2	vcglib/apps/sample/polygonmesh_zonohedra/polygonmesh_zonohedra.cpp	/^void example2(){$/;"	f
exchange	vcglib/wrap/system/getopt.cpp	/^exchange (char **argv)$/;"	f	file:
exec_name	vcglib/wrap/system/getopt.cpp	/^const char *exec_name;$/;"	v
existEdge	vcglib/vcg/complex/algorithms/hole.h	/^  static bool existEdge(PosType pi,PosType pf)$/;"	f	class:vcg::tri::Hole
exit2D	vcglib/wrap/qt/gl_label.h	/^    static void exit2D(QPainter *painter)$/;"	f	class:vcg::glLabel
exp	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::exp() const$/;"	f	class:Eigen::Cwise
exp	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^exp() const$/;"	f
exp	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^const MatrixExponentialReturnValue<Derived> MatrixBase<Derived>::exp() const$/;"	f	class:Eigen::MatrixBase
exp	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^    static Scalar exp(Scalar x, int)$/;"	f	class:Eigen::StdStemFunctions
exp	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal exp(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
exp10	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal exp10(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
exp2	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal exp2(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
expand	vcglib/vcg/complex/algorithms/nring.h	/^    void expand()$/;"	f	class:vcg::tri::Nring
expand	vcglib/vcg/complex/algorithms/nring.h	/^    void expand(int k)$/;"	f	class:vcg::tri::Nring
expandMaxLocal	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static void expandMaxLocal (MeshType & mesh, VertexType *v, int max, std::vector<VertexType*> *vv)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
expandSphereLocal	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static void expandSphereLocal (MeshType & mesh, VertexType *v, float r, int min, std::vector<VertexType*> *vv)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
expfn	vcglib/eigenlib/unsupported/doc/examples/MatrixFunction.cpp	/^std::complex<double> expfn(std::complex<double> x, int)$/;"	f
expfn	vcglib/eigenlib/unsupported/test/matrix_exponential.cpp	/^T expfn(T x, int)$/;"	f
explored	vcglib/vcg/space/index/space_iterators.h	/^		vcg::Box3i explored;		  \/\/current bounding box explored$/;"	m	class:vcg::ClosestIterator
expm1	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal expm1  (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
expression	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Lhs& expression() const $/;"	f	class:Eigen::SelfCwiseBinaryOp
expression	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    ExpressionType& expression() const { return m_expression; }$/;"	f	class:Eigen::SwapWrapper
extend	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
extend	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const VectorType& p)$/;"	f	class:Eigen::AlignedBox
extend	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
extend	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const MatrixBase<Derived>& a_p)$/;"	f	class:Eigen::AlignedBox
extend_entries	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void extend_entries(int extra_nnz){  $/;"	f	class:SparseMatrixData
extend_rows	vcglib/wrap/miq/core/sparsesystemdata.h	/^  virtual void extend_rows(int extra_rows){  $/;"	f	class:SparseMatrixData
extend_rows	vcglib/wrap/miq/core/sparsesystemdata.h	/^  virtual void extend_rows(int extra_rows){  $/;"	f	class:SparseSystemData
extendedTo	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    extendedTo(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
exteriorDistance	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline Scalar exteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox
exteriorDistance	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
exteriorDistance	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox
extp	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  void*      extp;      \/* Unused but available for extensions *\/$/;"	m	struct:malloc_state	file:
extract	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  static inline const XprType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits
extract	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits
extract	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits
extractData	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLUBase<MatrixType,Derived>::extractData() const$/;"	f	class:Eigen::SuperLUBase
extractData	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^void UmfPackLU<MatrixType>::extractData() const$/;"	f	class:Eigen::UmfPackLU
extractScalarFactor	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return Base::extractScalarFactor(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return conj(Base::extractScalarFactor(x.nestedExpression())); }$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x)$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }$/;"	f	struct:Eigen::internal::blas_traits
extract_data	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<typename T> const typename T::Scalar* extract_data(const T& m)$/;"	f	namespace:Eigen::internal
extract_data_selector	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector {$/;"	s	namespace:Eigen::internal
extract_data_selector	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector<T,false> {$/;"	s	namespace:Eigen::internal
exts	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t     exts;$/;"	m	struct:malloc_state	file:
f	vcglib/apps/pivoting/cmesh.h	/^   CFace *f;$/;"	m	class:CEdge
f	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    ScalarType f;       \/\/ overlap estimation as a percentage$/;"	m	struct:vcg::tri::FourPCS::Param
f	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  FaceType *f;$/;"	m	class:vcg::tri::BitQuad::Pos
f	vcglib/vcg/complex/algorithms/geodesic.h	/^      FacePointer f;$/;"	m	struct:vcg::tri::Geodesic::FaceDist
f	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& f() { return data[5];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
f	vcglib/vcg/complex/algorithms/update/flag.h	/^    FacePointer    f;				\/\/ Puntatore alla faccia generatrice$/;"	m	class:vcg::tri::UpdateFlags::EdgeSorter
f	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                FaceType * f;$/;"	m	struct:vcg::tri::UpdateHalfEdges::FacePtrInt
f	vcglib/vcg/complex/algorithms/update/topology.h	/^  FacePointer    f;                       \/\/ the face where this edge belong$/;"	m	class:vcg::tri::UpdateTopology::PEdgeTex
f	vcglib/vcg/complex/algorithms/update/topology.h	/^  FacePointer    f;     \/\/ the face where this edge belong$/;"	m	class:vcg::tri::UpdateTopology::PEdge
f	vcglib/vcg/simplex/face/pos.h	/^	FaceType *f;$/;"	m	class:vcg::face::VFIterator
f	vcglib/vcg/simplex/face/pos.h	/^	typename FaceType::FaceType *f;$/;"	m	class:vcg::face::Pos
f	vcglib/wrap/gl/trimesh.h	/^        typename MESH_TYPE::face_base_pointer f;$/;"	m	class:vcg::GLW::VertToSplit
f0	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  FacePointer f0,f1;$/;"	m	class:vcg::tri::VoronoiProcessing::VoronoiEdge
f1	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  FacePointer f0,f1;$/;"	m	class:vcg::tri::VoronoiProcessing::VoronoiEdge
fU	vcglib/vcg/complex/algorithms/clip.h	/^    ScalarType fU;$/;"	m	class:vcg::tri::TriMeshClipper::VertexClipInfo
fV	vcglib/vcg/complex/algorithms/clip.h	/^    ScalarType fV;$/;"	m	class:vcg::tri::TriMeshClipper::VertexClipInfo
fabs	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal fabs(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
fabsf	vcglib/vcg/math/base.h	/^    float fabsf (float v) {return fabs(v);}$/;"	f
fac_ui	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal fac_ui (unsigned long int v, mp_prec_t prec, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
face	vcglib/apps/pivoting/pivot.h	/^      int face;        \/\/corresponding face$/;"	m	struct:vcg::tri::Hinge
face	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^                size_t face, edge;$/;"	m	struct:vcg::tri::ExtendedMarchingCubes::LightEdge
face	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    Face& face(VecIndex i, VecIndex j){$/;"	f	class:vcg::tri::Zonohedron
face	vcglib/vcg/complex/append.h	/^        std::vector<int> vert,face,edge, hedge;$/;"	m	struct:vcg::tri::Append::Remap
face	vcglib/vcg/complex/base.h	/^    FaceContainer face;$/;"	m	class:vcg::tri::TriMesh
face	vcglib/vcg/simplex/face/component.h	/^namespace face {$/;"	n	namespace:vcg
face	vcglib/vcg/simplex/face/component_ep.h	/^  namespace face {$/;"	n	namespace:vcg
face	vcglib/vcg/simplex/face/component_occ.h	/^  namespace face {$/;"	n	namespace:vcg
face	vcglib/vcg/simplex/face/component_ocf.h	/^  namespace face {$/;"	n	namespace:vcg
face	vcglib/vcg/simplex/face/component_polygon.h	/^namespace face {$/;"	n	namespace:vcg
face	vcglib/vcg/simplex/face/distance.h	/^    namespace face{$/;"	n	namespace:vcg
face	vcglib/vcg/simplex/face/jumping_pos.h	/^	namespace face $/;"	n	namespace:vcg
face	vcglib/vcg/simplex/face/pos.h	/^namespace face {$/;"	n	namespace:vcg
face	vcglib/vcg/simplex/face/topology.h	/^namespace face {$/;"	n	namespace:vcg
face	vcglib/wrap/glw/framebuffer.h	/^		GLenum           face;$/;"	m	class:glw::RenderTarget
face_attr	vcglib/vcg/complex/base.h	/^    std::set< PointerToAttribute > face_attr;$/;"	m	class:vcg::tri::TriMesh
face_pointers	vcglib/wrap/gl/trimesh.h	/^    FACE_POINTER_CONTAINER face_pointers;$/;"	m	class:vcg::GlTrimesh
faces	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            set<FacePointer> faces;$/;"	m	class:vcg::tri::QuadDiagonalCollapseBase
facets	vcglib/apps/trimeshinfo/XMLTree.h	/^	NodeGroup facets;$/;"	m	class:FacetsNode
factor	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  inline Scalar& factor() { return m_factor; }$/;"	f	class:Eigen::UniformScaling
factor	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  inline const Scalar& factor() const { return m_factor; }$/;"	f	class:Eigen::UniformScaling
factor	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Scalar factor;$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
factor	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Scalar factor;$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
factor	vcglib/wrap/miq/quadrangulator.h	/^        ScalarType factor;$/;"	m	class:Quadrangulator::EdgePredicate
factor	vcglib/wrap/miq/quadrangulator.h	/^        ScalarType factor;$/;"	m	struct:Quadrangulator::SplitMidPoint
factorial_table	vcglib/vcg/math/factorial.h	/^ScalarType factorial_table(unsigned i)$/;"	f	namespace:vcg::math
factorial_table	vcglib/vcg/math/factorial.h	/^double factorial_table <double> (unsigned i)$/;"	f	namespace:vcg::math
factorial_table	vcglib/vcg/math/factorial.h	/^float factorial_table <float> (unsigned i)$/;"	f	namespace:vcg::math
factorial_table	vcglib/vcg/math/factorial.h	/^int factorial_table<int> (unsigned i)$/;"	f	namespace:vcg::math
factorial_table	vcglib/vcg/math/factorial.h	/^long double factorial_table <long double> (unsigned i)$/;"	f	namespace:vcg::math
factorize	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
factorize	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& factorize(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner
factorize	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& factorize(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
factorize	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::factorize(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
factorize	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& factorize(const MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase
factorize	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
factorize	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
factorize	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
factorize	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::factorize(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
factorize	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::factorize(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
factorize	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky
factorize	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholeskyBase
factorize	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT
factorize	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT
factorize	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperILU
factorize	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperLU
factorize	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
factorize	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  void factorize(int nfft)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
factorize_preordered	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::factorize_preordered(const CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase
fade	vcglib/vcg/math/perlin_noise.h	/^   static double fade(double t) { return t * t * t * (t * (t * 6 - 15) + 10); }$/;"	f	class:vcg::math::Perlin
false_type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
fb	vcglib/wrap/gl/gl_surface.h	/^		GLuint fb;$/;"	m	class:vcg::gl_surface
fcn_chkder	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^int fcn_chkder(const VectorXd &x, VectorXd &fvec, MatrixXd &fjac, int iflag)$/;"	f
fd	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  struct malloc_chunk* fd;         \/* double links -- used only if free. *\/$/;"	m	struct:malloc_chunk	typeref:struct:malloc_chunk::malloc_chunk	file:
fd	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  struct malloc_tree_chunk* fd;$/;"	m	struct:malloc_tree_chunk	typeref:struct:malloc_tree_chunk::malloc_tree_chunk	file:
fdjac1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/fdjac1.h	/^DenseIndex fdjac1($/;"	f	namespace:Eigen::internal
fdn	vcglib/wrap/io_tetramesh/io_ply.h	/^  int fdn;$/;"	m	class:vcg::tetra::io::PlyInfo
fdn	vcglib/wrap/io_trimesh/io_ply.h	/^  int fdn;$/;"	m	class:vcg::tri::io::PlyInfo
feButton	vcglib/apps/sample/trimesh_pos_demo/window.h	/^		QPushButton * fvButton,*feButton,*ffButton,*neButton,*ldButton,*nbButton,*vfButton;$/;"	m	class:Window
feedbackStream	vcglib/wrap/glw/program.h	/^		TransformFeedbackStream    feedbackStream;$/;"	m	class:glw::ProgramArguments
feetsize	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    int feetsize;       \/\/ how many points in the neighborhood of each of the 4 points$/;"	m	struct:vcg::tri::FourPCS::Param
fetchAndAddAcquire	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline int fetchAndAddAcquire( int valueToAdd )$/;"	f	class:mt::atomicInt
fetchAndAddAcquire	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline int fetchAndAddAcquire( int valueToAdd )$/;"	f	class:mt::atomicInt
ffButton	vcglib/apps/sample/trimesh_pos_demo/window.h	/^		QPushButton * fvButton,*feButton,*ffButton,*neButton,*ldButton,*nbButton,*vfButton;$/;"	m	class:Window
fft_rmse	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^    long double fft_rmse( const VT1 & fftbuf,const VT2 & timebuf)$/;"	f
fftw_cast	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  T * fftw_cast(const T* p)$/;"	f	namespace:Eigen::internal
fftw_cast	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  fftw_complex * fftw_cast( const std::complex<double> * p)$/;"	f	namespace:Eigen::internal
fftw_cast	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  fftwf_complex * fftw_cast( const std::complex<float> * p)$/;"	f	namespace:Eigen::internal
fftw_cast	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  fftwl_complex * fftw_cast( const std::complex<long double> * p)$/;"	f	namespace:Eigen::internal
fftw_impl	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  struct fftw_impl$/;"	s	namespace:Eigen::internal
fftw_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      fftw_plan() :m_plan(NULL) {}$/;"	f	struct:Eigen::internal::fftw_plan
fftw_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  struct fftw_plan {};$/;"	s	namespace:Eigen::internal
fftw_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  struct fftw_plan<double>$/;"	s	namespace:Eigen::internal
fftw_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  struct fftw_plan<float>$/;"	s	namespace:Eigen::internal
fftw_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^  struct fftw_plan<long double>$/;"	s	namespace:Eigen::internal
fghCircleTable	vcglib/wrap/gl/gl_geometry.h	/^static void fghCircleTable(double **sint,double **cost,const int n)$/;"	f
fieldScale	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    ScalarType fieldScale;$/;"	m	class:vcg::tri::PoissonSolver
field_value	vcglib/vcg/complex/algorithms/create/resampler.h	/^		typedef typename  std::pair<bool,float> field_value;$/;"	t	class:vcg::tri::Resampler::Walker
fileExtension	vcglib/wrap/io_trimesh/export_idtf.h	/^	static QString fileExtension(const QString& filepath)$/;"	f	namespace:vcg::tri::io::QtUtilityFunctions
fileNameFromPath	vcglib/wrap/io_trimesh/export_idtf.h	/^	static QString fileNameFromPath(const QString& filepath)$/;"	f	namespace:vcg::tri::io::QtUtilityFunctions
fileNameFromTrimmedPath	vcglib/wrap/io_trimesh/export_idtf.h	/^	static QString fileNameFromTrimmedPath(const QStringList& file_path)$/;"	f	namespace:vcg::tri::io::QtUtilityFunctions
filename	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^char * filename  = NULL;$/;"	v
filename	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^char * filename;\/\/\/ filename of the mesh to load$/;"	v
filename	vcglib/apps/trimeshinfo/XMLTree.h	/^	string filename;$/;"	m	class:XMLTree
fill	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE void DenseBase<Derived>::fill(const Scalar& value)$/;"	f	class:Eigen::DenseBase
fill	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    void fill(const Scalar& value) { setConstant(value); }$/;"	f	class:Eigen::TriangularView
fill	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index i)$/;"	f	class:Eigen::SparseVector
fill	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index r, Index c)$/;"	f	class:Eigen::SparseVector
fill	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED Scalar& fill(Index row, Index col)$/;"	f	class:Eigen::DynamicSparseMatrix
fill	vcglib/wrap/qt/Outline2ToQImage.h	/^      bool fill;$/;"	m	class:Outline2Dumper::Param
fillHoles	vcglib/wrap/io_trimesh/import_raw.h	/^static int fillHoles( MESH_TYPE &m, size_t rowCount, size_t colCount)$/;"	f	class:vcg::tri::io::ImporterRAW
fillScene	vcglib/wrap/io_trimesh/export_fbx.h	/^	static bool fillScene(SaveMeshType& m,KFbxScene& scene,const int mask)$/;"	f	class:ExporterFBX
fill_vcg_mesh	vcg_mesh.cpp	/^void fill_vcg_mesh(MyMesh& vcg_mesh,$/;"	f	namespace:vcg
fillrand	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index i)$/;"	f	class:Eigen::SparseVector
fillrand	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index r, Index c)$/;"	f	class:Eigen::SparseVector
fillrand	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index row, Index col)$/;"	f	class:Eigen::DynamicSparseMatrix
final	vcglib/wrap/gcache/cache.h	/^    bool final;$/;"	m	class:vcg::Cache
finalEigenStuff	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static void finalEigenStuff (VertexType *v, std::vector<CoordType> ref, QuadricLocal q)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
finalize	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void finalize()$/;"	f	class:Eigen::SparseMatrix
finalize	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline void finalize() {}$/;"	f	class:Eigen::SparseVector
finalize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline void finalize() {$/;"	f	class:Eigen::SkylineMatrix
finalize	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline void finalize() {}$/;"	f	class:Eigen::DynamicSparseMatrix
finalizeMain	vcglib/apps/trimeshinfo/XMLTree.h	/^void XMLTree::finalizeMain()$/;"	f	class:XMLTree
findArg	vcglib/wrap/system/qgetopt.cpp	/^bool GetOpt::findArg(const QString &name, Option &option) {$/;"	f	class:GetOpt
findCluster	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^typename MatrixFunction<MatrixType,AtomicType,1>::ListOfClusters::iterator MatrixFunction<MatrixType,AtomicType,1>::findCluster(Scalar key)$/;"	f	class:Eigen::MatrixFunction
findNodeBySpecificAttributeValue	vcglib/wrap/dae/util_dae.h	/^		inline static QDomNode findNodeBySpecificAttributeValue(const QDomDocument n,const QString& tag,const QString& attrname,const QString& attrvalue)$/;"	f	class:vcg::tri::io::UtilDAE
findNodeBySpecificAttributeValue	vcglib/wrap/dae/util_dae.h	/^		inline static QDomNode findNodeBySpecificAttributeValue(const QDomNode n,const QString& tag,const QString& attrname,const QString& attrvalue)$/;"	f	class:vcg::tri::io::UtilDAE
findNodeBySpecificAttributeValue	vcglib/wrap/dae/util_dae.h	/^		inline static QDomNode findNodeBySpecificAttributeValue(const QDomNodeList& ndl,const QString& attrname,const QString& attrvalue)$/;"	f	class:vcg::tri::io::UtilDAE
findOffSetForASingleSimplex	vcglib/wrap/dae/util_dae.h	/^		inline static int findOffSetForASingleSimplex(QDomNode node)$/;"	f	class:vcg::tri::io::UtilDAE
findOption	vcglib/wrap/system/qgetopt.cpp	/^bool GetOpt::findOption(char c, Option &option) {$/;"	f	class:GetOpt
findSmallSubdiagEntry	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu, Scalar norm)$/;"	f	class:Eigen::RealSchur
findSphere	vcglib/apps/pivoting/pivot.h	/^    bool findSphere(Point3f &p0, Point3f &p1, Point3f &p2, Point3f &center) {$/;"	f	class:vcg::tri::Pivot
findStringListAttribute	vcglib/wrap/dae/util_dae.h	/^		inline static int findStringListAttribute(QStringList& list,const QDomNode node,const QDomNode poly,const QDomDocument startpoint,const char* token)$/;"	f	class:vcg::tri::io::UtilDAE
find_doublet_hedges_quad	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static vector<HEdgePointer> find_doublet_hedges_quad(FacePointer fp)$/;"	f	class:vcg::tri::HalfEdgeTopology
finish	vcglib/wrap/gcache/controller.h	/^  void finish() {$/;"	f	class:vcg::Controller
finished	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  inline XprType& finished() { return m_xpr; }$/;"	f	struct:Eigen::CommaInitializer
finished	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool finished(const MatrixBase<VectorType> &v)$/;"	f	class:Eigen::IterationController
finished	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool finished(double nr)$/;"	f	class:Eigen::IterationController
first	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket first;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket
first	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  VectorType first;$/;"	m	struct:Eigen::internal::vector_int_pair
first	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool first() { return m_nit == 0; }$/;"	f	class:Eigen::IterationController
firstChildId	vcglib/vcg/space/index/kdtree/kdtree.h	/^				unsigned int firstChildId:24;$/;"	m	struct:KdTree::Node::__anon507::__anon508
first_aligned	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^static inline typename Derived::Index first_aligned(const Derived& m)$/;"	f	namespace:Eigen::internal
first_aligned	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^static inline Index first_aligned(const Scalar* array, Index size)$/;"	f	namespace:Eigen::internal
first_aligned_impl	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl$/;"	s	namespace:Eigen::internal
first_aligned_impl	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl<Derived, false>$/;"	s	namespace:Eigen::internal
first_coord_kept	vcglib/wrap/gui/trackmode.h	/^  int first_coord_kept;$/;"	m	class:vcg::AreaMode
first_nonopt	vcglib/wrap/system/getopt.cpp	/^static int first_nonopt;$/;"	v	file:
fit	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^        static QuadricLocal fit(std::vector<CoordType> &VV, bool svdRes, bool detCheck)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::QuadricLocal
fit	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static Quadric fit(std::vector<CoordType> VV)$/;"	f	class:vcg::tri::UpdateCurvatureFitting::Quadric
fit	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        static Bicubic fit(std::vector<CoordType> VV)$/;"	f	class:vcg::tri::Fitmaps::Bicubic
fitBicubicPoints	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    static bool fitBicubicPoints(VertexType* v, std::vector<CoordType>& ref, Bicubic& ret, std::vector<CoordType>& points, std::vector<VertexType*>& ring)$/;"	f	class:vcg::tri::Fitmaps
fitHyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/LeastSquares.h	/^void fitHyperplane(int numPoints,$/;"	f	namespace:Eigen
fitQuadric	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static Quadric fitQuadric(VertexTypeP v, std::vector<CoordType>& ref)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
fitQuadricLocal	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static void fitQuadricLocal (VertexType *v, std::vector<CoordType> ref, std::vector<VertexType*> &vv, QuadricLocal *q)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
fits_in_bits	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool mpreal::fits_in_bits(double x, int n)$/;"	f	class:mpfr::mpreal
fittingAdjNum	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    int fittingAdjNum; \/\/\/ number of adjacent nodes used for computing the fitting plane$/;"	m	struct:vcg::tri::PointCloudNormal::Param
fix_selected	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    bool use_direction_field,fix_selected,correct_fixed;$/;"	m	class:vcg::tri::PoissonSolver
fixedTimestepMode	vcglib/wrap/gui/trackball.h	/^	bool fixedTimestepMode; \/\/ if true, animations occurs at fixed time steps$/;"	m	class:vcg::Trackball
fjac	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    JacobianType fjac;$/;"	m	class:Eigen::HybridNonLinearSolver
fjac	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    JacobianType fjac;$/;"	m	class:Eigen::LevenbergMarquardt
flag	vcglib/wrap/system/getopt.h	/^  int *flag;$/;"	m	struct:option
flag_t	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef unsigned int flag_t;           \/* The type of various bit flag sets *\/$/;"	t	file:
flagged	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^DenseBase<Derived>::flagged() const$/;"	f	class:Eigen::DenseBase
flags	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  int flags;$/;"	m	struct:Eigen::IOFormat
flags	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    int flags() const {$/;"	f	class:Eigen::SkylineInplaceLU
flags	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^					unsigned int flags;$/;"	m	union:vcg::AABBBinaryTree::AABBBinaryTreeNode::SharedDataUnion
flags	vcglib/wrap/gl/shaders.h	/^	unsigned int flags;$/;"	m	class:Shader
flags	vcglib/wrap/io_tetramesh/import_ply.h	/^	int flags;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
flags	vcglib/wrap/io_tetramesh/import_ply.h	/^	int flags;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_VertAux
flags	vcglib/wrap/io_trimesh/import_ply.h	/^	int flags;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
flags	vcglib/wrap/io_trimesh/import_ply.h	/^	int flags;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
flags	vcglib/wrap/system/multithreading/thread.h	/^            volatile unsigned int flags;$/;"	m	class:mt::thread
flipE	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::flipE( ){$/;"	f	class:GLWidget
flipF	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::flipF( ){$/;"	f	class:GLWidget
flipFaces	vcglib/wrap/io_trimesh/import_gts.h	/^					bool flipFaces;$/;"	m	struct:vcg::tri::io::ImporterGTS::Options
flipV	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::flipV( ){$/;"	f	class:GLWidget
flip_edges	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static int flip_edges(MeshType &m)$/;"	f	class:vcg::tri::HalfedgeQuadClean
flip_edges	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static void flip_edges(MeshType &m, vector<HEdgePointer> &hedges, set<FacePointer> &faces)$/;"	f	class:vcg::tri::HalfedgeQuadClean
flipfaces	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  bool          flipfaces;			\/\/ flip all faces$/;"	v
flipfaces	vcglib/wrap/io_trimesh/import_ptx.h	/^			bool flipfaces;$/;"	m	class:vcg::tri::io::ImporterPTX::Info
floor	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal floor(const mpreal& v)$/;"	f	namespace:mpfr
floor_log2	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct floor_log2 {};$/;"	s	namespace:Eigen::internal
floor_log2	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_bogus>$/;"	s	namespace:Eigen::internal
floor_log2	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_down>$/;"	s	namespace:Eigen::internal
floor_log2	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_up>$/;"	s	namespace:Eigen::internal
floor_log2	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_terminate>$/;"	s	namespace:Eigen::internal
floor_log2_bogus	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  floor_log2_bogus$/;"	e	enum:Eigen::internal::__anon176
floor_log2_move_down	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  floor_log2_move_down,$/;"	e	enum:Eigen::internal::__anon176
floor_log2_move_up	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  floor_log2_move_up,$/;"	e	enum:Eigen::internal::__anon176
floor_log2_selector	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^template<unsigned int n, int lower, int upper> struct floor_log2_selector$/;"	s	namespace:Eigen::internal
floor_log2_terminate	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  floor_log2_terminate,$/;"	e	enum:Eigen::internal::__anon176
flush	vcglib/wrap/gcache/cache.h	/^    template <class FUNCTOR> void flush(FUNCTOR functor) {$/;"	f	class:vcg::Cache
flush	vcglib/wrap/gcache/cache.h	/^    void flush() {$/;"	f	class:vcg::Cache
flush	vcglib/wrap/gcache/controller.h	/^  void flush() {$/;"	f	class:vcg::Controller
flush	vcglib/wrap/gcache/provider.h	/^  template <class FUNCTOR> void flush(FUNCTOR functor) {$/;"	f	class:vcg::Provider
fm	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#undef fm$/;"	d	file:
fma	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^const mpreal fma (const mpreal& v1, const mpreal& v2, const mpreal& v3, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
fmax	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal fmax(const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
fmin	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal fmin(const mpreal& x, const mpreal& y,  mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
fmod	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal fmod (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
fms	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^const mpreal fms (const mpreal& v1, const mpreal& v2, const mpreal& v3, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
fn	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int vn,fn;$/;"	m	struct:MeshInfo	file:
fn	vcglib/vcg/complex/algorithms/closest.h	/^            VDistFunct fn;$/;"	m	class:vcg::tri::ClosestVertexIterator
fn	vcglib/vcg/complex/base.h	/^    int fn;$/;"	m	class:vcg::tri::TriMesh
fnorm	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar fnorm;$/;"	m	class:Eigen::HybridNonLinearSolver
fnorm	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar fnorm, gnorm;$/;"	m	class:Eigen::LevenbergMarquardt
fnorm	vcglib/wrap/minpack/minpack.h	/^	double fnorm; 		\/\/ norm of the residue vector fvec.$/;"	m	struct:LMDiff::__anon525
fnorm1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar pnorm, xnorm, fnorm1;$/;"	m	class:Eigen::HybridNonLinearSolver
fnorm1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
focal	vcglib/wrap/io_trimesh/import_ply.h	/^	float focal;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
focus	vcglib/wrap/mt/mt.h	/^  Point3f focus;$/;"	m	class:vcg::DiracPolicy
font	vcglib/wrap/gui/coordinateframe.h	/^  QFont font;$/;"	m	class:vcg::CoordinateFrame
fontSize	vcglib/wrap/qt/Outline2ToQImage.h	/^      int fontSize;$/;"	m	class:Outline2Dumper::Param
foo	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^EIGEN_DONT_INLINE Scalar foo(const Scalar& x, const Scalar& y)$/;"	f
foo	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^EIGEN_DONT_INLINE typename Vector::Scalar foo(const Vector& p)$/;"	f
foo	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^EIGEN_DONT_INLINE typename Vector::Scalar foo(const Vector& p)$/;"	f
footprint	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t     footprint;$/;"	m	struct:malloc_state	file:
forceAlignedAccess	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess() const$/;"	f	class:Eigen::MatrixBase
forceAlignedAccess	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess()$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf() const$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf()$/;"	f	class:Eigen::MatrixBase
fordblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MALLINFO_FIELD_TYPE fordblks; \/* total free space *\/$/;"	m	struct:mallinfo	file:
fordblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^  MALLINFO_FIELD_TYPE fordblks; \/* total free space *\/$/;"	m	struct:mallinfo
format	vcglib/eigenlib/Eigen/src/Core/IO.h	/^DenseBase<Derived>::format(const IOFormat& fmt) const$/;"	f	class:Eigen::DenseBase
format	vcglib/wrap/gl/fbo.h	/^	GLenum format;$/;"	m	class:BufferRenderTarget
format	vcglib/wrap/gl/fbo.h	/^	GLenum format;$/;"	m	class:Texture
format	vcglib/wrap/glw/renderable.h	/^		GLenum format(void) const$/;"	f	class:glw::Renderable
format	vcglib/wrap/glw/renderable.h	/^		GLenum format(void) const$/;"	f	class:glw::SafeRenderable
format	vcglib/wrap/glw/renderable.h	/^		GLenum format;$/;"	m	class:glw::RenderableArguments
format	vcglib/wrap/ply/plylib.h	/^	int    format;				\/\/ Formato del file (vedi enum )$/;"	m	class:vcg::ply::PlyFile
format	vcglib/wrap/ply/plylib.h	/^	int format;					\/\/ duplicazione del formato$/;"	m	class:vcg::ply::PropDescriptor
formatDesc	vcglib/wrap/system/qgetopt.cpp	/^QString GetOpt::formatDesc(QString desc, int len) {$/;"	f	class:GetOpt
fortran_to_c_numbering	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void fortran_to_c_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal
forward_jacobian	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^template<typename Func> void forward_jacobian(const Func& f)$/;"	f
fout	vcglib/wrap/bmt/bmt.h	/^  FILE *fout;$/;"	m	class:vcg::BmtBuilder
fp	vcglib/vcg/complex/algorithms/clean.h	/^                      EdgePointer fp;$/;"	m	class:vcg::tri::Clean::SortedPair
fp	vcglib/vcg/complex/algorithms/clean.h	/^                FacePointer fp;$/;"	m	class:vcg::tri::Clean::SortedTriple
fp	vcglib/wrap/bmt/bmt.h	/^  FILE *fp;$/;"	m	class:vcg::Bmt
frac	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal frac (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
fragmentOutputs	vcglib/wrap/glw/program.h	/^		FragmentOutputBinding      fragmentOutputs;$/;"	m	class:glw::ProgramArguments
frags	vcglib/wrap/mt/mt.h	/^    std::vector<Frag> frags;    $/;"	m	struct:vcg::MT::Node
frameBuffer	vcglib/wrap/gl/fbo.h	/^	FrameBuffer * frameBuffer;$/;"	m	class:RenderTarget
frexp	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal frexp(const mpreal& v, mp_exp_t* exp)$/;"	f	namespace:mpfr
fromPositionOrientationScale	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform
fromPositionOrientationScale	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform
fromRotationMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D
fromRotationMatrix	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis
fromRotationMatrix	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D
frommap	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  int			frommap;			\/\/ skip all maps BEFORE this index$/;"	v
front	vcglib/apps/pivoting/pivot.h	/^    std::list<Hinge> front;   $/;"	m	class:vcg::tri::Pivot
front	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  std::list<FrontEdge> front;$/;"	m	class:vcg::tri::AdvancingFront
frustum	vcglib/wrap/mt/mt.h	/^  Frustumf frustum;$/;"	m	class:vcg::FrustumPolicy
fsHandle	vcglib/vcg/complex/algorithms/update/selection.h	/^  typedef typename ComputeMeshType::template PerFaceAttributeHandle< bool >   fsHandle;$/;"	t	class:vcg::tri::SelectionStack
fsV	vcglib/vcg/complex/algorithms/update/selection.h	/^  std::vector<fsHandle> fsV;$/;"	m	class:vcg::tri::SelectionStack
fshd	vcglib/wrap/gl/shaders.h	/^	FragmentShader fshd;$/;"	m	class:ProgramVF
fsmblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MALLINFO_FIELD_TYPE fsmblks;  \/* always 0 *\/$/;"	m	struct:mallinfo	file:
fsmblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^  MALLINFO_FIELD_TYPE fsmblks;  \/* always 0 *\/$/;"	m	struct:mallinfo
ftmp	vcglib/wrap/bmt/bmt.h	/^  FILE *ftmp;$/;"	m	class:vcg::BmtBuilder
ftol	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Scalar ftol;$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
ftol	vcglib/wrap/minpack/minpack.h	/^	double ftol; 		\/\/ relative error desired in the sum of squares.$/;"	m	struct:LMDiff::__anon525
fullLog	vcglib/wrap/glw/program.h	/^		const std::string & fullLog(void) const$/;"	f	class:glw::Program
fullLog	vcglib/wrap/glw/program.h	/^		const std::string & fullLog(void) const$/;"	f	class:glw::SafeProgram
fullPivHouseholderQr	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^MatrixBase<Derived>::fullPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase
fullPivLu	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^MatrixBase<Derived>::fullPivLu() const$/;"	f	class:Eigen::MatrixBase
functor	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseBinaryOp
functor	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseNullaryOp
functor	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryOp
functor	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    const ViewOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryView
functor	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& functor() const $/;"	f	class:Eigen::SelfCwiseBinaryOp
functor	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FunctorType &functor;$/;"	m	class:Eigen::HybridNonLinearSolver
functor	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FunctorType &functor;$/;"	m	class:Eigen::LevenbergMarquardt
functor_allows_mixing_real_and_complex	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_allows_mixing_real_and_complex { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
functor_allows_mixing_real_and_complex	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_allows_mixing_real_and_complex	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_has_linear_access	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_has_linear_access	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_abs2_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_abs_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_acos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_add_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_asin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_binary_pow_op<Scalar,OtherScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cast_op<Scalar,NewType> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_conj_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_conjugate_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_constant_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cube_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_difference_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_exp_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_hypot_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_identity_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_imag_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_imag_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_inverse_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_log_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_max_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_min_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_multiple2_op<Scalar1,Scalar2> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_multiple_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_opposite_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_pow_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient1_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_real_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_real_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sqrt_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_square_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sum_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_tan_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binary_compose<T0,T1,T2> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binder1st<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::binder2nd<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::divides<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::greater<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::greater_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::less<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::less_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_and<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_not<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_or<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::minus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::multiplies<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::not_equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::plus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::project1st<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::project2nd<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::select1st<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::select2nd<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::unary_compose<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct functor_traits<std::unary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct functor_traits< linspaced_op<Scalar,RandomAccess> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_and_op> {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_or_op> {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Random.h	/^struct functor_traits<scalar_random_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^struct functor_traits<max_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^struct functor_traits<min_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
fvButton	vcglib/apps/sample/trimesh_pos_demo/window.h	/^		QPushButton * fvButton,*feButton,*ffButton,*neButton,*ldButton,*nbButton,*vfButton;$/;"	m	class:Window
fvec	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::HybridNonLinearSolver
fvec	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::LevenbergMarquardt
fwd	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd( Complex * dst,const Complex *src,int nfft)$/;"	f	struct:Eigen::internal::fftw_impl
fwd	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd( Complex * dst,const Scalar * src,int nfft) $/;"	f	struct:Eigen::internal::fftw_impl
fwd	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd(complex_type * dst,complex_type * src,int nfft) {$/;"	f	struct:Eigen::internal::fftw_plan
fwd	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd(complex_type * dst,scalar_type * src,int nfft) {$/;"	f	struct:Eigen::internal::fftw_plan
fwd	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void fwd( Complex * dst,const Complex *src,int nfft)$/;"	f	struct:Eigen::internal::kissfft_impl
fwd	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void fwd( Complex * dst,const Scalar * src,int nfft) $/;"	f	struct:Eigen::internal::kissfft_impl
fwd2	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd2( complex_type * dst,complex_type * src,int n0,int n1) {$/;"	f	struct:Eigen::internal::fftw_plan
fwd2	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void fwd2(Complex * dst, const Complex * src, int n0,int n1)$/;"	f	struct:Eigen::internal::fftw_impl
fwd2	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void fwd2( Complex * dst,const Complex *src,int n0,int n1)$/;"	f	struct:Eigen::internal::kissfft_impl
fwd_inv	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^void fwd_inv(size_t nfft)$/;"	f
fwrite_mem	vcglib/wrap/io_trimesh/export_vmi.h	/^        static int fwrite_mem(const void *src , size_t size, size_t count ){ memcpy(&Out_mem()[pos()],src,size*count); pos() += size * count;return size * count; }$/;"	f	class:vcg::tri::io::ExporterVMI
fwrite_sim	vcglib/wrap/io_trimesh/export_vmi.h	/^        static int fwrite_sim(const void * , size_t size, size_t count){ pos() += size * count;return size * count; }$/;"	f	class:vcg::tri::io::ExporterVMI
g	vcglib/vcg/complex/algorithms/smooth.h	/^    unsigned int g;$/;"	m	class:vcg::tri::Smooth::ColorSmoothInfo
g	vcglib/vcg/complex/algorithms/update/color.h	/^    unsigned int g;$/;"	m	class:vcg::tri::UpdateColor::ColorAvgInfo
g	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& g() { return data[6];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
g	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char g;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
g	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char g;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_VertAux
g	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char g;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
g	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char g;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
gIndex	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^static AIndex gIndex;$/;"	v	file:
gM	vcglib/vcg/complex/algorithms/point_sampling.h	/^TriMeshGrid gM;$/;"	m	class:vcg::tri::SurfaceSampling::RRParam
gMesh	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^static AMesh gMesh;$/;"	v	file:
gS2	vcglib/apps/metro/sampling.h	/^    MetroMeshGrid   gS2;$/;"	m	class:vcg::Sampling
gamma	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal gamma (const mpreal& x, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
gamma	vcglib/vcg/space/colorspace.h	/^	static double gamma(RGBSpaces rgb_space)$/;"	f	class:vcg::ColorSpace
gamma_correction	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^float lopass=0,hipass=1,gamma_correction=1;$/;"	v
gatherNeighsSurface	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    static vector<VertexType*> gatherNeighsSurface(VertexType* vt, float sigma, MeshType& m)$/;"	f	class:vcg::tri::Fitmaps
gebp_kernel	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gebp_kernel$/;"	s	namespace:Eigen::internal
gebp_madd	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void gebp_madd(const CJ& cj, A& a, B& b, C& c, T& t)$/;"	f	namespace:Eigen::internal
gebp_madd_selector	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename A, typename B, typename C, typename T> struct gebp_madd_selector {$/;"	s	namespace:Eigen::internal
gebp_madd_selector	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename T> struct gebp_madd_selector<CJ,T,T,T,T> {$/;"	s	namespace:Eigen::internal
gebp_traits	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits$/;"	c	namespace:Eigen::internal
gebp_traits	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<RealScalar, std::complex<RealScalar>, false, _ConjRhs >$/;"	c	namespace:Eigen::internal
gebp_traits	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, RealScalar, _ConjLhs, false>$/;"	c	namespace:Eigen::internal
gebp_traits	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, std::complex<RealScalar>, _ConjLhs, _ConjRhs >$/;"	c	namespace:Eigen::internal
gemm_blocking_space	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex \/*rows*\/, DenseIndex \/*cols*\/, DenseIndex \/*depth*\/)$/;"	f	class:Eigen::internal::gemm_blocking_space
gemm_blocking_space	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex rows, DenseIndex cols, DenseIndex depth)$/;"	f	class:Eigen::internal::gemm_blocking_space
gemm_blocking_space	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, false>$/;"	c	namespace:Eigen::internal
gemm_blocking_space	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, true>$/;"	c	namespace:Eigen::internal
gemm_functor	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  gemm_functor(const Lhs& lhs, const Rhs& rhs, Dest& dest, Scalar actualAlpha,$/;"	f	struct:Eigen::internal::gemm_functor
gemm_functor	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct gemm_functor$/;"	s	namespace:Eigen::internal
gemm_pack_lhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_lhs$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, ColMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, RowMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemv_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct gemv_selector<OnTheLeft,StorageOrder,BlasCompatible>$/;"	s	namespace:Eigen::internal
gemv_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,false>$/;"	s	namespace:Eigen::internal
gemv_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,true>$/;"	s	namespace:Eigen::internal
gemv_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,false>$/;"	s	namespace:Eigen::internal
gemv_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,Dynamic,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,false>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,true>$/;"	s	namespace:Eigen::internal
general_det3_helper	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^inline const typename Derived::Scalar general_det3_helper$/;"	f	namespace:Eigen::internal
general_matrix_matrix_product	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_product	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_rankupdate	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^struct general_matrix_matrix_rankupdate :$/;"	s	namespace:Eigen::internal
general_matrix_matrix_triangular_product	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_triangular_product	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product_gemv	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^struct general_matrix_vector_product_gemv :$/;"	s	namespace:Eigen::internal
generate	vcglib/vcg/math/legendre.h	/^	void generate(ScalarType cos_theta, ScalarType sin_theta)$/;"	f	class:vcg::math::DynamicLegendre
generate	vcglib/vcg/math/random_generator.h	/^	unsigned int generate(unsigned int \/*limit*\/)$/;"	f	class:vcg::math::MarsenneTwisterRNG
generate	vcglib/vcg/math/random_generator.h	/^	unsigned int generate(unsigned int limit= 0xffffffffu)$/;"	f	class:vcg::math::SubtractiveRingRNG
generate01	vcglib/vcg/math/random_generator.h	/^	double generate01()$/;"	f	class:vcg::math::MarsenneTwisterRNG
generate01	vcglib/vcg/math/random_generator.h	/^	double generate01()$/;"	f	class:vcg::math::SubtractiveRingRNG
generate01closed	vcglib/vcg/math/random_generator.h	/^	double generate01closed()$/;"	f	class:vcg::math::MarsenneTwisterRNG
generate01closed	vcglib/vcg/math/random_generator.h	/^	double generate01closed()$/;"	f	class:vcg::math::SubtractiveRingRNG
generate01open	vcglib/vcg/math/random_generator.h	/^	double generate01open()$/;"	f	class:vcg::math::MarsenneTwisterRNG
generate01open	vcglib/vcg/math/random_generator.h	/^	double generate01open()$/;"	f	class:vcg::math::SubtractiveRingRNG
generateBarycentric	vcglib/vcg/math/random_generator.h	/^	void generateBarycentric(PointType &p){$/;"	f	class:vcg::math::MarsenneTwisterRNG
generateMipmap	vcglib/wrap/glw/texture2d.h	/^		void generateMipmap(GLenum target, GLint unit)$/;"	f	class:glw::Texture2D
generateMipmap	vcglib/wrap/glw/texture2d.h	/^		void generateMipmap(void)$/;"	f	class:glw::BoundTexture2D
generateMipmap	vcglib/wrap/glw/texturecube.h	/^		void generateMipmap(GLenum target, GLint unit)$/;"	f	class:glw::TextureCube
generateMipmap	vcglib/wrap/glw/texturecube.h	/^		void generateMipmap(void)$/;"	f	class:glw::BoundTextureCube
generatePointsVector	vcglib/wrap/dae/poly_triangulator.h	/^		void generatePointsVector(std::vector<std::vector<vcg::Point3f> >& v)$/;"	f	class:vcg::tri::io::PolygonalMesh
generateRange	vcglib/vcg/math/random_generator.h	/^	virtual double generateRange(double minV, double maxV) { return minV+(maxV-minV)*generate01(); }$/;"	f	class:vcg::math::RandomGenerator
generateTestMatrix	vcglib/eigenlib/unsupported/test/matrix_square_root.cpp	/^struct generateTestMatrix<MatrixType,0>$/;"	s	file:
generateTestMatrix	vcglib/eigenlib/unsupported/test/matrix_square_root.cpp	/^struct generateTestMatrix<MatrixType,1>$/;"	s	file:
generic_aligned_realloc	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void* generic_aligned_realloc(void* ptr, size_t size, size_t old_size)$/;"	f	namespace:Eigen::internal
geodesicDistanceFlag	vcglib/vcg/complex/algorithms/point_sampling.h	/^  bool geodesicDistanceFlag;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
geodesicRelaxFlag	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  bool geodesicRelaxFlag;$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
geometryStage	vcglib/wrap/glw/program.h	/^		GeometryStage              geometryStage;$/;"	m	class:glw::ProgramArguments
getAverageNormal	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static void getAverageNormal (VertexType *vp, std::vector<VertexType*> &vv, CoordType *ppn)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
getBestPrecomputedMontecarloSample	vcglib/vcg/complex/algorithms/point_sampling.h	/^static VertexPointer getBestPrecomputedMontecarloSample(Point3i &cell, MontecarloSHT & samplepool, ScalarType diskRadius, const PoissonDiskParam &pp)$/;"	f	class:vcg::tri::SurfaceSampling
getBottom	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector<int>& getBottom(int i) { return bottom[i]; }$/;"	f	class:vcg::RasterizedOutline2
getBoundHole	vcglib/vcg/complex/algorithms/hole.h	/^    static void getBoundHole (PosType sp,std::vector<PosType >&ret)$/;"	f	class:vcg::tri::Hole
getBoxFiltered	vcglib/img/img_filter.h	/^inline Image<Channels,ScalarType,Safe> getBoxFiltered(const Image<Channels,ScalarType,Safe> &image,int radius)$/;"	f	namespace:img
getChildren	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  EIGEN_STRONG_INLINE void getChildren(Index index, VolumeIterator &outVBegin, VolumeIterator &outVEnd,$/;"	f	class:Eigen::KdBVH
getClosestFaceRay	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            static FacePointer getClosestFaceRay(TriMeshType &m, GRID &grid, CoordType P, CoordType raydir, CoordType* closest, ScalarType* minDist)$/;"	f	class:vcg::tri::FitmapsCollapse
getColor	vcglib/wrap/io_trimesh/import_fbx.h	/^			ColorType getColor() const {return color;}$/;"	f	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
getColorspace	vcglib/img/img_attributes.h	/^  void getColorspace(COLORSPACE &ret_colorspace) const$/;"	f	class:img::ImgAttributes
getConvolved	vcglib/img/img_filter.h	/^inline Image<Channels,ScalarType,Safe> getConvolved(const Image<Channels,ScalarType,Safe> &image,const ScalarType *matrix,int matrix_width,int matrix_height)$/;"	f	namespace:img
getCostX	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int getCostX(RasterizedOutline2& poly, Point2i pos, int rast_i) {$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
getCostY	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int getCostY(RasterizedOutline2& poly, Point2i pos, int rast_i) {$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
getDeltaX	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector<int>& getDeltaX(int i) { return deltaX[i]; }$/;"	f	class:vcg::RasterizedOutline2
getDeltaY	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector<int>& getDeltaY(int i) { return deltaY[i]; }$/;"	f	class:vcg::RasterizedOutline2
getDeltaY	vcglib/wrap/gui/trackutils.h	/^float getDeltaY(Trackball * tb, Point3f new_point)$/;"	f	namespace:vcg::trackutils
getDiscreteArea	vcglib/vcg/space/rasterized_outline2_packer.h	/^    int& getDiscreteArea(int i) { return discreteAreas[i]; }$/;"	f	class:vcg::RasterizedOutline2
getDoGFiltered	vcglib/img/img_filter.h	/^inline Image<Channels,ScalarType,Safe> getDoGFiltered(const Image<Channels,ScalarType,Safe> &image,int radius1,int radius2)$/;"	f	namespace:img
getFaces	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static set<FacePointer> getFaces(VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
getGamma	vcglib/img/img_attributes.h	/^  void getGamma(OtherScalarType &ret_gamma) const$/;"	f	class:img::ImgAttributes
getGaussianSmoothed	vcglib/img/img_filter.h	/^inline Image<Channels,ScalarType,Safe> getGaussianSmoothed(const Image<Channels,ScalarType,Safe> &image,const int radius)$/;"	f	namespace:img
getGlobalMatrix	vcglib/wrap/io_trimesh/import_fbx.h	/^	static KFbxXMatrix getGlobalMatrix(KFbxNode* pNode, const KTime& pTime, KFbxPose* pPose, KFbxXMatrix* pParentGlobalPosition = NULL)$/;"	f	class:ImporterFBX
getGrids	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector< std::vector<int> >& getGrids(int rast_i)  { return grids[rast_i]; }$/;"	f	class:vcg::RasterizedOutline2
getHEdges	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static vector<HEdgePointer> getHEdges(FacePointer fp, HEdgePointer starting_he = NULL)$/;"	f	class:vcg::tri::HalfEdgeTopology
getImage	vcglib/wrap/glw/texture2d.h	/^		void getImage(GLenum target, GLint unit, GLint level, GLenum dataFormat, GLenum dataType, void * data)$/;"	f	class:glw::Texture2D
getImage	vcglib/wrap/glw/texture2d.h	/^		void getImage(GLint level, GLenum dataFormat, GLenum dataType, void * data)$/;"	f	class:glw::BoundTexture2D
getImage	vcglib/wrap/glw/texturecube.h	/^		void getImage(GLenum face, GLint level, GLenum dataFormat, GLenum dataType, void * data)$/;"	f	class:glw::BoundTextureCube
getImage	vcglib/wrap/glw/texturecube.h	/^		void getImage(GLenum target, GLint unit, GLint level, GLenum dataFormat, GLenum dataType, void * data)$/;"	f	class:glw::TextureCube
getInCellUpdated	vcglib/vcg/space/index/spatial_hashing.h	/^		void getInCellUpdated(vcg::Point3i cell,std::vector<ObjPtr> &elems)$/;"	f	class:vcg::DynamicSpatialHashTable
getInSphere	vcglib/apps/pivoting/pivot.h	/^    unsigned int getInSphere(vcg::Point3f &p, float distance, $/;"	f	class:vcg::tri::Pivot
getIndex	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	inline Index  getIndex(int i) const { return mElements[i].index; }$/;"	f	class:HeapMaxPriorityQueue
getInfoLog	vcglib/wrap/glw/program.h	/^		static std::string getInfoLog(GLuint Program)$/;"	f	class:glw::Program
getInfoLog	vcglib/wrap/glw/shader.h	/^		static std::string getInfoLog(GLuint Shader)$/;"	f	class:glw::Shader
getL	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getL	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits
getL	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits
getL	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits
getL	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::traits
getLaplacianFiltered	vcglib/img/img_filter.h	/^inline Image<Channels,ScalarType,Safe> getLaplacianFiltered(const Image<Channels,ScalarType,Safe> &image)$/;"	f	namespace:img
getLeft	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector<int>& getLeft(int i) { return left[i]; }$/;"	f	class:vcg::RasterizedOutline2
getLoGFiltered	vcglib/img/img_filter.h	/^inline Image<Channels,ScalarType,Safe> getLoGFiltered(const Image<Channels,ScalarType,Safe> &image,int radius)$/;"	f	namespace:img
getMarketHeader	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^inline bool getMarketHeader(const std::string& filename, int& sym, bool& iscomplex, bool& isvector)$/;"	f	namespace:Eigen
getMaterial	vcglib/wrap/io_trimesh/import_fbx.h	/^		MaterialInfo* getMaterial(const char* attr)$/;"	f	class:ImporterFBX::VCGMaterialBridge
getMatrix	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT
getMatrix	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT
getMatrix	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU
getMaxMaskRadius	vcglib/wrap/qt/Outline2ToQImage.cpp	/^int Outline2Dumper::getMaxMaskRadius(int x,int y,QImage &img)$/;"	f	class:Outline2Dumper
getMeanCurvature	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    float getMeanCurvature(VertexType* vp)$/;"	f	class:vcg::tri::Fitmaps
getMedianFiltered	vcglib/img/img_filter.h	/^inline Image<Channels,ScalarType,Safe> getMedianFiltered(const Image<Channels,ScalarType,Safe> &image,int radius)$/;"	f	namespace:img
getNeighbor	vcglib/vcg/space/index/kdtree/kdtree.h	/^	inline const VectorType& getNeighbor(int i) { return mPoints[ mNeighborQueue.getIndex(i) ]; }$/;"	f	class:KdTree
getNeighborId	vcglib/vcg/space/index/kdtree/kdtree.h	/^	inline unsigned int getNeighborId(int i) { return mIndices[mNeighborQueue.getIndex(i)]; }$/;"	f	class:KdTree
getNeighborSquaredDistance	vcglib/vcg/space/index/kdtree/kdtree.h	/^	inline float getNeighborSquaredDistance(int i) { return mNeighborQueue.getWeight(i); }$/;"	f	class:KdTree
getNofElements	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	inline int getNofElements() const { return mCount; }$/;"	f	class:HeapMaxPriorityQueue
getNofFoundNeighbors	vcglib/vcg/space/index/kdtree/kdtree.h	/^	inline int getNofFoundNeighbors(void) { return mNeighborQueue.getNofElements(); }$/;"	f	class:KdTree
getNormalized	vcglib/img/img_filter.h	/^inline Image<Channels,ScalarType,Safe> getNormalized(const Image<Channels,ScalarType,Safe> &image)$/;"	f	namespace:img
getPadeDegree	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^int MatrixLogarithmAtomic<MatrixType>::getPadeDegree(double normTminusI)$/;"	f	class:Eigen::MatrixLogarithmAtomic
getPadeDegree	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^int MatrixLogarithmAtomic<MatrixType>::getPadeDegree(float normTminusI)$/;"	f	class:Eigen::MatrixLogarithmAtomic
getPadeDegree	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^int MatrixLogarithmAtomic<MatrixType>::getPadeDegree(long double normTminusI)$/;"	f	class:Eigen::MatrixLogarithmAtomic
getPixel	vcglib/img/img_image.h	/^  inline void getPixel(int x, int y, ScalarType (& ret_pixel)[Channels]) const$/;"	f	class:img::Image
getPixelAsClamped	vcglib/img/img_image.h	/^  inline void getPixelAsClamped(int x, int y, ScalarType (& ret_pixel)[Channels]) const$/;"	f	class:img::Image
getPoints	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector<Point2f>&  getPoints()           { return points; }$/;"	f	class:vcg::RasterizedOutline2
getPointsConst	vcglib/vcg/space/rasterized_outline2_packer.h	/^    const std::vector<Point2f>&  getPointsConst() const{ return points; }$/;"	f	class:vcg::RasterizedOutline2
getPolyBB	vcglib/vcg/space/outline2_packer.h	/^  static Box2f getPolyBB(const std::vector<Point2x> &poly)$/;"	f	class:vcg::PolyPacker
getPolyOOBB	vcglib/vcg/space/outline2_packer.h	/^  static Box2f getPolyOOBB(const std::vector<Point2x> &poly, float &rot)$/;"	f	class:vcg::PolyPacker
getPrecision	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int mpreal::getPrecision() const$/;"	f	class:mpfr::mpreal
getPriority	vcglib/wrap/gcache/token.h	/^    Priority getPriority() {$/;"	f	class:vcg::Token
getRHSCmplx	vcglib/wrap/miq/core/sparsesystemdata.h	/^  Cmplx getRHSCmplx(unsigned int i) { $/;"	f	class:SparseSystemData
getRHSReal	vcglib/wrap/miq/core/sparsesystemdata.h	/^  double getRHSReal(unsigned int i) { $/;"	f	class:SparseSystemData
getRange	vcglib/img/img_attributes.h	/^  void getRange(OtherScalarType &ret_range_min, OtherScalarType &ret_range_max) const$/;"	f	class:img::ImgAttributes
getReferenceWhite	vcglib/img/img_attributes.h	/^  void getReferenceWhite(OtherScalarType &ret_reference_white_x, OtherScalarType &ret_reference_white_y, OtherScalarType &ret_reference_white_z) const$/;"	f	class:img::ImgAttributes
getRootIndex	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  inline Index getRootIndex() const { return (int)boxes.size() - 1; }$/;"	f	class:Eigen::KdBVH
getSampleFromCell	vcglib/vcg/complex/algorithms/point_sampling.h	/^static VertexPointer getSampleFromCell(Point3i &cell, MontecarloSHT & samplepool)$/;"	f	class:vcg::tri::SurfaceSampling
getSecondRing	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static std::set<CoordType> getSecondRing(VertexTypeP v)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
getStatus	vcglib/wrap/glw/framebuffer.h	/^		GLenum getStatus(void) const$/;"	f	class:glw::BoundFramebuffer
getSubData	vcglib/wrap/glw/buffer.h	/^		void getSubData(GLenum target, GLint unit, GLintptr offset, GLsizeiptr size, GLvoid * data)$/;"	f	class:glw::Buffer
getSubData	vcglib/wrap/glw/buffer.h	/^		void getSubData(GLintptr offset, GLsizeiptr size, GLvoid * data)$/;"	f	class:glw::BoundBuffer
getSurfaceMaterial	vcglib/wrap/io_trimesh/import_fbx.h	/^			KFbxSurfaceMaterial* getSurfaceMaterial() const {return surfMat;}$/;"	f	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
getTextureFileObject	vcglib/wrap/io_trimesh/import_fbx.h	/^			KFbxFileTexture* getTextureFileObject (const char* attributeName) $/;"	f	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
getTextureIndex	vcglib/wrap/io_trimesh/import_fbx.h	/^			int getTextureIndex() const {return textindex;}$/;"	f	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
getTopWeight	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	inline Weight getTopWeight() const { return mElements[0].weight; }$/;"	f	class:HeapMaxPriorityQueue
getTransfMatrixFromNode	vcglib/wrap/io_trimesh/import_dae.h	/^static Matrix44f getTransfMatrixFromNode(const QDomElement parentNode)$/;"	f	class:vcg::tri::io::ImporterDAE
getU	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getU	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits
getU	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits
getU	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits
getU	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::traits
getUniformLocation	vcglib/wrap/glw/program.h	/^		GLint getUniformLocation(const std::string & name) const$/;"	f	class:glw::Program
getUnsharpMasked	vcglib/img/img_filter.h	/^inline Image<Channels,ScalarType,Safe> getUnsharpMasked(const Image<Channels,ScalarType,Safe> &image,int radius,float factor)$/;"	f	namespace:img
getValue	vcglib/img/img_image.h	/^  inline ScalarType getValue(int x, int y, int channel) const$/;"	f	class:img::Image
getValueAsClamped	vcglib/img/img_image.h	/^  inline float getValueAsClamped(int x, int y, int channel) const$/;"	f	class:img::Image
getVertices	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static vector<VertexPointer> getVertices(FacePointer fp, HEdgePointer starting_he = NULL)$/;"	f	class:vcg::tri::HalfEdgeTopology
getVertices	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static vector<VertexPointer> getVertices(VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
getVolume	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  inline const Volume &getVolume(Index index) const$/;"	f	class:Eigen::KdBVH
getWeight	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	inline Weight getWeight(int i) const { return mElements[i].weight; }$/;"	f	class:HeapMaxPriorityQueue
getXCmplx	vcglib/wrap/miq/core/sparsesystemdata.h	/^  Cmplx getXCmplx(unsigned int i) { $/;"	f	class:SparseSystemData
get_adjacent_faces	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static vector<FacePointer> get_adjacent_faces(FacePointer fp)$/;"	f	class:vcg::tri::HalfEdgeTopology
get_boxes_helper	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^struct get_boxes_helper {$/;"	s	namespace:Eigen::internal
get_boxes_helper	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^struct get_boxes_helper<ObjectList, VolumeList, int> {$/;"	s	namespace:Eigen::internal
get_color_attachment_format	vcglib/wrap/gl/gl_surface.h	/^		GLenum get_color_attachment_format(int attachment) const$/;"	f	class:vcg::gl_surface
get_color_pixels	vcglib/wrap/gl/gl_surface.h	/^		bool get_color_pixels(int attachment, GLenum format, GLenum type, void * pixels)$/;"	f	class:vcg::gl_surface
get_default_base	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int mpreal::get_default_base()$/;"	f	class:mpfr::mpreal
get_default_prec	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_prec_t mpreal::get_default_prec()$/;"	f	class:mpfr::mpreal
get_default_rnd	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_rnd_t mpreal::get_default_rnd()$/;"	f	class:mpfr::mpreal
get_depth_attachment_format	vcglib/wrap/gl/gl_surface.h	/^		GLenum get_depth_attachment_format(void) const$/;"	f	class:vcg::gl_surface
get_depth_pixels	vcglib/wrap/gl/gl_surface.h	/^		bool get_depth_pixels(GLenum format, GLenum type, void * pixels)$/;"	f	class:vcg::gl_surface
get_double_bits	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int mpreal::get_double_bits()$/;"	f	class:mpfr::mpreal
get_emax	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emax (void)$/;"	f	class:mpfr::mpreal
get_emax_max	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emax_max (void)$/;"	f	class:mpfr::mpreal
get_emax_min	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emax_min (void)$/;"	f	class:mpfr::mpreal
get_emin	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emin (void)$/;"	f	class:mpfr::mpreal
get_emin_max	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emin_max (void)$/;"	f	class:mpfr::mpreal
get_emin_min	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_emin_min (void)$/;"	f	class:mpfr::mpreal
get_exp	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_exp_t mpreal::get_exp ()$/;"	f	class:mpfr::mpreal
get_factor	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<typename From,typename To> struct get_factor {$/;"	s	namespace:Eigen::internal
get_factor	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {$/;"	s	namespace:Eigen::internal
get_foot	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define get_foot(/;"	d	file:
get_height	vcglib/wrap/gl/gl_surface.h	/^		int get_height(void) const$/;"	f	class:vcg::gl_surface
get_incident_faces	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static vector<FacePointer> get_incident_faces(VertexPointer vp, HEdgePointer starting_he = NULL)$/;"	f	class:vcg::tri::HalfEdgeTopology
get_incident_hedges	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static vector<HEdgePointer> get_incident_hedges(VertexPointer vp, HEdgePointer starting_he = NULL)$/;"	f	class:vcg::tri::HalfEdgeTopology
get_mstate_for	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define get_mstate_for(/;"	d	file:
get_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      PlanData & get_plan(int n0,int n1,bool inverse,void * dst,const void * src)$/;"	f	struct:Eigen::internal::fftw_impl
get_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      PlanData & get_plan(int nfft,bool inverse,void * dst,const void * src)$/;"	f	struct:Eigen::internal::fftw_impl
get_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    PlanData & get_plan(int nfft, bool inverse)$/;"	f	struct:Eigen::internal::kissfft_impl
get_position	vcglib/wrap/gl/glu_tesselator.h	/^        static inline void get_position(const vcg::Point2<scalar_type> & p, GLdouble * d)$/;"	f	class:vcg::glu_tesselator
get_position	vcglib/wrap/gl/glu_tesselator.h	/^        static inline void get_position(const vcg::Point3<scalar_type> & p, GLdouble * d)$/;"	f	class:vcg::glu_tesselator
get_prec	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mp_prec_t mpreal::get_prec() const$/;"	f	class:mpfr::mpreal
get_restart	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  int get_restart() { return m_restart; }$/;"	f	class:Eigen::GMRES
get_vertices	vcg_mesh.hpp	/^    void get_vertices(std::vector<Vert_t>& vertices)$/;"	f	class:vcg::MyMesh
get_width	vcglib/wrap/gl/gl_surface.h	/^		int get_width(void) const$/;"	f	class:vcg::gl_surface
getopt	vcglib/wrap/system/getopt.cpp	/^getopt (int argc, char *const *argv, const char *optstring)$/;"	f
getopt_long	vcglib/wrap/system/getopt.cpp	/^getopt_long (int argc, char *const *argv, const char *shortopts,$/;"	f
glArrow	vcglib/wrap/gl/addons.h	/^			static void glArrow(Point3f tail, Point3f head,float body_width,float head_lenght,$/;"	f	class:vcg::Add_Ons
glBoxClip	vcglib/wrap/gl/deprecated_space.h	/^inline void glBoxClip(const Box3<T>  & b)$/;"	f	namespace:vcg
glBoxClip	vcglib/wrap/gl/space.h	/^inline void glBoxClip(const Box3<T>  & b)$/;"	f	namespace:vcg
glBoxFlat	vcglib/wrap/gl/deprecated_space.h	/^inline void glBoxFlat(Box3<T> const & b)$/;"	f	namespace:vcg
glBoxFlat	vcglib/wrap/gl/space.h	/^inline void glBoxFlat(Box3<T> const & b)$/;"	f	namespace:vcg
glBoxWire	vcglib/wrap/gl/deprecated_space.h	/^   inline void glBoxWire(Box3<T> const & b)$/;"	f	namespace:vcg
glBoxWire	vcglib/wrap/gl/deprecated_space.h	/^   inline void glBoxWire(const Box2<T>  & b)$/;"	f	namespace:vcg
glBoxWire	vcglib/wrap/gl/space.h	/^   inline void glBoxWire(Box3<T> const & b)$/;"	f	namespace:vcg
glBoxWire	vcglib/wrap/gl/space.h	/^   inline void glBoxWire(const Box2<T>  & b)$/;"	f	namespace:vcg
glClearColor	vcglib/wrap/gl/deprecated_space.h	/^  inline void glClearColor(Color4b const &c) { ::glClearColor(float(c[0])\/255.0f,float(c[1])\/255.0f,float(c[2])\/255.0f,1.0f);}$/;"	f	namespace:vcg
glClearColor	vcglib/wrap/gl/deprecated_space.h	/^  inline void glClearColor(Color4d const &c) { ::glClearColor(float(c[0]),float(c[1]),float(c[2]),float(c[3])); }$/;"	f	namespace:vcg
glClearColor	vcglib/wrap/gl/deprecated_space.h	/^  inline void glClearColor(Color4f const &c) { ::glClearColor(c[0],c[1],c[2],c[3]); }$/;"	f	namespace:vcg
glClearColor	vcglib/wrap/gl/space.h	/^  inline void glClearColor(Color4b const &c) {	::glClearColor(float(c[0])\/255.0f,float(c[1])\/255.0f,float(c[2])\/255.0f,1.0f);}$/;"	f	namespace:vcg
glColor	vcglib/wrap/gl/deprecated_space.h	/^  inline void glColor(Color4b const & c)   { glColor4ubv(c.V());}$/;"	f	namespace:vcg
glColor	vcglib/wrap/gl/deprecated_space.h	/^  inline void glColor(Color4d const & c)   { glColor4dv (c.V());}$/;"	f	namespace:vcg
glColor	vcglib/wrap/gl/deprecated_space.h	/^  inline void glColor(Color4f const & c)   { glColor4fv (c.V());}$/;"	f	namespace:vcg
glColor	vcglib/wrap/gl/space.h	/^  inline void glColor(Color4b const & c)   { glColor4ubv(c.data());}$/;"	f	namespace:vcg
glCone	vcglib/wrap/gl/addons.h	/^			static void glCone(Point3f tail, Point3f head,float width,int slice=10,bool useDisplList=true)$/;"	f	class:vcg::Add_Ons
glCylinder	vcglib/wrap/gl/addons.h	/^			static void glCylinder(Point3f tail, Point3f head,float width,int slice=10,bool useDisplList=true)$/;"	f	class:vcg::Add_Ons
glDiamond	vcglib/wrap/gl/addons.h	/^			static void glDiamond (Point3f Center, float size,bool useDisplList=true)$/;"	f	class:vcg::Add_Ons
glGetDirectv	vcglib/wrap/gl/deprecated_math.h	/^inline void glGetDirectv(const GLenum  pname, Matrix44f  & m){$/;"	f	namespace:vcg
glGetDirecv	vcglib/wrap/gl/deprecated_math.h	/^inline void glGetDirecv(const GLenum  pname, Matrix44d  & m){$/;"	f	namespace:vcg
glGetv	vcglib/wrap/gl/deprecated_math.h	/^inline void glGetv(const GLenum  pname, Matrix44d  & m){$/;"	f	namespace:vcg
glGetv	vcglib/wrap/gl/deprecated_math.h	/^inline void glGetv(const GLenum  pname, Matrix44f  & m){$/;"	f	namespace:vcg
glGetv	vcglib/wrap/gl/math.h	/^inline void glGetv(const GLenum  pname, Eigen::Matrix<float,4,4>& matrix){$/;"	f	namespace:vcg
glGetv	vcglib/wrap/gl/math.h	/^inline void glGetv(const GLenum pname, Eigen::Matrix<double,4,4,Eigen::RowMajor>& matrix){$/;"	f	namespace:vcg
glGetv	vcglib/wrap/gl/math.h	/^inline void glGetv(const GLenum pname, Eigen::Matrix<double,4,4>& matrix){$/;"	f	namespace:vcg
glGetv	vcglib/wrap/gl/math.h	/^inline void glGetv(const GLenum pname, Eigen::Matrix<float,4,4,Eigen::RowMajor>& matrix){$/;"	f	namespace:vcg
glGetv	vcglib/wrap/gl/math.h	/^inline void glGetv(const GLenum pname, const Eigen::Transform<Scalar,3>& t)$/;"	f	namespace:vcg
glLabel	vcglib/wrap/qt/gl_label.h	/^  class glLabel$/;"	c	namespace:vcg
glLight	vcglib/wrap/gl/deprecated_space.h	/^  inline void glLight(GLenum light, GLenum pname,  Color4b const & c) {$/;"	f	namespace:vcg
glLight	vcglib/wrap/gl/space.h	/^  inline void glLight(GLenum light, GLenum pname,  Color4b const & c)   {$/;"	f	namespace:vcg
glLoadMatrix	vcglib/wrap/gl/deprecated_math.h	/^inline void glLoadMatrix(const Matrix44d &matrix) {$/;"	f	namespace:vcg
glLoadMatrix	vcglib/wrap/gl/deprecated_math.h	/^inline void glLoadMatrix(const Matrix44f &matrix) {$/;"	f	namespace:vcg
glLoadMatrix	vcglib/wrap/gl/math.h	/^inline void glLoadMatrix(const Eigen::Matrix<T,4,4,StorageOrder>& matrix) { assert(0); }$/;"	f	namespace:vcg
glLoadMatrix	vcglib/wrap/gl/math.h	/^inline void glLoadMatrix(const Eigen::Matrix<double,4,4,Eigen::RowMajor>& matrix) {$/;"	f	namespace:vcg
glLoadMatrix	vcglib/wrap/gl/math.h	/^inline void glLoadMatrix(const Eigen::Matrix<double,4,4>& matrix) { glLoadMatrixd(matrix.data()); }$/;"	f	namespace:vcg
glLoadMatrix	vcglib/wrap/gl/math.h	/^inline void glLoadMatrix(const Eigen::Transform<Scalar,3>& t) { glLoadMatrix(t.matrix()); }$/;"	f	namespace:vcg
glLoadMatrix	vcglib/wrap/gl/math.h	/^template<> inline void glLoadMatrix(const Eigen::Matrix<float,4,4,Eigen::RowMajor>& matrix) {$/;"	f	namespace:vcg
glLoadMatrix	vcglib/wrap/gl/math.h	/^template<> inline void glLoadMatrix(const Eigen::Matrix<float,4,4>& matrix) { glLoadMatrixf(matrix.data()); }$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/deprecated_math.h	/^inline void glMultMatrix(const Matrix44d &matrix) {$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/deprecated_math.h	/^inline void glMultMatrix(const Matrix44f &matrix) {$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/deprecated_math.h	/^inline void glMultMatrix(const Similarityd &s) {$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/deprecated_math.h	/^inline void glMultMatrix(const Similarityf &s) {$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/math.h	/^inline void glMultMatrix(const Eigen::Matrix<T,4,4,StorageOrder>& matrix) { assert(0); }$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/math.h	/^inline void glMultMatrix(const Eigen::Matrix<float,4,4,Eigen::RowMajor>& matrix) {$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/math.h	/^inline void glMultMatrix(const Eigen::Transform<Scalar,3>& t) { glMultMatrix(t.matrix()); }$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/math.h	/^inline void glMultMatrix(const Similarityd &s) {$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/math.h	/^inline void glMultMatrix(const Similarityf &s) {$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/math.h	/^template<> inline void glMultMatrix(const Eigen::Matrix<double,4,4,Eigen::RowMajor>& matrix) {$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/math.h	/^template<> inline void glMultMatrix(const Eigen::Matrix<double,4,4>& matrix) { glMultMatrixd(matrix.data()); }$/;"	f	namespace:vcg
glMultMatrix	vcglib/wrap/gl/math.h	/^template<> inline void glMultMatrix(const Eigen::Matrix<float,4,4>& matrix) { glMultMatrixf(matrix.data()); }$/;"	f	namespace:vcg
glMultMatrixDirect	vcglib/wrap/gl/deprecated_math.h	/^inline void glMultMatrixDirect(const Matrix44d &matrix) {$/;"	f	namespace:vcg
glMultMatrixDirect	vcglib/wrap/gl/deprecated_math.h	/^inline void glMultMatrixDirect(const Matrix44f &matrix) {$/;"	f	namespace:vcg
glMultMatrixE	vcglib/wrap/gl/deprecated_math.h	/^inline void glMultMatrixE(const Matrix44d &matrix) {$/;"	f	namespace:vcg
glMultMatrixE	vcglib/wrap/gl/deprecated_math.h	/^inline void glMultMatrixE(const Matrix44f &matrix) {$/;"	f	namespace:vcg
glNormal	vcglib/wrap/gl/deprecated_space.h	/^	inline void glNormal(Point3<double> const & p){ glNormal3dv(p.V());}$/;"	f	namespace:vcg
glNormal	vcglib/wrap/gl/deprecated_space.h	/^	inline void glNormal(Point3<float> const & p) { glNormal3fv(p.V());}$/;"	f	namespace:vcg
glNormal	vcglib/wrap/gl/deprecated_space.h	/^	inline void glNormal(Point3<int> const & p)   { glNormal3iv((const GLint*)p.V());}$/;"	f	namespace:vcg
glNormal	vcglib/wrap/gl/deprecated_space.h	/^	inline void glNormal(Point3<short> const & p) { glNormal3sv(p.V());}$/;"	f	namespace:vcg
glNormal	vcglib/wrap/gl/space.h	/^	template<> inline void glNormal(const Eigen::Matrix<double,3,1> & p){ glNormal3dv(p.data());}$/;"	f	namespace:vcg
glNormal	vcglib/wrap/gl/space.h	/^	template<> inline void glNormal(const Eigen::Matrix<float,3,1> & p) { glNormal3fv(p.data());}$/;"	f	namespace:vcg
glNormal	vcglib/wrap/gl/space.h	/^	template<> inline void glNormal(const Eigen::Matrix<int,3,1> & p)   { glNormal3iv((const GLint*)p.data());}$/;"	f	namespace:vcg
glNormal	vcglib/wrap/gl/space.h	/^	template<> inline void glNormal(const Eigen::Matrix<short,3,1> & p) { glNormal3sv(p.data());}$/;"	f	namespace:vcg
glNormal	vcglib/wrap/gl/space.h	/^	template<typename T> inline void glNormal(const Eigen::Matrix<T,3,1> & p) { assert(0); }$/;"	f	namespace:vcg
glPlane3	vcglib/wrap/gl/deprecated_space.h	/^	inline void glPlane3( Plane3<T>   p, Point3<T>  c, T size )  {$/;"	f	namespace:vcg
glPlane3	vcglib/wrap/gl/space.h	/^	inline void glPlane3( Plane3<T>   p, Point3<T>  c, T size )  {$/;"	f	namespace:vcg
glPoint	vcglib/wrap/gl/addons.h	/^			static void glPoint(vcg::Point3f Center,float size,int slices =16,int stacks =16)$/;"	f	class:vcg::Add_Ons
glScale	vcglib/wrap/gl/deprecated_space.h	/^	inline void glScale(Point2<double> const & p){ glScaled(p[0],p[1],1.0);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/deprecated_space.h	/^	inline void glScale(Point2<float> const & p) { glScalef(p[0],p[1],1.0);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/deprecated_space.h	/^	inline void glScale(Point3<double> const & p){ glScaled(p[0],p[1],p[2]);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/deprecated_space.h	/^	inline void glScale(Point3<float> const & p) { glScalef(p[0],p[1],p[2]);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/deprecated_space.h	/^	inline void glScale(double const & p){ glScaled(p,p,p);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/deprecated_space.h	/^	inline void glScale(float const & p){ glScalef(p,p,p);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/space.h	/^	inline void glScale(double const & p){ glScaled(p,p,p);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/space.h	/^	inline void glScale(float const & p){ glScalef(p,p,p);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/space.h	/^	template<> inline void glScale(const Eigen::Matrix<double,2,1> & p){ glScaled(p[0],p[1],1.0);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/space.h	/^	template<> inline void glScale(const Eigen::Matrix<double,3,1> & p){ glScaled(p[0],p[1],p[2]);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/space.h	/^	template<> inline void glScale(const Eigen::Matrix<float,2,1> & p) { glScalef(p[0],p[1],1.f);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/space.h	/^	template<> inline void glScale(const Eigen::Matrix<float,3,1> & p) { glScalef(p[0],p[1],p[2]);}$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/space.h	/^	template<typename T> inline void glScale(const Eigen::Matrix<T,2,1> & p) { assert(0); }$/;"	f	namespace:vcg
glScale	vcglib/wrap/gl/space.h	/^	template<typename T> inline void glScale(const Eigen::Matrix<T,3,1> & p) { assert(0); }$/;"	f	namespace:vcg
glTetra3	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTetra3(  TetraType & c )  {$/;"	f	namespace:vcg
glTetra3	vcglib/wrap/gl/space.h	/^	inline void glTetra3(  TetraType & c )  {$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTexCoord(Point2<double> const & p){ glTexCoord2dv(p.V());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTexCoord(Point2<float> const & p) { glTexCoord2fv(p.V());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTexCoord(Point2<int> const & p)   { glTexCoord2iv((const GLint*)p.V());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTexCoord(Point2<short> const & p) { glTexCoord2sv(p.V());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTexCoord(Point3<double> const & p){ glTexCoord3dv(p.V());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTexCoord(Point3<float> const & p) { glTexCoord3fv(p.V());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTexCoord(Point3<int> const & p)   { glTexCoord3iv((const GLint*)p.V());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTexCoord(Point3<short> const & p) { glTexCoord3sv(p.V());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/space.h	/^	template<> inline void glTexCoord(const Eigen::Matrix<double,2,1> & p){ glTexCoord2dv(p.data());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/space.h	/^	template<> inline void glTexCoord(const Eigen::Matrix<double,3,1> & p){ glTexCoord3dv(p.data());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/space.h	/^	template<> inline void glTexCoord(const Eigen::Matrix<float,2,1> & p) { glTexCoord2fv(p.data());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/space.h	/^	template<> inline void glTexCoord(const Eigen::Matrix<float,3,1> & p) { glTexCoord3fv(p.data());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/space.h	/^	template<> inline void glTexCoord(const Eigen::Matrix<int,2,1> & p)   { glTexCoord2iv((const GLint*)p.data());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/space.h	/^	template<> inline void glTexCoord(const Eigen::Matrix<int,3,1> & p)   { glTexCoord3iv((const GLint*)p.data());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/space.h	/^	template<> inline void glTexCoord(const Eigen::Matrix<short,2,1> & p) { glTexCoord2sv(p.data());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/space.h	/^	template<> inline void glTexCoord(const Eigen::Matrix<short,3,1> & p) { glTexCoord3sv(p.data());}$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/space.h	/^	template<typename T> inline void glTexCoord(const Eigen::Matrix<T,2,1> & p) { assert(0); }$/;"	f	namespace:vcg
glTexCoord	vcglib/wrap/gl/space.h	/^	template<typename T> inline void glTexCoord(const Eigen::Matrix<T,3,1> & p) { assert(0); }$/;"	f	namespace:vcg
glTranslate	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTranslate(Point2<double> const & p){ glTranslated(p[0],p[1],0);}$/;"	f	namespace:vcg
glTranslate	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTranslate(Point2<float> const & p) { glTranslatef(p[0],p[1],0);}$/;"	f	namespace:vcg
glTranslate	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTranslate(Point3<double> const & p){ glTranslated(p[0],p[1],p[2]);}$/;"	f	namespace:vcg
glTranslate	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTranslate(Point3<float> const & p) { glTranslatef(p[0],p[1],p[2]);}$/;"	f	namespace:vcg
glTranslate	vcglib/wrap/gl/space.h	/^	template<> inline void glTranslate(const Eigen::Matrix<double,2,1> & p){ glTranslated(p[0],p[1],0);}$/;"	f	namespace:vcg
glTranslate	vcglib/wrap/gl/space.h	/^	template<> inline void glTranslate(const Eigen::Matrix<double,3,1> & p){ glTranslated(p[0],p[1],p[2]);}$/;"	f	namespace:vcg
glTranslate	vcglib/wrap/gl/space.h	/^	template<> inline void glTranslate(const Eigen::Matrix<float,2,1> & p) { glTranslatef(p[0],p[1],0);}$/;"	f	namespace:vcg
glTranslate	vcglib/wrap/gl/space.h	/^	template<> inline void glTranslate(const Eigen::Matrix<float,3,1> & p) { glTranslatef(p[0],p[1],p[2]);}$/;"	f	namespace:vcg
glTranslate	vcglib/wrap/gl/space.h	/^	template<typename T> inline void glTranslate(const Eigen::Matrix<T,2,1> & p) { assert(0); }$/;"	f	namespace:vcg
glTranslate	vcglib/wrap/gl/space.h	/^	template<typename T> inline void glTranslate(const Eigen::Matrix<T,3,1> & p) { assert(0); }$/;"	f	namespace:vcg
glTriangle3	vcglib/wrap/gl/deprecated_space.h	/^	inline void glTriangle3(  TriangleType & c )  {$/;"	f	namespace:vcg
glTriangle3	vcglib/wrap/gl/space.h	/^	inline void glTriangle3(  TriangleType & c )  {$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/deprecated_space.h	/^	inline void glVertex(Point2<double> const & p){ glVertex2dv(p.V());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/deprecated_space.h	/^	inline void glVertex(Point2<float> const & p) { glVertex2fv(p.V());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/deprecated_space.h	/^	inline void glVertex(Point2<int> const & p)   { glVertex2iv((const GLint*)p.V());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/deprecated_space.h	/^	inline void glVertex(Point2<short> const & p) { glVertex2sv(p.V());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/deprecated_space.h	/^	inline void glVertex(Point3<double> const & p){ glVertex3dv(p.V());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/deprecated_space.h	/^	inline void glVertex(Point3<float> const & p) { glVertex3fv(p.V());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/deprecated_space.h	/^	inline void glVertex(Point3<short> const & p) { glVertex3sv(p.V());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/deprecated_space.h	/^  inline void glVertex(Point3<int> const & p)   { glVertex3iv((const GLint*)p.V());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/space.h	/^	template<> inline void glVertex(const Eigen::Matrix<double,2,1> & p){ glVertex2dv(p.data());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/space.h	/^	template<> inline void glVertex(const Eigen::Matrix<double,3,1> & p){ glVertex3dv(p.data());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/space.h	/^	template<> inline void glVertex(const Eigen::Matrix<float,2,1> & p) { glVertex2fv(p.data());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/space.h	/^	template<> inline void glVertex(const Eigen::Matrix<float,3,1> & p) { glVertex3fv(p.data());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/space.h	/^	template<> inline void glVertex(const Eigen::Matrix<int,2,1> & p)   { glVertex2iv((const GLint*)p.data());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/space.h	/^	template<> inline void glVertex(const Eigen::Matrix<int,3,1> & p)   { glVertex3iv((const GLint*)p.data());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/space.h	/^	template<> inline void glVertex(const Eigen::Matrix<short,2,1> & p) { glVertex2sv(p.data());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/space.h	/^	template<> inline void glVertex(const Eigen::Matrix<short,3,1> & p) { glVertex3sv(p.data());}$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/space.h	/^	template<typename T> inline void glVertex(const Eigen::Matrix<T,2,1> & p) { assert(0); }$/;"	f	namespace:vcg
glVertex	vcglib/wrap/gl/space.h	/^	template<typename T> inline void glVertex(const Eigen::Matrix<T,3,1> & p) { assert(0); }$/;"	f	namespace:vcg
glWidget	vcglib/apps/sample/trimesh_pos_demo/window.h	/^    GLWidget *glWidget;$/;"	m	class:Window
glWrap	vcglib/apps/sample/trimesh_QT/glarea.h	/^  vcg::GlTrimesh<CMesh> glWrap;$/;"	m	class:GLArea
glWrap	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^vcg::GlTrimesh<CMesh> glWrap;$/;"	v
glWrap	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^vcg::GlTrimesh<CMesh> glWrap;    \/\/\/ the active mesh opengl wrapper$/;"	v
glWrap	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		vcg::GlTrimesh<MyStraightMesh> glWrap;$/;"	m	class:GLWidget
glWrap	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^vcg::GlTrimesh<CMesh> glWrap;$/;"	v
glWrap	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^vcg::GlTrimesh<CMesh> glWrap;$/;"	v
gl_surface	vcglib/wrap/gl/gl_surface.h	/^		gl_surface(void) : width(0), height(0), depth_tex(0), fb(0)$/;"	f	class:vcg::gl_surface
gl_surface	vcglib/wrap/gl/gl_surface.h	/^class gl_surface$/;"	c	namespace:vcg
glmode	vcglib/wrap/gl/trimesh.h	/^        int glmode;$/;"	m	class:vcg::GLW::GLAElem
global_mark	vcglib/vcg/space/index/octree.h	/^        unsigned char  global_mark;$/;"	m	class:vcg::Octree
global_math_functions_filtering_base	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct global_math_functions_filtering_base$/;"	s	namespace:Eigen::internal
glu_tesselator	vcglib/wrap/gl/glu_tesselator.h	/^class glu_tesselator$/;"	c	namespace:vcg
glue	vcglib/apps/pivoting/pivot.h	/^    bool Pivot::glue(std::list<Hinge>::iterator a, std::list<Hinge>::iterator b) {$/;"	f	class:vcg::tri::Pivot::Pivot
glutPrintf	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^void glutPrintf(int x, int y, const char * f, ... )$/;"	f
glutSolidSphere	vcglib/wrap/gl/gl_geometry.h	/^inline void glutSolidSphere(GLdouble radius, GLint slices, GLint stacks)$/;"	f
glutWireSphere	vcglib/wrap/gl/gl_geometry.h	/^inline void glutWireSphere(GLdouble radius, GLint slices, GLint stacks)$/;"	f
glw	vcglib/wrap/glw/bookkeeping.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/buffer.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/common.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/context.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/fragmentshader.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/framebuffer.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/geometryshader.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/noncopyable.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/object.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/objectdeleter.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/program.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/renderable.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/renderbuffer.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/shader.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/texture.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/texture2d.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/texturecube.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/type.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/utility.h	/^namespace glw$/;"	n
glw	vcglib/wrap/glw/vertexshader.h	/^namespace glw$/;"	n
gm	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define gm /;"	d	file:
gmres	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^bool gmres(const MatrixType & mat, const Rhs & rhs, Dest & x, const Preconditioner & precond,$/;"	f	namespace:Eigen::internal
gnorm	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar fnorm, gnorm;$/;"	m	class:Eigen::LevenbergMarquardt
goal	vcglib/vcg/space/index/space_iterators.h	/^		CoordType goal;$/;"	m	class:vcg::RayIterator
grabMatrix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLDLT
grabMatrix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLLT
grabMatrix	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLU
grad	vcglib/vcg/math/perlin_noise.h	/^   static double grad(int hash, double x, double y, double z) {$/;"	f	class:vcg::math::Perlin
granularity	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t granularity;$/;"	m	struct:malloc_params	file:
granularity_align	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define granularity_align(/;"	d	file:
grapInput	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput(const MatrixType& mat)$/;"	f	class:Eigen::UmfPackLU
greater	vcglib/vcg/math/eigen.h	/^	inline static bool greater(const Derived1& a, const Derived2& b) {$/;"	f	struct:Eigen::ei_lexi_comparison
greaterEqual	vcglib/vcg/math/eigen.h	/^	inline static bool greaterEqual(const Derived1& a, const Derived2& b) {$/;"	f	struct:Eigen::ei_lexi_comparison
greatestChild	vcglib/wrap/gcache/dheap.h	/^  int greatestChild(int i) {$/;"	f	class:DHeap
greatestRealRoot	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& greatestRealRoot($/;"	f	class:Eigen::PolynomialSolverBase
greatestRoot	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RootType& greatestRoot() const$/;"	f	class:Eigen::PolynomialSolverBase
grid	vcglib/apps/pivoting/pivot.h	/^    StaticGrid grid;$/;"	m	class:vcg::tri::Pivot
grid	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            static GRID* &grid()$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
grid	vcglib/vcg/space/index/grid_static_obj.h	/^	 ObjType *grid;$/;"	m	class:vcg::GridStaticObj
grid	vcglib/vcg/space/index/grid_static_ptr.h	/^		std::vector<Cell> grid;   \/\/\/ Griglia vera e propria$/;"	m	class:vcg::GridStaticPtr
gridCellNum	vcglib/vcg/complex/algorithms/point_sampling.h	/^    int gridCellNum;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam::Stat
gridFix	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    MeshGrid* gridFix;                          \/\/variable to manage uniform grid$/;"	m	class:OverlapEstimation
gridHeight	vcglib/vcg/space/rasterized_outline2_packer.h	/^    int gridHeight(int i) { return grids.at(i).size(); }$/;"	f	class:vcg::RasterizedOutline2
gridSize	vcglib/vcg/complex/algorithms/point_sampling.h	/^    Point3i gridSize;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam::Stat
gridTime	vcglib/vcg/complex/algorithms/point_sampling.h	/^    int gridTime;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam::Stat
gridWidth	vcglib/vcg/space/rasterized_outline2_packer.h	/^    int gridWidth( int i) { return grids.at(i).at(0).size(); }$/;"	f	class:vcg::RasterizedOutline2
grids	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector < std::vector< std::vector<int> > > grids;$/;"	m	class:vcg::RasterizedOutline2
gtol	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Scalar gtol;$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
gtol	vcglib/wrap/minpack/minpack.h	/^	double gtol; 		\/\/ orthogonality desired between fvec and its derivs.$/;"	m	struct:LMDiff::__anon525
gzfp	vcglib/wrap/ply/plylib.h	/^	GZFILE gzfp;$/;"	m	class:vcg::ply::PlyFile
h	vcglib/vcg/complex/algorithms/local_optimization.h	/^	HeapType h;$/;"	m	class:vcg::LocalOptimization
h	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& h() { return data[7];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
hCoeffs	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::ColPivHouseholderQR
hCoeffs	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::FullPivHouseholderQR
hCoeffs	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::HouseholderQR
hInsertResult	vcglib/vcg/math/disjoint_set.h	/^		typedef std::pair< hIterator, bool >															hInsertResult;$/;"	t	class:vcg::DisjointSet
hIterator	vcglib/vcg/math/disjoint_set.h	/^		typedef typename STDEXT::hash_map< ObjectPointer, int, SimpleObjHashFunc  >::iterator	hIterator;$/;"	t	class:vcg::DisjointSet
hIterator	vcglib/vcg/math/disjoint_set.h	/^	  typedef typename STDEXT::hash_map< ObjectPointer, int >::iterator	hIterator;$/;"	t	class:vcg::DisjointSet
hPair	vcglib/vcg/math/disjoint_set.h	/^		typedef std::pair< ObjectPointer, int >														hPair;$/;"	t	class:vcg::DisjointSet
hS2	vcglib/apps/metro/sampling.h	/^    MetroMeshHash   hS2;$/;"	m	class:vcg::Sampling
hahn1_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    hahn1_functor(void) : Functor<double>(7,236) {}$/;"	f	struct:hahn1_functor
hahn1_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct hahn1_functor : Functor<double>$/;"	s	file:
halfVp	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		vcg::Point2f halfVp;$/;"	m	struct:SplatRenderer::UniformParameters
handle	vcglib/wrap/glw/buffer.h	/^		BufferHandle & handle(void)$/;"	f	class:glw::BoundBuffer
handle	vcglib/wrap/glw/buffer.h	/^		const BufferHandle & handle(void) const$/;"	f	class:glw::BoundBuffer
handle	vcglib/wrap/glw/fragmentshader.h	/^		FragmentShaderHandle & handle(void)$/;"	f	class:glw::BoundFragmentShader
handle	vcglib/wrap/glw/fragmentshader.h	/^		const FragmentShaderHandle & handle(void) const$/;"	f	class:glw::BoundFragmentShader
handle	vcglib/wrap/glw/framebuffer.h	/^		FramebufferHandle & handle(void)$/;"	f	class:glw::BoundFramebuffer
handle	vcglib/wrap/glw/framebuffer.h	/^		const FramebufferHandle & handle(void) const$/;"	f	class:glw::BoundFramebuffer
handle	vcglib/wrap/glw/geometryshader.h	/^		GeometryShaderHandle & handle(void)$/;"	f	class:glw::BoundGeometryShader
handle	vcglib/wrap/glw/geometryshader.h	/^		const GeometryShaderHandle & handle(void) const$/;"	f	class:glw::BoundGeometryShader
handle	vcglib/wrap/glw/object.h	/^		ObjectHandle & handle(void)$/;"	f	class:glw::BoundObject
handle	vcglib/wrap/glw/object.h	/^		const ObjectHandle & handle(void) const$/;"	f	class:glw::BoundObject
handle	vcglib/wrap/glw/program.h	/^		ProgramHandle & handle(void)$/;"	f	class:glw::BoundProgram
handle	vcglib/wrap/glw/program.h	/^		const ProgramHandle & handle(void) const$/;"	f	class:glw::BoundProgram
handle	vcglib/wrap/glw/renderable.h	/^		RenderableHandle & handle(void)$/;"	f	class:glw::BoundRenderable
handle	vcglib/wrap/glw/renderable.h	/^		const RenderableHandle & handle(void) const$/;"	f	class:glw::BoundRenderable
handle	vcglib/wrap/glw/renderbuffer.h	/^		RenderbufferHandle & handle(void)$/;"	f	class:glw::BoundRenderbuffer
handle	vcglib/wrap/glw/renderbuffer.h	/^		const RenderbufferHandle & handle(void) const$/;"	f	class:glw::BoundRenderbuffer
handle	vcglib/wrap/glw/shader.h	/^		ShaderHandle & handle(void)$/;"	f	class:glw::BoundShader
handle	vcglib/wrap/glw/shader.h	/^		const ShaderHandle & handle(void) const$/;"	f	class:glw::BoundShader
handle	vcglib/wrap/glw/texture.h	/^		TextureHandle & handle(void)$/;"	f	class:glw::BoundTexture
handle	vcglib/wrap/glw/texture.h	/^		const TextureHandle & handle(void) const$/;"	f	class:glw::BoundTexture
handle	vcglib/wrap/glw/texture2d.h	/^		Texture2DHandle & handle(void)$/;"	f	class:glw::BoundTexture2D
handle	vcglib/wrap/glw/texture2d.h	/^		const Texture2DHandle & handle(void) const$/;"	f	class:glw::BoundTexture2D
handle	vcglib/wrap/glw/texturecube.h	/^		TextureCubeHandle & handle(void)$/;"	f	class:glw::BoundTextureCube
handle	vcglib/wrap/glw/texturecube.h	/^		const TextureCubeHandle & handle(void) const$/;"	f	class:glw::BoundTextureCube
handle	vcglib/wrap/glw/vertexshader.h	/^		VertexShaderHandle & handle(void)$/;"	f	class:glw::BoundVertexShader
handle	vcglib/wrap/glw/vertexshader.h	/^		const VertexShaderHandle & handle(void) const$/;"	f	class:glw::BoundVertexShader
handmade_aligned_free	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void handmade_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
handmade_aligned_malloc	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal
handmade_aligned_realloc	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_realloc(void* ptr, size_t size, size_t = 0)$/;"	f	namespace:Eigen::internal
hasColor	vcglib/wrap/io_trimesh/import_fbx.h	/^			bool hasColor() const {return hascolor;}$/;"	f	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
hasColorspace	vcglib/img/img_attributes.h	/^  bool hasColorspace(COLORSPACE arg_colorspace) const$/;"	f	class:img::ImgAttributes
hasColorspace	vcglib/img/img_attributes.h	/^  bool hasColorspace(const ImgAttributes<ScalarType> &attributes) const$/;"	f	class:img::ImgAttributes
hasFColor	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool hasFColor;$/;"	m	struct:MeshInfo	file:
hasFNormal	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool hasFNormal;$/;"	m	struct:MeshInfo	file:
hasGamma	vcglib/img/img_attributes.h	/^  bool hasGamma(ScalarType arg_gamma) const$/;"	f	class:img::ImgAttributes
hasGamma	vcglib/img/img_attributes.h	/^  bool hasGamma(const ImgAttributes<ScalarType> &attributes) const$/;"	f	class:img::ImgAttributes
hasRange	vcglib/img/img_attributes.h	/^  bool hasRange(ScalarType arg_range_min, ScalarType arg_range_max) const$/;"	f	class:img::ImgAttributes
hasRange	vcglib/img/img_attributes.h	/^  bool hasRange(const ImgAttributes<ScalarType> &attributes) const$/;"	f	class:img::ImgAttributes
hasReferenceWhite	vcglib/img/img_attributes.h	/^  bool hasReferenceWhite(ScalarType arg_reference_white_x, ScalarType arg_reference_white_y, ScalarType arg_reference_white_z) const$/;"	f	class:img::ImgAttributes
hasReferenceWhite	vcglib/img/img_attributes.h	/^  bool hasReferenceWhite(const ImgAttributes<ScalarType> &attributes) const$/;"	f	class:img::ImgAttributes
hasRhs	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline bool hasRhs() {return m_hasRhs; }$/;"	f	class:Eigen::MatrixMarketIterator
hasTexture	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool hasTexture;$/;"	m	struct:MeshInfo	file:
hasTexture	vcglib/wrap/io_trimesh/import_fbx.h	/^			bool hasTexture() const {return (textindex != -1);}$/;"	f	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
hasToPick	vcglib/apps/sample/trimesh_ant_qt/glwidget.h	/^     bool hasToPick;$/;"	m	class:GLWidget
hasVColor	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool hasVColor;$/;"	m	struct:MeshInfo	file:
hasVNormal	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	bool hasVNormal;$/;"	m	struct:MeshInfo	file:
has_arg	vcglib/wrap/system/getopt.h	/^  int has_arg;$/;"	m	struct:option
has_depth_attachment	vcglib/wrap/gl/gl_surface.h	/^		bool has_depth_attachment(void) const$/;"	f	class:vcg::gl_surface
has_direct_access	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { has_direct_access = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon268
has_direct_access	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct has_direct_access$/;"	s	namespace:Eigen::internal
has_doublet_quad	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static bool has_doublet_quad(FacePointer fp)$/;"	f	class:vcg::tri::HalfEdgeTopology
has_doublets	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static bool has_doublets(MeshType &m)$/;"	f	class:vcg::tri::HalfedgeQuadClean
has_none	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	s	namespace:Eigen::internal
has_segment_link	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static int has_segment_link(mstate m, msegmentptr ss) {$/;"	f	file:
has_singlets	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static bool has_singlets(MeshType &m)$/;"	f	class:vcg::tri::HalfedgeQuadClean
has_std_result_type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	s	namespace:Eigen::internal
has_tr1_result	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	s	namespace:Eigen::internal
has_write_access	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^         has_write_access = (traits<Derived>::Flags & LvalueBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon268
hascolor	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  bool			hascolor;			\/\/ true if the current mesh has color$/;"	v
hascolor	vcglib/wrap/io_trimesh/import_fbx.h	/^			bool hascolor;$/;"	m	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
hash	vcglib/vcg/complex/algorithms/clustering.h	/^  template <> struct hash<vcg::tri::HashedPoint3i>{$/;"	s	namespace:STDEXT
hash	vcglib/vcg/math/disjoint_set.h	/^	template <> class hash<void *>: private hash<unsigned long>$/;"	c	namespace:__gnu_cxx
hash_table	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^		HashType hash_table; \/\/ The real HASH TABLE **************************************$/;"	m	class:vcg::SpatialHashTable2D
hash_table	vcglib/vcg/space/index/spatial_hashing.h	/^	HashType hash_table; \/\/ The real HASH TABLE **************************************$/;"	m	class:vcg::SpatialHashTable
hasrefX	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline bool hasrefX() {return m_hasrefX; }$/;"	f	class:Eigen::MatrixMarketIterator
have_to_pick	vcglib/wrap/gui/rubberband.h	/^  bool have_to_pick;$/;"	m	class:vcg::Rubberband
hblkhd	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MALLINFO_FIELD_TYPE hblkhd;   \/* space in mmapped regions *\/$/;"	m	struct:mallinfo	file:
hblkhd	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^  MALLINFO_FIELD_TYPE hblkhd;   \/* space in mmapped regions *\/$/;"	m	struct:mallinfo
hblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MALLINFO_FIELD_TYPE hblks;    \/* always 0 *\/$/;"	m	struct:mallinfo	file:
hblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^  MALLINFO_FIELD_TYPE hblks;    \/* always 0 *\/$/;"	m	struct:mallinfo
he	vcglib/vcg/connectors/halfedge_pos.h	/^            HEdgePointer he;$/;"	m	class:vcg::hedge::Pos
head	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head() const$/;"	f	class:Eigen::DenseBase
head	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head()$/;"	f	class:Eigen::DenseBase
head	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head(Index size) const$/;"	f	class:Eigen::DenseBase
head	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::head(Index size)$/;"	f	class:Eigen::DenseBase
head	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t                    head;$/;"	m	struct:malloc_tree_chunk	file:
head	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t               head;       \/* Size and inuse bits. *\/$/;"	m	struct:malloc_chunk	file:
header	vcglib/wrap/io_tetramesh/io_ply.h	/^  std::string header;$/;"	m	class:vcg::tetra::io::PlyInfo
header	vcglib/wrap/io_trimesh/io_ply.h	/^  std::string header;$/;"	m	class:vcg::tri::io::PlyInfo
header	vcglib/wrap/ply/plylib.h	/^  std::string   header;			\/\/ Testo dell'header	$/;"	m	class:vcg::ply::PlyFile
headers	vcglib/apps/trimeshinfo/XMLTree.h	/^	list<pair<const char* , const char* > > headers;$/;"	m	class:MainNode
heap	vcglib/wrap/gcache/dheap.h	/^  DHeap<Item> heap;$/;"	m	class:PtrDHeap
heap	vcglib/wrap/gcache/provider.h	/^  PtrDHeap<Token> heap;$/;"	m	class:vcg::Provider
heap_dirty	vcglib/wrap/gcache/provider.h	/^  bool heap_dirty;$/;"	m	class:vcg::Provider
heap_lock	vcglib/wrap/gcache/provider.h	/^  mt::mutex heap_lock;$/;"	m	class:vcg::Provider
hedge	vcglib/vcg/complex/append.h	/^        std::vector<int> vert,face,edge, hedge;$/;"	m	struct:vcg::tri::Append::Remap
hedge	vcglib/vcg/complex/base.h	/^    HEdgeContainer hedge;$/;"	m	class:vcg::tri::TriMesh
hedge	vcglib/vcg/connectors/halfedge_pos.h	/^    namespace hedge$/;"	n	namespace:vcg
hedge	vcglib/vcg/connectors/hedge_component.h	/^	namespace hedge {$/;"	n	namespace:vcg
height	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^int width,height;$/;"	v
height	vcglib/apps/test/trackball/main.cpp	/^int height = 600;$/;"	v
height	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^int height = 600;$/;"	v
height	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^int height = 768;$/;"	v
height	vcglib/img/img_image.h	/^  inline int height() const$/;"	f	class:img::Image
height	vcglib/wrap/gl/fbo.h	/^	GLsizei height;$/;"	m	class:BufferRenderTarget
height	vcglib/wrap/gl/gl_surface.h	/^		int height;$/;"	m	class:vcg::gl_surface
height	vcglib/wrap/glw/renderbuffer.h	/^		GLsizei height(void) const$/;"	f	class:glw::Renderbuffer
height	vcglib/wrap/glw/renderbuffer.h	/^		GLsizei height(void) const$/;"	f	class:glw::SafeRenderbuffer
height	vcglib/wrap/glw/renderbuffer.h	/^		GLsizei height;$/;"	m	class:glw::RenderbufferArguments
height	vcglib/wrap/glw/texture2d.h	/^		GLsizei           height;$/;"	m	class:glw::Texture2DArguments
height	vcglib/wrap/glw/texture2d.h	/^		GLsizei height(void) const$/;"	f	class:glw::SafeTexture2D
height	vcglib/wrap/glw/texture2d.h	/^		GLsizei height(void) const$/;"	f	class:glw::Texture2D
height	vcglib/wrap/glw/texturecube.h	/^		GLsizei height(void) const$/;"	f	class:glw::SafeTextureCube
height	vcglib/wrap/glw/texturecube.h	/^		GLsizei height(void) const$/;"	f	class:glw::TextureCube
height	vcglib/wrap/io_trimesh/export_idtf.h	/^		short height;             $/;"	m	struct:vcg::tri::io::TGA_Exporter::TGAHeader
height	vcglib/wrap/qt/Outline2ToQImage.h	/^      int height;$/;"	m	class:Outline2Dumper::Param
help	vcglib/wrap/system/qgetopt.h	/^  QString help;             \/\/help text$/;"	m	class:GetOpt
hipass	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^float lopass=0,hipass=1,gamma_correction=1;$/;"	v
hist	vcglib/apps/metro/sampling.h	/^    Histogram<double>            hist;$/;"	m	class:vcg::Sampling
history	vcglib/wrap/bmt/bmt.h	/^  std::vector< MT<Bmt::Cell>::Update > history;$/;"	m	class:vcg::Bmt
history	vcglib/wrap/gui/trackball.h	/^  std::list<Transform> history;$/;"	m	class:vcg::Trackball
history_offset	vcglib/wrap/bmt/bmt.h	/^  unsigned int history_offset;$/;"	m	class:vcg::Bmt
history_size	vcglib/wrap/bmt/bmt.h	/^  unsigned int history_size;  $/;"	m	class:vcg::Bmt
history_size	vcglib/wrap/gui/trackball.h	/^  int history_size;$/;"	m	class:vcg::Trackball
hn	vcglib/vcg/complex/base.h	/^    int hn;$/;"	m	class:vcg::tri::TriMesh
hnormalized	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::hnormalized() const$/;"	f	class:Eigen::MatrixBase
hnormalized	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::hnormalized() const$/;"	f	class:Eigen::VectorwiseOp
homogeneous	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::homogeneous() const$/;"	f	class:Eigen::MatrixBase
homogeneous	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::homogeneous() const$/;"	f	class:Eigen::VectorwiseOp
homogeneous_left_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  homogeneous_left_product_impl(const Lhs& lhs, const MatrixType& rhs)$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
homogeneous_left_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs>$/;"	s	namespace:Eigen::internal
homogeneous_right_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  homogeneous_right_product_impl(const MatrixType& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
homogeneous_right_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs>$/;"	s	namespace:Eigen::internal
householder	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    const MatrixType& householder() const { return m_householder; }$/;"	f	class:Eigen::internal::UpperBidiagonalization
householderCoefficients	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const CoeffVectorType& householderCoefficients() const$/;"	f	class:Eigen::HessenbergDecomposition
householderCoefficients	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline CoeffVectorType householderCoefficients() const$/;"	f	class:Eigen::Tridiagonalization
householderQ	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^  ::householderQ() const$/;"	f	class:Eigen::ColPivHouseholderQR
householderQ	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    HouseholderSequenceType householderQ() const$/;"	f	class:Eigen::HouseholderQR
householderQr	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^MatrixBase<Derived>::householderQr() const$/;"	f	class:Eigen::MatrixBase
householderSequence	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType> householderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen
householderU	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderUSequenceType householderU() const$/;"	f	class:Eigen::internal::UpperBidiagonalization
householderV	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderVSequenceType householderV() \/\/ const here gives nasty errors and i'm lazy$/;"	f	class:Eigen::internal::UpperBidiagonalization
householder_qr_inplace_blocked	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^void householder_qr_inplace_blocked(MatrixQR& mat, HCoeffs& hCoeffs,$/;"	f	namespace:Eigen::internal
householder_qr_inplace_unblocked	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^void householder_qr_inplace_unblocked(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)$/;"	f	namespace:Eigen::internal
hp	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            HEdgePointer hp;$/;"	m	class:vcg::tri::QuadDiagonalCollapseBase
hseq_side_dependent_impl	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl$/;"	s	namespace:Eigen::internal
hseq_side_dependent_impl	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl<VectorsType, CoeffsType, OnTheRight>$/;"	s	namespace:Eigen::internal
hybrd1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::hybrd1($/;"	f	class:Eigen::HybridNonLinearSolver
hybrd_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    hybrd_functor(void) : Functor<double>(9,9) {}$/;"	f	struct:hybrd_functor
hybrd_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct hybrd_functor : Functor<double>$/;"	s	file:
hybrj1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::hybrj1($/;"	f	class:Eigen::HybridNonLinearSolver
hybrj_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    hybrj_functor(void) : Functor<double>(9,9) {}$/;"	f	struct:hybrj_functor
hybrj_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct hybrj_functor : Functor<double>$/;"	s	file:
hypot	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(hypot, Scalar) hypot(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal
hypot	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal hypot (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
hypotNorm	vcglib/eigenlib/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::hypotNorm() const$/;"	f	class:Eigen::MatrixBase
hypotNorm	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_hypotNorm,RealScalar>::Type hypotNorm() const$/;"	f	class:Eigen::VectorwiseOp
hypot_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct hypot_impl$/;"	s	namespace:Eigen::internal
hypot_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct hypot_retval$/;"	s	namespace:Eigen::internal
i	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& i() { return data[8];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
i	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                int i;$/;"	m	struct:vcg::tri::UpdateHalfEdges::FacePtrInt
i	vcglib/vcg/space/index/grid_static_ptr.h	/^			int i;$/;"	m	class:vcg::GridStaticPtr::Link
ialloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void** ialloc(mstate m,$/;"	f	file:
icc_11_workaround	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  template<int OtherMode,int OtherOptions> struct icc_11_workaround$/;"	s	class:Eigen::Transform
id	vcglib/apps/trimeshinfo/InstancesNode.h	/^	char*	id;$/;"	m	class:InstanceNode
id	vcglib/vcg/complex/algorithms/clustering.h	/^  int id;$/;"	m	class:vcg::tri::AverageColorCell
id	vcglib/vcg/complex/algorithms/clustering.h	/^  int id;$/;"	m	class:vcg::tri::NearestToCenter
id	vcglib/vcg/container/vector_occ.h	/^	int id;$/;"	m	class:vcg::vector_occ
id_img	vcglib/wrap/io_trimesh/import_out.h	/^    unsigned int id_img,key;$/;"	m	struct:vcg::tri::io::Correspondence
identsize	vcglib/wrap/io_trimesh/export_idtf.h	/^		unsigned char  identsize;          $/;"	m	struct:vcg::tri::io::TGA_Exporter::TGAHeader
idle_and_keys_mode	vcglib/wrap/gui/trackball.h	/^  TrackMode *idle_and_keys_mode; $/;"	m	class:vcg::Trackball
ids_to_round	vcglib/wrap/miq/core/poisson_solver.h	/^	std::vector<int> ids_to_round;$/;"	m	class:PoissonSolver
idx	vcglib/vcg/complex/algorithms/clip.h	/^    unsigned int idx;$/;"	m	class:vcg::tri::TriMeshClipper::EdgeIsect
idx	vcglib/vcg/complex/algorithms/clip.h	/^    unsigned int idx;$/;"	m	class:vcg::tri::TriMeshClipper::TriangleInfo
idx	vcglib/vcg/complex/algorithms/clip.h	/^    unsigned int idx;$/;"	m	class:vcg::tri::TriMeshClipper::VertexClipInfo
idx2bit	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define idx2bit(/;"	d	file:
ii	vcglib/vcg/complex/algorithms/clustering.h	/^    int ii(int i) const {return *((int *)(&(v[i])));}$/;"	f	class:vcg::tri::Clustering::SimpleTri
illum	vcglib/wrap/io_trimesh/io_material.h	/^		int illum;\/\/specular illumination$/;"	m	struct:vcg::tri::io::Material
imag	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag, Scalar) imag(const Scalar& x)$/;"	f	namespace:Eigen::internal
imag	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^imag() const { return derived(); }$/;"	f
imag	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^imag() { return derived(); }$/;"	f
imag	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline typename DerType::Scalar imag(const AutoDiffScalar<DerType>&)    { return 0.; }$/;"	f	namespace:Eigen
imag_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct imag_impl$/;"	s	namespace:Eigen::internal
imag_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct imag_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
imag_ref	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) imag_ref(Scalar& x)$/;"	f	namespace:Eigen::internal
imag_ref	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline typename add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) >::type imag_ref(const Scalar& x)$/;"	f	namespace:Eigen::internal
imag_ref_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl$/;"	s	namespace:Eigen::internal
imag_ref_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
imag_ref_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal
imag_ref_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct imag_ref_retval$/;"	s	namespace:Eigen::internal
imag_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct imag_retval$/;"	s	namespace:Eigen::internal
image	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    const ImageResultType image() const$/;"	f	class:Eigen::LU
image	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^      image(const MatrixType& originalMatrix) const$/;"	f	class:Eigen::FullPivLU
imageDimensions	vcglib/wrap/glw/renderable.h	/^		int imageDimensions(void) const$/;"	f	class:glw::SafeRenderable
imageDimensions	vcglib/wrap/glw/renderbuffer.h	/^		virtual int imageDimensions(void) const$/;"	f	class:glw::Renderbuffer
imageDimensions	vcglib/wrap/glw/texture2d.h	/^		virtual int imageDimensions(void) const$/;"	f	class:glw::Texture2D
imageDimensions	vcglib/wrap/glw/texturecube.h	/^		virtual int imageDimensions(void) const$/;"	f	class:glw::TextureCube
image_retval	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^struct image_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
image_retval_base	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  image_retval_base(const DecompositionType& dec, const MatrixType& originalMatrix)$/;"	f	struct:Eigen::internal::image_retval_base
image_retval_base	vcglib/eigenlib/Eigen/src/misc/Image.h	/^template<typename _DecompositionType> struct image_retval_base$/;"	s	namespace:Eigen::internal
imagetype	vcglib/wrap/io_trimesh/export_idtf.h	/^		unsigned char  imagetype;          $/;"	m	struct:vcg::tri::io::TGA_Exporter::TGAHeader
imark	vcglib/vcg/complex/base.h	/^int imark;$/;"	m	class:vcg::tri::TriMesh
img	vcglib/apps/unsupported/shadevis/simplepic.h	/^    std::vector<PixType> img;$/;"	m	class:vcg::SimplePic
img	vcglib/img/img_attributes.h	/^namespace img {$/;"	n
img	vcglib/img/img_base.h	/^namespace img {$/;"	n
img	vcglib/img/img_convert.h	/^namespace img {$/;"	n
img	vcglib/img/img_cs_base.h	/^namespace img {$/;"	n
img	vcglib/img/img_filter.h	/^namespace img {$/;"	n
img	vcglib/img/img_image.h	/^namespace img {$/;"	n
img	vcglib/img/img_info.h	/^namespace img {$/;"	n
img	vcglib/img/img_io.h	/^namespace img {$/;"	n
img	vcglib/img/img_scalar.h	/^namespace img {$/;"	n
img	vcglib/wrap/qt/img_qt_convert.h	/^namespace img {$/;"	n
img	vcglib/wrap/qt/img_qt_io.h	/^namespace img {$/;"	n
img_filters	vcglib/apps/sample/img_filters/img_filters.cpp	/^void img_filters(QString input_dir,QString image,QString output_dir)$/;"	f
imgcnt	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^int imgcnt=0;$/;"	v
impl	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  const linspaced_op_impl<Scalar,RandomAccess> impl;$/;"	m	struct:Eigen::internal::linspaced_op
in	vcglib/wrap/mt/mt.h	/^    std::vector<Node *> in;$/;"	m	struct:vcg::MT::Node
inactive_mode	vcglib/wrap/gui/trackball.h	/^  TrackMode *inactive_mode;$/;"	m	class:vcg::Trackball
incidentIrregular	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE incidentIrregular(int k) {$/;"	f	struct:vcg::tri::ContinuityLoopWeight
incidentIrregular	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE incidentIrregular(int k) {$/;"	f	struct:vcg::tri::RegularLoopWeight
incidentIrregular	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE incidentIrregular(int) {$/;"	f	struct:vcg::tri::LoopWeight
incidentRegular	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE incidentRegular(int k) {$/;"	f	struct:vcg::tri::ContinuityLoopWeight
incidentRegular	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE incidentRegular(int k) {$/;"	f	struct:vcg::tri::RegularLoopWeight
incidentRegular	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE incidentRegular(int) {$/;"	f	struct:vcg::tri::LoopWeight
incrementToNonZero	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  void incrementToNonZero()$/;"	f	class:Eigen::SparseView::InnerIterator
increment_if_fixed_size	vcglib/eigenlib/unsupported/test/polynomialsolver.cpp	/^struct increment_if_fixed_size$/;"	s	namespace:Eigen::internal	file:
increment_if_fixed_size	vcglib/eigenlib/unsupported/test/polynomialutils.cpp	/^struct increment_if_fixed_size$/;"	s	namespace:Eigen::internal	file:
index	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    int index() const$/;"	f	class:Eigen::Diagonal
index	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    index = Start * packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon231
index	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^      Index index;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
index	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index index() const { return m_cachedIndex; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
index	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index& index(size_t i) { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
index	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline const Index& index(size_t i) const { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
index	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_inner; }$/;"	f	class:Eigen::DenseBase::InnerIterator
index	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
index	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
index	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_id; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
index	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_lhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
index	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_rhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
index	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
index	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
index	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index index() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
index	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator
index	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
index	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index index() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
index	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index index() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
index	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  bindex_t                  index;$/;"	m	struct:malloc_tree_chunk	file:
index	vcglib/vcg/math/matrix44.h	/^	int index[4]; \/\/hold permutation$/;"	m	class:vcg::LinearSolve
index	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^			Index index;$/;"	m	struct:HeapMaxPriorityQueue::Element
index	vcglib/wrap/bmt/bmt.h	/^  std::vector<Bmt::Cell> index;$/;"	m	class:vcg::BmtBuilder
index	vcglib/wrap/bmt/bmt.h	/^  std::vector<Cell> index;$/;"	m	class:vcg::Bmt
index	vcglib/wrap/io_trimesh/io_material.h	/^		unsigned int index;\/\/index of material$/;"	m	struct:vcg::tri::io::Material
indexTextureByImgNode	vcglib/wrap/dae/util_dae.h	/^		static int indexTextureByImgNode(const QDomDocument doc,const QDomNode node)$/;"	f	class:vcg::tri::io::UtilDAE
index_offset	vcglib/wrap/bmt/bmt.h	/^  unsigned int index_offset;$/;"	m	class:vcg::Bmt
index_size	vcglib/wrap/bmt/bmt.h	/^  unsigned int index_size;$/;"	m	class:vcg::Bmt
indices	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase
indices	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map
indices	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix
indices	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase
indices	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map
indices	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix
indices	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationWrapper
indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase
indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map
indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Transpositions
indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper
indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase
indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map
indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Transpositions
indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper
indices	vcglib/wrap/gl/glu_tesselator.h	/^                std::vector<int> indices;$/;"	m	class:vcg::glu_tesselator::tess_prim_data
indices	vcglib/wrap/gl/trimesh.h	/^    std::vector<unsigned int> indices;$/;"	m	class:vcg::GlTrimesh
inflate_percentage	vcglib/apps/metro/sampling.h	/^		float inflate_percentage			     ;$/;"	m	class:vcg::Sampling
info	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LDLT
info	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LLT
info	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::CholmodBase
info	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexEigenSolver
info	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexSchur
info	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::EigenSolver
info	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::RealSchur
info	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
info	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::IncompleteLUT
info	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ComputationInfo info() const$/;"	f	class:Eigen::IterativeSolverBase
info	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PastixBase
info	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PardisoImpl
info	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SimplicialCholeskyBase
info	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SuperLUBase
info	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::UmfPackLU
info	vcglib/wrap/minpack/minpack.h	/^	int info; 		\/\/ status of minimization.$/;"	m	struct:LMDiff::__anon525
init	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::init(QString file, float ballsize = 1.2) {$/;"	f	class:GLArea
init	vcglib/apps/test/trackball/main.cpp	/^bool init() {$/;"	f
init	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodDecomposition
init	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLDLT
init	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLLT
init	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSupernodalLLT
init	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    void init()$/;"	f	class:Eigen::Block
init	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  inline void init(const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::coeff_visitor
init	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void init()$/;"	f	class:Eigen::IterativeSolverBase
init	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLDLT
init	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLLT
init	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLU
init	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::init()$/;"	f	class:Eigen::PastixBase
init	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(double estimatedDensity)$/;"	f	class:Eigen::internal::AmbiVector
init	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(int mode)$/;"	f	class:Eigen::internal::AmbiVector
init	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    void init()$/;"	f	class:Eigen::SparseSparseProduct
init	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperILU
init	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLU
init	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLUBase
init	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void init()$/;"	f	class:Eigen::UmfPackLU
init	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  template<typename Iter> void init(Iter begin, Iter end) { init(begin, end, 0, 0); }$/;"	f	class:Eigen::KdBVH
init	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  template<typename OIter, typename BIter> void init(OIter begin, OIter end, BIter boxBegin, BIter boxEnd)$/;"	f	class:Eigen::KdBVH
init	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void init()$/;"	f	class:Eigen::IterationController
init	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    void init()$/;"	f	class:Scaling
init	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	inline void init() { mCount = 0; }$/;"	f	class:HeapMaxPriorityQueue
initAcc	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(AccPacket& p)$/;"	f	class:Eigen::internal::gebp_traits
initAcc	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(DoublePacket& p)$/;"	f	class:Eigen::internal::gebp_traits
initAcc	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(Scalar& p) { p = Scalar(0); }$/;"	f	class:Eigen::internal::gebp_traits
initAssignment	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    void initAssignment(const Other& other)$/;"	f	class:Eigen::SparseMatrix
initFactorization	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void initFactorization(const MatrixType& a)$/;"	f	class:Eigen::SuperLUBase
initFrancisQRStep	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)$/;"	f	class:Eigen::RealSchur
initFromGrid	vcglib/vcg/space/rasterized_outline2_packer.h	/^    void initFromGrid(int rast_i) {$/;"	f	class:vcg::RasterizedOutline2
initGL	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^void initGL()$/;"	f
initGL	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^void initGL()$/;"	f
initGrid	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^void initGrid(CMesh & m)$/;"	f
initMesh	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::initMesh(QString message)$/;"	f	class:GLArea
initMesh	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void initMesh()$/;"	f
initMeshInfo	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^void initMeshInfo(MeshInfo &mi)$/;"	f
initParallel	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^inline void initParallel()$/;"	f	namespace:Eigen
initParallelSession	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void initParallelSession() const$/;"	f	struct:Eigen::internal::gemm_functor
initSDL	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^bool initSDL(const std::string &str) {$/;"	f
initSDL	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^bool initSDL(const std::string &str) {$/;"	f
init_bins	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void init_bins(mstate m) {$/;"	f	file:
init_called	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	bool init_called;$/;"	m	class:SplatRenderer
init_heap	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^void init_heap(MyPolyMesh &m, vcg::LocalOptimization<MyPolyMesh> &loc, bool adaptive)$/;"	f
init_malloc_global_mutex	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void init_malloc_global_mutex() {$/;"	f	file:
init_mparams	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static int init_mparams(void) {$/;"	f	file:
init_top	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void init_top(mstate m, mchunkptr p, size_t psize) {$/;"	f	file:
init_user_mstate	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static mstate init_user_mstate(char* tbase, size_t tsize) {$/;"	f	file:
initial_state	vcglib/wrap/gui/trackmode.h	/^  float initial_state;$/;"	m	class:vcg::PathMode
initial_status	vcglib/wrap/gui/trackmode.h	/^  Point3f initial_status;$/;"	m	class:vcg::AreaMode
initialize	vcglib/vcg/math/random_generator.h	/^	void initialize(unsigned int seed)$/;"	f	class:vcg::math::MarsenneTwisterRNG
initialize	vcglib/vcg/math/random_generator.h	/^	void initialize(unsigned int seed)$/;"	f	class:vcg::math::SubtractiveRingRNG
initialize	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void initialize(int nr, int nc) {$/;"	f	class:SparseMatrixData
initialize	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void initialize(unsigned int nr, unsigned int nc) {$/;"	f	class:SparseSystemData
initializeByArray	vcglib/vcg/math/random_generator.h	/^	void initializeByArray(unsigned int init_key[], int key_length)$/;"	f	class:vcg::math::MarsenneTwisterRNG
initializeGL	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::initializeGL() { $/;"	f	class:GLArea
initializeGL	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::initializeGL ()$/;"	f	class:GLArea
initializeGL	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void GLWidget::initializeGL ()$/;"	f	class:GLWidget
initializeGL	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::initializeGL()$/;"	f	class:GLWidget
initializeMain	vcglib/apps/trimeshinfo/XMLTree.h	/^void XMLTree::initializeMain()$/;"	f	class:XMLTree
initializeTarget	vcglib/wrap/glw/context.h	/^		void initializeTarget(const TBindingParams & params)$/;"	f	class:glw::Context
initializeTargets	vcglib/wrap/glw/context.h	/^		void initializeTargets(void)$/;"	f	class:glw::Context
inner	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon40
inner	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon41
inner	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    inner = Start % Derived::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon229
inner	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    inner = index % int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon231
inner	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    inline Index inner() const { return m_inner.value(); }$/;"	f	class:Eigen::Stride
innerInd	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *innerInd;$/;"	m	struct:Eigen::SluMatrix::__anon434
innerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index* innerIndexPtr() { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix
innerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix
innerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    inline Index* innerIndexPtr()$/;"	f	class:Eigen::SparseInnerVectorSet
innerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Index* innerIndexPtr() const$/;"	f	class:Eigen::SparseInnerVectorSet
innerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* innerIndexPtr() { return &m_data.index(0); }$/;"	f	class:Eigen::SparseMatrix
innerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return &m_data.index(0); }$/;"	f	class:Eigen::SparseMatrix
innerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index* innerIndexPtr() { return &m_data.index(0); }$/;"	f	class:Eigen::SparseVector
innerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Index* innerIndexPtr() const { return &m_data.index(0); }$/;"	f	class:Eigen::SparseVector
innerNonZeroPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* innerNonZeroPtr() { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix
innerNonZeroPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* innerNonZeroPtr() const { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix
innerNonZeros	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Eigen::Map<Matrix<Index,Dynamic,1> > innerNonZeros() { return Eigen::Map<Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix
innerNonZeros	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    const  Eigen::Map<const Matrix<Index,Dynamic,1> > innerNonZeros() const { return Eigen::Map<const Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix
innerNonZeros	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index innerNonZeros(Index j) const { return m_data[j].size(); }$/;"	f	class:Eigen::DynamicSparseMatrix
innerSize	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    Index innerSize() const$/;"	f	class:Eigen::DenseBase
innerSize	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix
innerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::SparseMatrix
innerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index innerSize() const { return (int(Flags)&RowMajorBit) ? this->cols() : this->rows(); }$/;"	f	class:Eigen::SparseMatrixBase
innerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index innerSize() const { return m_size; }$/;"	f	class:Eigen::SparseVector
innerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  inline Index innerSize() const { return m_matrix.innerSize(); }$/;"	f	class:Eigen::SparseView
innerSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index innerSize() const {$/;"	f	class:Eigen::SkylineMatrix
innerSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    Index innerSize() const {$/;"	f	class:Eigen::SkylineMatrixBase
innerSize	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::DynamicSparseMatrix
innerStride	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Array
innerStride	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ArrayWrapper
innerStride	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::MatrixWrapper
innerStride	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Block
innerStride	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl
innerStride	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::DenseCoeffsBase
innerStride	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Diagonal
innerStride	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::Flagged
innerStride	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess
innerStride	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Map
innerStride	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Matrix
innerStride	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::NestByValue
innerStride	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Reverse
innerStride	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfAdjointView
innerStride	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp
innerStride	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::SwapWrapper
innerStride	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline Index innerStride() const { return derived().nestedExpression().innerStride(); }$/;"	f	class:Eigen::TransposeImpl
innerStride	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return derived().innerStride(); }$/;"	f	class:Eigen::TriangularBase
innerStride	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::TriangularView
innerVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::innerVector(Index outer)$/;"	f	class:Eigen::SparseMatrixBase
innerVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::innerVector(Index outer) const$/;"	f	class:Eigen::SparseMatrixBase
innerVectors	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseMatrixBase
innerVectors	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize) const$/;"	f	class:Eigen::SparseMatrixBase
inner_stride_at_compile_time	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time$/;"	s	namespace:Eigen::internal
inner_stride_at_compile_time	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
inplace_decomposition	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  static bool inplace_decomposition(MatrixType& m)$/;"	f	struct:Eigen::internal::LLT_Traits
inplace_transpose_selector	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,false> { \/\/ non square matrix$/;"	s	namespace:Eigen::internal
inplace_transpose_selector	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,true> { \/\/ square matrix$/;"	s	namespace:Eigen::internal
inproduct5	vcglib/vcg/math/quadric5.h	/^  ScalarType inline inproduct5(const ScalarType a[5], const ScalarType b[5])$/;"	f	namespace:vcg::math
input	vcglib/wrap/gcache/cache.h	/^    Provider<Token> *input;$/;"	m	class:vcg::Cache
inputs	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^  int inputs() const { return m_inputs; }$/;"	f	struct:Functor
inputs	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^  int inputs() const { return m_inputs; }$/;"	f	struct:Functor
inputs	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  int inputs() const { return m_inputs; }$/;"	f	struct:TestFunc1
inputs	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  int inputs() const { return m_inputs; }$/;"	f	struct:TestFunc1
insert	vcglib/apps/pivoting/ring.h	/^    iterator insert(const T& x){$/;"	f	class:ring::iterator
insert	vcglib/apps/pivoting/ring.h	/^  iterator insert(iterator &i, const T& x) {$/;"	f	class:ring
insert	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insert	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    Scalar& insert(Index i)$/;"	f	class:Eigen::SparseVector
insert	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseVector
insert	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::deque
insert	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::deque
insert	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^    iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::list
insert	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^    void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::list
insert	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::vector
insert	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::vector
insert	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    EIGEN_DONT_INLINE Scalar & insert(Index row, Index col) {$/;"	f	class:Eigen::SkylineMatrix
insert	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::DynamicSparseMatrix
insert	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	inline void insert(Index index, Weight weight)$/;"	f	class:HeapMaxPriorityQueue
insertAndFlag	vcglib/vcg/complex/algorithms/nring.h	/^    void insertAndFlag(FaceType* f)$/;"	f	class:vcg::tri::Nring
insertAndFlag	vcglib/vcg/complex/algorithms/nring.h	/^    void insertAndFlag(VertexType* v)$/;"	f	class:vcg::tri::Nring
insertAndFlag1Ring	vcglib/vcg/complex/algorithms/nring.h	/^    void insertAndFlag1Ring(VertexType* v)$/;"	f	class:vcg::tri::Nring
insertBack	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBack(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertBack	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBack(Index i)$/;"	f	class:Eigen::SparseVector
insertBack	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Scalar& insertBack(Index row, Index col)$/;"	f	class:Eigen::DynamicSparseMatrix
insertBackByOuterInner	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix
insertBackByOuterInner	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseVector
insertBackByOuterInner	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::DynamicSparseMatrix
insertBackByOuterInnerUnordered	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInnerUnordered(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix
insertBackUncompressed	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertByOuterInner	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertByOuterInner(Index j, Index i)$/;"	f	class:Eigen::SparseMatrix
insertCompressed	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertCompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertMaterialElementLayer	vcglib/wrap/io_trimesh/export_fbx.h	/^	static void insertMaterialElementLayer(KFbxMesh* vcgmesh)$/;"	f	class:ExporterFBX
insertMaterialInfoAndTextureName	vcglib/wrap/io_trimesh/import_fbx.h	/^		void insertMaterialInfoAndTextureName(KFbxSurfaceMaterial& mat,const char* colorAttributeName,OpenMeshType& m)$/;"	f	class:ImporterFBX::VCGMaterialBridge
insertUncompressed	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE Scalar& insertUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insert_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define insert_chunk(/;"	d	file:
insert_large_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define insert_large_chunk(/;"	d	file:
insert_small_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define insert_small_chunk(/;"	d	file:
inserted_objects	vcglib/vcg/math/disjoint_set.h	/^		STDEXT::hash_map< OBJECT_TYPE*, int > inserted_objects;$/;"	m	class:vcg::DisjointSet
inserted_objects	vcglib/vcg/math/disjoint_set.h	/^		STDEXT::hash_map< OBJECT_TYPE*, int, SimpleObjHashFunc > inserted_objects;$/;"	m	class:vcg::DisjointSet
instances	vcglib/apps/trimeshinfo/InstancesNode.h	/^	NodeGroup instances;$/;"	m	class:InstancesNode
int16_t	vcglib/wrap/gcache/cache.h	/^typedef __int16 int16_t;$/;"	t
int32_t	vcglib/wrap/gcache/cache.h	/^typedef __int32 int32_t;$/;"	t
int64_t	vcglib/wrap/gcache/cache.h	/^typedef __int64 int64_t;$/;"	t
intFunc	vcglib/vcg/complex/algorithms/refine.h	/^     InterpolatorFunctorType *intFunc; \/\/\/ This callback is called to fill up$/;"	m	struct:vcg::tri::MidPoint
intValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^					int intValue;$/;"	m	union:vcg::AABBBinaryTree::AABBBinaryTreeNode::SharedDataUnion
int_funct	vcglib/vcg/space/index/space_iterators.h	/^		INTFUNCTOR &int_funct;$/;"	m	class:vcg::RayIterator
int_value	vcglib/wrap/system/qgetopt.h	/^    int *int_value;$/;"	m	struct:GetOpt::Option
integerVar	vcglib/wrap/miq/core/vertex_indexing.h	/^    int integerVar;$/;"	m	struct:SeamInfo
integer_jumps_bary	vcglib/wrap/miq/core/poisson_solver.h	/^	bool integer_jumps_bary;$/;"	m	class:PoissonSolver
integer_rounding	vcglib/wrap/miq/core/poisson_solver.h	/^    bool integer_rounding;$/;"	m	class:PoissonSolver
intensity	vcglib/wrap/io_trimesh/import_ply.h	/^	float intensity;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
interlockedcompareexchange	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define interlockedcompareexchange /;"	d	file:
interlockedexchange	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define interlockedexchange /;"	d	file:
internal	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^namespace internal{$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Cholesky/LLT_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Array.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Block.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^namespace internal$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/GlobalFunctions.h	/^  namespace internal$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/IO.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Map.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Product.h	/^namespace internal {$/;"	n
internal	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Random.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Select.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/StableNorm.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/util/Macros.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Core/util/XprHelper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Geometry/Umeyama.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Householder/BlockHouseholder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Householder/Householder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/LU/PartialPivLU_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/OrderingMethods/Amd.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/QR/HouseholderQR_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/misc/Image.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/MoreVectorization/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/chkder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/covar.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/dogleg.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/fdjac1.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/lmpar.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/qrsolv.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/r1mpyq.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/r1updt.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/rwupdt.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^namespace internal $/;"	n	namespace:Eigen
internal	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^    namespace internal {$/;"	n	namespace:Eigen	file:
internal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^namespace internal{$/;"	n	namespace:mpfr
internal	vcglib/eigenlib/unsupported/test/polynomialsolver.cpp	/^namespace internal {$/;"	n	namespace:Eigen	file:
internal	vcglib/eigenlib/unsupported/test/polynomialutils.cpp	/^namespace internal {$/;"	n	namespace:Eigen	file:
internal_free	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define internal_free(/;"	d	file:
internal_mallinfo	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static struct mallinfo internal_mallinfo(mstate m) {$/;"	f	file:
internal_malloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define internal_malloc(/;"	d	file:
internal_malloc_stats	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void internal_malloc_stats(mstate m) {$/;"	f	file:
internal_memalign	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {$/;"	f	file:
internal_realloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void* internal_realloc(mstate m, void* oldmem, size_t bytes) {$/;"	f	file:
interpret_texture_name	vcglib/wrap/ply/plylib.cpp	/^void interpret_texture_name(const char*a, const char*fn, char*output){$/;"	f	namespace:vcg::ply
intersect	vcglib/apps/pivoting/pivot.h	/^    bool intersect(int v0, int v1, Point3f &center) {$/;"	f	class:vcg::tri::Pivot
intersectObject	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  bool intersectObject(const Object1 &obj) { return intersector.intersectObjectObject(obj, stored); }$/;"	f	struct:Eigen::internal::intersector_helper1
intersectObject	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  bool intersectObject(const Object2 &obj) { return intersector.intersectObjectObject(stored, obj); }$/;"	f	struct:Eigen::internal::intersector_helper2
intersectObject	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  bool intersectObject(const BallType &b) {$/;"	f	struct:BallPointStuff
intersectObjectObject	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  bool intersectObjectObject(const BallType &b, const VectorType &v){$/;"	f	struct:BallPointStuff
intersectObjectObject	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  bool intersectObjectObject(const BallType &b1, const BallType &b2){$/;"	f	struct:BallPointStuff
intersectObjectVolume	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  bool intersectObjectVolume(const BallType &b, const BoxType &r) { ++calls; return r.squaredExteriorDistance(b.center) < SQR(b.radius); }$/;"	f	struct:BallPointStuff
intersectVolume	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  bool intersectVolume(const Volume1 &vol) { return intersector.intersectVolumeObject(vol, stored); }$/;"	f	struct:Eigen::internal::intersector_helper1
intersectVolume	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  bool intersectVolume(const Volume2 &vol) { return intersector.intersectObjectVolume(stored, vol); }$/;"	f	struct:Eigen::internal::intersector_helper2
intersectVolume	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  bool intersectVolume(const BoxType &r) { ++calls; return r.contains(p); }$/;"	f	struct:BallPointStuff
intersectVolumeObject	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  bool intersectVolumeObject(const BoxType &r, const BallType &b) { ++calls; return r.squaredExteriorDistance(b.center) < SQR(b.radius); }$/;"	f	struct:BallPointStuff
intersectVolumeObject	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  bool intersectVolumeObject(const BoxType &r, const VectorType &v) { ++calls; return r.contains(v); }$/;"	f	struct:BallPointStuff
intersectVolumeVolume	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  bool intersectVolumeVolume(const BoxType &r1, const BoxType &r2) { ++calls; return !(r1.intersection(r2)).isNull(); }$/;"	f	struct:BallPointStuff
intersect_helper	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^bool intersect_helper(const BVH &tree, Intersector &intersector, typename BVH::Index root)$/;"	f	namespace:Eigen::internal
intersection	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other)$/;"	f	class:Eigen::Hyperplane
intersection	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim>::intersection(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine
intersection	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox intersection(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
intersection	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other) const$/;"	f	class:Eigen::Hyperplane
intersection	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersection	vcglib/vcg/space/index/space_iterators.h	/^			CoordType intersection;$/;"	m	struct:vcg::ClosestIterator::Entry_Type
intersection	vcglib/vcg/space/index/space_iterators.h	/^			CoordType intersection;$/;"	m	struct:vcg::RayIterator::Entry_Type
intersectionParameter	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersectionPoint	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersections	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	std::vector<CMesh::FaceType *> intersections;$/;"	m	struct:MeshInfo	file:
intersector	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Intersector &intersector;$/;"	m	struct:Eigen::internal::intersector_helper1
intersector	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Intersector &intersector;$/;"	m	struct:Eigen::internal::intersector_helper2
intersector_helper1	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  intersector_helper1(const Object2 &inStored, Intersector &in) : stored(inStored), intersector(in) {}$/;"	f	struct:Eigen::internal::intersector_helper1
intersector_helper1	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^struct intersector_helper1$/;"	s	namespace:Eigen::internal
intersector_helper2	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  intersector_helper2(const Object1 &inStored, Intersector &in) : stored(inStored), intersector(in) {}$/;"	f	struct:Eigen::internal::intersector_helper2
intersector_helper2	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^struct intersector_helper2$/;"	s	namespace:Eigen::internal
inv	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv( Scalar * dst,const Complex * src,int nfft) $/;"	f	struct:Eigen::internal::fftw_impl
inv	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv(Complex * dst,const Complex  *src,int nfft)$/;"	f	struct:Eigen::internal::fftw_impl
inv	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv(complex_type * dst,complex_type * src,int nfft) {$/;"	f	struct:Eigen::internal::fftw_plan
inv	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv(scalar_type * dst,complex_type * src,int nfft) {$/;"	f	struct:Eigen::internal::fftw_plan
inv	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void inv( Scalar * dst,const Complex * src,int nfft) $/;"	f	struct:Eigen::internal::kissfft_impl
inv	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void inv(Complex * dst,const Complex  *src,int nfft)$/;"	f	struct:Eigen::internal::kissfft_impl
inv2	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv2( complex_type * dst,complex_type * src,int n0,int n1) {$/;"	f	struct:Eigen::internal::fftw_plan
inv2	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      void inv2(Complex * dst, const Complex * src, int n0,int n1)$/;"	f	struct:Eigen::internal::fftw_impl
inv2	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void inv2( Complex * dst,const Complex *src,int n0,int n1)$/;"	f	struct:Eigen::internal::kissfft_impl
invDirection	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^		CoordType invDirection;$/;"	m	class:vcg::AABBBinaryTreeRay::Ray3Ex
invalidateReferencesToAllObjects	vcglib/wrap/glw/context.h	/^		void invalidateReferencesToAllObjects(void)$/;"	f	class:glw::Context
inverse	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inverse() const$/;"	f	class:Eigen::DiagonalBase
inverse	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> inverse() const$/;"	f	class:Eigen::PermutationBase
inverse	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> inverse() const$/;"	f	class:Eigen::TranspositionsBase
inverse	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::inverse() const$/;"	f	class:Eigen::Cwise
inverse	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis
inverse	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::inverse() const$/;"	f	class:Eigen::Quaternion
inverse	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D
inverse	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase
inverse	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling inverse() const$/;"	f	class:Eigen::Scaling
inverse	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::inverse(TransformTraits traits) const$/;"	f	class:Eigen::Transform
inverse	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation
inverse	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis
inverse	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^inline Quaternion<typename internal::traits<Derived>::Scalar> QuaternionBase<Derived>::inverse() const$/;"	f	class:Eigen::QuaternionBase
inverse	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D
inverse	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase
inverse	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling inverse() const$/;"	f	class:Eigen::UniformScaling
inverse	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::inverse(TransformTraits hint) const$/;"	f	class:Eigen::Transform
inverse	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation
inverse	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType inverse() const { return adjoint(); }$/;"	f	class:Eigen::HouseholderSequence
inverse	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline const internal::solve_retval<FullPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::FullPivLU
inverse	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^inline const internal::inverse_impl<Derived> MatrixBase<Derived>::inverse() const$/;"	f	class:Eigen::MatrixBase
inverse	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    inline const internal::solve_retval<PartialPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::PartialPivLU
inverse	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::ColPivHouseholderQR
inverse	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::FullPivHouseholderQR
inverse	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^inverse() const$/;"	f
inverse	vcglib/wrap/gui/view.h	/^  Matrix44<T> inverse;$/;"	m	class:vcg::View
inverse_impl	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  inverse_impl(const MatrixType& matrix)$/;"	f	struct:Eigen::internal::inverse_impl
inverse_impl	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct inverse_impl : public ReturnByValue<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal
invertQuality	vcglib/vcg/complex/algorithms/point_sampling.h	/^  bool invertQuality;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
io	vcglib/wrap/dae/poly_triangulator.h	/^namespace io {	$/;"	n	namespace:vcg::tri
io	vcglib/wrap/dae/util_dae.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_edgemesh/export_dxf.h	/^		namespace io {$/;"	n	namespace:vcg::edg
io	vcglib/wrap/io_edgemesh/export_svg.h	/^		namespace io $/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_tetramesh/export_ply.h	/^namespace io {$/;"	n	namespace:vcg::tetra
io	vcglib/wrap/io_tetramesh/export_ts.h	/^namespace io {$/;"	n	namespace:vcg::tetra
io	vcglib/wrap/io_tetramesh/import_ply.h	/^namespace io {$/;"	n	namespace:vcg::tetra
io	vcglib/wrap/io_tetramesh/import_ts.h	/^namespace io {$/;"	n	namespace:vcg::tetra
io	vcglib/wrap/io_tetramesh/io_ply.h	/^namespace io {$/;"	n	namespace:vcg::tetra
io	vcglib/wrap/io_trimesh/export.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_3ds.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_ctm.h	/^        namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_dae.h	/^namespace io$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_dxf.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_field.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_gts.h	/^		namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_idtf.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_obj.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_off.h	/^		namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_ply.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_smf.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_stl.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_u3d.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_vmi.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/export_vrml.h	/^		namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_asc.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_ctm.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_dae.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_field.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_gts.h	/^		namespace io$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_nvm.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_obj.h	/^        namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_off.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_out.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_ply.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_ptx.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_raw.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_smf.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_stl.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/import_vmi.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/io_fan_tessellator.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/io_mask.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/io_material.h	/^namespace io {$/;"	n	namespace:vcg::tri
io	vcglib/wrap/io_trimesh/io_ply.h	/^namespace io {$/;"	n	namespace:vcg::tri
iparm	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<Index,IPARM_SIZE,1>& iparm()$/;"	f	class:Eigen::PastixBase
iparm	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int& iparm(int idxparam)$/;"	f	class:Eigen::PastixBase
isAcquired	vcglib/wrap/glw/context.h	/^		bool isAcquired(void) const$/;"	f	class:glw::Context
isApprox	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    bool isApprox(const DiagonalBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase
isApprox	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase
isApprox	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isApprox($/;"	f	class:Eigen::DenseBase
isApprox	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(bool x, bool y, bool)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isApprox	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApprox	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApprox	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline bool isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal
isApprox	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView
isApprox	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    bool isApprox(const TriangularView<OtherMatrixType, Mode>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView
isApprox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AlignedBox
isApprox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AngleAxis
isApprox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Hyperplane
isApprox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::ParametrizedLine
isApprox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  bool isApprox(const Quaternion& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Quaternion
isApprox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Rotation2D
isApprox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  bool isApprox(const Scaling& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Scaling
isApprox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  bool isApprox(const Transform& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Transform
isApprox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Translation
isApprox	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, RealScalar prec = ScalarTraits::dummy_precision()) const$/;"	f	class:Eigen::AlignedBox
isApprox	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::AngleAxis
isApprox	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Hyperplane
isApprox	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::ParametrizedLine
isApprox	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  bool isApprox(const QuaternionBase<OtherDerived>& other, RealScalar prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::QuaternionBase
isApprox	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Rotation2D
isApprox	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  bool isApprox(const UniformScaling& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::UniformScaling
isApprox	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  bool isApprox(const Transform& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Transform
isApprox	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Translation
isApprox	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase
isApprox	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const SparseMatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase
isApproxOrLessThan	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApproxOrLessThan	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApproxOrLessThan	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isApproxOrLessThan	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal
isApproxToConstant	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isApproxToConstant$/;"	f	class:Eigen::DenseBase
isApprox_selector	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector$/;"	s	namespace:Eigen::internal
isApprox_selector	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isArray	vcglib/wrap/glw/renderable.h	/^		bool isArray(void) const$/;"	f	class:glw::SafeRenderable
isArray	vcglib/wrap/glw/renderbuffer.h	/^		virtual bool isArray(void) const$/;"	f	class:glw::Renderbuffer
isArray	vcglib/wrap/glw/texture2d.h	/^		virtual bool isArray(void) const$/;"	f	class:glw::Texture2D
isArray	vcglib/wrap/glw/texturecube.h	/^		virtual bool isArray(void) const$/;"	f	class:glw::TextureCube
isBorder	vcglib/vcg/complex/algorithms/update/curvature.h	/^    bool isBorder;$/;"	m	struct:vcg::tri::UpdateCurvature::AdjVertex
isBorderCorner	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static bool isBorderCorner(FaceType *f, typename MeshType::template PerVertexAttributeHandle<VertexPointer> &sources)$/;"	f	class:vcg::tri::VoronoiProcessing
isBorderVertex	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static bool isBorderVertex(VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
isCompiled	vcglib/wrap/glw/shader.h	/^		bool isCompiled(void) const$/;"	f	class:glw::SafeShader
isCompiled	vcglib/wrap/glw/shader.h	/^		bool isCompiled(void) const$/;"	f	class:glw::Shader
isComplete	vcglib/wrap/glw/framebuffer.h	/^		bool isComplete(void) const$/;"	f	class:glw::BoundFramebuffer
isCompressed	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline bool isCompressed() const { return m_innerNonZeros==0; }$/;"	f	class:Eigen::SparseMatrix
isConstant	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isConstant$/;"	f	class:Eigen::DenseBase
isDiagonal	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^bool MatrixBase<Derived>::isDiagonal(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase
isEmpty	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline bool isEmpty() const { return (m_min.array() > m_max.array()).any(); }$/;"	f	class:Eigen::AlignedBox
isEqualFuzzy	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool isEqualFuzzy(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
isEqualFuzzy	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool isEqualFuzzy(const mpreal& a, const mpreal& b, const mpreal& eps)$/;"	f	namespace:mpfr
isEqualUlps	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool isEqualUlps(const mpreal& a, const mpreal& b, int maxUlps)$/;"	f	namespace:mpfr
isFixed	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  SimpleTempData<typename MESH_TYPE::VertContainer, int > isFixed;$/;"	m	class:vcg::tri::TextureOptimizer
isFull	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	inline bool isFull() const { return mCount == mMaxSize; }$/;"	f	class:HeapMaxPriorityQueue
isFullRank	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^    bool isFullRank() const {$/;"	f	class:Eigen::QR
isHeap	vcglib/wrap/gcache/dheap.h	/^  bool isHeap() { \/\/checks everything is in order$/;"	f	class:DHeap
isHeap	vcglib/wrap/gcache/dheap.h	/^  bool isHeap() { return heap.isHeap(); }$/;"	f	class:PtrDHeap
isIdentity	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^bool MatrixBase<Derived>::isIdentity$/;"	f	class:Eigen::MatrixBase
isInCache	vcglib/wrap/gcache/token.h	/^    bool isInCache() { return count != OUTSIDE; }  \/\/careful, can be used only when provider thread is locked.$/;"	f	class:vcg::Token
isInjective	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivLU
isInjective	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::ColPivHouseholderQR
isInjective	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivHouseholderQR
isInside	vcglib/img/img_image.h	/^  inline bool isInside(float x, float y) const$/;"	f	class:img::Image
isInside	vcglib/img/img_image.h	/^  inline bool isInside(int x, int y) const$/;"	f	class:img::Image
isInvertible	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivLU
isInvertible	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::ColPivHouseholderQR
isInvertible	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivHouseholderQR
isLinked	vcglib/wrap/glw/program.h	/^		bool isLinked(void) const$/;"	f	class:glw::Program
isLinked	vcglib/wrap/glw/program.h	/^		bool isLinked(void) const$/;"	f	class:glw::SafeProgram
isLocked	vcglib/wrap/gcache/token.h	/^    bool isLocked() {$/;"	f	class:vcg::Token
isLowerTriangular	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isLowerTriangular(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase
isMapped	vcglib/wrap/glw/buffer.h	/^		bool isMapped(GLenum target, GLint unit) const$/;"	f	class:glw::Buffer
isMapped	vcglib/wrap/glw/buffer.h	/^		bool isMapped(void) const$/;"	f	class:glw::BoundBuffer
isMax	vcglib/wrap/gcache/dheap.h	/^  int isMax(int e) const { return e & 1; }$/;"	f	class:DHeap
isMuchSmallerThan	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase
isMuchSmallerThan	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isMuchSmallerThan	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const Scalar&, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isMuchSmallerThan	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isMuchSmallerThan	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen::internal
isMuchSmallerThan_object_selector	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_object_selector	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector<Derived, true>$/;"	s	namespace:Eigen::internal
isNegative	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    inline bool isNegative(void) const$/;"	f	class:Eigen::LDLT
isNull	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool isNull() const { return (m_min.cwise() > m_max).any(); }$/;"	f	class:Eigen::AlignedBox
isNull	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline bool isNull() const { return isEmpty(); }$/;"	f	class:Eigen::AlignedBox
isNull	vcglib/wrap/glw/bookkeeping.h	/^		bool isNull(void) const$/;"	f	class:glw::detail::ObjectSharedPointer
isNull	vcglib/wrap/glw/bookkeeping.h	/^		bool isNull(void) const$/;"	f	class:glw::detail::RefCountedObject
isNull	vcglib/wrap/glw/framebuffer.h	/^		bool isNull(void) const$/;"	f	class:glw::RenderTarget
isNull	vcglib/wrap/glw/object.h	/^		bool isNull(void) const$/;"	f	class:glw::BoundObject
isNull	vcglib/wrap/glw/object.h	/^		bool isNull(void) const$/;"	f	class:glw::SafeObject
isOnes	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isOnes$/;"	f	class:Eigen::DenseBase
isOrthogonal	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isOrthogonal$/;"	f	class:Eigen::MatrixBase
isPositive	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    inline bool isPositive() const$/;"	f	class:Eigen::LDLT
isPositiveDefinite	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    inline bool isPositiveDefinite() const$/;"	f	class:Eigen::LDLT
isPositiveDefinite	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    bool isPositiveDefinite() const { return true; }$/;"	f	class:Eigen::LLT
isRValue	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isRValue() const { return m_isRValue; }$/;"	f	class:Eigen::SparseMatrixBase
isRValue	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    bool isRValue() const {$/;"	f	class:Eigen::SkylineMatrixBase
isReliable	vcglib/wrap/dae/xmldocumentmanaging.h	/^	bool isReliable() const $/;"	f	class:XMLDocumentWriter
isSticky	vcglib/wrap/gui/trackmode.cpp	/^bool AreaMode::isSticky() {$/;"	f	class:AreaMode
isSticky	vcglib/wrap/gui/trackmode.cpp	/^bool NavigatorWasdMode::isSticky(){$/;"	f	class:NavigatorWasdMode
isSticky	vcglib/wrap/gui/trackmode.cpp	/^bool PathMode::isSticky() {$/;"	f	class:PathMode
isSticky	vcglib/wrap/gui/trackmode.cpp	/^bool TrackMode::isSticky() {$/;"	f	class:TrackMode
isSupported	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	bool isSupported() {return mIsSupported;}$/;"	f	class:SplatRenderer
isSurjective	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivLU
isSurjective	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::ColPivHouseholderQR
isSurjective	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivHouseholderQR
isThereTag	vcglib/wrap/dae/util_dae.h	/^		inline static bool isThereTag(const QDomDocument n,const QString& tagname)$/;"	f	class:vcg::tri::io::UtilDAE
isThereTag	vcglib/wrap/dae/util_dae.h	/^		inline static bool isThereTag(const QDomNode n,const QString& tagname)$/;"	f	class:vcg::tri::io::UtilDAE
isThereTag	vcglib/wrap/dae/util_dae.h	/^		inline static bool isThereTag(const QDomNodeList& list)$/;"	f	class:vcg::tri::io::UtilDAE
isUnitary	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isUnitary(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase
isUpperTriangular	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isUpperTriangular(RealScalar prec) const$/;"	f	class:Eigen::MatrixBase
isValid	vcglib/img/img_image.h	/^  inline bool isValid() const$/;"	f	class:img::Image
isValid	vcglib/wrap/glw/context.h	/^		bool isValid(void) const$/;"	f	class:glw::Context
isValid	vcglib/wrap/glw/object.h	/^		bool isValid(void) const$/;"	f	class:glw::Object
isValid	vcglib/wrap/glw/object.h	/^		bool isValid(void) const$/;"	f	class:glw::SafeObject
isVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline bool isVector() const { return rows()==1 || cols()==1; }$/;"	f	class:Eigen::SparseMatrixBase
isVisible	vcglib/vcg/space/index/octree.h	/^        int						isVisible;$/;"	m	struct:vcg::OcreeRenderingSetting
isWaiting	vcglib/wrap/gcache/controller.h	/^  bool isWaiting() {$/;"	f	class:vcg::Controller
isWaiting	vcglib/wrap/gcache/door.h	/^  bool isWaiting() {$/;"	f	class:QDoor
isZero	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isZero(RealScalar prec) const$/;"	f	class:Eigen::DenseBase
is_aligned	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define is_aligned(/;"	d	file:
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	s	namespace:Eigen::internal
is_const	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_const	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
is_custom_malloc	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^bool       mpreal::is_custom_malloc = false;$/;"	m	class:mpfr::mpreal	file:
is_custom_malloc	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	static bool is_custom_malloc;$/;"	m	class:mpfr::mpreal
is_diagonal	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T, int S> struct is_diagonal<DiagonalMatrix<T,S> >$/;"	s	namespace:Eigen
is_diagonal	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal$/;"	s	namespace:Eigen
is_diagonal	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalBase<T> >$/;"	s	namespace:Eigen
is_diagonal	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalWrapper<T> >$/;"	s	namespace:Eigen
is_extern_segment	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define is_extern_segment(/;"	d	file:
is_global	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define is_global(/;"	d	file:
is_granularity_aligned	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define is_granularity_aligned(/;"	d	file:
is_initialized	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define is_initialized(/;"	d	file:
is_inuse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define is_inuse(/;"	d	file:
is_large	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  enum { is_large = MaxSize == Dynamic ||$/;"	e	enum:Eigen::internal::product_size_category::__anon141
is_malloc_allowed	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline bool is_malloc_allowed() { return is_malloc_allowed_impl(false); }$/;"	f	namespace:Eigen::internal
is_malloc_allowed_impl	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline bool is_malloc_allowed_impl(bool update, bool new_value = false)$/;"	f	namespace:Eigen::internal
is_mmapped	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define is_mmapped(/;"	d	file:
is_mmapped_segment	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define is_mmapped_segment(/;"	d	file:
is_nonManifold_vertex	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static bool is_nonManifold_vertex(MeshType &m, VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
is_nonManifold_vertex	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static bool is_nonManifold_vertex(VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
is_page_aligned	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define is_page_aligned(/;"	d	file:
is_running	vcglib/wrap/system/multithreading/thread.h	/^            bool is_running(void) const$/;"	f	class:mt::thread
is_same	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_same	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
is_singlet_quad	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static bool is_singlet_quad(FacePointer fp)$/;"	f	class:vcg::tri::HalfEdgeTopology
is_small	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define is_small(/;"	d	file:
is_started	vcglib/wrap/system/multithreading/thread.h	/^            bool is_started(void) const$/;"	f	class:mt::thread
is_valid	vcglib/wrap/gl/gl_surface.h	/^		bool is_valid(void) const$/;"	f	class:vcg::gl_surface
isect2	vcglib/vcg/space/intersection/triangle_triangle3.h	/^inline void isect2(Point3<T> VTX0,Point3<T> VTX1,Point3<T> VTX2,float VV0,float VV1,float VV2,$/;"	f	namespace:vcg
isects	vcglib/vcg/complex/algorithms/clip.h	/^    EdgeIsect isects[6];$/;"	m	class:vcg::tri::TriMeshClipper::EdgeIntersections
isfinite	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^template<typename T> bool (isfinite)(const T& x)$/;"	f	namespace:Eigen::internal
isfinite	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool isfinite(const mpreal& v){	return (mpfr_number_p(v.mp)		!= 0);	}$/;"	f	namespace:mpfr
isinf	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool isinf	(const mpreal& v){	return (mpfr_inf_p(v.mp)		!= 0);	}$/;"	f	namespace:mpfr
isint	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool isint	(const mpreal& v){	return (mpfr_integer_p(v.mp)	!= 0);	}$/;"	f	namespace:mpfr
islist	vcglib/wrap/ply/plylib.h	/^	int    islist;				\/\/ Vero se e' una lista$/;"	m	class:vcg::ply::PlyProperty
islist	vcglib/wrap/ply/plylib.h	/^	int islist;					\/\/ 1 se lista, 0 altrimenti$/;"	m	class:vcg::ply::PropDescriptor
isnan	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool isnan	(const mpreal& v){	return (mpfr_nan_p(v.mp)		!= 0);	}$/;"	f	namespace:mpfr
isregular	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool isregular(const mpreal& v){	return (mpfr_regular_p(v.mp));}$/;"	f	namespace:mpfr
iszero	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool iszero	(const mpreal& v){	return (mpfr_zero_p(v.mp)		!= 0);	}$/;"	f	namespace:mpfr
it	vcglib/apps/pivoting/ring.h	/^    typename list<T>::iterator it;$/;"	m	class:ring::iterator
iter	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index iter;$/;"	m	class:Eigen::HybridNonLinearSolver
iter	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Index iter;$/;"	m	class:Eigen::LevenbergMarquardt
iterNum	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^     int iterNum;$/;"	m	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam::Stat
iteration	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    size_t iteration() const { return m_nit; }$/;"	f	class:Eigen::IterationController
iterations	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int iterations() const$/;"	f	class:Eigen::IterativeSolverBase
iterator	vcglib/apps/pivoting/ring.h	/^    iterator(): r(NULL) {}$/;"	f	class:ring::iterator
iterator	vcglib/apps/pivoting/ring.h	/^    iterator(list<T>& lst, const typename list<T>::iterator& i)$/;"	f	class:ring::iterator
iterator	vcglib/apps/pivoting/ring.h	/^  class iterator : $/;"	c	class:ring
iterator	vcglib/apps/trimeshinfo/Node.h	/^	typedef list<Node *>::iterator iterator;$/;"	t	class:NodeGroup
iwinner	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  int iwinner;											\/\/ winner == U[iwinner]$/;"	m	class:vcg::tri::FourPCS
jacobiSvd	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^MatrixBase<Derived>::jacobiSvd(unsigned int computationOptions) const$/;"	f	class:Eigen::MatrixBase
jacobian	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline JacobianType& jacobian() { return m_jacobian; }$/;"	f	class:Eigen::AutoDiffVector
jacobian	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline const JacobianType& jacobian() const { return m_jacobian; }$/;"	f	class:Eigen::AutoDiffVector
jeval	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    bool jeval;$/;"	m	class:Eigen::HybridNonLinearSolver
k	vcglib/vcg/math/camera.h	/^    S			k[4];				\/\/\/ 1st & 2nd order radial lens distortion coefficient (only the first 2 terms are used)$/;"	m	class:vcg::Camera
k1	vcglib/vcg/simplex/face/component.h	/^        S k1,k2;\/\/ max and min curvature values$/;"	m	struct:vcg::face::CurvatureDirBaseType
k1	vcglib/vcg/simplex/face/component_ocf.h	/^        S k1,k2;\/\/ max and min curvature values$/;"	m	struct:vcg::face::CurvatureDirOcfBaseType
k1	vcglib/vcg/simplex/vertex/component.h	/^          S k1,k2;\/\/ max and min curvature values$/;"	m	struct:vcg::vertex::CurvatureDirBaseType
k1	vcglib/vcg/simplex/vertex/component_occ.h	/^	S k1,k2;\/\/ max and min curvature values$/;"	m	struct:vcg::vertex::CurvatureDirTypeOcc
k1	vcglib/vcg/simplex/vertex/component_ocf.h	/^	S k1,k2;$/;"	m	struct:vcg::vertex::CurvatureDirTypeOcf
k1	vcglib/wrap/io_trimesh/import_ply.h	/^	float k1;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
k2	vcglib/vcg/simplex/face/component.h	/^        S k1,k2;\/\/ max and min curvature values$/;"	m	struct:vcg::face::CurvatureDirBaseType
k2	vcglib/vcg/simplex/face/component_ocf.h	/^        S k1,k2;\/\/ max and min curvature values$/;"	m	struct:vcg::face::CurvatureDirOcfBaseType
k2	vcglib/vcg/simplex/vertex/component.h	/^          S k1,k2;\/\/ max and min curvature values$/;"	m	struct:vcg::vertex::CurvatureDirBaseType
k2	vcglib/vcg/simplex/vertex/component_occ.h	/^	S k1,k2;\/\/ max and min curvature values$/;"	m	struct:vcg::vertex::CurvatureDirTypeOcc
k2	vcglib/vcg/simplex/vertex/component_ocf.h	/^	S k1,k2;$/;"	m	struct:vcg::vertex::CurvatureDirTypeOcf
k2	vcglib/wrap/io_trimesh/import_ply.h	/^	float k2;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
k3	vcglib/wrap/io_trimesh/import_ply.h	/^	float k3;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
k4	vcglib/wrap/io_trimesh/import_ply.h	/^	float k4;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
k_factor	vcglib/vcg/math/spherical_harmonics.h	/^	ScalarType k_factor[MAX_BAND][MAX_BAND];$/;"	m	class:vcg::math::ScalingFactor
kc	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex kc() const { return m_kc; }$/;"	f	class:Eigen::internal::level3_blocking
keep_diag	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    struct keep_diag {$/;"	s	class:Eigen::IncompleteLUT
keep_diag	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    struct keep_diag {$/;"	s	class:Eigen::SimplicialCholeskyBase
keepcost	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MALLINFO_FIELD_TYPE keepcost; \/* releasable (via malloc_trim) space *\/$/;"	m	struct:mallinfo	file:
keepcost	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^  MALLINFO_FIELD_TYPE keepcost; \/* releasable (via malloc_trim) space *\/$/;"	m	struct:mallinfo
kernel	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline const internal::kernel_retval<FullPivLU> kernel() const$/;"	f	class:Eigen::FullPivLU
kernel_retval	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^struct kernel_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
kernel_retval_base	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  kernel_retval_base(const DecompositionType& dec)$/;"	f	struct:Eigen::internal::kernel_retval_base
kernel_retval_base	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^template<typename _DecompositionType> struct kernel_retval_base$/;"	s	namespace:Eigen::internal
key	vcglib/wrap/gcache/door.h	/^  QAtomicInt key; \/\/keep tracks of door status$/;"	m	class:QDoor
key	vcglib/wrap/io_trimesh/import_out.h	/^    unsigned int id_img,key;$/;"	m	struct:vcg::tri::io::Correspondence
keyPressEvent	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::keyPressEvent (QKeyEvent * e)$/;"	f	class:GLArea
keyPressEvent	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void   keyPressEvent (unsigned char k,int x,int  y)$/;"	f
keyPressEvent	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void GLWidget::keyPressEvent (QKeyEvent * e)$/;"	f	class:GLWidget
keyPressEvent	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^ void GLWidget::keyPressEvent ( QKeyEvent * e ) {$/;"	f	class:GLWidget
keyReleaseEvent	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::keyReleaseEvent ( QKeyEvent * e )$/;"	f	class:GLArea
keyReleaseEvent	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::keyReleaseEvent (QKeyEvent * e)$/;"	f	class:GLArea
keyReleaseEvent	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void   keyReleaseEvent (unsigned char k,int x,int y)$/;"	f
keyReleaseEvent	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void GLWidget::keyReleaseEvent (QKeyEvent * e)$/;"	f	class:GLWidget
keypress	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		int ScreenH,ScreenW,pic_x,pic_y,keypress;$/;"	m	class:GLWidget
kill	vcglib/wrap/system/multithreading/thread.h	/^            virtual bool kill(void)$/;"	f	class:mt::thread
killHinge	vcglib/apps/pivoting/pivot.h	/^     void killHinge(std::list<Hinge>::iterator e) {$/;"	f	class:vcg::tri::Pivot
kiss_cpx_fft	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^struct kiss_cpx_fft$/;"	s	namespace:Eigen::internal
kissfft_impl	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^struct kissfft_impl$/;"	s	namespace:Eigen::internal
knots	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    const KnotVectorType& knots() const { return m_knots; }$/;"	f	class:Eigen::Spline
kroneckerProduct	vcglib/eigenlib/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^void kroneckerProduct(const MatrixBase<A>& a, const MatrixBase<B>& b, Matrix<CScalar,CRows,CCols,COptions,CMaxRows,CMaxCols>& c)$/;"	f	namespace:Eigen
kroneckerProduct	vcglib/eigenlib/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^void kroneckerProduct(const MatrixBase<A>& a, const MatrixBase<B>& b, MatrixBase<C> const & c_)$/;"	f	namespace:Eigen
kroneckerProduct	vcglib/eigenlib/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^void kroneckerProduct(const MatrixBase<A>& a, const SparseMatrixBase<B>& b, SparseMatrixBase<C>& c)$/;"	f	namespace:Eigen
kroneckerProduct	vcglib/eigenlib/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^void kroneckerProduct(const SparseMatrixBase<A>& a, const MatrixBase<B>& b, SparseMatrixBase<C>& c)$/;"	f	namespace:Eigen
kroneckerProduct	vcglib/eigenlib/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^void kroneckerProduct(const SparseMatrixBase<A>& a, const SparseMatrixBase<B>& b, SparseMatrixBase<C>& c)$/;"	f	namespace:Eigen
kroneckerProduct_full	vcglib/eigenlib/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^void kroneckerProduct_full(const Derived_A& A, const Derived_B& B, Derived_AB & AB)$/;"	f	namespace:Eigen::internal
kroneckerProduct_sparse	vcglib/eigenlib/unsupported/Eigen/src/KroneckerProduct/KroneckerTensorProduct.h	/^void kroneckerProduct_sparse(const Derived_A &A, const Derived_B &B, Derived_AB &AB)$/;"	f	namespace:Eigen::internal
l	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  volatile long l;$/;"	m	struct:win32_mlock_t	file:
l	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  volatile unsigned int l;$/;"	m	struct:pthread_mlock_t	file:
l	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& l() { return data[9];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
l1CacheSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l1CacheSize()$/;"	f	namespace:Eigen
l2CacheSize	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l2CacheSize()$/;"	f	namespace:Eigen
l2s	vcglib/wrap/miq/core/auxmath.h	/^inline double l2s( const double angle ){$/;"	f
lSize	vcglib/vcg/space/index/octree_template.h	/^	int						lSize;$/;"	m	class:vcg::OctreeTemplate
labelColor	vcglib/wrap/qt/Outline2ToQImage.h	/^      vcg::Color4b labelColor;$/;"	m	class:Outline2Dumper::Param
lanczos1_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    lanczos1_functor(void) : Functor<double>(6,24) {}$/;"	f	struct:lanczos1_functor
lanczos1_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct lanczos1_functor : Functor<double>$/;"	s	file:
lastCoeff	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    const Scalar& lastCoeff() const$/;"	f	class:Eigen::SparseInnerVectorSet
lastCoeff	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    const Scalar& lastCoeff() const$/;"	f	class:Eigen::SparseInnerVectorSet
lastF	vcglib/vcg/complex/algorithms/nring.h	/^    std::vector<FaceType*> lastF;$/;"	m	class:vcg::tri::Nring
lastPos	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^    QPoint lastPos;$/;"	m	class:GLWidget
lastV	vcglib/vcg/complex/algorithms/nring.h	/^    std::vector<VertexType*> lastV;$/;"	m	class:vcg::tri::Nring
last_nonopt	vcglib/wrap/system/getopt.cpp	/^static int last_nonopt;$/;"	v	file:
last_point	vcglib/wrap/gui/trackball.h	/^  Point3f last_point;$/;"	m	class:vcg::Trackball
last_seed	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  int last_seed;     \/\/used for new seeds when front is empty$/;"	m	class:vcg::tri::BallPivoting
last_time	vcglib/wrap/gui/trackball.h	/^	unsigned int last_time;$/;"	m	class:vcg::Trackball
last_track	vcglib/wrap/gui/trackball.h	/^  Similarityf last_track;$/;"	m	class:vcg::Trackball
last_view	vcglib/wrap/gui/trackball.h	/^  Similarityf last_view;$/;"	m	class:vcg::Trackball
layer	vcglib/wrap/glw/framebuffer.h	/^		GLint            layer;$/;"	m	class:glw::RenderTarget
lazy	vcglib/eigenlib/Eigen/src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::lazy() const$/;"	f	class:Eigen::MatrixBase
lazyAssign	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  ::lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
lazyAssign	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    Derived& lazyAssign(const Flagged<OtherDerived, 0, EvalBeforeAssigningBit>& other)$/;"	f	class:Eigen::MatrixBase
lazyAssign	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
lazyAssign	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^Derived& MatrixBase<Derived>::lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::MatrixBase
lazyAssign	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp
lazyAssign	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView
lazyAssign	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView
lazyProduct	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::lazyProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
ldButton	vcglib/apps/sample/trimesh_pos_demo/window.h	/^		QPushButton * fvButton,*feButton,*ffButton,*neButton,*ldButton,*nbButton,*vfButton;$/;"	m	class:Window
lda	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon434::__anon435
ldexp	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal ldexp(const mpreal& v, mp_exp_t exp)$/;"	f	namespace:mpfr
ldlt	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^MatrixBase<Derived>::ldlt() const$/;"	f	class:Eigen::MatrixBase
ldlt	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^SelfAdjointView<MatrixType, UpLo>::ldlt() const$/;"	f	class:Eigen::SelfAdjointView
ldlt_inplace	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Lower>$/;"	s	namespace:Eigen::internal
ldlt_inplace	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Upper>$/;"	s	namespace:Eigen::internal
leaf	vcglib/vcg/space/index/kdtree/kdtree.h	/^				unsigned int leaf:1;$/;"	m	struct:KdTree::Node::__anon507::__anon508
leafDiagonal	vcglib/vcg/space/index/octree_template.h	/^	ScalarType			leafDiagonal;$/;"	m	class:vcg::OctreeTemplate
leafDimension	vcglib/vcg/space/index/octree_template.h	/^	CoordinateType	leafDimension;$/;"	m	class:vcg::OctreeTemplate
leaf_pointer	vcglib/vcg/space/index/octree.h	/^            LeafPointer		leaf_pointer;$/;"	m	struct:vcg::Octree::ObjectPlaceholder
least_addr	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  char*      least_addr;$/;"	m	struct:malloc_state	file:
least_bit	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define least_bit(/;"	d	file:
leave	vcglib/wrap/gcache/door.h	/^  void leave() { room.unlock(); }$/;"	f	class:QDoor
leave	vcglib/wrap/gcache/door.h	/^  void leave() {$/;"	f	class:QDoor
leave	vcglib/wrap/gcache/door.h	/^  void leave() {}$/;"	f	class:QDoor
left	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector< std::vector<int> > left;$/;"	m	class:vcg::RasterizedOutline2
leftChildMax	vcglib/wrap/gcache/dheap.h	/^  int leftChildMax(int i) const { return (((i+2)>>1)<<2) -1; }$/;"	f	class:DHeap
leftChildMin	vcglib/wrap/gcache/dheap.h	/^  int leftChildMin(int i) const { return (((i+2)>>1)<<2) -2; }$/;"	f	class:DHeap
leftCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr leftCols(Index n)$/;"	f
leftCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr leftCols(Index n) const$/;"	f
leftCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type leftCols() const$/;"	f
leftCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type leftCols()$/;"	f
leftHorizon	vcglib/vcg/space/rasterized_outline2_packer.h	/^      std::vector<int>& leftHorizon() { return mLeftHorizon; }$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
left_bits	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define left_bits(/;"	d	file:
leftmost_child	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define leftmost_child(/;"	d	file:
leftshift_for_tree_index	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define leftshift_for_tree_index(/;"	d	file:
legendre	vcglib/vcg/math/spherical_harmonics.h	/^	static DynamicLegendre<ScalarType, MAX_BAND> legendre;$/;"	m	class:vcg::math::SphericalHarmonics
legendre	vcglib/vcg/math/spherical_harmonics.h	/^DynamicLegendre<ScalarType, MAX_BAND> SphericalHarmonics<ScalarType, MAX_BAND>::legendre;$/;"	m	class:vcg::math::SphericalHarmonics
legendre_P_l	vcglib/vcg/math/legendre.h	/^	static inline double legendre_P_l(unsigned l, ScalarType x)$/;"	f	class:vcg::math::Legendre
legendre_P_l_m	vcglib/vcg/math/legendre.h	/^	static inline double legendre_P_l_m(unsigned l, unsigned m, ScalarType cos_theta, ScalarType sin_theta)$/;"	f	class:vcg::math::Legendre
legendre_P_m_m	vcglib/vcg/math/legendre.h	/^	static inline double legendre_P_m_m(unsigned m, ScalarType sin_theta)$/;"	f	class:vcg::math::Legendre
legendre_P_m_mplusone	vcglib/vcg/math/legendre.h	/^	static inline double legendre_P_m_mplusone(unsigned m, ScalarType p_m_m, ScalarType x)$/;"	f	class:vcg::math::Legendre
legendre_next	vcglib/vcg/math/legendre.h	/^	static inline ScalarType legendre_next(unsigned l, ScalarType P_lm1, ScalarType P_lm2, ScalarType x)$/;"	f	class:vcg::math::Legendre
legendre_next	vcglib/vcg/math/legendre.h	/^	static inline double legendre_next(unsigned l, unsigned m, ScalarType P_lm1, ScalarType P_lm2, ScalarType x)$/;"	f	class:vcg::math::Legendre
len	vcglib/wrap/gl/trimesh.h	/^        int len;$/;"	m	class:vcg::GLW::GLAElem
length	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    Index length() const { return m_length; }  \/**< \\brief Returns the length of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence
lerp	vcglib/vcg/math/perlin_noise.h	/^   static double lerp(double t, double a, double b) { return a + t * (b - a); }$/;"	f	class:vcg::math::Perlin
lerp	vcglib/vcg/space/color4.h	/^  inline void lerp(const Color4 &c0, const Color4 &c1, const Color4 &c2, const Point3f &ip)$/;"	f	class:vcg::Color4
lerp	vcglib/vcg/space/color4.h	/^  inline void lerp(const Color4 &c0, const Color4 &c1, const float x)$/;"	f	class:vcg::Color4
less	vcglib/vcg/math/eigen.h	/^	inline static bool less(const Derived1& a, const Derived2& b) {$/;"	f	struct:Eigen::ei_lexi_comparison
lessEqual	vcglib/vcg/math/eigen.h	/^	inline static bool lessEqual(const Derived1& a, const Derived2& b) {$/;"	f	struct:Eigen::ei_lexi_comparison
level	vcglib/vcg/math/gen_normal.h	/^    int level;$/;"	m	class:vcg::GenNormal::OctaLevel
level	vcglib/vcg/space/index/octree_template.h	/^		char				level;$/;"	m	struct:vcg::OctreeTemplate::Node
level	vcglib/wrap/gl/fbo.h	/^	GLint level;$/;"	m	class:TextureRenderTarget
level	vcglib/wrap/glw/framebuffer.h	/^		GLint            level;$/;"	m	class:glw::RenderTarget
level3_blocking	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    level3_blocking()$/;"	f	class:Eigen::internal::level3_blocking
level3_blocking	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class level3_blocking$/;"	c	namespace:Eigen::internal
lgamma	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal lgamma (const mpreal& v, int *signp, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
lhs	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CwiseBinaryOp
lhs	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    const LhsNestedCleaned& lhs() const { return m_lhs; }$/;"	f	class:Product
lhs	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::ProductBase
lhs	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CoeffBasedProduct
lhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct
lhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDiagonalProduct
lhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseSparseProduct
lhs	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const {$/;"	f	class:Eigen::internal::SkylineProduct
li2	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal li2(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
line2ray	vcglib/wrap/gui/trackutils.h	/^Ray3f line2ray(const Line3f &l){$/;"	f	namespace:vcg::trackutils
lineColor	vcglib/wrap/qt/Outline2ToQImage.h	/^      vcg::Color4b lineColor;$/;"	m	class:Outline2Dumper::Param
lineWidthPt	vcglib/wrap/io_edgemesh/export_svg.h	/^	int lineWidthPt;	\/\/ Line width.$/;"	m	class:vcg::tri::io::SVGProperties
linear	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform
linear	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline LinearPart linear() { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform
linear	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return ConstLinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform
linear	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline LinearPart linear() { return LinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform
linearExt	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt()$/;"	f	class:Eigen::Transform
linearExt	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt() const$/;"	f	class:Eigen::Transform
linearRegression	vcglib/eigenlib/Eigen/src/Eigen2Support/LeastSquares.h	/^void linearRegression(int numPoints,$/;"	f	namespace:Eigen
linewidth	vcglib/wrap/gui/coordinateframe.h	/^  float linewidth;$/;"	m	class:vcg::CoordinateFrame
linked	vcglib/wrap/gl/shaders.h	/^	bool linked;$/;"	m	class:Program
links	vcglib/vcg/space/index/grid_static_ptr.h	/^		std::vector<Link>   links;   \/\/\/ Insieme di tutti i links$/;"	m	class:vcg::GridStaticPtr
linspaced_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  linspaced_op(Scalar low, Scalar high, int num_steps) : impl((num_steps==1 ? high : low), (num_steps==1 ? Scalar() : (high-low)\/(num_steps-1))) {}$/;"	f	struct:Eigen::internal::linspaced_op
linspaced_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct linspaced_op$/;"	s	namespace:Eigen::internal
linspaced_op_impl	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  linspaced_op_impl(Scalar low, Scalar step) :$/;"	f	struct:Eigen::internal::linspaced_op_impl
linspaced_op_impl	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,false>$/;"	s	namespace:Eigen::internal
linspaced_op_impl	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
list	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^  class list<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
list_base	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > list_base;$/;"	t	class:std::list
llt	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^MatrixBase<Derived>::llt() const$/;"	f	class:Eigen::MatrixBase
llt	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^SelfAdjointView<MatrixType, UpLo>::llt() const$/;"	f	class:Eigen::SelfAdjointView
llt_inplace	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Lower>$/;"	s	namespace:Eigen::internal
llt_inplace	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Upper>$/;"	s	namespace:Eigen::internal
llt_rank_update_lower	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^static typename MatrixType::Index llt_rank_update_lower(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)$/;"	f	namespace:Eigen::internal
lm_control_type	vcglib/wrap/minpack/minpack.h	/^} lm_control_type;$/;"	t	class:LMDiff	typeref:struct:LMDiff::__anon525
lm_evaluate_type	vcglib/wrap/minpack/minpack.h	/^typedef int (lm_evaluate_type) ($/;"	t	class:LMDiff
lm_initialize_control	vcglib/wrap/minpack/minpack.h	/^void LMDiff::lm_initialize_control( )$/;"	f	class:LMDiff
lm_param	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar lm_param(void) { return par; }$/;"	f	class:Eigen::LevenbergMarquardt
lm_status_type	vcglib/wrap/minpack/minpack.h	/^} lm_status_type;$/;"	t	class:LMDiff	typeref:struct:LMDiff::__anon526
lmder1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::lmder1($/;"	f	class:Eigen::LevenbergMarquardt
lmder_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    lmder_functor(void): Functor<double>(3,15) {}$/;"	f	struct:lmder_functor
lmder_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct lmder_functor : Functor<double>$/;"	s	file:
lmdif1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::lmdif1($/;"	f	class:Eigen::LevenbergMarquardt
lmdif_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    lmdif_functor(void) : Functor<double>(3,15) {}$/;"	f	struct:lmdif_functor
lmdif_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct lmdif_functor : Functor<double>$/;"	s	file:
lmpar	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/lmpar.h	/^void lmpar($/;"	f	namespace:Eigen::internal
lmpar2	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/lmpar.h	/^void lmpar2($/;"	f	namespace:Eigen::internal
lmstr1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::lmstr1($/;"	f	class:Eigen::LevenbergMarquardt
lmstr_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    lmstr_functor(void) : Functor<double>(3,15) {}$/;"	f	struct:lmstr_functor
lmstr_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct lmstr_functor : Functor<double>$/;"	s	file:
lngamma	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal lngamma (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
load	vcglib/wrap/gcache/cache.h	/^    bool load() {$/;"	f	class:vcg::Cache
loadDodecahedron	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::loadDodecahedron(){$/;"	f	class:GLArea
loadDodecahedron	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void TW_CALL loadDodecahedron(void * ){$/;"	f
loadLhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhs(const LhsScalar* a, LhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadMarket	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^bool loadMarket(SparseMatrixType& mat, const std::string& filename)$/;"	f	namespace:Eigen
loadMarketVector	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^bool loadMarketVector(VectorType& vec, const std::string& filename)$/;"	f	namespace:Eigen
loadMesh	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^void loadMesh(CMesh & m, char* fn, bool loadFitmaps = false)$/;"	f
loadMesh	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::loadMesh(QString fileName)$/;"	f	class:GLArea
loadMesh	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void  TW_CALL loadMesh(void *)$/;"	f
loadMesh	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void TW_CALL loadMesh(void *)$/;"	f
loadModel	vcglib/apps/pivoting/glarea.cpp	/^bool GLArea::loadModel(const QString &file) {$/;"	f	class:GLArea
loadProgram	vcglib/wrap/glw/utility.h	/^inline ProgramHandle loadProgram(Context & ctx, const std::string & srcPrefix, const std::string & vertexFile, const std::string & fragmentFile, const ProgramArguments & args = ProgramArguments())$/;"	f	namespace:glw
loadProgram	vcglib/wrap/glw/utility.h	/^inline ProgramHandle loadProgram(Context & ctx, const std::string & srcPrefix, const std::string & vertexFile, const std::string & geometryFile, const std::string & fragmentFile, const ProgramArguments & args = ProgramArguments())$/;"	f	namespace:glw
loadRhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, DoublePacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, ResPacket& dest) const { dest = *b; }$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, RhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadSource	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^QString SplatRenderer<MeshType>::loadSource(const QString& func,const QString& filename)$/;"	f	class:SplatRenderer
loadTetrahedron	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::loadTetrahedron(){$/;"	f	class:GLArea
loadTetrahedron	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void  TW_CALL loadTetrahedron(void *){$/;"	f
loadTetrahedron	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void  TW_CALL loadTetrahedron(void *){$/;"	f
loadTo	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer <MeshType>::UniformParameters::loadTo(Program& prg)$/;"	f	class:SplatRenderer::UniformParameters
load_fitmaps	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^void load_fitmaps(CMesh &m, char* fn)$/;"	f
locModPtr	vcglib/vcg/complex/algorithms/local_optimization.h	/^    LocModPtrType locModPtr;$/;"	m	struct:vcg::LocalOptimization::HeapElem
localMark	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            int localMark;$/;"	m	class:vcg::tri::QuadDiagonalCollapseBase
localMark	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^	int localMark;$/;"	m	class:vcg::tri::TriEdgeCollapse
location	vcglib/wrap/glw/program.h	/^				GLint       location;$/;"	m	class:glw::Program::UniformInfo
lock	vcglib/wrap/gcache/door.h	/^  void lock() { \/\/prevend door opening and entering$/;"	f	class:QDoor
lock	vcglib/wrap/gcache/door.h	/^  void lock() {$/;"	f	class:QDoor
lock	vcglib/wrap/gcache/token.h	/^    bool lock() {$/;"	f	class:vcg::Token
lock	vcglib/wrap/system/multithreading/mutex.h	/^		void lock(void)$/;"	f	class:mt::mutex
lock_read	vcglib/wrap/system/multithreading/rw_lock.h	/^		void lock_read(void)$/;"	f	class:mt::rw_lock
lock_write	vcglib/wrap/system/multithreading/rw_lock.h	/^		void lock_write(void)$/;"	f	class:mt::rw_lock
log	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::log() const$/;"	f	class:Eigen::Cwise
log	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^log() const$/;"	f
log	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^const MatrixLogarithmReturnValue<Derived> MatrixBase<Derived>::log() const$/;"	f	class:Eigen::MatrixBase
log	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal log  (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
log	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        void (*log)(int level, const char * f, ... );   \/\/\/< Pointer to a log function.$/;"	m	class:OverlapEstimation::Parameters
log	vcglib/wrap/glw/program.h	/^		const std::string & log(void) const$/;"	f	class:glw::Program
log	vcglib/wrap/glw/program.h	/^		const std::string & log(void) const$/;"	f	class:glw::SafeProgram
log	vcglib/wrap/glw/shader.h	/^		const std::string & log(void) const$/;"	f	class:glw::SafeShader
log	vcglib/wrap/glw/shader.h	/^		const std::string & log(void) const$/;"	f	class:glw::Shader
log10	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal log10(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
log1p	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal log1p  (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
log2	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^  template <typename Scalar> Scalar log2(Scalar v) { using std::log; return log(v)\/log(Scalar(2)); }$/;"	f	namespace:Eigen
log2	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal log2(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
logAbsDeterminant	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR
logAbsDeterminant	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR
logAbsDeterminant	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::HouseholderQR
lopass	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^float lopass=0,hipass=1,gamma_correction=1;$/;"	v
lower	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Scalar& lower(Index i) {$/;"	f	class:Eigen::SkylineStorage
lower	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline const Scalar& lower(Index i) const {$/;"	f	class:Eigen::SkylineStorage
lowerNonZeros	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index lowerNonZeros() const {$/;"	f	class:Eigen::SkylineMatrix
lowerNonZeros	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index lowerNonZeros(Index j) const {$/;"	f	class:Eigen::SkylineMatrix
lowerProfile	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index& lowerProfile(Index i) {$/;"	f	class:Eigen::SkylineStorage
lowerProfile	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline const Index& lowerProfile(Index i) const {$/;"	f	class:Eigen::SkylineStorage
lowerProfileSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index lowerProfileSize() const {$/;"	f	class:Eigen::SkylineStorage
lowerSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index lowerSize() const {$/;"	f	class:Eigen::SkylineStorage
lpNorm	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::lpNorm() const$/;"	f	class:Eigen::MatrixBase
lpNorm_selector	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^struct lpNorm_selector$/;"	s	namespace:Eigen::internal
lpNorm_selector	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 1>$/;"	s	namespace:Eigen::internal
lpNorm_selector	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 2>$/;"	s	namespace:Eigen::internal
lpNorm_selector	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, Infinity>$/;"	s	namespace:Eigen::internal
lst	vcglib/apps/pivoting/ring.h	/^  list<T> lst;$/;"	m	class:ring
lu	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase
lu	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase
m	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^AMesh m;$/;"	v
m	vcglib/apps/unsupported/shadevis/visshader.h	/^	MESH_TYPE &m;$/;"	m	class:vcg::VisShader
m	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Index m;$/;"	m	class:Eigen::LevenbergMarquardt
m	vcglib/vcg/complex/algorithms/clip.h	/^    MESH_TYPE &m;$/;"	m	class:vcg::tri::GenericVertexInterpolator
m	vcglib/vcg/complex/algorithms/closest.h	/^			MESH_TYPE *m;$/;"	m	class:vcg::tri::Tmark
m	vcglib/vcg/complex/algorithms/local_optimization.h	/^	MeshType & m;$/;"	m	class:vcg::LocalOptimization
m	vcglib/vcg/complex/algorithms/nring.h	/^    MeshType* m;$/;"	m	class:vcg::tri::Nring
m	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        MeshType* m;  \/\/this is needed for advanced sampling (i.e poisson sampling)$/;"	m	class:OverlapEstimation::VertexPointerSampler
m	vcglib/vcg/complex/algorithms/point_sampling.h	/^  MeshType &m;$/;"	m	class:vcg::tri::MeshSampler
m	vcglib/vcg/complex/algorithms/refine.h	/^  MESH_TYPE &m;$/;"	m	struct:vcg::tri::MidPointButterfly
m	vcglib/vcg/complex/algorithms/refine_loop.h	/^	MESH_TYPE &m;$/;"	m	struct:vcg::tri::OddPointLoopGeneric
m	vcglib/vcg/complex/algorithms/smooth.h	/^  CoordType m;$/;"	m	class:vcg::tri::Smooth::PDFaceInfo
m	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  MESH_TYPE &m;$/;"	m	class:vcg::tri::TextureOptimizer
m	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& m() { return data[10];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
m	vcglib/vcg/space/obox3.h	/^		Matrix44<T> m;			\/\/ a matrix to go in OB space$/;"	m	class:vcg::Obox3
m	vcglib/wrap/gcache/door.h	/^  mt::mutex m;$/;"	m	class:QDoor
m	vcglib/wrap/gl/trimesh.h	/^    MESH_TYPE *m;$/;"	m	class:vcg::GlTrimesh
m	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  mutex m;$/;"	m	class:mt::atomicInt
m	vcglib/wrap/system/multithreading/mutex.h	/^		pthread_mutex_t m;$/;"	m	class:mt::mutex
mAABB	vcglib/vcg/space/index/kdtree/kdtree.h	/^        AxisAlignedBoxType mAABB; \/\/BoundingBox$/;"	m	class:KdTree
mBindedPass	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	int mBindedPass;$/;"	m	class:SplatRenderer
mBottomHorizon	vcglib/vcg/space/rasterized_outline2_packer.h	/^      std::vector<int> mBottomHorizon;$/;"	m	class:vcg::RasterizedOutline2Packer::packingfield
mBuggedAtiBlending	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	bool mBuggedAtiBlending;$/;"	m	class:SplatRenderer
mCachedFlags	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	int mCachedFlags;$/;"	m	class:SplatRenderer
mCachedMV	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	float mCachedMV[16];$/;"	m	class:SplatRenderer
mCachedProj	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	float mCachedProj[16];$/;"	m	class:SplatRenderer
mCachedVP	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	GLint mCachedVP[4];$/;"	m	class:SplatRenderer
mCount	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	int mCount;$/;"	m	class:HeapMaxPriorityQueue
mDepthTextureID	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	GLuint mDepthTextureID;$/;"	m	class:SplatRenderer
mDummyTexId	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	GLuint mDummyTexId; \/\/ on ATI graphics card we need to bind a texture to get point sprite working !$/;"	m	class:SplatRenderer
mElements	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	Element* mElements;$/;"	m	class:HeapMaxPriorityQueue
mFix	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    MeshType* mFix;                             \/** Pointer to mesh \\c mFix. *\/$/;"	m	class:OverlapEstimation
mFlags	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	int mFlags;$/;"	m	class:SplatRenderer
mIndices	vcglib/vcg/space/index/kdtree/kdtree.h	/^        std::vector<int> mIndices; \/\/points indices$/;"	m	class:KdTree
mIsSupported	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	bool mIsSupported;$/;"	m	class:SplatRenderer
mLeftHorizon	vcglib/vcg/space/rasterized_outline2_packer.h	/^      std::vector<int> mLeftHorizon;$/;"	m	class:vcg::RasterizedOutline2Packer::packingfield
mMaxSize	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	int mMaxSize;$/;"	m	class:HeapMaxPriorityQueue
mMov	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    MeshType* mMov;                             \/** Pointer to mesh \\c mMov. *\/$/;"	m	class:OverlapEstimation
mNeighborQueue	vcglib/vcg/space/index/kdtree/kdtree.h	/^        HeapMaxPriorityQueue<int,Scalar> mNeighborQueue; \/\/used to perform the knn-query$/;"	m	class:KdTree
mNodeStack	vcglib/vcg/space/index/kdtree/kdtree.h	/^        QueryNode mNodeStack[64]; \/\/used in the implementation of the knn-query$/;"	m	class:KdTree
mNodes	vcglib/vcg/space/index/kdtree/kdtree.h	/^        NodeList mNodes; \/\/kd-tree nodes$/;"	m	class:KdTree
mNormalTextureID	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	GLuint mNormalTextureID;$/;"	m	class:SplatRenderer
mParams	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	UniformParameters mParams;$/;"	m	class:SplatRenderer
mPoints	vcglib/vcg/space/index/kdtree/kdtree.h	/^        std::vector<VectorType> mPoints; \/\/points read from the input DataWrapper$/;"	m	class:KdTree
mRenderBuffer	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	QGLFramebufferObject* mRenderBuffer;$/;"	m	class:SplatRenderer
mRenderBufferMask	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	int mRenderBufferMask;$/;"	m	class:SplatRenderer
mShaderSrcs	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	QString mShaderSrcs[6];$/;"	m	class:SplatRenderer
mShaders	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	ProgramVF mShaders[3];$/;"	m	class:SplatRenderer
mSize	vcglib/vcg/space/index/kdtree/kdtree.h	/^		size_t mSize;$/;"	m	class:ConstDataWrapper
mSize	vcglib/vcg/space/rasterized_outline2_packer.h	/^      vcg::Point2i mSize;$/;"	m	class:vcg::RasterizedOutline2Packer::packingfield
mStride	vcglib/vcg/space/index/kdtree/kdtree.h	/^		int mStride;$/;"	m	class:ConstDataWrapper
mSupportedMask	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	int mSupportedMask;$/;"	m	class:SplatRenderer
mWorkaroundATI	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^	bool mWorkaroundATI;$/;"	m	class:SplatRenderer
m_A	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typename internal::nested<Derived>::type m_A;$/;"	m	class:Eigen::MatrixFunctionReturnValue
m_A	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    typename internal::nested<MatrixType>::type m_A; \/**< \\brief Reference to argument of matrix function. *\/$/;"	m	class:Eigen::MatrixFunction
m_A	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  typename internal::nested<Derived>::type m_A;$/;"	m	class:Eigen::MatrixLogarithmReturnValue
m_A	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    const MatrixType& m_A;$/;"	m	class:Eigen::MatrixSquareRoot
m_A	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    const MatrixType& m_A;$/;"	m	class:Eigen::MatrixSquareRootQuasiTriangular
m_A	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    const MatrixType& m_A;$/;"	m	class:Eigen::MatrixSquareRootTriangular
m_A	vcglib/wrap/miq/core/sparsesystemdata.h	/^  SparseMatrixData m_A;$/;"	m	class:SparseSystemData
m_Arows	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    Index m_Arows;$/;"	m	class:Eigen::MatrixFunctionAtomic
m_Ashifted	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    MatrixType m_Ashifted;$/;"	m	class:Eigen::MatrixFunctionAtomic
m_BOUNDING_BOX_EXPANSION_FACTOR	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		const static float	m_BOUNDING_BOX_EXPANSION_FACTOR;$/;"	m	class:vcg::PerfectSpatialHashing
m_BOUNDING_BOX_EXPANSION_FACTOR	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^const SCALAR_TYPE vcg::PerfectSpatialHashing< OBJECT_TYPE, SCALAR_TYPE >::m_BOUNDING_BOX_EXPANSION_FACTOR	= SCALAR_TYPE(0.035);$/;"	m	class:vcg::PerfectSpatialHashing
m_Bitmap	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		BinaryImage	m_Bitmap;$/;"	m	class:vcg::PerfectSpatialHashing
m_BoundingBox	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			BoundingBoxType	m_BoundingBox;	\/*!< The bounding box of the uniform grid.	*\/$/;"	m	class:vcg::PerfectSpatialHashing::UniformGrid
m_CellPerSide	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			int							m_CellPerSide;	\/*!< The number of cell per side.						*\/$/;"	m	class:vcg::PerfectSpatialHashing::UniformGrid
m_CellSize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			CoordinateType 	m_CellSize;			\/*!< The dimension of each cell.						*\/$/;"	m	class:vcg::PerfectSpatialHashing::UniformGrid
m_Center	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			vcg::Point3i	m_Center;						\/*!< The cell whose neighboring cells are to be looked up.	*\/$/;"	m	struct:vcg::PerfectSpatialHashing::NeighboringEntryIterator
m_CurrentIteration	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			int						m_CurrentIteration; \/*!< The current iteration.																	*\/$/;"	m	struct:vcg::PerfectSpatialHashing::NeighboringEntryIterator
m_CurrentNeighbor	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			vcg::Point3i	m_CurrentNeighbor;	\/*!< The neighboring cell at the current iteration.					*\/$/;"	m	struct:vcg::PerfectSpatialHashing::NeighboringEntryIterator
m_CurrentPosition	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				CellCoordinate		m_CurrentPosition;$/;"	m	struct:vcg::PerfectSpatialHashing::UniformGrid::EntryIterator
m_DIMENSION	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		const static int    m_DIMENSION;$/;"	m	class:vcg::PerfectSpatialHashing
m_DIMENSION	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^const int vcg::PerfectSpatialHashing< OBJECT_TYPE, SCALAR_TYPE >::m_DIMENSION	= 3;$/;"	m	class:vcg::PerfectSpatialHashing
m_EntryPerSide	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			int																									m_EntryPerSide; \/*!< The number of entries for each side of the hash-table. *\/$/;"	m	class:vcg::PerfectSpatialHashing::HashTable
m_EntryPerSide	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			int								m_EntryPerSide;							\/*!< The resolution of the offset table.												*\/$/;"	m	class:vcg::PerfectSpatialHashing::OffsetTable
m_FreeEntries	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			std::list< EntryCoordinate >												m_FreeEntries;  \/*!< The list containing the free entries. *\/$/;"	m	class:vcg::PerfectSpatialHashing::HashTable
m_Grid	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^											m_Grid;					\/*!< The uniform grid												*\/$/;"	m	class:vcg::PerfectSpatialHashing::UniformGrid
m_H1PreImage	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			std::vector< std::vector< std::vector< std::vector< typename UniformGrid::CellCoordinate > > > >	m_H1PreImage; \/*!< The \\f$f1\\f$ pre-image.		*\/$/;"	m	class:vcg::PerfectSpatialHashing::OffsetTable
m_HashTable	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		HashTable		m_HashTable;		\/*!< The hash table that will substitute the uniform grid.				*\/$/;"	m	class:vcg::PerfectSpatialHashing
m_Id	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    MatrixType m_Id;$/;"	m	class:Eigen::MatrixExponential
m_LDLT	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_LDLT;$/;"	m	class:Eigen::SimplicialCholesky
m_M	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    typename internal::nested<MatrixType>::type m_M;$/;"	m	class:Eigen::MatrixExponential
m_MAX_NUM_OF_RANDOM_GENERATED_OFFSET	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		const static int		m_MAX_NUM_OF_RANDOM_GENERATED_OFFSET;$/;"	m	class:vcg::PerfectSpatialHashing
m_MAX_NUM_OF_RANDOM_GENERATED_OFFSET	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^const int vcg::PerfectSpatialHashing< OBJECT_TYPE, SCALAR_TYPE >::m_MAX_NUM_OF_RANDOM_GENERATED_OFFSET	= 32;$/;"	m	class:vcg::PerfectSpatialHashing
m_MAX_TRIALS_IN_COMPACT_CONSTRUCTION	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		const static int		m_MAX_TRIALS_IN_COMPACT_CONSTRUCTION;$/;"	m	class:vcg::PerfectSpatialHashing
m_MAX_TRIALS_IN_COMPACT_CONSTRUCTION	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^const int vcg::PerfectSpatialHashing< OBJECT_TYPE, SCALAR_TYPE >::m_MAX_TRIALS_IN_COMPACT_CONSTRUCTION	= 5;$/;"	m	class:vcg::PerfectSpatialHashing
m_MAX_VERSOR_LENGTH	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			const static int	m_MAX_VERSOR_LENGTH = 256;	\/*!< The maximal length of the single component of each offset. *\/ $/;"	m	class:vcg::PerfectSpatialHashing::OffsetTable
m_Mask	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^						m_Mask;					\/*!< The bitmap image.							*\/$/;"	m	class:vcg::PerfectSpatialHashing::BinaryImage
m_NumberOfOccupiedEntries	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			int								m_NumberOfOccupiedEntries;	\/*!< The number of entries containing a valid offset.						*\/$/;"	m	class:vcg::PerfectSpatialHashing::OffsetTable
m_OffsetTable	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		OffsetTable m_OffsetTable;	\/*!< The offset table corresponding to \\f$\\Phi\\f$ in the article. *\/$/;"	m	class:vcg::PerfectSpatialHashing
m_P	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ Fill-reducing permutation$/;"	m	class:Eigen::IncompleteLUT
m_P	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ the permutation$/;"	m	class:Eigen::SimplicialCholeskyBase
m_Pinv	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ Inverse permutation$/;"	m	class:Eigen::IncompleteLUT
m_Pinv	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ the inverse permutation$/;"	m	class:Eigen::SimplicialCholeskyBase
m_Resolution	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 int	m_Resolution;		\/*!< The resolution of the bitmap.	*\/$/;"	m	class:vcg::PerfectSpatialHashing::BinaryImage
m_SIGMA	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		const static float	m_SIGMA;$/;"	m	class:vcg::PerfectSpatialHashing
m_SIGMA	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^const SCALAR_TYPE vcg::PerfectSpatialHashing< OBJECT_TYPE, SCALAR_TYPE >::m_SIGMA	= SCALAR_TYPE(1.0f\/(2.0f*SCALAR_TYPE(m_DIMENSION)));$/;"	m	class:vcg::PerfectSpatialHashing
m_T	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    MatrixType m_T; \/**< \\brief Triangular part of Schur decomposition *\/$/;"	m	class:Eigen::MatrixFunction
m_Table	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			std::vector< std::vector< std::vector < Data* > > > m_Table;				\/*!< The table. *\/$/;"	m	class:vcg::PerfectSpatialHashing::HashTable
m_Table	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			std::vector< std::vector< std::vector< OffsetPointer > > >																				m_Table;			\/*!< The offset table.					*\/$/;"	m	class:vcg::PerfectSpatialHashing::OffsetTable
m_TableSize	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			int						m_TableSize;				\/*!< The number of cell in the UniformGrid for each side		*\/$/;"	m	struct:vcg::PerfectSpatialHashing::NeighboringEntryIterator
m_U	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    MatrixType m_U;$/;"	m	class:Eigen::MatrixExponential
m_U	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    MatrixType m_U; \/**< \\brief Unitary part of Schur decomposition *\/$/;"	m	class:Eigen::MatrixFunction
m_UniformGrid	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				UniformGrid			* m_UniformGrid;$/;"	m	struct:vcg::PerfectSpatialHashing::UniformGrid::EntryIterator
m_UniformGrid	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		UniformGrid m_UniformGrid;	\/*!< The uniform grid used for partitioning the volume.						*\/$/;"	m	class:vcg::PerfectSpatialHashing
m_V	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    MatrixType m_V;$/;"	m	class:Eigen::MatrixExponential
m_acquired	vcglib/wrap/glw/context.h	/^		bool                    m_acquired;$/;"	m	class:glw::Context
m_actualAlpha	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Scalar m_actualAlpha;$/;"	m	struct:Eigen::internal::gemm_functor
m_adjoint	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  TransposeTypeWithSameStorageOrder m_adjoint;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_allocatedElements	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_allocatedElements;$/;"	m	class:Eigen::internal::AmbiVector
m_allocatedSize	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_allocatedSize;$/;"	m	class:Eigen::internal::AmbiVector
m_allocatedSize	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    size_t m_allocatedSize;$/;"	m	class:Eigen::internal::CompressedStorage
m_allocatedSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_allocatedSize;$/;"	m	class:Eigen::SkylineStorage
m_alpha	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    Scalar m_alpha;$/;"	m	class:Eigen::ScaledProduct
m_analysisIsOk	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::CholmodBase
m_analysisIsOk	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::IncompleteLUT
m_analysisIsOk	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase
m_analysisIsOk	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::PastixBase
m_analysisIsOk	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl
m_analysisIsOk	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_analysisIsOk	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::SuperLUBase
m_analysisIsOk	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::UmfPackLU
m_angle	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis
m_angle	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D
m_angle	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis
m_angle	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D
m_arguments	vcglib/wrap/glw/program.h	/^		ProgramArguments m_arguments;$/;"	m	class:glw::Program
m_atomic	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    AtomicType& m_atomic; \/**< \\brief Class for computing matrix function of atomic blocks. *\/$/;"	m	class:Eigen::MatrixFunction
m_avgEival	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    Scalar m_avgEival;$/;"	m	class:Eigen::MatrixFunctionAtomic
m_axis	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis
m_axis	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis
m_b	vcglib/wrap/miq/core/sparsesystemdata.h	/^  double       *m_b;$/;"	m	class:SparseSystemData
m_base	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  mutable Packet m_base;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_bidiagonal	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    BidiagonalType m_bidiagonal;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_bindings	vcglib/wrap/glw/context.h	/^		RefCountedBindingPtrMap m_bindings;$/;"	m	class:glw::Context
m_bl_diag	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^      BottomLeftDiagonal         m_bl_diag;$/;"	m	class:Eigen::internal::companion
m_blockA	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    LhsScalar* m_blockA;$/;"	m	class:Eigen::internal::level3_blocking
m_blockB	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockB;$/;"	m	class:Eigen::internal::level3_blocking
m_blockCols	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::Block
m_blockRows	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::Block
m_blockStart	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    DynamicIntVectorType m_blockStart; \/**< \\brief Row index at which block corresponding to i-th cluster starts *\/$/;"	m	class:Eigen::MatrixFunction
m_blockW	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockW;$/;"	m	class:Eigen::internal::level3_blocking
m_blocking	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    BlockingType& m_blocking;$/;"	m	struct:Eigen::internal::gemm_functor
m_buffer	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar* m_buffer;$/;"	m	class:Eigen::internal::AmbiVector
m_c	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation
m_cachedIndex	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_cachedIndex;          \/\/ current coordinate$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_cachedValue	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_cachedValue;       \/\/ current value$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_callback	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void (*m_callback)(const IterationController&);$/;"	m	class:Eigen::IterationController
m_cholmod	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable cholmod_common m_cholmod;$/;"	m	class:Eigen::CholmodBase
m_cholmodFactor	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_factor* m_cholmodFactor;$/;"	m	class:Eigen::CholmodBase
m_clusterSize	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    DynamicIntVectorType m_clusterSize; \/**< \\brief Number of eigenvalues in each clusters  *\/$/;"	m	class:Eigen::MatrixFunction
m_clusters	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    ListOfClusters m_clusters; \/**< \\brief Partition of eigenvalues into clusters of ei'vals "close" to each other *\/$/;"	m	class:Eigen::MatrixFunction
m_coeffs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    CoefficientsType m_coeffs;$/;"	m	class:Eigen::internal::BandMatrix
m_coeffs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    const CoefficientsType& m_coeffs;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_coeffs	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane
m_coeffs	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion
m_coeffs	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Scaling
m_coeffs	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation
m_coeffs	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane
m_coeffs	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    Coefficients m_coeffs;$/;"	m	class:Eigen::Map
m_coeffs	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^    const Coefficients m_coeffs;$/;"	m	class:Eigen::Map
m_coeffs	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion
m_coeffs	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation
m_coeffs	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    typename CoeffsType::Nested m_coeffs;$/;"	m	class:Eigen::HouseholderSequence
m_col	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  Index m_col;              \/\/ current col id$/;"	m	struct:Eigen::CommaInitializer
m_col	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor
m_col	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet
m_colFactor	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, ColFactor> m_colFactor;$/;"	m	class:Eigen::Replicate
m_colSqNorms	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealRowVectorType m_colSqNorms;$/;"	m	class:Eigen::ColPivHouseholderQR
m_colStartIndex	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index* m_colStartIndex;$/;"	m	class:Eigen::SkylineMatrix
m_colind	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int *m_colind;$/;"	m	class:SparseMatrixData
m_cols	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::CwiseNullaryOp
m_cols	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    DenseIndex m_cols;$/;"	m	class:Eigen::DenseStorage
m_cols	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::MapBase
m_cols	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD
m_cols	vcglib/eigenlib/Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base
m_cols	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_colsPermutation	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    PermutationType m_colsPermutation;$/;"	m	class:Eigen::ColPivHouseholderQR
m_colsTranspositions	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::FullPivLU
m_colsTranspositions	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::ColPivHouseholderQR
m_cols_permutation	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    PermutationType m_cols_permutation;$/;"	m	class:Eigen::FullPivHouseholderQR
m_cols_transpositions	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    IntRowVectorType m_cols_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR
m_comm	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_comm; \/\/ The MPI communicator identifier$/;"	m	class:Eigen::PastixBase
m_compiled	vcglib/wrap/glw/shader.h	/^		bool         m_compiled;$/;"	m	class:glw::Shader
m_computationOptions	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    unsigned int m_computationOptions;$/;"	m	class:Eigen::JacobiSVD
m_computeFullU	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD
m_computeFullV	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD
m_computeThinU	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD
m_computeThinV	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD
m_condition	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    typename ConditionMatrixType::Nested m_condition;$/;"	m	class:Eigen::Select
m_config	vcglib/wrap/glw/framebuffer.h	/^		FramebufferArguments m_config;$/;"	m	class:glw::Framebuffer
m_conservative	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    bool m_conservative;$/;"	m	class:Eigen::SparseSparseProduct
m_context	vcglib/wrap/glw/object.h	/^		Context * m_context;$/;"	m	class:glw::Object
m_copyMatrix	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackMatrixType m_copyMatrix;$/;"	m	class:Eigen::UmfPackLU
m_countPerCol	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerCol;$/;"	m	class:Eigen::SparseSelfAdjointView
m_countPerRow	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerRow;$/;"	m	class:Eigen::SparseSelfAdjointView
m_ctrls	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    ControlPointVectorType  m_ctrls; \/*!< Control points. *\/$/;"	m	class:Eigen::Spline
m_currentBlockRows	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  Index m_currentBlockRows; \/\/ current block height$/;"	m	struct:Eigen::CommaInitializer
m_currentEl	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_currentEl;            \/\/ the current element in sparse\/linked-list mode$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_curs_id	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    struct dirent *m_curs_id; $/;"	m	class:Eigen::MatrixMarketIterator	typeref:struct:Eigen::MatrixMarketIterator::dirent
m_data	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    T *m_data;$/;"	m	class:Eigen::DenseStorage
m_data	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    internal::plain_array<T,Size,_Options> m_data;$/;"	m	class:Eigen::DenseStorage
m_data	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  internal::plain_array<Scalar,EIGEN_SIZE_MIN_PREFER_FIXED(Size,MaxSize),0> m_data;$/;"	m	struct:Eigen::internal::gemv_static_vector_if
m_data	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    PointerType m_data;$/;"	m	class:Eigen::MapBase
m_data	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::blas_data_mapper
m_data	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    const Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::const_blas_data_mapper
m_data	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseMatrix
m_data	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::InnerIterator
m_data	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator
m_data	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    internal::CompressedStorage<Scalar,Index> m_data;$/;"	m	class:Eigen::SparseVector
m_data	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    SkylineStorage<Scalar> m_data;$/;"	m	class:Eigen::SkylineMatrix
m_data	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    std::vector<internal::CompressedStorage<Scalar,Index> > m_data;$/;"	m	class:Eigen::DynamicSparseMatrix
m_deallocate	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    bool m_deallocate;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_dec	vcglib/eigenlib/Eigen/src/misc/Image.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::image_retval_base
m_dec	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_dec	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_base
m_dec	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_with_guess
m_dec	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base
m_defines	vcglib/wrap/glw/utility.h	/^		DefineMap    m_defines;$/;"	m	class:glw::ShaderHeaderBuilder
m_deleter	vcglib/wrap/glw/bookkeeping.h	/^		DeleterType  m_deleter;$/;"	m	class:glw::detail::RefCountedObject
m_derivatives	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    DerType m_derivatives;$/;"	m	class:Eigen::AutoDiffScalar
m_dest	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Dest& m_dest;$/;"	m	struct:Eigen::internal::gemm_functor
m_det_p	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    Index m_det_p;$/;"	m	class:Eigen::PartialPivLU
m_det_pq	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU
m_det_pq	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::ColPivHouseholderQR
m_det_pq	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::FullPivHouseholderQR
m_diag	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorType m_diag;                                \/\/ the diagonal coefficients (LDLT mode)$/;"	m	class:Eigen::SimplicialCholeskyBase
m_diag	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Scalar* m_diag;$/;"	m	class:Eigen::SkylineStorage
m_diagSize	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD
m_diagSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_diagSize;$/;"	m	class:Eigen::SkylineStorage
m_diagonal	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalVectorType m_diagonal;$/;"	m	class:Eigen::DiagonalMatrix
m_diagonal	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    typename DiagonalVectorType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalWrapper
m_diagonal	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    typename DiagonalType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalProduct
m_direction	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_direction	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_dparm	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<double,DPARM_SIZE,1> m_dparm; \/\/ Scalar vector for the input parameters$/;"	m	class:Eigen::PastixBase
m_droptol	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    RealScalar m_droptol;$/;"	m	class:Eigen::IncompleteLUT
m_eigenvectorsOk	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::ComplexEigenSolver
m_eigenvectorsOk	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::EigenSolver
m_eigenvectorsOk	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_eivalToCluster	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    DynamicIntVectorType m_eivalToCluster; \/**< \\brief m_eivalToCluster[i] = j means i-th ei'val is in j-th cluster *\/$/;"	m	class:Eigen::MatrixFunction
m_eivalues	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::ComplexEigenSolver
m_eivalues	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::EigenSolver
m_eivalues	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    RealVectorType m_eivalues;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_eivec	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_eivec;$/;"	m	class:Eigen::ComplexEigenSolver
m_eivec	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::EigenSolver
m_eivec	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_else	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    typename ElseMatrixType::Nested m_else;$/;"	m	class:Eigen::Select
m_end	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_end;$/;"	m	class:Eigen::internal::AmbiVector
m_end	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    const Index m_end;$/;"	m	class:Eigen::DenseBase::InnerIterator
m_end	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator
m_end	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
m_end	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_end;$/;"	m	class:Eigen::SparseMatrix::InnerIterator
m_end	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    const Index m_end;$/;"	m	class:Eigen::SparseVector::InnerIterator
m_end	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::SkylineMatrix::InnerLowerIterator
m_end	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::SkylineMatrix::InnerUpperIterator
m_epsilon	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    RealScalar m_epsilon;       \/\/ epsilon used to prune zero coefficients$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_epsilon	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  typename NumTraits<Scalar>::Real m_epsilon;$/;"	m	class:Eigen::SparseView
m_error	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable RealScalar m_error;$/;"	m	class:Eigen::IterativeSolverBase
m_exponent	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  const Scalar m_exponent;$/;"	m	struct:Eigen::internal::scalar_pow_op
m_expression	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::ArrayWrapper
m_expression	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::MatrixWrapper
m_expression	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    const ExpressionType& m_expression;$/;"	m	class:Eigen::ForceAlignedAccess
m_expression	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    const ExpressionType m_expression;$/;"	m	class:Eigen::NestByValue
m_expression	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::NoAlias
m_expression	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::SwapWrapper
m_expression	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    const Derived& m_expression;$/;"	m	class:Eigen::DenseBase::InnerIterator
m_extensions	vcglib/wrap/glw/utility.h	/^		ExtensionMap m_extensions;$/;"	m	class:glw::ShaderHeaderBuilder
m_extractedDataAreDirty	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::SuperLUBase
m_extractedDataAreDirty	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::UmfPackLU
m_f	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    StemFunction *m_f;$/;"	m	class:Eigen::MatrixFunctionReturnValue
m_f	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    StemFunction* m_f;$/;"	m	class:Eigen::MatrixFunctionAtomic
m_fT	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    MatrixType m_fT; \/**< \\brief %Matrix function applied to #m_T *\/$/;"	m	class:Eigen::MatrixFunction
m_factor	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  Scalar m_factor;$/;"	m	class:Eigen::UniformScaling
m_factor	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    Scalar m_factor;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator
m_factorizationIsOk	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::CholmodBase
m_factorizationIsOk	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::IncompleteLUT
m_factorizationIsOk	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase
m_factorizationIsOk	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::PastixBase
m_factorizationIsOk	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl
m_factorizationIsOk	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_factorizationIsOk	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::SuperLUBase
m_factorizationIsOk	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::UmfPackLU
m_fillfactor	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    int m_fillfactor;$/;"	m	class:Eigen::IncompleteLUT
m_flags	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    int m_flags;$/;"	m	class:Eigen::SkylineInplaceLU
m_folder	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    std::string m_folder;$/;"	m	class:Eigen::MatrixMarketIterator
m_folder_id	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    DIR * m_folder_id;$/;"	m	class:Eigen::MatrixMarketIterator
m_format	vcglib/eigenlib/Eigen/src/Core/IO.h	/^    IOFormat m_format;$/;"	m	class:Eigen::WithFormat
m_format	vcglib/wrap/glw/renderable.h	/^		GLenum m_format;$/;"	m	class:glw::Renderable
m_fullLog	vcglib/wrap/glw/program.h	/^		std::string      m_fullLog;$/;"	m	class:glw::Program
m_functor	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp m_functor;$/;"	m	class:Eigen::CwiseBinaryOp
m_functor	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp m_functor;$/;"	m	class:Eigen::CwiseNullaryOp
m_functor	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOp
m_functor	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryView
m_functor	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::SelfCwiseBinaryOp
m_functor	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const MemberOp m_functor;$/;"	m	class:Eigen::PartialReduxExpr
m_functor	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::member_redux
m_functor	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_functor	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_functor	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_functor	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::InnerIterator
m_functor	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
m_functor	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::InnerIterator
m_functor	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
m_guess	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^    const typename Guess::Nested m_guess;$/;"	m	struct:Eigen::internal::solve_retval_with_guess
m_hCoeffs	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::HessenbergDecomposition
m_hCoeffs	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::Tridiagonalization
m_hCoeffs	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::ColPivHouseholderQR
m_hCoeffs	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::FullPivHouseholderQR
m_hCoeffs	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename HCoeffsType::Nested m_hCoeffs;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_hCoeffs	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::HouseholderQR
m_handle	vcglib/wrap/glw/object.h	/^		ObjectHandle m_handle;$/;"	m	class:glw::BoundObject
m_hasRhs	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool m_hasRhs; \/\/ The right hand side exists$/;"	m	class:Eigen::MatrixMarketIterator
m_hashmaps	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    HashMapType* m_hashmaps;$/;"	m	class:Eigen::RandomSetter
m_hasrefX	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool m_hasrefX; \/\/ A reference solution is provided$/;"	m	class:Eigen::MatrixMarketIterator
m_height	vcglib/wrap/glw/renderbuffer.h	/^		GLsizei m_height;$/;"	m	class:glw::Renderbuffer
m_height	vcglib/wrap/glw/texture2d.h	/^		GLsizei m_height;$/;"	m	class:glw::Texture2D
m_hess	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::ComplexSchur
m_hess	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const HessenbergDecomposition<MatrixType>& m_hess;$/;"	m	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
m_hess	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::RealSchur
m_householder	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    MatrixType m_householder;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_id	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator
m_id	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
m_id	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Index m_id;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_id	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::InnerIterator
m_id	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator
m_id	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::InnerIterator
m_id	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator
m_id	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SkylineMatrix::InnerLowerIterator
m_id	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SkylineMatrix::InnerUpperIterator
m_index	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    const internal::variable_if_dynamic<Index, DiagIndex> m_index;$/;"	m	class:Eigen::Diagonal
m_index	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^        Index m_index;$/;"	m	class:Eigen::SparseMatrix::SingletonVector
m_indices	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map
m_indices	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::PermutationMatrix
m_indices	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::PermutationWrapper
m_indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map
m_indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Transpositions
m_indices	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    const typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::TranspositionsWrapper
m_indices	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    Index* m_indices;$/;"	m	class:Eigen::internal::CompressedStorage
m_indices	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::InnerIterator
m_indices	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator
m_info	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::LLT
m_info	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::CholmodBase
m_info	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::ComplexSchur
m_info	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::RealSchur
m_info	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_info	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::IncompleteLUT
m_info	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable ComputationInfo m_info;$/;"	m	class:Eigen::IterativeSolverBase
m_info	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable ComputationInfo m_info; $/;"	m	class:Eigen::PastixBase
m_info	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::PardisoImpl
m_info	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_info	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SuperLUBase
m_info	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::UmfPackLU
m_info	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    mutable ComputationInfo m_info; $/;"	m	class:Scaling
m_initialized	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl
m_initisOk	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_initisOk; $/;"	m	class:Eigen::PastixBase
m_inner	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, InnerStrideAtCompileTime> m_inner;$/;"	m	class:Eigen::Stride
m_inner	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    Index m_inner;$/;"	m	class:Eigen::DenseBase::InnerIterator
m_innerIndexPtr	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_innerIndexPtr;$/;"	m	class:Eigen::UmfPackLU
m_innerIndices	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_innerIndices;$/;"	m	class:Eigen::MappedSparseMatrix
m_innerNonZeros	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Index* m_innerNonZeros;     \/\/ optional, if null then the data is compressed$/;"	m	class:Eigen::SparseMatrix
m_innerSize	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_innerSize;$/;"	m	class:Eigen::MappedSparseMatrix
m_innerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::SparseMatrix
m_innerSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::SkylineMatrix
m_innerSize	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::DynamicSparseMatrix
m_inputs	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^  const int m_inputs, m_values;$/;"	m	struct:Functor	file:
m_inputs	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^  int m_inputs, m_values;$/;"	m	struct:Functor	file:
m_inputs	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  int m_inputs, m_values;$/;"	m	struct:TestFunc1	file:
m_inputs	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  int m_inputs, m_values;$/;"	m	struct:TestFunc1	file:
m_interPacket	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  const Packet m_interPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_invdiag	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Vector m_invdiag;$/;"	m	class:Eigen::DiagonalPreconditioner
m_inverse	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  bool m_inverse;$/;"	m	struct:Eigen::internal::kiss_cpx_fft
m_invp	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_invp;  \/\/ Inverse permutation vector$/;"	m	class:Eigen::PastixBase
m_iparm	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<int,IPARM_SIZE,1> m_iparm; \/\/ integer vector for the input parameters$/;"	m	class:Eigen::PastixBase
m_iparm	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable ParameterType m_iparm;$/;"	m	class:Eigen::PardisoImpl
m_isAllocated	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated;$/;"	m	class:Eigen::JacobiSVD
m_isDense	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    bool m_isDense;             \/\/ mode of the vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_isInitialized	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LDLT
m_isInitialized	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LLT
m_isInitialized	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::CholmodBase
m_isInitialized	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexEigenSolver
m_isInitialized	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexSchur
m_isInitialized	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::EigenSolver
m_isInitialized	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HessenbergDecomposition
m_isInitialized	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::RealSchur
m_isInitialized	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_isInitialized	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::Tridiagonalization
m_isInitialized	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::DiagonalPreconditioner
m_isInitialized	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::IncompleteLUT
m_isInitialized	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase
m_isInitialized	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_isInitialized	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PartialPivLU
m_isInitialized	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PastixBase
m_isInitialized	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR
m_isInitialized	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR
m_isInitialized	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HouseholderQR
m_isInitialized	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated;$/;"	m	class:Eigen::JacobiSVD
m_isInitialized	vcglib/eigenlib/Eigen/src/SVD/UpperBidiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_isInitialized	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_isInitialized	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SuperLUBase
m_isInitialized	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::UmfPackLU
m_isInitialized	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::IncompleteLU
m_isInitialized	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    bool m_isInitialized; $/;"	m	class:Scaling
m_isRValue	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool m_isRValue;$/;"	m	class:Eigen::SparseMatrixBase
m_isRValue	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    bool m_isRValue;$/;"	m	class:Eigen::SkylineMatrixBase
m_isvalid	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool m_isvalid; $/;"	m	class:Eigen::MatrixMarketIterator
m_iterations	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable int m_iterations;$/;"	m	class:Eigen::IterativeSolverBase
m_jacobian	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    JacobianType m_jacobian;$/;"	m	class:Eigen::AutoDiffVector
m_kc	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_kc;$/;"	m	class:Eigen::internal::level3_blocking
m_keyBitsOffset	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    unsigned char m_keyBitsOffset;$/;"	m	class:Eigen::RandomSetter
m_knots	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^    KnotVectorType m_knots; \/*!< Knot vector. *\/$/;"	m	class:Eigen::Spline
m_l	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::SuperLUBase
m_l	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::UmfPackLU
m_l1norm	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    RealScalar m_l1norm;$/;"	m	class:Eigen::MatrixExponential
m_left	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    VectorXd m_left; \/\/ Left scaling vector$/;"	m	class:Scaling
m_length	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    Index m_length;$/;"	m	class:Eigen::HouseholderSequence
m_lhs	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::CwiseBinaryOp
m_lhs	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    const LhsNested m_lhs;$/;"	m	class:Product
m_lhs	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::ProductBase
m_lhs	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<LhsNested>::type m_lhs;$/;"	m	class:Eigen::CoeffBasedProduct
m_lhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Lhs& m_lhs;$/;"	m	struct:Eigen::internal::gemm_functor
m_lhs	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typename LhsMatrixTypeCleaned::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl
m_lhs	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl
m_lhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDenseOuterProduct
m_lhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDiagonalProduct
m_lhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseSparseProduct
m_lhs	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::internal::SkylineProduct
m_lhsIter	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    LhsIterator m_lhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_linked	vcglib/wrap/glw/program.h	/^		bool             m_linked;$/;"	m	class:glw::Program
m_llCurrent	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llCurrent;$/;"	m	class:Eigen::internal::AmbiVector
m_llSize	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llSize;$/;"	m	class:Eigen::internal::AmbiVector
m_llStart	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llStart;$/;"	m	class:Eigen::internal::AmbiVector
m_log	vcglib/wrap/glw/program.h	/^		std::string      m_log;$/;"	m	class:glw::Program
m_log	vcglib/wrap/glw/shader.h	/^		std::string  m_log;$/;"	m	class:glw::Shader
m_low	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  const Scalar m_low;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_lowPacket	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  const Packet m_lowPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_lower	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Scalar* m_lower;$/;"	m	class:Eigen::SkylineStorage
m_lowerProfile	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index* m_lowerProfile;$/;"	m	class:Eigen::SkylineStorage
m_lowerProfileSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_lowerProfileSize;$/;"	m	class:Eigen::SkylineStorage
m_lowerSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_lowerSize;$/;"	m	class:Eigen::SkylineStorage
m_lu	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    FactorType m_lu;$/;"	m	class:Eigen::IncompleteLUT
m_lu	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::FullPivLU
m_lu	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::PartialPivLU
m_lu	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    FactorType m_lu;$/;"	m	class:Eigen::IncompleteLU
m_lu	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    MatrixType& m_lu;$/;"	m	class:Eigen::SkylineInplaceLU
m_mapAccess	vcglib/wrap/glw/buffer.h	/^		GLenum     m_mapAccess;$/;"	m	class:glw::Buffer
m_mapPointer	vcglib/wrap/glw/buffer.h	/^		void *     m_mapPointer;$/;"	m	class:glw::Buffer
m_mat	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    MatrixType m_mat; \/\/ Current matrix  $/;"	m	class:Eigen::MatrixMarketIterator
m_matIsLoaded	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    bool m_matIsLoaded; \/\/ Determine if the matrix has already been loaded from the file$/;"	m	class:Eigen::MatrixMarketIterator
m_matT	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur
m_matT	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::EigenSolver
m_matT	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::RealSchur
m_matU	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    MatrixUType m_matU;$/;"	m	class:Eigen::SVD
m_matU	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur
m_matU	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matU;$/;"	m	class:Eigen::RealSchur
m_matUisUptodate	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::ComplexSchur
m_matUisUptodate	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::RealSchur
m_matV	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    MatrixVType m_matV;$/;"	m	class:Eigen::SVD
m_matX	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_matX;$/;"	m	class:Eigen::ComplexEigenSolver
m_matname	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    std::string m_matname; \/\/ Matrix Name$/;"	m	class:Eigen::MatrixMarketIterator
m_matrix	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LDLT
m_matrix	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LLT
m_matrix	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    typename internal::nested<MatrixType>::type m_matrix;$/;"	m	class:Eigen::CwiseUnaryView
m_matrix	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Diagonal
m_matrix	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::DiagonalProduct
m_matrix	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Flagged
m_matrix	vcglib/eigenlib/Eigen/src/Core/IO.h	/^    const typename ExpressionType::Nested m_matrix;$/;"	m	class:Eigen::WithFormat
m_matrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval
m_matrix	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::Replicate
m_matrix	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Reverse
m_matrix	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SelfAdjointView
m_matrix	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Lhs& m_matrix;$/;"	m	class:Eigen::SelfCwiseBinaryOp
m_matrix	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Transpose
m_matrix	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval
m_matrix	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::TriangularView
m_matrix	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::VectorwiseOp
m_matrix	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::PartialReduxExpr
m_matrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Cwise
m_matrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform
m_matrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    const typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Minor
m_matrix	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::HessenbergDecomposition
m_matrix	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::Tridiagonalization
m_matrix	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
m_matrix	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Homogeneous
m_matrix	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform
m_matrix	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  MatrixTypeNested m_matrix;$/;"	m	struct:Eigen::internal::inverse_impl
m_matrix	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable SparseMatrixType m_matrix;$/;"	m	class:Eigen::PardisoImpl
m_matrix	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    CholMatrixType m_matrix;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_matrix	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator
m_matrix	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
m_matrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    const typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseInnerVectorSet
m_matrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseInnerVectorSet
m_matrix	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval
m_matrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct
m_matrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseSelfAdjointView
m_matrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseTriangularView
m_matrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseView
m_matrix	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_matrix;  \/\/ copy of the factorized matrix$/;"	m	class:Eigen::SuperLUBase
m_matrix	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    MatrixType m_matrix;$/;"	m	class:Scaling
m_matrix	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const SkylineMatrix& m_matrix;$/;"	m	class:Eigen::SkylineMatrix::InnerLowerIterator
m_matrix	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const SkylineMatrix& m_matrix;$/;"	m	class:Eigen::SkylineMatrix::InnerUpperIterator
m_matrix	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    const typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseInnerVectorSet
m_matrixU	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    MatrixUType m_matrixU;$/;"	m	class:Eigen::JacobiSVD
m_matrixV	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    MatrixVType m_matrixV;$/;"	m	class:Eigen::JacobiSVD
m_max	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_max	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_maxFeedbackBuffers	vcglib/wrap/glw/context.h	/^		int                     m_maxFeedbackBuffers;$/;"	m	class:glw::Context
m_maxIterations	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::ComplexSchur
m_maxIterations	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    static const int m_maxIterations = 40;$/;"	m	class:Eigen::RealSchur
m_maxIterations	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_maxIterations	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int m_maxIterations;$/;"	m	class:Eigen::IterativeSolverBase
m_maxTextureUnits	vcglib/wrap/glw/context.h	/^		int                     m_maxTextureUnits;$/;"	m	class:glw::Context
m_maxUniformBuffers	vcglib/wrap/glw/context.h	/^		int                     m_maxUniformBuffers;$/;"	m	class:glw::Context
m_maxiter	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    size_t m_maxiter;     \/\/\/< Max. number of iterations$/;"	m	class:Eigen::IterationController
m_maxits	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    int m_maxits; \/\/ Maximum number of iterations allowed$/;"	m	class:Scaling
m_maxpivot	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_maxpivot	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR
m_maxpivot	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR
m_mc	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_mc;$/;"	m	class:Eigen::internal::level3_blocking
m_min	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_min	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_mode	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_mode;$/;"	m	class:Eigen::internal::AmbiVector
m_monic	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^      RightColumn                m_monic;$/;"	m	class:Eigen::internal::companion
m_msglvl	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl
m_mu	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^    RealScalar m_mu;$/;"	m	class:Eigen::MatrixFunctionAtomic
m_name	vcglib/wrap/glw/object.h	/^		GLuint    m_name;$/;"	m	class:glw::Object
m_nc	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_nc;$/;"	m	class:Eigen::internal::level3_blocking
m_ncols	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int m_ncols;$/;"	m	class:SparseMatrixData
m_nentries	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int m_nentries; \/\/ total number of (including repeated) (i,j) entries$/;"	m	class:SparseMatrixData
m_nit	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    size_t m_nit;         \/\/\/< iteration number$/;"	m	class:Eigen::IterationController
m_nnz	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_nnz;$/;"	m	class:Eigen::MappedSparseMatrix
m_noise	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    int m_noise;          \/\/\/< if noise > 0 iterations are printed$/;"	m	class:Eigen::IterationController
m_nonZerosPerCol	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_nonZerosPerCol;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_nonzeroSingularValues	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD
m_nonzero_pivots	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU
m_nonzero_pivots	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::ColPivHouseholderQR
m_nonzero_pivots	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::FullPivHouseholderQR
m_nrows	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int m_nrows;$/;"	m	class:SparseMatrixData
m_numeric	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_numeric;$/;"	m	class:Eigen::UmfPackLU
m_nz	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int *m_nz;      \/\/ nonzeros per row$/;"	m	class:SparseMatrixData
m_object	vcglib/wrap/glw/bookkeeping.h	/^		ObjectType * m_object;$/;"	m	class:glw::detail::RefCountedObject
m_object	vcglib/wrap/glw/object.h	/^		ObjectPtr m_object;$/;"	m	class:glw::SafeObject
m_objects	vcglib/wrap/glw/context.h	/^		RefCountedPtrPtrMap     m_objects;$/;"	m	class:glw::Context
m_offset	vcglib/wrap/glw/buffer.h	/^		GLintptr   m_offset;$/;"	m	class:glw::BoundFeedbackBuffer
m_offset	vcglib/wrap/glw/buffer.h	/^		GLintptr   m_offset;$/;"	m	class:glw::BoundUniformBuffer
m_origin	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_origin	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_originalMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    const MatrixType& m_originalMatrix;$/;"	m	class:Eigen::LU
m_originalMatrix	vcglib/eigenlib/Eigen/src/misc/Image.h	/^    const MatrixType& m_originalMatrix;$/;"	m	struct:Eigen::internal::image_retval_base
m_other	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_inverse_mult_op
m_other	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_add_op
m_other	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_constant_op
m_other	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar2>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple2_op
m_other	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple_op
m_other	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_quotient1_op
m_outer	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, OuterStrideAtCompileTime> m_outer;$/;"	m	class:Eigen::Stride
m_outer	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    const Index m_outer;$/;"	m	class:Eigen::DenseBase::InnerIterator
m_outer	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator
m_outer	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
m_outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::SparseInnerVectorSet::InnerIterator
m_outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator
m_outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const Index m_outer;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    int m_outer;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator
m_outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    Index m_outer;$/;"	m	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
m_outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::InnerIterator
m_outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator
m_outer	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SkylineMatrix::InnerLowerIterator
m_outer	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SkylineMatrix::InnerUpperIterator
m_outer	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^        Index m_outer;$/;"	m	class:Eigen::SparseInnerVectorSet::InnerIterator
m_outer	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::DynamicSparseMatrix::InnerIterator
m_outer	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
m_outerIndex	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_outerIndex;$/;"	m	class:Eigen::MappedSparseMatrix
m_outerIndex	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Index* m_outerIndex;$/;"	m	class:Eigen::SparseMatrix
m_outerIndexPtr	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_outerIndexPtr;$/;"	m	class:Eigen::UmfPackLU
m_outerPackets	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    Index m_outerPackets;$/;"	m	class:Eigen::RandomSetter
m_outerSize	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_outerSize;$/;"	m	class:Eigen::MappedSparseMatrix
m_outerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, Size> m_outerSize;$/;"	m	class:Eigen::SparseInnerVectorSet
m_outerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_outerSize;$/;"	m	class:Eigen::SparseMatrix
m_outerSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index m_outerSize;$/;"	m	class:Eigen::SkylineMatrix
m_outerSize	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    const internal::variable_if_dynamic<Index, Size> m_outerSize;$/;"	m	class:Eigen::SparseInnerVectorSet
m_outerStart	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    Index m_outerStart;$/;"	m	class:Eigen::SparseInnerVectorSet
m_outerStart	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    Index m_outerStart;$/;"	m	class:Eigen::SparseInnerVectorSet
m_outerStride	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    Index m_outerStride;$/;"	m	class:Eigen::Block
m_p	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    PermutationPType m_p;$/;"	m	class:Eigen::FullPivLU
m_p	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    PermutationType m_p;$/;"	m	class:Eigen::PartialPivLU
m_p	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::SuperLUBase
m_p	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::UmfPackLU
m_packetStep	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  const Packet m_packetStep;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_parent	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_parent;                                \/\/ elimination tree$/;"	m	class:Eigen::SimplicialCholeskyBase
m_pastixdata	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable pastix_data_t *m_pastixdata; \/\/ Data structure for pastix$/;"	m	class:Eigen::PastixBase
m_perm	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_perm;  \/\/ Permutation vector$/;"	m	class:Eigen::PastixBase
m_perm	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable IntColVectorType m_perm;$/;"	m	class:Eigen::PardisoImpl
m_perm	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const Perm& m_perm;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct
m_permutation	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	class:Eigen::Transpose
m_permutation	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval
m_permutation	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval
m_permutation	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    IntVectorType m_permutation; \/**< \\brief Permutation which groups ei'vals in the same cluster together *\/$/;"	m	class:Eigen::MatrixFunction
m_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      ::fftw_plan m_plan;$/;"	m	struct:Eigen::internal::fftw_plan
m_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      fftwf_plan m_plan;$/;"	m	struct:Eigen::internal::fftw_plan
m_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      fftwl_plan m_plan;$/;"	m	struct:Eigen::internal::fftw_plan
m_plans	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      PlanMap m_plans;$/;"	m	struct:Eigen::internal::fftw_impl
m_plans	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  PlanMap m_plans;$/;"	m	struct:Eigen::internal::kissfft_impl
m_precision	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_precision;$/;"	m	class:Eigen::FullPivHouseholderQR
m_precision	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    RealScalar m_precision;$/;"	m	class:Eigen::SkylineInplaceLU
m_preconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner m_preconditioner;$/;"	m	class:Eigen::IterativeSolverBase
m_prescribedThreshold	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_prescribedThreshold	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR
m_prescribedThreshold	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR
m_prod	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    const NestedProduct& m_prod;$/;"	m	class:Eigen::ScaledProduct
m_pt	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable void *m_pt[64];$/;"	m	class:Eigen::PardisoImpl
m_ptr	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    T* m_ptr;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_q	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    PermutationQType m_q;$/;"	m	class:Eigen::FullPivLU
m_q	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::SuperLUBase
m_q	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::UmfPackLU
m_qr	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::ColPivHouseholderQR
m_qr	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::FullPivHouseholderQR
m_qr	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename MatrixType::Nested m_qr;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_qr	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::HouseholderQR
m_qr	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  ColPivHouseholderQR<MatrixType> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_qr	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  ColPivHouseholderQR<TransposeTypeWithSameStorageOrder> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_qr	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  FullPivHouseholderQR<MatrixType> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_qr	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  FullPivHouseholderQR<TransposeTypeWithSameStorageOrder> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_qr	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  HouseholderQR<MatrixType> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_qr	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  HouseholderQR<TransposeTypeWithSameStorageOrder> m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_qr_precond_morecols	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows> m_qr_precond_morecols;$/;"	m	class:Eigen::JacobiSVD
m_qr_precond_morerows	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols> m_qr_precond_morerows;$/;"	m	class:Eigen::JacobiSVD
m_rank	vcglib/eigenlib/Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base
m_rank	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_realSchur	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    RealSchur<MatrixType> m_realSchur;$/;"	m	class:Eigen::EigenSolver
m_realTwiddles	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::map<int, std::vector<Complex> > m_realTwiddles;$/;"	m	struct:Eigen::internal::kissfft_impl
m_refCount	vcglib/wrap/glw/bookkeeping.h	/^		int          m_refCount;$/;"	m	class:glw::detail::RefCountedObject
m_refObject	vcglib/wrap/glw/bookkeeping.h	/^		RefCountedObjectType * m_refObject;$/;"	m	class:glw::detail::ObjectSharedPointer
m_refX	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    VectorType m_refX; \/\/ The reference solution, if exists$/;"	m	class:Eigen::MatrixMarketIterator
m_reference	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  Scalar m_reference;$/;"	m	class:Eigen::SparseView
m_res	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double m_res;         \/\/\/< last computed residual$/;"	m	class:Eigen::IterationController
m_resadd	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double m_resminreach, m_resadd;$/;"	m	class:Eigen::IterationController
m_reserved_entries	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int m_reserved_entries;$/;"	m	class:SparseMatrixData
m_resmax	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double m_resmax;      \/\/\/< maximum residual$/;"	m	class:Eigen::IterationController
m_resminreach	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double m_resminreach, m_resadd;$/;"	m	class:Eigen::IterationController
m_restart	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  int m_restart;$/;"	m	class:Eigen::GMRES
m_result	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    mutable PlainObject m_result;$/;"	m	class:Eigen::ProductBase
m_result	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    mutable PlainObject m_result;$/;"	m	class:Eigen::CoeffBasedProduct
m_returnOne	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    bool m_returnOne;$/;"	m	class:Eigen::SparseTriangularView::InnerIterator
m_rhs	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::CwiseBinaryOp
m_rhs	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    const RhsNested m_rhs;$/;"	m	class:Product
m_rhs	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::ProductBase
m_rhs	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::triangular_solve_retval
m_rhs	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<RhsNested>::type m_rhs;$/;"	m	class:Eigen::CoeffBasedProduct
m_rhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Rhs& m_rhs;$/;"	m	struct:Eigen::internal::gemm_functor
m_rhs	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl
m_rhs	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl
m_rhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_rhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDenseOuterProduct
m_rhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDiagonalProduct
m_rhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseSparseProduct
m_rhs	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_base
m_rhs	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^    const typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_with_guess
m_rhs	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base
m_rhs	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::internal::SkylineProduct
m_rhs	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    VectorType m_rhs;  \/\/ Current vector$/;"	m	class:Eigen::MatrixMarketIterator
m_rhsIter	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsIterator m_rhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_rhsn	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double m_rhsn;        \/\/\/< Right hand side norm$/;"	m	class:Eigen::IterationController
m_right	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    VectorXd m_right; \/\/ m_right scaling vector$/;"	m	class:Scaling
m_roots	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    RootsType               m_roots;$/;"	m	class:Eigen::PolynomialSolverBase
m_row	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  Index m_row;              \/\/ current row id$/;"	m	struct:Eigen::CommaInitializer
m_row	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor
m_row	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet
m_rowFactor	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, RowFactor> m_rowFactor;$/;"	m	class:Eigen::Replicate
m_rowStartIndex	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    Index* m_rowStartIndex;$/;"	m	class:Eigen::SkylineMatrix
m_rowind	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int *m_rowind;$/;"	m	class:SparseMatrixData
m_rows	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrix
m_rows	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_rows	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::CwiseNullaryOp
m_rows	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    DenseIndex m_rows;$/;"	m	class:Eigen::DenseStorage
m_rows	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::MapBase
m_rows	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD
m_rowsTranspositions	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    IntColVectorType m_rowsTranspositions;$/;"	m	class:Eigen::FullPivLU
m_rowsTranspositions	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    TranspositionType m_rowsTranspositions;$/;"	m	class:Eigen::PartialPivLU
m_rowsTranspositions	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^  typename IntColVectorType::Nested m_rowsTranspositions;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_rows_transpositions	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    IntColVectorType m_rows_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR
m_s	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation
m_schur	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexSchur<MatrixType> m_schur;$/;"	m	class:Eigen::ComplexEigenSolver
m_scratchBuf	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<Complex> m_scratchBuf;$/;"	m	struct:Eigen::internal::kiss_cpx_fft
m_shift	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    Index m_shift;$/;"	m	class:Eigen::HouseholderSequence
m_shiftOffset	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftOffset;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_shiftScale	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftScale;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_sigma	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    SingularValuesType m_sigma;$/;"	m	class:Eigen::SVD
m_sign	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    int m_sign;$/;"	m	class:Eigen::LDLT
m_singularValues	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    SingularValuesType m_singularValues;$/;"	m	class:Eigen::JacobiSVD
m_size	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_size	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_size; \/\/ Size of the matrix $/;"	m	class:Eigen::PastixBase
m_size	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_size;$/;"	m	class:Eigen::PardisoImpl
m_size	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_size;$/;"	m	class:Eigen::internal::AmbiVector
m_size	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::CompressedStorage
m_size	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    Index m_size;$/;"	m	class:Eigen::SparseVector
m_size	vcglib/wrap/glw/buffer.h	/^		GLsizeiptr m_size;$/;"	m	class:glw::BoundFeedbackBuffer
m_size	vcglib/wrap/glw/buffer.h	/^		GLsizeiptr m_size;$/;"	m	class:glw::BoundUniformBuffer
m_size	vcglib/wrap/glw/buffer.h	/^		GLsizeiptr m_size;$/;"	m	class:glw::Buffer
m_size	vcglib/wrap/glw/texturecube.h	/^		GLsizei m_size;$/;"	m	class:glw::TextureCube
m_sizeA	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeA;$/;"	m	class:Eigen::internal::gemm_blocking_space
m_sizeB	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeB;$/;"	m	class:Eigen::internal::gemm_blocking_space
m_sizeW	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeW;$/;"	m	class:Eigen::internal::gemm_blocking_space
m_sluA	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluA;$/;"	m	class:Eigen::SuperLUBase
m_sluB	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase
m_sluBerr	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase
m_sluCscale	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase
m_sluEqued	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable char m_sluEqued;$/;"	m	class:Eigen::SuperLUBase
m_sluEtree	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable std::vector<int> m_sluEtree;$/;"	m	class:Eigen::SuperLUBase
m_sluFerr	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase
m_sluL	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase
m_sluOptions	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable superlu_options_t m_sluOptions;$/;"	m	class:Eigen::SuperLUBase
m_sluRscale	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase
m_sluStat	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperLUStat_t m_sluStat;$/;"	m	class:Eigen::SuperLUBase
m_sluU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase
m_sluX	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase
m_source	vcglib/wrap/glw/shader.h	/^		std::string  m_source;$/;"	m	class:glw::Shader
m_squarings	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    int m_squarings;$/;"	m	class:Eigen::MatrixExponential
m_src	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    const Derived& m_src;$/;"	m	struct:Eigen::MatrixExponentialReturnValue
m_src	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    const Derived& m_src;$/;"	m	class:Eigen::MatrixSquareRootReturnValue
m_stageRadix	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<int> m_stageRadix;$/;"	m	struct:Eigen::internal::kiss_cpx_fft
m_stageRemainder	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<int> m_stageRemainder;$/;"	m	struct:Eigen::internal::kiss_cpx_fft
m_start	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index m_start;$/;"	m	class:Eigen::internal::AmbiVector
m_start	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator
m_start	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
m_start	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator
m_start	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator
m_start	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::SkylineMatrix::InnerLowerIterator
m_start	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::SkylineMatrix::InnerUpperIterator
m_startCol	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::Block
m_startRow	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::Block
m_staticA	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 LhsScalar m_staticA[SizeA];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_staticB	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticB[SizeB];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_staticW	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticW[SizeW];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_status	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    mutable int m_status;$/;"	m	class:Eigen::SkylineInplaceLU
m_step	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  const Scalar m_step;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_stepPacket	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  const Packet m_stepPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_storage	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;$/;"	m	class:Eigen::PlainObjectBase
m_stride	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    StrideType m_stride;$/;"	m	class:Eigen::Map
m_stride	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::blas_data_mapper
m_stride	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::const_blas_data_mapper
m_structureIsUptodate	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool m_structureIsUptodate;$/;"	m	class:Eigen::PastixLU
m_subdiag	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typename TridiagonalizationType::SubDiagonalType m_subdiag;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_subs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrix
m_subs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_succeeded	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    bool m_succeeded;$/;"	m	class:Eigen::SkylineInplaceLU
m_supers	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrix
m_supers	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_sym	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    int m_sym; \/\/ Symmetry of the matrix$/;"	m	class:Eigen::MatrixMarketIterator
m_symbolic	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_symbolic;$/;"	m	class:Eigen::UmfPackLU
m_target	vcglib/wrap/glw/object.h	/^		GLenum       m_target;$/;"	m	class:glw::BoundObject
m_temp	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    VectorType m_temp;$/;"	m	class:Eigen::HessenbergDecomposition
m_temp	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::ColPivHouseholderQR
m_temp	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::FullPivHouseholderQR
m_temp	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::HouseholderQR
m_temporary	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    TmpMatrixType m_temporary;$/;"	m	class:Eigen::LDLT
m_texts	vcglib/wrap/glw/utility.h	/^		TextVector   m_texts;$/;"	m	class:glw::ShaderHeaderBuilder
m_then	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    typename ThenMatrixType::Nested m_then;$/;"	m	class:Eigen::Select
m_tmp	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::EigenSolver
m_tmp1	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    MatrixType m_tmp1;$/;"	m	class:Eigen::MatrixExponential
m_tmp2	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    MatrixType m_tmp2;$/;"	m	class:Eigen::MatrixExponential
m_tmpBuf1	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<Complex> m_tmpBuf1;$/;"	m	struct:Eigen::internal::kissfft_impl
m_tmpBuf2	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<Complex> m_tmpBuf2;$/;"	m	struct:Eigen::internal::kissfft_impl
m_tol	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    double m_tol; $/;"	m	class:Scaling
m_tolerance	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar m_tolerance;$/;"	m	class:Eigen::IterativeSolverBase
m_tolerance	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    RealScalar m_tolerance;$/;"	m	class:Eigen::SparseSparseProduct
m_trans	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    bool m_trans;$/;"	m	class:Eigen::HouseholderSequence
m_transpositions	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    TranspositionType m_transpositions;$/;"	m	class:Eigen::LDLT
m_transpositions	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	class:Eigen::Transpose
m_transpositions	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval
m_triangularMatrix	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^    const TriangularType& m_triangularMatrix;$/;"	m	struct:Eigen::internal::triangular_solve_retval
m_twiddles	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^  std::vector<Complex> m_twiddles;$/;"	m	struct:Eigen::internal::kiss_cpx_fft
m_type	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl
m_u	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::SuperLUBase
m_u	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::UmfPackLU
m_uniforms	vcglib/wrap/glw/program.h	/^		UniformMap       m_uniforms;$/;"	m	class:glw::Program
m_unit	vcglib/wrap/glw/object.h	/^		GLint        m_unit;$/;"	m	class:glw::BoundObject
m_upper	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Scalar* m_upper;$/;"	m	class:Eigen::SkylineStorage
m_upperProfile	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index* m_upperProfile;$/;"	m	class:Eigen::SkylineStorage
m_upperProfileSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_upperProfileSize;$/;"	m	class:Eigen::SkylineStorage
m_upperSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    Index m_upperSize;$/;"	m	class:Eigen::SkylineStorage
m_usage	vcglib/wrap/glw/buffer.h	/^		GLenum     m_usage;$/;"	m	class:glw::Buffer
m_usePrescribedThreshold	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_usePrescribedThreshold	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR
m_usePrescribedThreshold	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR
m_vals	vcglib/wrap/miq/core/sparsesystemdata.h	/^  double       *m_vals;$/;"	m	class:SparseMatrixData
m_value	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Scalar m_value;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_value	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^        Index m_value;$/;"	m	class:Eigen::SparseMatrix::SingletonVector
m_value	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^  Scalar m_value;$/;"	m	class:Eigen::Triplet
m_value	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    Scalar m_value;$/;"	m	class:Eigen::AutoDiffScalar
m_valuePtr	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const Scalar* m_valuePtr;$/;"	m	class:Eigen::UmfPackLU
m_values	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    Scalar* m_values;$/;"	m	class:Eigen::internal::CompressedStorage
m_values	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Scalar* m_values;$/;"	m	class:Eigen::MappedSparseMatrix
m_values	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::InnerIterator
m_values	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator
m_values	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    ValueType m_values;$/;"	m	class:Eigen::AutoDiffVector
m_values	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^  const int m_inputs, m_values;$/;"	m	struct:Functor	file:
m_values	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^  int m_inputs, m_values;$/;"	m	struct:Functor	file:
m_values	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  int m_inputs, m_values;$/;"	m	struct:TestFunc1	file:
m_values	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  int m_inputs, m_values;$/;"	m	struct:TestFunc1	file:
m_vector	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    const AmbiVector& m_vector; \/\/ the target vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_vectors	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    typename VectorsType::Nested m_vectors;$/;"	m	class:Eigen::HouseholderSequence
m_version	vcglib/wrap/glw/utility.h	/^		std::string  m_version;$/;"	m	class:glw::ShaderHeaderBuilder
m_view	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  const SparseView& m_view;$/;"	m	class:Eigen::SparseView::InnerIterator
m_width	vcglib/wrap/glw/renderbuffer.h	/^		GLsizei m_width;$/;"	m	class:glw::Renderbuffer
m_width	vcglib/wrap/glw/texture2d.h	/^		GLsizei m_width;$/;"	m	class:glw::Texture2D
m_workMatrix	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    WorkMatrixType m_workMatrix;$/;"	m	class:Eigen::JacobiSVD
m_workspace	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  WorkspaceType m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspace	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_col_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspace	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_row_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspaceVector	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    ColumnVectorType m_workspaceVector;$/;"	m	class:Eigen::RealSchur
m_written	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    bool m_written;$/;"	m	class:Eigen::IterationController
m_x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double m_x[14];$/;"	m	struct:misra1a_functor	file:
m_x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double m_x[236];$/;"	m	struct:hahn1_functor	file:
m_x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double m_x[54];$/;"	m	struct:chwirut2_functor	file:
m_x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double chwirut2_functor::m_x[54] = { 0.500E0, 1.000E0, 1.750E0, 3.750E0, 5.750E0, 0.875E0, 2.250E0, 3.250E0, 5.250E0, 0.750E0, 1.750E0, 2.750E0, 4.750E0, 0.625E0, 1.250E0, 2.250E0, 4.250E0, .500E0, 3.000E0, .750E0, 3.000E0, 1.500E0, 6.000E0, 3.000E0, 6.000E0, 1.500E0, 3.000E0, .500E0, 2.000E0, 4.000E0, .750E0, 2.000E0, 5.000E0, .750E0, 2.250E0, 3.750E0, 5.750E0, 3.000E0, .750E0, 2.500E0, 4.000E0, .750E0, 2.500E0, 4.000E0, .750E0, 2.500E0, 4.000E0, .500E0, 6.000E0, 3.000E0, .500E0, 2.750E0, .500E0, 1.750E0};$/;"	m	class:chwirut2_functor	file:
m_x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double hahn1_functor::m_x[236] = { 24.41E0 , 34.82E0 , 44.09E0 , 45.07E0 , 54.98E0 , 65.51E0 , 70.53E0 , 75.70E0 , 89.57E0 , 91.14E0 , 96.40E0 , 97.19E0 , 114.26E0 , 120.25E0 , 127.08E0 , 133.55E0 , 133.61E0 , 158.67E0 , 172.74E0 , 171.31E0 , 202.14E0 , 220.55E0 , 221.05E0 , 221.39E0 , 250.99E0 , 268.99E0 , 271.80E0 , 271.97E0 , 321.31E0 , 321.69E0 , 330.14E0 , 333.03E0 , 333.47E0 , 340.77E0 , 345.65E0 , 373.11E0 , 373.79E0 , 411.82E0 , 419.51E0 , 421.59E0 , 422.02E0 , 422.47E0 , 422.61E0 , 441.75E0 , 447.41E0 , 448.7E0  , 472.89E0 , 476.69E0 , 522.47E0 , 522.62E0 , 524.43E0 , 546.75E0 , 549.53E0 , 575.29E0 , 576.00E0 , 625.55E0 , 20.15E0 , 28.78E0 , 29.57E0 , 37.41E0 , 39.12E0 , 50.24E0 , 61.38E0 , 66.25E0 , 73.42E0 , 95.52E0 , 107.32E0 , 122.04E0 , 134.03E0 , 163.19E0 , 163.48E0 , 175.70E0 , 179.86E0 , 211.27E0 , 217.78E0 , 219.14E0 , 262.52E0 , 268.01E0 , 268.62E0 , 336.25E0 , 337.23E0 , 339.33E0 , 427.38E0 , 428.58E0 , 432.68E0 , 528.99E0 , 531.08E0 , 628.34E0 , 253.24E0 , 273.13E0 , 273.66E0 , 282.10E0 , 346.62E0 , 347.19E0 , 348.78E0 , 351.18E0 , 450.10E0 , 450.35E0 , 451.92E0 , 455.56E0 , 552.22E0 , 553.56E0 , 555.74E0 , 652.59E0 , 656.20E0 , 14.13E0 , 20.41E0 , 31.30E0 , 33.84E0 , 39.70E0 , 48.83E0 , 54.50E0 , 60.41E0 , 72.77E0 , 75.25E0 , 86.84E0 , 94.88E0 , 96.40E0 , 117.37E0 , 139.08E0 , 147.73E0 , 158.63E0 , 161.84E0 , 192.11E0 , 206.76E0 , 209.07E0 , 213.32E0 , 226.44E0 , 237.12E0 , 330.90E0 , 358.72E0 , 370.77E0 , 372.72E0 , 396.24E0 , 416.59E0 , 484.02E0 , 495.47E0 , 514.78E0 , 515.65E0 , 519.47E0 , 544.47E0 , 560.11E0 , 620.77E0 , 18.97E0 , 28.93E0 , 33.91E0 , 40.03E0 , 44.66E0 , 49.87E0 , 55.16E0 , 60.90E0 , 72.08E0 , 85.15E0 , 97.06E0 , 119.63E0 , 133.27E0 , 143.84E0 , 161.91E0 , 180.67E0 , 198.44E0 , 226.86E0 , 229.65E0 , 258.27E0 , 273.77E0 , 339.15E0 , 350.13E0 , 362.75E0 , 371.03E0 , 393.32E0 , 448.53E0 , 473.78E0 , 511.12E0 , 524.70E0 , 548.75E0 , 551.64E0 , 574.02E0 , 623.86E0 , 21.46E0 , 24.33E0 , 33.43E0 , 39.22E0 , 44.18E0 , 55.02E0 , 94.33E0 , 96.44E0 , 118.82E0 , 128.48E0 , 141.94E0 , 156.92E0 , 171.65E0 , 190.00E0 , 223.26E0 , 223.88E0 , 231.50E0 , 265.05E0 , 269.44E0 , 271.78E0 , 273.46E0 , 334.61E0 , 339.79E0 , 349.52E0 , 358.18E0 , 377.98E0 , 394.77E0 , 429.66E0 , 468.22E0 , 487.27E0 , 519.54E0 , 523.03E0 , 612.99E0 , 638.59E0 , 641.36E0 , 622.05E0 , 631.50E0 , 663.97E0 , 646.9E0  , 748.29E0 , 749.21E0 , 750.14E0 , 647.04E0 , 646.89E0 , 746.9E0  , 748.43E0 , 747.35E0 , 749.27E0 , 647.61E0 , 747.78E0 , 750.51E0 , 851.37E0 , 845.97E0 , 847.54E0 , 849.93E0 , 851.61E0 , 849.75E0 , 850.98E0 , 848.23E0};$/;"	m	class:hahn1_functor	file:
m_x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double misra1a_functor::m_x[14] = { 77.6E0, 114.9E0, 141.1E0, 190.8E0, 239.9E0, 289.0E0, 332.8E0, 378.4E0, 434.8E0, 477.3E0, 536.8E0, 593.1E0, 689.1E0, 760.0E0};$/;"	m	class:misra1a_functor	file:
m_x	vcglib/wrap/miq/core/sparsesystemdata.h	/^  double       *m_x;$/;"	m	class:SparseSystemData
m_xpr	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    const typename XprType::Nested m_xpr;$/;"	m	class:Eigen::Block
m_xpr	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::Block
m_xpr	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  XprType& m_xpr;   \/\/ target expression$/;"	m	struct:Eigen::CommaInitializer
m_xpr	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::CwiseUnaryOp
m_xpr	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const CwiseBinaryXpr& m_xpr;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double m_y[14];$/;"	m	struct:misra1a_functor	file:
m_y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double m_y[54];$/;"	m	struct:chwirut2_functor	file:
m_y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double chwirut2_functor::m_y[54] = { 92.9000E0 ,57.1000E0 ,31.0500E0 ,11.5875E0 ,8.0250E0 ,63.6000E0 ,21.4000E0 ,14.2500E0 ,8.4750E0 ,63.8000E0 ,26.8000E0 ,16.4625E0 ,7.1250E0 ,67.3000E0 ,41.0000E0 ,21.1500E0 ,8.1750E0 ,81.5000E0 ,13.1200E0 ,59.9000E0 ,14.6200E0 ,32.9000E0 ,5.4400E0 ,12.5600E0 ,5.4400E0 ,32.0000E0 ,13.9500E0 ,75.8000E0 ,20.0000E0 ,10.4200E0 ,59.5000E0 ,21.6700E0 ,8.5500E0 ,62.0000E0 ,20.2000E0 ,7.7600E0 ,3.7500E0 ,11.8100E0 ,54.7000E0 ,23.7000E0 ,11.5500E0 ,61.3000E0 ,17.7000E0 ,8.7400E0 ,59.2000E0 ,16.3000E0 ,8.6200E0 ,81.0000E0 ,4.8700E0 ,14.6200E0 ,81.7000E0 ,17.1700E0 ,81.3000E0 ,28.9000E0  };$/;"	m	class:chwirut2_functor	file:
m_y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double misra1a_functor::m_y[14] = { 10.07E0, 14.73E0, 17.94E0, 23.93E0, 29.61E0, 35.18E0, 40.02E0, 44.82E0, 50.76E0, 55.05E0, 61.01E0, 66.40E0, 75.47E0, 81.78E0};$/;"	m	class:misra1a_functor	file:
m_zero	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_zero;$/;"	m	class:Eigen::internal::AmbiVector
machine_epsilon	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T machine_epsilon () { return NumTraits<T>::epsilon(); }$/;"	f	namespace:Eigen
machine_epsilon	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal machine_epsilon(const mpreal& x)$/;"	f	namespace:mpfr
machine_epsilon	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal machine_epsilon(mp_prec_t prec)$/;"	f	namespace:mpfr
madd	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits
madd	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits
madd	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits
madd	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits
madd_impl	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const$/;"	f	class:Eigen::internal::gebp_traits
madd_impl	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& \/*tmp*\/, const false_type&) const$/;"	f	class:Eigen::internal::gebp_traits
mag2	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^T mag2(T a)$/;"	f
mag2	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^T mag2(const std::vector<T> & vec)$/;"	f
mag2	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^T mag2(const std::vector<std::complex<T> > & vec)$/;"	f
mag2	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^T mag2(std::complex<T> a)$/;"	f
magFilter	vcglib/wrap/glw/texture.h	/^		GLenum magFilter;$/;"	m	class:glw::TextureSampleMode
magic	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t     magic;$/;"	m	struct:malloc_state	file:
magic	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  volatile size_t magic;$/;"	m	struct:malloc_params	file:
main	poissonDisk.cpp	/^int main(int argc, char *argv[]) $/;"	f
main	vcglib/apps/metro/metro.cpp	/^int main(int argc, char**argv)$/;"	f
main	vcglib/apps/pivoting/main.cpp	/^int main(int argc, char *argv[]) {   $/;"	f
main	vcglib/apps/plyrefine/main.cpp	/^int  main(int argc, char **argv){$/;"	f
main	vcglib/apps/quadrangulator/quadrangulator.cpp	/^int main(int argc, const char * argv[])$/;"	f
main	vcglib/apps/sample/aabb_binary_tree/aabb_binary_tree.cpp	/^int main (int \/*argc*\/, char ** \/*argv*\/) {$/;"	f
main	vcglib/apps/sample/colorspace/colorspace.cpp	/^int main(int argc,char ** argv)$/;"	f
main	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/img_filters/img_filters.cpp	/^int main(int argc,char ** argv)$/;"	f
main	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^int			main(int argc, char *argv[]) {$/;"	f
main	vcglib/apps/sample/polygonmesh_polychord_collapse/polygonmesh_polychord_collapse.cpp	/^int main(int argc, char *argv[])$/;"	f
main	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^int main(int argc, char *argv[]) {$/;"	f
main	vcglib/apps/sample/polygonmesh_zonohedra/polygonmesh_zonohedra.cpp	/^int main(int argc, char *argv[]){$/;"	f
main	vcglib/apps/sample/space_minimal/space_minimal.cpp	/^int main(int argc, char *argv[])$/;"	f
main	vcglib/apps/sample/space_packer/space_packer.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_QT/main.cpp	/^int main(int argc, char *argv[])$/;"	f
main	vcglib/apps/sample/trimesh_allocate/trimesh_allocate.cpp	/^int main()$/;"	f
main	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^int main(int argc, char *argv[])$/;"	f
main	vcglib/apps/sample/trimesh_ant_qt/main.cpp	/^int main(int argc, char *argv[])$/;"	f
main	vcglib/apps/sample/trimesh_attribute/trimesh_attribute.cpp	/^int main()$/;"	f
main	vcglib/apps/sample/trimesh_ball_pivoting/trimesh_ball_pivoting.cpp	/^int  main(int argc, char **argv)$/;"	f
main	vcglib/apps/sample/trimesh_base/trimesh_base.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_closest/trimesh_closest.cpp	/^int main(int argc ,char**argv)$/;"	f
main	vcglib/apps/sample/trimesh_clustering/trimesh_clustering.cpp	/^int  main(int argc, char **argv)$/;"	f
main	vcglib/apps/sample/trimesh_color/trimesh_color.cpp	/^int  main()$/;"	f
main	vcglib/apps/sample/trimesh_copy/trimesh_copy.cpp	/^int main(int \/*argc*\/ ,char**argv)$/;"	f
main	vcglib/apps/sample/trimesh_curvature/trimesh_curvature.cpp	/^int main( int \/*argc*\/, char **\/*argv*\/ )$/;"	f
main	vcglib/apps/sample/trimesh_cylclip/trimesh_cylclip.cpp	/^int main()$/;"	f
main	vcglib/apps/sample/trimesh_diskparam/trimesh_diskparam.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_edge/trimesh_edge.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_fitting/trimesh_fitting.cpp	/^int main( )$/;"	f
main	vcglib/apps/sample/trimesh_geodesic/trimesh_geodesic.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_hole/trimesh_hole.cpp	/^int main(int argc,char ** argv){$/;"	f
main	vcglib/apps/sample/trimesh_inertia/trimesh_inertia.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_intersection/trimesh_intersection.cpp	/^int main(int argc,char ** argv)$/;"	f
main	vcglib/apps/sample/trimesh_isosurface/trimesh_isosurface.cpp	/^int main(int \/*argc*\/ , char **\/*argv*\/)$/;"	f
main	vcglib/apps/sample/trimesh_join/trimesh_join.cpp	/^int main(int argc,char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_kdtree/trimesh_kdtree.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_normal/trimesh_normal.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_optional/trimesh_optional.cpp	/^int main(int , char **)$/;"	f
main	vcglib/apps/sample/trimesh_optional/trimesh_optional_occ.cpp	/^int main()$/;"	f
main	vcglib/apps/sample/trimesh_optional/trimesh_optional_ocf.cpp	/^int main()$/;"	f
main	vcglib/apps/sample/trimesh_optional/trimesh_simpdata_simp.cpp	/^int main()$/;"	f
main	vcglib/apps/sample/trimesh_pointcloud_sampling/trimesh_pointcloud_sampling.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_pointmatching/trimesh_pointmatching.cpp	/^int main( )$/;"	f
main	vcglib/apps/sample/trimesh_pos_demo/main.cpp	/^int main(int argc, char *argv[])$/;"	f
main	vcglib/apps/sample/trimesh_pos_demo/trimesh_pos_demo.cpp	/^int main()$/;"	f
main	vcglib/apps/sample/trimesh_pos_demo/trimesh_vfiter_demo.cpp	/^int main()$/;"	f
main	vcglib/apps/sample/trimesh_ray/trimesh_ray.cpp	/^int main(int argc,char ** argv)$/;"	f
main	vcglib/apps/sample/trimesh_refine/trimesh_refine.cpp	/^int  main(int argc, char **argv)$/;"	f
main	vcglib/apps/sample/trimesh_sampling/trimesh_sampling.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_smooth/trimesh_smooth.cpp	/^int main(int argc,char ** argv)$/;"	f
main	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^int main(int argc, char ** argv)$/;"	f
main	vcglib/apps/sample/trimesh_texture/trimesh_texture.cpp	/^int main(int ,char ** )$/;"	f
main	vcglib/apps/sample/trimesh_topology/trimesh_topology.cpp	/^int main(int ,char ** )$/;"	f
main	vcglib/apps/sample/trimesh_voronoi/trimesh_voronoi.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_voronoiatlas/trimesh_voronoiatlas.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_voronoiclustering/trimesh_voronoiclustering.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/sample/trimesh_voronoisampling/trimesh_voronoisampling.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/test/camerashot/camerashot_test.cpp	/^int main()$/;"	f
main	vcglib/apps/test/quaternion/quat_test.cpp	/^int main() {$/;"	f
main	vcglib/apps/test/tetramesh/test/test.cpp	/^int main( int argc, char **argv )$/;"	f
main	vcglib/apps/test/trackball/main.cpp	/^int main(int argc, unsigned short **argv) {  $/;"	f
main	vcglib/apps/tridecimator/tridecimator.cpp	/^int main(int argc ,char**argv){$/;"	f
main	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^int main(int argc, char ** argv)$/;"	f
main	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^void main(int argc,char ** argv){$/;"	f
main	vcglib/apps/unsupported/extractors/extractor/main.cpp	/^int main(int argc, char *argv[])$/;"	f
main	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^int main(int argc, char *argv[])$/;"	f
main	vcglib/apps/unsupported/shadevis/shadevis.cpp	/^int main(int argc, char** argv)$/;"	f
main	vcglib/apps/unsupported/texdeci/texdeci.cpp	/^int main(int argc, char**argv){$/;"	f
main	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^int main(int argc, char *argv[]) {	$/;"	f
main	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^int main(int argc, char *argv[]) {	$/;"	f
main	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^int main()$/;"	f
main	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^int main()$/;"	f
main	vcglib/eigenlib/unsupported/doc/examples/MatrixExponential.cpp	/^int main()$/;"	f
main	vcglib/eigenlib/unsupported/doc/examples/MatrixFunction.cpp	/^int main()$/;"	f
main	vcglib/eigenlib/unsupported/doc/examples/MatrixLogarithm.cpp	/^int main()$/;"	f
main	vcglib/eigenlib/unsupported/doc/examples/MatrixSine.cpp	/^int main()$/;"	f
main	vcglib/eigenlib/unsupported/doc/examples/MatrixSinh.cpp	/^int main()$/;"	f
main	vcglib/eigenlib/unsupported/doc/examples/MatrixSquareRoot.cpp	/^int main()$/;"	f
main	vcglib/eigenlib/unsupported/doc/examples/PolynomialSolver1.cpp	/^int main()$/;"	f
main	vcglib/eigenlib/unsupported/doc/examples/PolynomialUtils1.cpp	/^int main()$/;"	f
makeAffine	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  void makeAffine()$/;"	f	class:Eigen::Transform
makeCompressed	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    void makeCompressed()$/;"	f	class:Eigen::SparseMatrix
makeGivens	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)$/;"	f	class:Eigen::JacobiRotation
makeGivens	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)$/;"	f	class:Eigen::JacobiRotation
makeGivens	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* z)$/;"	f	class:Eigen::JacobiRotation
makeHouseholder	vcglib/eigenlib/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholder($/;"	f	class:Eigen::MatrixBase
makeHouseholderInPlace	vcglib/eigenlib/Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholderInPlace(Scalar& tau, RealScalar& beta)$/;"	f	class:Eigen::MatrixBase
makeJacobi	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^bool JacobiRotation<Scalar>::makeJacobi(RealScalar x, Scalar y, RealScalar z)$/;"	f	class:Eigen::JacobiRotation
makeJacobi	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)$/;"	f	class:Eigen::JacobiRotation
makeString	vcglib/wrap/qt/checkGLError.h	/^  static QString makeString(const char* m)$/;"	f	class:checkGLError
make_block_householder_triangular_factor	vcglib/eigenlib/Eigen/src/Householder/BlockHouseholder.h	/^void make_block_householder_triangular_factor(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal
make_coherent	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^void make_coherent(const A& a, const B&b)$/;"	f	namespace:Eigen::internal
make_coherent_impl	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct make_coherent_impl {$/;"	s	namespace:Eigen::internal
make_coherent_impl	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct make_coherent_impl<A, Matrix<B_Scalar, B_Rows, B_Cols, B_Options, B_MaxRows, B_MaxCols> > {$/;"	s	namespace:Eigen::internal
make_coherent_impl	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct make_coherent_impl<Matrix<A_Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols>, B> {$/;"	s	namespace:Eigen::internal
make_coherent_impl	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct make_coherent_impl<Matrix<A_Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols>,$/;"	s	namespace:Eigen::internal
make_twiddles	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void make_twiddles(int nfft,bool inverse)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
mallinfo	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^struct mallinfo {$/;"	s	file:
mallinfo	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^struct mallinfo {$/;"	s
malloc_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^struct malloc_chunk {$/;"	s	file:
malloc_corruption_error_count	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^int malloc_corruption_error_count;$/;"	v
malloc_getpagesize	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#                define malloc_getpagesize /;"	d	file:
malloc_getpagesize	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#              define malloc_getpagesize /;"	d	file:
malloc_getpagesize	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#          define malloc_getpagesize /;"	d	file:
malloc_getpagesize	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#        define malloc_getpagesize /;"	d	file:
malloc_getpagesize	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#      define malloc_getpagesize /;"	d	file:
malloc_getpagesize	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#    define malloc_getpagesize /;"	d	file:
malloc_global_mutex	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static MLOCK_T malloc_global_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
malloc_global_mutex	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static MLOCK_T malloc_global_mutex = { 0, 0, 0};$/;"	v	file:
malloc_global_mutex	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static MLOCK_T malloc_global_mutex;$/;"	v	file:
malloc_global_mutex_status	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static volatile long malloc_global_mutex_status;$/;"	v	file:
malloc_params	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^struct malloc_params {$/;"	s	file:
malloc_segment	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^struct malloc_segment {$/;"	s	file:
malloc_state	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^struct malloc_state {$/;"	s	file:
malloc_tree_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^struct malloc_tree_chunk {$/;"	s	file:
manageErrorCode	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void manageErrorCode(Index error)$/;"	f	class:Eigen::PardisoImpl
manage_caching_sizes	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void manage_caching_sizes(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)$/;"	f	namespace:Eigen::internal
manage_caching_sizes_helper	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t manage_caching_sizes_helper(std::ptrdiff_t a, std::ptrdiff_t b)$/;"	f	namespace:Eigen::internal
manage_multi_threading	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^inline void manage_multi_threading(Action action, int* v)$/;"	f	namespace:Eigen::internal
manipulator	vcglib/wrap/gui/activecoordinateframe.h	/^  Trackball *manipulator;$/;"	m	class:vcg::ActiveCoordinateFrame
map	vcglib/wrap/glw/buffer.h	/^		void * map(GLenum access)$/;"	f	class:glw::BoundBuffer
map	vcglib/wrap/glw/buffer.h	/^		void * map(GLenum target, GLint unit, GLenum access)$/;"	f	class:glw::Buffer
mapAccess	vcglib/wrap/glw/buffer.h	/^		GLenum mapAccess(GLenum target, GLint unit) const$/;"	f	class:glw::Buffer
mapAccess	vcglib/wrap/glw/buffer.h	/^		GLenum mapAccess(void) const$/;"	f	class:glw::BoundBuffer
mapPointer	vcglib/wrap/glw/buffer.h	/^		void * mapPointer(GLenum target, GLint unit) const$/;"	f	class:glw::Buffer
mapPointer	vcglib/wrap/glw/buffer.h	/^		void * mapPointer(void) const$/;"	f	class:glw::BoundBuffer
mapType	vcglib/wrap/math/system_interface_ldl.h	/^	typedef std::map<IndexType,int> mapType;$/;"	t	class:SystemLDL
map_Kd	vcglib/wrap/io_trimesh/io_material.h	/^		std::string map_Kd; \/\/filename texture$/;"	m	struct:vcg::tri::io::Material
map_superlu	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> map_superlu(SluMatrix& sluMat)$/;"	f	namespace:Eigen::internal
mapsub	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  std::vector<int> mapsub;					\/\/ subset of index to the vertices in Q$/;"	m	class:vcg::tri::FourPCS
marginCm	vcglib/wrap/io_edgemesh/export_svg.h	/^ 	Point2f marginCm; \/\/ how much space between each slice box (in cm)$/;"	m	class:vcg::tri::io::SVGProperties
mark	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^	int mark;$/;"	m	class:MyMarker	file:
mark	vcglib/apps/sample/hashing_2D/test_hash2D.cpp	/^	int mark;$/;"	m	class:MySegmentType	file:
mark	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    unsigned long mark;$/;"	m	struct:vcg::tri::PolychordCollapse::PC_Chord
markAsRValue	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& markAsRValue() { m_isRValue = true; return derived(); }$/;"	f	class:Eigen::SparseMatrixBase
markAsRValue	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    Derived& markAsRValue() {$/;"	f	class:Eigen::SkylineMatrixBase
mark_inuse_foot	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define mark_inuse_foot(/;"	d	file:
mark_smallmap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define mark_smallmap(/;"	d	file:
mark_treemap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define mark_treemap(/;"	d	file:
marked	vcglib/eigenlib/Eigen/src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::marked() const$/;"	f	class:Eigen::MatrixBase
markerFunctor	vcglib/vcg/complex/algorithms/create/resampler.h	/^		MarkerFace markerFunctor;$/;"	m	class:vcg::tri::Resampler::Walker
markerFunctor	vcglib/vcg/complex/algorithms/point_sampling.h	/^tri::FaceTmark<MetroMesh> markerFunctor;$/;"	m	class:vcg::tri::SurfaceSampling::RRParam
markerFunctorFix	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    MarkerVertex markerFunctorFix;              \/\/variable to manage uniform grid$/;"	m	class:OverlapEstimation
marks	vcglib/vcg/space/index/octree.h	/^        unsigned char	*marks;$/;"	m	class:vcg::Octree
mask	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            const unsigned int mask;$/;"	m	struct:vcg::tri::AttributeSeam::ASCompare
mask	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            const unsigned int mask;$/;"	m	struct:vcg::tri::AttributeSeam::ASExtract
mask	vcglib/wrap/io_tetramesh/io_ply.h	/^  int mask;  $/;"	m	class:vcg::tetra::io::PlyInfo
mask	vcglib/wrap/io_trimesh/additionalinfo.h	/^	int mask;$/;"	m	class:AdditionalInfo
mask	vcglib/wrap/io_trimesh/import_fbx.h	/^		int mask;  $/;"	m	class:ImporterFBX::Info
mask	vcglib/wrap/io_trimesh/import_obj.h	/^                    int mask;$/;"	m	class:vcg::tri::io::ImporterOBJ::Info
mask	vcglib/wrap/io_trimesh/import_ptx.h	/^			int mask;  $/;"	m	class:vcg::tri::io::ImporterPTX::Info
mask	vcglib/wrap/io_trimesh/io_ply.h	/^  int mask;  $/;"	m	class:vcg::tri::io::PlyInfo
matPrefix	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat
matSuffix	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat
matchVertexID	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^  inline static int matchVertexID(FaceType *f,VertexType *v)$/;"	f	class:vcg::tri::TriEdgeCollapseQuadricTex
material	vcglib/wrap/io_trimesh/import_fbx.h	/^		std::map<const char*,MaterialInfo> material;$/;"	m	class:ImporterFBX::VCGMaterialBridge
materialName	vcglib/wrap/io_trimesh/io_material.h	/^		std::string materialName;$/;"	m	struct:vcg::tri::io::Material
math	vcglib/vcg/math/base.h	/^namespace math {$/;"	n	namespace:vcg
math	vcglib/vcg/math/factorial.h	/^namespace math{$/;"	n	namespace:vcg
math	vcglib/vcg/math/legendre.h	/^namespace math {$/;"	n	namespace:vcg
math	vcglib/vcg/math/perlin_noise.h	/^ namespace math {$/;"	n	namespace:vcg
math	vcglib/vcg/math/quadric.h	/^namespace math {$/;"	n	namespace:vcg
math	vcglib/vcg/math/quadric5.h	/^namespace math {$/;"	n	namespace:vcg
math	vcglib/vcg/math/random_generator.h	/^namespace math {$/;"	n	namespace:vcg
math	vcglib/vcg/math/spherical_harmonics.h	/^namespace math{$/;"	n	namespace:vcg
matname	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline std::string& matname() { return m_matname; }$/;"	f	class:Eigen::MatrixMarketIterator
matrix	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    MatrixWrapper<Derived> matrix() { return derived(); }$/;"	f	class:Eigen::ArrayBase
matrix	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    const MatrixWrapper<const Derived> matrix() const { return derived(); }$/;"	f	class:Eigen::ArrayBase
matrix	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    MatrixBase<Derived>& matrix() { return *this; }$/;"	f	class:Eigen::MatrixBase
matrix	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    const MatrixBase<Derived>& matrix() const { return *this; }$/;"	f	class:Eigen::MatrixBase
matrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType matrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase
matrix	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    _MatrixTypeNested& matrix() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::SparseSelfAdjointView
matrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const _MatrixTypeNested& matrix() const { return m_matrix; }$/;"	f	class:Eigen::SparseSelfAdjointView
matrix	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline MatrixType& matrix() $/;"	f	class:Eigen::MatrixMarketIterator
matrix	vcglib/vcg/math/legendre.h	/^	ScalarType matrix[MAX_L][MAX_L]; \/\/dynamic table$/;"	m	class:vcg::math::DynamicLegendre
matrix	vcglib/wrap/gui/view.h	/^  Matrix44<T> matrix;$/;"	m	class:vcg::View
matrixFunction	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^const MatrixFunctionReturnValue<Derived> MatrixBase<Derived>::matrixFunction(typename internal::stem_function<typename internal::traits<Derived>::Scalar>::type f) const$/;"	f	class:Eigen::MatrixBase
matrixH	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixHReturnType matrixH() const$/;"	f	class:Eigen::HessenbergDecomposition
matrixL	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LDLT
matrixL	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LLT
matrixL	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLDLT
matrixL	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLLT
matrixL	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const LMatrixType& matrixL() const$/;"	f	class:Eigen::SuperLU
matrixL	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixL() const$/;"	f	class:Eigen::UmfPackLU
matrixLDLT	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    inline const MatrixType& matrixLDLT() const$/;"	f	class:Eigen::LDLT
matrixLLT	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    inline const MatrixType& matrixLLT() const$/;"	f	class:Eigen::LLT
matrixLU	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::FullPivLU
matrixLU	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::PartialPivLU
matrixQ	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^    MatrixType matrixQ(void) const {$/;"	f	class:Eigen::QR
matrixQ	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::HessenbergDecomposition
matrixQ	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::Tridiagonalization
matrixQ	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^inline typename FullPivHouseholderQR<MatrixType>::MatrixQReturnType FullPivHouseholderQR<MatrixType>::matrixQ() const$/;"	f	class:Eigen::FullPivHouseholderQR
matrixQR	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::ColPivHouseholderQR
matrixQR	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::FullPivHouseholderQR
matrixQR	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::HouseholderQR
matrixR	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^    matrixR(void) const$/;"	f	class:Eigen::QR
matrixT	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixT() const$/;"	f	class:Eigen::ComplexSchur
matrixT	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixT() const$/;"	f	class:Eigen::RealSchur
matrixT	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixTReturnType matrixT() const$/;"	f	class:Eigen::Tridiagonalization
matrixU	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LDLT
matrixU	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LLT
matrixU	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    const MatrixUType& matrixU() const { return m_matU; }$/;"	f	class:Eigen::SVD
matrixU	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixU() const$/;"	f	class:Eigen::ComplexSchur
matrixU	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixU() const$/;"	f	class:Eigen::RealSchur
matrixU	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    const MatrixUType& matrixU() const$/;"	f	class:Eigen::JacobiSVD
matrixU	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLDLT
matrixU	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLLT
matrixU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const UMatrixType& matrixU() const$/;"	f	class:Eigen::SuperLU
matrixU	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixU() const$/;"	f	class:Eigen::UmfPackLU
matrixV	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    const MatrixVType& matrixV() const { return m_matV; }$/;"	f	class:Eigen::SVD
matrixV	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    const MatrixVType& matrixV() const$/;"	f	class:Eigen::JacobiSVD
matrix_swap_impl	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl$/;"	s	namespace:Eigen::internal
matrix_swap_impl	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>$/;"	s	namespace:Eigen::internal
matrix_type_times_scalar_type	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^template<typename OtherScalarType, typename MatrixType> struct matrix_type_times_scalar_type$/;"	s	namespace:Eigen::internal
max	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^(max)(const Scalar &other) const$/;"	f
max	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<DerType> (max)(const AutoDiffScalar<DerType>& x, const T& y)    { return (x >= y ? x : y); }$/;"	f	namespace:Eigen
max	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<DerType> (max)(const T& x, const AutoDiffScalar<DerType>& y)    { return (x > y ? x : y); }$/;"	f	namespace:Eigen
max	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal (max)(const mpreal& x, const mpreal& y)$/;"	f	namespace:mpfr
max	vcglib/vcg/space/box2.h	/^  PointType max;$/;"	m	class:vcg::Box2
max	vcglib/vcg/space/box3.h	/^    Point3<BoxScalarType> max;$/;"	m	class:vcg::Box3
max	vcglib/wrap/gcache/dheap.h	/^  T &max() { Item &i = heap.max(); return *i.value; }$/;"	f	class:PtrDHeap
max	vcglib/wrap/gcache/dheap.h	/^  T &max() {$/;"	f	class:DHeap
max3	vcglib/img/img_scalar.h	/^inline ScalarType max3(ScalarType a, ScalarType b, ScalarType c)$/;"	f	namespace:img
maxCoeff	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::maxCoeff() const$/;"	f	class:Eigen::DenseBase
maxCoeff	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_maxCoeff>::Type maxCoeff() const$/;"	f	class:Eigen::VectorwiseOp
maxCoeff	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase
maxCoeff	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* row, IndexType* col) const$/;"	f	class:Eigen::DenseBase
maxDist	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    ScalarType maxDist;$/;"	m	class:vcg::tri::CylinderClipping::CylPred
maxElem	vcglib/vcg/math/histogram.h	/^  ScalarType maxElem;	\/\/! Maximum value.$/;"	m	class:vcg::Histogram
maxIterNum	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^   int maxIterNum;$/;"	m	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam
maxIterarions	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    size_t maxIterarions() const { return m_maxiter; }$/;"	f	class:Eigen::IterationController
maxIterations	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int maxIterations() const$/;"	f	class:Eigen::IterativeSolverBase
maxPadeDegree	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  static const int maxPadeDegree = std::numeric_limits<RealScalar>::digits<= 24?  5:      \/\/ single precision$/;"	m	class:Eigen::MatrixLogarithmAtomic
maxPivot	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivLU
maxPivot	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::ColPivHouseholderQR
maxPivot	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivHouseholderQR
maxResidual	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double maxResidual() const { return m_resmax; }$/;"	f	class:Eigen::IterationController
maxValue	vcglib/img/img_info.h	/^inline ScalarType maxValue(const Image<Channels,ScalarType,Safe> &image)$/;"	f	namespace:img
maxVisibleDepth	vcglib/vcg/space/index/octree.h	/^        int						maxVisibleDepth;$/;"	m	struct:vcg::OcreeRenderingSetting
maxXofPoly	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int maxXofPoly(RasterizedOutline2& poly, Point2i pos, int rast_i)$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
maxYofPoly	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int maxYofPoly(RasterizedOutline2& poly, Point2i pos, int rast_i)$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
max_angle	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  float max_angle;       \/\/max angle between 2 faces (cos(angle) actually)  $/;"	m	class:vcg::tri::BallPivoting
max_coeff_visitor	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^struct max_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal
max_dim	vcglib/vcg/complex/algorithms/create/resampler.h	/^		float max_dim; \/\/ the limit value of the search (that takes into account of the offset)$/;"	m	class:vcg::tri::Resampler::Walker
max_dir	vcglib/vcg/simplex/face/component.h	/^        Point3<S>max_dir,min_dir; \/\/ max and min curvature direction$/;"	m	struct:vcg::face::CurvatureDirBaseType
max_dir	vcglib/vcg/simplex/face/component_ocf.h	/^        Point3<S>max_dir,min_dir; \/\/ max and min curvature direction$/;"	m	struct:vcg::face::CurvatureDirOcfBaseType
max_dir	vcglib/vcg/simplex/vertex/component.h	/^          Point3<S>max_dir,min_dir; \/\/ max and min curvature direction$/;"	m	struct:vcg::vertex::CurvatureDirBaseType
max_dir	vcglib/vcg/simplex/vertex/component_occ.h	/^	Point3<S>max_dir,min_dir; \/\/ max and min curvature direction $/;"	m	struct:vcg::vertex::CurvatureDirTypeOcc
max_dir	vcglib/vcg/simplex/vertex/component_ocf.h	/^	Point3<S>max_dir,min_dir;$/;"	m	struct:vcg::vertex::CurvatureDirTypeOcf
max_dist	vcglib/apps/metro/sampling.h	/^    double          max_dist;$/;"	m	class:vcg::Sampling
max_dist	vcglib/vcg/space/index/space_iterators.h	/^		ScalarType max_dist;		  \/\/max distance when the scan terminate$/;"	m	class:vcg::ClosestIterator
max_dist	vcglib/vcg/space/index/space_iterators.h	/^		ScalarType max_dist;$/;"	m	class:vcg::RayIterator
max_edge	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  float max_edge;        \/\/min length of an edge $/;"	m	class:vcg::tri::BallPivoting
max_footprint	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t     max_footprint;$/;"	m	struct:malloc_state	file:
max_size	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    size_type max_size() const$/;"	f	class:Eigen::aligned_allocator
max_tokens	vcglib/wrap/gcache/provider.h	/^  int max_tokens;$/;"	m	class:vcg::Provider
max_v	vcglib/vcg/math/histogram.h	/^	double max_v;$/;"	m	class:vcg::Distribution
maxcall	vcglib/wrap/minpack/minpack.h	/^	int maxcall; 		\/\/ maximum number of iterations.$/;"	m	struct:LMDiff::__anon525
maxfev	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Index maxfev;   \/\/ maximum number of function evaluation$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
maxfev	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Index maxfev;   \/\/ maximum number of function evaluation$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
maximumDepth	vcglib/vcg/space/index/octree_template.h	/^	int						maximumDepth;$/;"	m	class:vcg::OctreeTemplate
maxv	vcglib/vcg/math/histogram.h	/^	ScalarType maxv;	\/\/! Maximum value.$/;"	m	class:vcg::Histogram
mc	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex mc() const { return m_mc; }$/;"	f	class:Eigen::internal::level3_blocking
mchunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef struct malloc_chunk  mchunk;$/;"	t	typeref:struct:malloc_chunk	file:
mchunkptr	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef struct malloc_chunk* mchunkptr;$/;"	t	typeref:struct:malloc_chunk	file:
mean	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::mean() const$/;"	f	class:Eigen::DenseBase
mean	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_mean>::Type mean() const$/;"	f	class:Eigen::VectorwiseOp
mean_dist	vcglib/apps/metro/sampling.h	/^    double          mean_dist;$/;"	m	class:vcg::Sampling
median3	vcglib/img/img_scalar.h	/^inline ScalarType median3(ScalarType a, ScalarType b, ScalarType c)$/;"	f	namespace:img
medianFilter	vcglib/img/img_filter.h	/^inline void medianFilter(const Image<Channels,SrcScalarType,SrcSafe> &source,Image<Channels,DestScalarType,DestSafe> &destination,int radius)$/;"	f	namespace:img
mem2chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define mem2chunk(/;"	d	file:
member_redux	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  member_redux(const BinaryOp func) : m_functor(func) {}$/;"	f	struct:Eigen::internal::member_redux
member_redux	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^struct member_redux {$/;"	s	namespace:Eigen::internal
memtype1	vcglib/wrap/ply/plylib.h	/^	int memtype1;				\/\/ Tipo dell'elemento in memoria (se lista tipo degli elementi della lista)$/;"	m	class:vcg::ply::PropDescriptor
memtype2	vcglib/wrap/ply/plylib.h	/^	int memtype2;				\/\/ Tipo del numero di elementi della lista in memoria$/;"	m	class:vcg::ply::PropDescriptor
memtypename	vcglib/wrap/ply/plylib.cpp	/^const char *PropDescriptor::memtypename() const {return PlyFile::typenames[memtype1];}$/;"	f	class:vcg::ply::PropDescriptor
memtypesize	vcglib/wrap/ply/plylib.cpp	/^size_t PropDescriptor::memtypesize() const {return TypeSize[memtype1];}$/;"	f	class:vcg::ply::PropDescriptor
merged	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox merged(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
mesh	vcg_mesh.hpp	/^    MyMesh *mesh;$/;"	m	class:vcg::MySampler
mesh	vcglib/apps/pivoting/glarea.h	/^    CMesh mesh;$/;"	m	class:GLArea
mesh	vcglib/apps/pivoting/pivot.h	/^    MESH &mesh;    $/;"	m	class:vcg::tri::Pivot
mesh	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^CMesh mesh,mesh1;$/;"	v
mesh	vcglib/apps/sample/trimesh_QT/glarea.h	/^  CMesh mesh;$/;"	m	class:GLArea
mesh	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^CMesh mesh;$/;"	v
mesh	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^CMesh mesh;     \/\/\/ the active mesh instance$/;"	v
mesh	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		MyStraightMesh mesh;$/;"	m	class:GLWidget
mesh	vcglib/apps/tridecimator/tridecimator.cpp	/^MyMesh mesh;$/;"	v
mesh	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^CMesh mesh;$/;"	v
mesh	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^CMesh mesh;$/;"	v
mesh	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  MESH &mesh;           \/\/this structure will be filled by the algorithm$/;"	m	class:vcg::tri::AdvancingFront
mesh	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    MeshType &mesh;$/;"	m	class:vcg::tri::PoissonSolver
mesh	vcglib/wrap/miq/core/poisson_solver.h	/^    MeshType &mesh;$/;"	m	class:PoissonSolver
mesh	vcglib/wrap/miq/core/seams_initializer.h	/^    MeshType *mesh;$/;"	m	class:SeamsInitializer
mesh	vcglib/wrap/miq/core/vertex_indexing.h	/^    MeshType *mesh;$/;"	m	class:VertexIndexing
mesh1	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^CMesh mesh,mesh1;$/;"	v
mesh_attr	vcglib/vcg/complex/base.h	/^    std::set< PointerToAttribute > mesh_attr;$/;"	m	class:vcg::tri::TriMesh
mesh_type	vcglib/wrap/gl/trimesh.h	/^    typedef MESH_TYPE mesh_type;$/;"	t	class:vcg::GlTrimesh
meshnum	vcglib/wrap/io_trimesh/import_ptx.h	/^			int meshnum;$/;"	m	class:vcg::tri::io::ImporterPTX::Info
message	vcglib/img/img_base.h	/^  const char *message;$/;"	m	class:img::ImageException
meta_sqrt	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c	namespace:Eigen
mflags	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  flag_t     mflags;$/;"	m	struct:malloc_state	file:
mi	vcglib/vcg/space/obox3.h	/^		Matrix44<T> mi;		  \/\/ inverse of m: from OB space to World$/;"	m	class:vcg::Obox3
middle	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  enum { middle = (lower + upper) \/ 2,$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon177
middle	vcglib/wrap/gcache/cache.h	/^    virtual void middle() {}$/;"	f	class:vcg::Cache
middleCols	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleCols(Index start, Index size)$/;"	f	class:Eigen::SparseMatrixBase
middleCols	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleCols(Index start, Index size) const$/;"	f	class:Eigen::SparseMatrixBase
middleCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr middleCols(Index startCol, Index numCols)$/;"	f
middleCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr middleCols(Index startCol, Index numCols) const$/;"	f
middleCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type middleCols(Index startCol) const$/;"	f
middleCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type middleCols(Index startCol)$/;"	f
middleRows	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleRows(Index start, Index size)$/;"	f	class:Eigen::SparseMatrixBase
middleRows	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,Dynamic> SparseMatrixBase<Derived>::middleRows(Index start, Index size) const$/;"	f	class:Eigen::SparseMatrixBase
middleRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr middleRows(Index startRow, Index numRows) const$/;"	f
middleRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr middleRows(Index startRow, Index numRows)$/;"	f
middleRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type middleRows(Index startRow) const$/;"	f
middleRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type middleRows(Index startRow)$/;"	f
min	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^(min)(const Scalar &other) const$/;"	f
min	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<DerType> (min)(const AutoDiffScalar<DerType>& x, const T& y)    { return (x <= y ? x : y); }$/;"	f	namespace:Eigen
min	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline AutoDiffScalar<DerType> (min)(const T& x, const AutoDiffScalar<DerType>& y)    { return (x < y ? x : y); }$/;"	f	namespace:Eigen
min	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal (min)(const mpreal& x, const mpreal& y)$/;"	f	namespace:mpfr
min	vcglib/vcg/space/box2.h	/^  PointType min;$/;"	m	class:vcg::Box2
min	vcglib/vcg/space/box3.h	/^  Point3<BoxScalarType> min;$/;"	m	class:vcg::Box3
min	vcglib/wrap/gcache/dheap.h	/^  T &min() { Item &i = heap.min(); return *i.value; }$/;"	f	class:PtrDHeap
min	vcglib/wrap/gcache/dheap.h	/^  T &min() { return this->front(); } \/\/root is smallest element$/;"	f	class:DHeap
min3	vcglib/img/img_scalar.h	/^inline ScalarType min3(ScalarType a, ScalarType b, ScalarType c)$/;"	f	namespace:img
minCoeff	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::minCoeff() const$/;"	f	class:Eigen::DenseBase
minCoeff	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_minCoeff>::Type minCoeff() const$/;"	f	class:Eigen::VectorwiseOp
minCoeff	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase
minCoeff	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* row, IndexType* col) const$/;"	f	class:Eigen::DenseBase
minDiag	vcglib/vcg/complex/algorithms/point_sampling.h	/^float minDiag;$/;"	m	class:vcg::tri::SurfaceSampling::RRParam
minDist	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^			ScalarType minDist;$/;"	m	class:vcg::AABBBinaryTreeKClosest::ClosestObjType
minEdgeLen	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    ScalarType minEdgeLen;$/;"	m	class:vcg::tri::CylinderClipping::CylPred
minElem	vcglib/vcg/math/histogram.h	/^  ScalarType minElem; 	\/\/! Minimum value.$/;"	m	class:vcg::Histogram
minFilter	vcglib/wrap/glw/texture.h	/^		GLenum minFilter;$/;"	m	class:glw::TextureSampleMode
minPadeDegree	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  static const int minPadeDegree = 3;$/;"	m	class:Eigen::MatrixLogarithmAtomic
minValue	vcglib/img/img_info.h	/^inline ScalarType minValue(const Image<Channels,ScalarType,Safe> &image)$/;"	f	namespace:img
minVisibleDepth	vcglib/vcg/space/index/octree.h	/^        int						minVisibleDepth;$/;"	m	struct:vcg::OcreeRenderingSetting
min_buckets	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^			min_buckets = 8$/;"	e	enum:vcg::HashFunctor2D::__anon506
min_buckets	vcglib/vcg/space/index/spatial_hashing.h	/^				min_buckets = 8$/;"	e	enum:vcg::HashFunctor::__anon510
min_coeff_visitor	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^struct min_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal
min_dir	vcglib/vcg/simplex/face/component.h	/^        Point3<S>max_dir,min_dir; \/\/ max and min curvature direction$/;"	m	struct:vcg::face::CurvatureDirBaseType
min_dir	vcglib/vcg/simplex/face/component_ocf.h	/^        Point3<S>max_dir,min_dir; \/\/ max and min curvature direction$/;"	m	struct:vcg::face::CurvatureDirOcfBaseType
min_dir	vcglib/vcg/simplex/vertex/component.h	/^          Point3<S>max_dir,min_dir; \/\/ max and min curvature direction$/;"	m	struct:vcg::vertex::CurvatureDirBaseType
min_dir	vcglib/vcg/simplex/vertex/component_occ.h	/^	Point3<S>max_dir,min_dir; \/\/ max and min curvature direction $/;"	m	struct:vcg::vertex::CurvatureDirTypeOcc
min_dir	vcglib/vcg/simplex/vertex/component_ocf.h	/^	Point3<S>max_dir,min_dir;$/;"	m	struct:vcg::vertex::CurvatureDirTypeOcf
min_edge	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  float min_edge;        \/\/min length of an edge $/;"	m	class:vcg::tri::BallPivoting
min_seg_length	vcglib/wrap/gui/trackmode.h	/^  float min_seg_length;$/;"	m	class:vcg::PathMode
min_side_length	vcglib/wrap/gui/trackmode.h	/^  float min_side_length;$/;"	m	class:vcg::AreaMode
min_size	vcglib/apps/metro/sampling.h	/^		unsigned int min_size					     ;$/;"	m	class:vcg::Sampling
min_v	vcglib/vcg/math/histogram.h	/^	double min_v;$/;"	m	class:vcg::Distribution
mindist	vcglib/apps/pivoting/pivot.h	/^    float mindist; \/\/minimum distance between points in the mesh (% of radius)   $/;"	m	class:vcg::tri::Pivot
minimize	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimize(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeInit	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimizeInit(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeOneStep	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimizeOneStep(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeOptimumStorage	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimizeOptimumStorage(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeOptimumStorageInit	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimizeOptimumStorageInit(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimizeOptimumStorageOneStep	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^LevenbergMarquardt<FunctorType,Scalar>::minimizeOptimumStorageOneStep(FVectorType  &x)$/;"	f	class:Eigen::LevenbergMarquardt
minimize_helper	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^typename Minimizer::Scalar minimize_helper(const BVH &tree, Minimizer &minimizer, typename BVH::Index root, typename Minimizer::Scalar minimum)$/;"	f	namespace:Eigen::internal
minimizer	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Minimizer &minimizer;$/;"	m	struct:Eigen::internal::minimizer_helper1
minimizer	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Minimizer &minimizer;$/;"	m	struct:Eigen::internal::minimizer_helper2
minimizer_helper1	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  minimizer_helper1(const Object2 &inStored, Minimizer &m) : stored(inStored), minimizer(m) {}$/;"	f	struct:Eigen::internal::minimizer_helper1
minimizer_helper1	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^struct minimizer_helper1$/;"	s	namespace:Eigen::internal
minimizer_helper2	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  minimizer_helper2(const Object1 &inStored, Minimizer &m) : stored(inStored), minimizer(m) {}$/;"	f	struct:Eigen::internal::minimizer_helper2
minimizer_helper2	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^struct minimizer_helper2$/;"	s	namespace:Eigen::internal
minimumOnObject	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Scalar minimumOnObject(const Object1 &obj) { return minimizer.minimumOnObjectObject(obj, stored); }$/;"	f	struct:Eigen::internal::minimizer_helper1
minimumOnObject	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Scalar minimumOnObject(const Object2 &obj) { return minimizer.minimumOnObjectObject(stored, obj); }$/;"	f	struct:Eigen::internal::minimizer_helper2
minimumOnObject	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  double minimumOnObject(const BallType &b) { ++calls; return (std::max)(0., (b.center - p).squaredNorm() - SQR(b.radius)); }$/;"	f	struct:BallPointStuff
minimumOnObjectObject	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^  double minimumOnObjectObject(const Vector2d &v1, const Vector2d &v2) { ++calls; return (v1 - v2).squaredNorm(); }$/;"	f	struct:PointPointMinimizer
minimumOnObjectObject	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  double minimumOnObjectObject(const BallType &b, const VectorType &v){ ++calls; return SQR((std::max)(0., (b.center - v).norm() - b.radius)); }$/;"	f	struct:BallPointStuff
minimumOnObjectObject	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  double minimumOnObjectObject(const BallType &b1, const BallType &b2){ ++calls; return SQR((std::max)(0., (b1.center - b2.center).norm() - b1.radius - b2.radius)); }$/;"	f	struct:BallPointStuff
minimumOnObjectVolume	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^  double minimumOnObjectVolume(const Vector2d &v, const Box2d &r) { ++calls; return r.squaredExteriorDistance(v); }$/;"	f	struct:PointPointMinimizer
minimumOnObjectVolume	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  double minimumOnObjectVolume(const BallType &b, const BoxType &r) { ++calls; return SQR((std::max)(0., r.exteriorDistance(b.center) - b.radius)); }$/;"	f	struct:BallPointStuff
minimumOnVolume	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Scalar minimumOnVolume(const Volume1 &vol) { return minimizer.minimumOnVolumeObject(vol, stored); }$/;"	f	struct:Eigen::internal::minimizer_helper1
minimumOnVolume	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Scalar minimumOnVolume(const Volume2 &vol) { return minimizer.minimumOnObjectVolume(stored, vol); }$/;"	f	struct:Eigen::internal::minimizer_helper2
minimumOnVolume	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  double minimumOnVolume(const BoxType &r) { ++calls; return r.squaredExteriorDistance(p); }$/;"	f	struct:BallPointStuff
minimumOnVolumeObject	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^  double minimumOnVolumeObject(const Box2d &r, const Vector2d &v) { ++calls; return r.squaredExteriorDistance(v); }$/;"	f	struct:PointPointMinimizer
minimumOnVolumeObject	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  double minimumOnVolumeObject(const BoxType &r, const BallType &b) { ++calls; return SQR((std::max)(0., r.exteriorDistance(b.center) - b.radius)); }$/;"	f	struct:BallPointStuff
minimumOnVolumeObject	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  double minimumOnVolumeObject(const BoxType &r, const VectorType &v) { ++calls; return r.squaredExteriorDistance(v); }$/;"	f	struct:BallPointStuff
minimumOnVolumeVolume	vcglib/eigenlib/unsupported/doc/examples/BVH_Example.cpp	/^  double minimumOnVolumeVolume(const Box2d &r1, const Box2d &r2) { ++calls; return r1.squaredExteriorDistance(r2); }$/;"	f	struct:PointPointMinimizer
minimumOnVolumeVolume	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  double minimumOnVolumeVolume(const BoxType &r1, const BoxType &r2) { ++calls; return r1.squaredExteriorDistance(r2); }$/;"	f	struct:BallPointStuff
minimumSizeHint	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^QSize GLWidget::minimumSizeHint() const$/;"	f	class:GLWidget
minimum_degree_ordering	vcglib/eigenlib/Eigen/src/OrderingMethods/Amd.h	/^void minimum_degree_ordering(SparseMatrix<Scalar,ColMajor,Index>& C, PermutationMatrix<Dynamic,Dynamic,Index>& perm)$/;"	f	namespace:Eigen::internal
minor	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col) const$/;"	f	class:Eigen::MatrixBase
minor	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col)$/;"	f	class:Eigen::MatrixBase
minsize_for_tree_index	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define minsize_for_tree_index(/;"	d	file:
minv	vcglib/vcg/math/histogram.h	/^	ScalarType minv; 	\/\/! Minimum value.$/;"	m	class:vcg::Histogram
misra1a_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    misra1a_functor(void) : Functor<double>(2,14) {}$/;"	f	struct:misra1a_functor
misra1a_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct misra1a_functor : Functor<double>$/;"	s	file:
misra1d_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    misra1d_functor(void) : Functor<double>(2,14) {}$/;"	f	struct:misra1d_functor
misra1d_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct misra1d_functor : Functor<double>$/;"	s	file:
mmap_align	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define mmap_align(/;"	d	file:
mmap_alloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void* mmap_alloc(mstate m, size_t nb) {$/;"	f	file:
mmap_resize	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb) {$/;"	f	file:
mmap_threshold	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t mmap_threshold;$/;"	m	struct:malloc_params	file:
mode	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  enum{ PAIR, AROUND , NOTHING } mode;$/;"	m	class:vcg::tri::BitQuad::Pos	typeref:enum:vcg::tri::BitQuad::Pos::__anon479
mode	vcglib/wrap/gui/trackrecorder.h	/^	enum { PLAY,REC,OFF } mode;$/;"	m	struct:vcg::TrackRecorder	typeref:enum:vcg::TrackRecorder::__anon521
model	vcglib/wrap/gui/view.h	/^  Matrix44<T> model;$/;"	m	class:vcg::View
modes	vcglib/wrap/gui/trackball.h	/^  std::map<int, TrackMode *> modes;$/;"	m	class:vcg::Trackball
modf	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal modf(const mpreal& v, mpreal& n)$/;"	f	namespace:mpfr
montecarloSampleNum	vcglib/vcg/complex/algorithms/point_sampling.h	/^    int montecarloSampleNum;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam::Stat
montecarloTime	vcglib/vcg/complex/algorithms/point_sampling.h	/^    int montecarloTime;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam::Stat
mouseDoubleClickEvent	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void GLWidget::mouseDoubleClickEvent (QMouseEvent * e)$/;"	f	class:GLWidget
mouseDoubleClickEvent	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^ void GLWidget::mouseDoubleClickEvent(QMouseEvent *e){$/;"	f	class:GLWidget
mouseMoveEvent	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::mouseMoveEvent(QMouseEvent *e) {$/;"	f	class:GLArea
mouseMoveEvent	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::mouseMoveEvent (QMouseEvent * e)$/;"	f	class:GLArea
mouseMoveEvent	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void mouseMoveEvent (int x, int y )$/;"	f
mouseMoveEvent	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void GLWidget::mouseMoveEvent (QMouseEvent * e)$/;"	f	class:GLWidget
mouseMoveEvent	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::mouseMoveEvent(QMouseEvent *e)$/;"	f	class:GLWidget
mousePressEvent	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::mousePressEvent(QMouseEvent *e) {$/;"	f	class:GLArea
mousePressEvent	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::mousePressEvent (QMouseEvent * e)$/;"	f	class:GLArea
mousePressEvent	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^ void mousePressEvent(int bt,int state,int x,int y){$/;"	f
mousePressEvent	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void GLWidget::mousePressEvent (QMouseEvent * e)$/;"	f	class:GLWidget
mousePressEvent	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^ void GLWidget:: mousePressEvent(QMouseEvent *e)$/;"	f	class:GLWidget
mouseReleaseEvent	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::mouseReleaseEvent(QMouseEvent *e) { $/;"	f	class:GLArea
mouseReleaseEvent	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::mouseReleaseEvent (QMouseEvent * e)$/;"	f	class:GLArea
mouseReleaseEvent	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void GLWidget::mouseReleaseEvent (QMouseEvent * e)$/;"	f	class:GLWidget
mouseReleaseEvent	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^ void GLWidget::mouseReleaseEvent ( QMouseEvent * e ){$/;"	f	class:GLWidget
mov_snap	vcglib/wrap/gui/activecoordinateframe.h	/^  float rot_snap_rad,mov_snap;$/;"	m	class:vcg::ActiveCoordinateFrame
moveBack	vcglib/apps/pivoting/pivot.h	/^     void moveBack(std::list<Hinge>::iterator e) {$/;"	f	class:vcg::tri::Pivot
moveFront	vcglib/apps/pivoting/pivot.h	/^     void moveFront(std::list<Hinge>::iterator e) {$/;"	f	class:vcg::tri::Pivot
move_button	vcglib/wrap/gui/activecoordinateframe.h	/^  const int move_button,rotate_button;$/;"	m	class:vcg::ActiveCoordinateFrame
movx	vcglib/wrap/gui/activecoordinateframe.h	/^  int movx,movy,movz,rotx,roty,rotz;$/;"	m	class:vcg::ActiveCoordinateFrame
movy	vcglib/wrap/gui/activecoordinateframe.h	/^  int movx,movy,movz,rotx,roty,rotz;$/;"	m	class:vcg::ActiveCoordinateFrame
movz	vcglib/wrap/gui/activecoordinateframe.h	/^  int movx,movy,movz,rotx,roty,rotz;$/;"	m	class:vcg::ActiveCoordinateFrame
mp	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	mpfr_t mp;$/;"	m	class:mpfr::mpreal
mp	vcglib/vcg/complex/algorithms/clean.h	/^  MeshType *mp;$/;"	m	class:vcg::tri::ConnectedComponentIterator
mp	vcglib/vcg/complex/algorithms/refine.h	/^     MESH_TYPE *mp;$/;"	m	struct:vcg::tri::MidPoint
mpData	vcglib/vcg/space/index/kdtree/kdtree.h	/^		const unsigned char* mpData;$/;"	m	class:ConstDataWrapper
mpOffsetedElements	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	Element* mpOffsetedElements;$/;"	m	class:HeapMaxPriorityQueue
mp_matrix	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const MatrixType* mp_matrix;$/;"	m	class:Eigen::IterativeSolverBase
mp_target	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    SparseMatrixType* mp_target;$/;"	m	class:Eigen::RandomSetter
mparams	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static struct malloc_params mparams;$/;"	v	typeref:struct:malloc_params	file:
mpfr	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^namespace mpfr{$/;"	n	file:
mpfr	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^namespace mpfr {$/;"	n
mpfr_ptr	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline ::mpfr_ptr		mpreal::mpfr_ptr()			{	return mp;	}$/;"	f	class:mpfr::mpreal
mpfr_srcptr	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline ::mpfr_srcptr	mpreal::mpfr_srcptr() const	{	return const_cast< ::mpfr_srcptr >(mp);	}$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal() $/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const char* s, mp_prec_t prec, int base, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const double u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const int64_t u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const long double u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const long int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const mpf_t u)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const mpfr_t u)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const mpq_t u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const mpreal& u) $/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const mpz_t u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const std::string& s, mp_prec_t prec, int base, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const uint64_t u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const unsigned int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::mpreal(const unsigned long int u, mp_prec_t prec, mp_rnd_t mode)$/;"	f	class:mpfr::mpreal
mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^class mpreal {$/;"	c	namespace:mpfr
mpreal_allocate	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^	void * mpreal::mpreal_allocate(size_t alloc_size)$/;"	f	class:mpfr::mpreal
mpreal_free	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^	void mpreal::mpreal_free(void *ptr, size_t size)$/;"	f	class:mpfr::mpreal
mpreal_max	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal mpreal_max(mp_prec_t prec)$/;"	f	namespace:mpfr
mpreal_min	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal mpreal_min(mp_prec_t prec)$/;"	f	namespace:mpfr
mpreal_reallocate	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^	void * mpreal::mpreal_reallocate(void *ptr, size_t old_size, size_t new_size)$/;"	f	class:mpfr::mpreal
mr	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
mr	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
mr	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon200
mr	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2*ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
msegment	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef struct malloc_segment  msegment;$/;"	t	typeref:struct:malloc_segment	file:
msegmentptr	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef struct malloc_segment* msegmentptr;$/;"	t	typeref:struct:malloc_segment	file:
mspace	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef void* mspace;$/;"	t	file:
mspace	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^typedef void* mspace;$/;"	t
mspace_calloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size) {$/;"	f
mspace_footprint	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^size_t mspace_footprint(mspace msp) {$/;"	f
mspace_free	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void mspace_free(mspace msp, void* mem) {$/;"	f
mspace_independent_calloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void** mspace_independent_calloc(mspace msp, size_t n_elements,$/;"	f
mspace_independent_comalloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void** mspace_independent_comalloc(mspace msp, size_t n_elements,$/;"	f
mspace_mallinfo	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^struct mallinfo mspace_mallinfo(mspace msp) {$/;"	f
mspace_malloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void* mspace_malloc(mspace msp, size_t bytes) {$/;"	f
mspace_malloc_stats	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void mspace_malloc_stats(mspace msp) {$/;"	f
mspace_mallopt	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^int mspace_mallopt(int param_number, int value) {$/;"	f
mspace_max_footprint	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^size_t mspace_max_footprint(mspace msp) {$/;"	f
mspace_memalign	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void* mspace_memalign(mspace msp, size_t alignment, size_t bytes) {$/;"	f
mspace_realloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^void* mspace_realloc(mspace msp, void* oldmem, size_t bytes) {$/;"	f
mspace_track_large_chunks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^int mspace_track_large_chunks(mspace msp, int enable) {$/;"	f
mspace_trim	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^int mspace_trim(mspace msp, size_t pad) {$/;"	f
mspace_usable_size	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^size_t mspace_usable_size(void* mem) {$/;"	f
mstate	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef struct malloc_state*    mstate;$/;"	t	typeref:struct:malloc_state	file:
mt	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  TriMeshType *mt;$/;"	m	class:vcg::tri::TriEdgeCollapse
mt	vcglib/vcg/math/random_generator.h	/^	unsigned int mt[N]; \/\/ the array for the state vector$/;"	m	class:vcg::math::MarsenneTwisterRNG
mt	vcglib/wrap/system/multithreading/atomic_int.h	/^  namespace mt{$/;"	n
mt	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^namespace mt{$/;"	n
mt	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^namespace mt{$/;"	n
mt	vcglib/wrap/system/multithreading/base.h	/^namespace mt$/;"	n
mt	vcglib/wrap/system/multithreading/condition.h	/^namespace mt$/;"	n
mt	vcglib/wrap/system/multithreading/mt.h	/^namespace mt{$/;"	n
mt	vcglib/wrap/system/multithreading/mutex.h	/^namespace mt$/;"	n
mt	vcglib/wrap/system/multithreading/rw_lock.h	/^namespace mt$/;"	n
mt	vcglib/wrap/system/multithreading/scoped_mutex_lock.h	/^namespace mt$/;"	n
mt	vcglib/wrap/system/multithreading/scoped_read_lock.h	/^namespace mt$/;"	n
mt	vcglib/wrap/system/multithreading/scoped_write_lock.h	/^namespace mt$/;"	n
mt	vcglib/wrap/system/multithreading/semaphore.h	/^namespace mt$/;"	n
mt	vcglib/wrap/system/multithreading/thread.h	/^namespace mt$/;"	n
mt	vcglib/wrap/system/multithreading/util.h	/^namespace mt$/;"	n
mt	vcglib/wrap/system/time/clock.h	/^namespace mt{$/;"	n
mti	vcglib/vcg/math/random_generator.h	/^	int mti;$/;"	m	class:vcg::math::MarsenneTwisterRNG
mtx	vcglib/wrap/system/multithreading/scoped_mutex_lock.h	/^            mutex & mtx;$/;"	m	class:mt::scoped_mutex_lock
mul_2si	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal mul_2si(const mpreal& v, long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
mul_2ui	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal mul_2ui(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
multiOutline2VecToSingleOutline2Vec	vcglib/wrap/qt/Outline2ToQImage.cpp	/^void Outline2Dumper::multiOutline2VecToSingleOutline2Vec(const std::vector< std::vector<Point2f> > &multiPolyVec,$/;"	f	class:Outline2Dumper
multiRectSetToSingleOutline2Vec	vcglib/wrap/qt/Outline2ToQImage.cpp	/^void Outline2Dumper::multiRectSetToSingleOutline2Vec(vector< Box2f > &rectVec,$/;"	f	class:Outline2Dumper
mutex	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MLOCK_T    mutex;     \/* locate lock among fields that rarely change *\/$/;"	m	struct:malloc_state	file:
mutex	vcglib/wrap/system/multithreading/mt.h	/^  typedef QMutex mutex;$/;"	t	namespace:mt
mutex	vcglib/wrap/system/multithreading/mutex.h	/^		mutex(void)$/;"	f	class:mt::mutex
mutex	vcglib/wrap/system/multithreading/mutex.h	/^class mutex$/;"	c	namespace:mt
mutexlocker	vcglib/wrap/system/multithreading/mt.h	/^  typedef QMutexLocker mutexlocker;$/;"	t	namespace:mt
mutexlocker	vcglib/wrap/system/multithreading/mt.h	/^  typedef scoped_mutex_lock mutexlocker;$/;"	t	namespace:mt
myReshapeFunc	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^void myReshapeFunc(GLsizei w, GLsizei h)$/;"	f
myReshapeFunc	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^void myReshapeFunc(GLsizei w, GLsizei h)$/;"	f
my_bcopy	vcglib/wrap/system/getopt.cpp	/^#define        my_bcopy(/;"	d	file:
my_bcopy	vcglib/wrap/system/getopt.cpp	/^my_bcopy (const char *from, char *to, int size)$/;"	f	file:
my_functor	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^    my_functor(void): Functor<double>(3,15) {}$/;"	f	struct:my_functor
my_functor	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^struct my_functor : Functor<double>$/;"	s	file:
my_index	vcglib/wrap/system/getopt.cpp	/^#define        my_index /;"	d	file:
my_index	vcglib/wrap/system/getopt.cpp	/^my_index (const char *str, int chr)$/;"	f	file:
n	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index n;$/;"	m	class:Eigen::HybridNonLinearSolver
n	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Index n;$/;"	m	class:Eigen::LevenbergMarquardt
n	vcglib/vcg/complex/algorithms/clip.h	/^    unsigned int n;$/;"	m	class:vcg::tri::TriMeshClipper::EdgeIntersections
n	vcglib/vcg/complex/algorithms/clustering.h	/^  CoordType n;$/;"	m	class:vcg::tri::AverageColorCell
n	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    int n; \/\/ number of input vectors$/;"	m	class:vcg::tri::Zonohedron
n	vcglib/vcg/complex/algorithms/hole.h	/^  CoordType n; \/\/ the normal of the face defined by the ear$/;"	m	class:vcg::tri::TrivialEar
n	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& n() { return data[11];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
n	vcglib/vcg/math/histogram.h	/^  int n;	\/\/! Number of vaild intervals stored between minv and maxv.$/;"	m	class:vcg::Histogram
n	vcglib/vcg/space/texcoord2.h	/^        \/**\/inline short n() const { return _n[0]; }$/;"	f	class:vcg::TexCoord2
n	vcglib/vcg/space/texcoord2.h	/^        \/**\/inline short n(const int i) const { return _n[i]; }$/;"	f	class:vcg::TexCoord2
n	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline short     & n() { return _n[0]; }$/;"	f	class:vcg::TexCoord2
n	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline short     & n(const int i) { return _n[i]; }$/;"	f	class:vcg::TexCoord2
n	vcglib/vcg/space/texcoord2.h	/^    inline short   n() const { assert(static_n()==0); return 0; }$/;"	f	class:vcg::TexCoord2Simple
n	vcglib/vcg/space/texcoord2.h	/^    inline short   n(const int i) const { (void)i; assert(i==0); return 0; }$/;"	f	class:vcg::TexCoord2Simple
n	vcglib/vcg/space/texcoord2.h	/^    inline short & n()       { assert(static_n()==0); return static_n(); }$/;"	f	class:vcg::TexCoord2Simple
n	vcglib/vcg/space/texcoord2.h	/^    inline short & n(const int i)       { (void)i; assert(i==0); return static_n(); }$/;"	f	class:vcg::TexCoord2Simple
n	vcglib/wrap/io_trimesh/import_obj.h	/^                    std::vector<int> n;$/;"	m	struct:vcg::tri::io::ImporterOBJ::ObjIndexedFace
n	vcglib/wrap/io_trimesh/import_ply.h	/^	S n[3];$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
n	vcglib/wrap/io_trimesh/import_smf.h	/^		vcg::Point3f n;$/;"	m	class:vcg::tri::io::ImporterSMF::SMFFacet
n	vcglib/wrap/io_trimesh/import_stl.h	/^  Point3f n;$/;"	m	class:vcg::tri::io::ImporterSTL::STLFacet
nPerfmormedOps	vcglib/vcg/complex/algorithms/local_optimization.h	/^  int nPerfmormedOps,$/;"	m	class:vcg::LocalOptimization
nTargetOps	vcglib/vcg/complex/algorithms/local_optimization.h	/^		nTargetOps,$/;"	m	class:vcg::LocalOptimization
nTargetSimplices	vcglib/vcg/complex/algorithms/local_optimization.h	/^		nTargetSimplices,$/;"	m	class:vcg::LocalOptimization
nTargetVertices	vcglib/vcg/complex/algorithms/local_optimization.h	/^		nTargetVertices;$/;"	m	class:vcg::LocalOptimization
n_attr	vcglib/vcg/complex/base.h	/^        int n_attr;$/;"	m	class:vcg::tri::TriMesh::AttributeHandle
n_attr	vcglib/vcg/complex/base.h	/^        int n_attr;$/;"	m	class:vcg::tri::TriMesh::PerMeshAttributeHandle
n_attr	vcglib/vcg/complex/base.h	/^    int n_attr;							\/\/ unique ID of the attribute$/;"	m	class:vcg::PointerToAttribute
n_base	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    int n_base;$/;"	m	class:vcg::tri::FourPCS
n_coords	vcglib/vcg/space/texcoord2.h	/^    enum { n_coords=1};$/;"	e	enum:vcg::TexCoord2Simple::__anon514
n_coords	vcglib/vcg/space/texcoord2.h	/^    enum { n_coords=NMAX };$/;"	e	enum:vcg::TexCoord2::__anon513
n_fixed_vars	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    unsigned int n_fixed_vars;$/;"	m	class:vcg::tri::PoissonSolver
n_fixed_vars	vcglib/wrap/miq/core/poisson_solver.h	/^	unsigned int n_fixed_vars;$/;"	m	class:PoissonSolver
n_hist_bins	vcglib/apps/metro/sampling.h	/^		int n_hist_bins                    ;$/;"	m	class:vcg::Sampling
n_integer_vars	vcglib/wrap/miq/core/poisson_solver.h	/^	unsigned int n_integer_vars; $/;"	m	class:PoissonSolver
n_samples	vcglib/apps/metro/sampling.h	/^    int             n_samples;$/;"	m	class:vcg::Sampling
n_samples_edge_to_face_ratio	vcglib/apps/metro/sampling.h	/^		float n_samples_edge_to_face_ratio ;$/;"	m	class:vcg::Sampling
n_samples_per_area_unit	vcglib/apps/metro/sampling.h	/^	double					n_samples_per_area_unit;$/;"	m	class:vcg::Sampling
n_samples_per_face	vcglib/apps/metro/sampling.h	/^		unsigned int n_samples_per_face    ;$/;"	m	class:vcg::Sampling
n_samples_target	vcglib/apps/metro/sampling.h	/^	unsigned long   n_samples_target;$/;"	m	class:vcg::Sampling
n_total_area_samples	vcglib/apps/metro/sampling.h	/^    unsigned long   n_total_area_samples;$/;"	m	class:vcg::Sampling
n_total_edge_samples	vcglib/apps/metro/sampling.h	/^    unsigned long   n_total_edge_samples;$/;"	m	class:vcg::Sampling
n_total_samples	vcglib/apps/metro/sampling.h	/^    unsigned long   n_total_samples;$/;"	m	class:vcg::Sampling
n_total_vertex_samples	vcglib/apps/metro/sampling.h	/^    unsigned long   n_total_vertex_samples;$/;"	m	class:vcg::Sampling
n_vert_vars	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    unsigned int n_vert_vars;$/;"	m	class:vcg::tri::PoissonSolver
n_vert_vars	vcglib/wrap/miq/core/poisson_solver.h	/^	unsigned int n_vert_vars;$/;"	m	class:PoissonSolver
name	vcglib/apps/trimeshinfo/SlotsNode.h	/^	const char* name;$/;"	m	class:OwnSlotNode
name	vcglib/wrap/glw/object.h	/^		GLuint name(void) const$/;"	f	class:glw::Object
name	vcglib/wrap/glw/object.h	/^		GLuint name(void) const$/;"	f	class:glw::SafeObject
name	vcglib/wrap/glw/program.h	/^				std::string name;$/;"	m	class:glw::Program::UniformInfo
name	vcglib/wrap/ply/plylib.h	/^	std::string name;				\/\/ Nome dell'elemento$/;"	m	class:vcg::ply::PlyElement
name	vcglib/wrap/ply/plylib.h	/^	std::string name;				\/\/ Nome della propieta'$/;"	m	class:vcg::ply::PlyProperty
name	vcglib/wrap/system/getopt.h	/^  const char *name;$/;"	m	struct:option
name	vcglib/wrap/system/qgetopt.h	/^    QString name;$/;"	m	struct:GetOpt::Option
namemesh1	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    char namemesh1[255],namemesh2[255];$/;"	m	class:vcg::tri::FourPCS
namemesh2	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    char namemesh1[255],namemesh2[255];$/;"	m	class:vcg::tri::FourPCS
nb	vcglib/apps/pivoting/pivot.h	/^    std::vector<int> nb; \/\/number of fronts a vertex is into,$/;"	m	class:vcg::tri::Pivot
nb	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  std::vector<int> nb; \/\/number of fronts a vertex is into,$/;"	m	class:vcg::tri::AdvancingFront
nbButton	vcglib/apps/sample/trimesh_pos_demo/window.h	/^		QPushButton * fvButton,*feButton,*ffButton,*neButton,*ldButton,*nbButton,*vfButton;$/;"	m	class:Window
nbThreads	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^inline int nbThreads()$/;"	f	namespace:Eigen
nb_of_subdiagonals	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Index nb_of_subdiagonals;$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
nb_of_superdiagonals	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Index nb_of_superdiagonals;$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
nb_vert	vcg_mesh.hpp	/^    int nb_vert() const { return this->vn; }$/;"	f	class:vcg::MyMesh
nc	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex nc() const { return m_nc; }$/;"	f	class:Eigen::internal::level3_blocking
ncfail	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index ncfail;$/;"	m	class:Eigen::HybridNonLinearSolver
ncolors	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char ncolors;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
ncolors	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char ncolors;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
ncols	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int   ncols()    { return m_ncols   ; }$/;"	f	class:SparseMatrixData
ncsuc	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index ncsuc;$/;"	m	class:Eigen::HybridNonLinearSolver
ndim	vcglib/vcg/math/old_deprecated_matrix.h	/^	namespace ndim{$/;"	n	namespace:vcg
ndim	vcglib/vcg/math/old_matrix.h	/^namespace ndim{$/;"	n	namespace:vcg
ndim	vcglib/vcg/space/deprecated_point.h	/^    namespace ndim{$/;"	n	namespace:vcg
ndim	vcglib/vcg/space/point.h	/^namespace ndim{$/;"	n	namespace:vcg
neButton	vcglib/apps/sample/trimesh_pos_demo/window.h	/^		QPushButton * fvButton,*feButton,*ffButton,*neButton,*ldButton,*nbButton,*vfButton;$/;"	m	class:Window
nearestPixel	vcglib/img/img_image.h	/^  inline void nearestPixel(float x, float y, ScalarType (& ret_pixel)[Channels]) const$/;"	f	class:img::Image
nearest_point	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 CoordinateType nearest_point;$/;"	m	struct:vcg::PerfectSpatialHashing::Neighbor
nentries	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int   nentries() { return m_nentries; }$/;"	f	class:SparseMatrixData
nestByValue	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^DenseBase<Derived>::nestByValue() const$/;"	f	class:Eigen::DenseBase
nested	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^struct nested<GeneralProduct<Lhs,Rhs,Mode>, N, PlainObject>$/;"	s	namespace:Eigen::internal
nested	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^struct nested<ReturnByValue<Derived>, n, PlainObject>$/;"	s	namespace:Eigen::internal
nested	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct nested<CoeffBasedProduct<Lhs,Rhs,EvalBeforeNestingBit|EvalBeforeAssigningBit>, N, PlainObject>$/;"	s	namespace:Eigen::internal
nestedExpression	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::ArrayWrapper
nestedExpression	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::MatrixWrapper
nestedExpression	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const $/;"	f	class:Eigen::Block
nestedExpression	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::CwiseUnaryOp
nestedExpression	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() { return m_xpr.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryOp
nestedExpression	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::CwiseUnaryView
nestedExpression	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryView
nestedExpression	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    nestedExpression() const $/;"	f	class:Eigen::Diagonal
nestedExpression	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    const _MatrixTypeNested& nestedExpression() const$/;"	f	class:Eigen::Replicate
nestedExpression	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    nestedExpression() const $/;"	f	class:Eigen::Reverse
nestedExpression	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::SelfAdjointView
nestedExpression	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView
nestedExpression	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::Transpose
nestedExpression	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::Transpose
nestedExpression	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::TriangularView
nestedExpression	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::TriangularView
nestedExpression	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SparseTriangularView
nestedPermutation	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& nestedPermutation() const { return m_permutation; }$/;"	f	class:Eigen::Transpose
newBase	vcglib/vcg/complex/allocate.h	/^                SimplexPointerType newBase;$/;"	m	class:vcg::tri::Allocator::PointerUpdater
newCAT	vcglib/vcg/container/container_allocation_table.h	/^				static CAT<TYPE_1,TYPE_2> *  newCAT(){$/;"	f	struct:vcg::Env
newData	vcglib/wrap/gcache/cache.h	/^    bool newData() {$/;"	f	class:vcg::Cache
newData	vcglib/wrap/gcache/controller.h	/^  bool newData() {$/;"	f	class:vcg::Controller
newEnd	vcglib/vcg/complex/allocate.h	/^                SimplexPointerType newEnd;$/;"	m	class:vcg::tri::Allocator::PointerUpdater
newHinge	vcglib/apps/pivoting/pivot.h	/^     std::list<Hinge>::iterator newHinge(Hinge e) {                  $/;"	f	class:vcg::tri::Pivot
newPhongMaterial	vcglib/wrap/io_trimesh/export_fbx.h	/^	static KFbxSurfacePhong* newPhongMaterial(KFbxScene& scene,const char* name,KFbxFileTexture* text = NULL,const fbxDouble3& dif = fbxDouble3(1.0,1.0,1.0)\/*,const fbxDouble3& amb = fbxDouble3(1.0,1.0,1.0),const fbxDouble3& em = fbxDouble3(1.0,1.0,1.0),const double& transp = 0.0,const double& shin = 0.0*\/)$/;"	f	class:ExporterFBX
newPtMap	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    std::map< std::pair<CoordType,CoordType>, CoordType > *newPtMap;$/;"	m	class:vcg::tri::CylinderClipping::CylMidPoint
newPtMap	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    std::map< std::pair<CoordType,CoordType>,CoordType > newPtMap;$/;"	m	class:vcg::tri::CylinderClipping::CylPred
newTexture	vcglib/wrap/io_trimesh/export_fbx.h	/^	static KFbxFileTexture* newTexture(KFbxScene& scene,const char* name,const KFbxVector2& trans = KFbxVector2(0.0,0.0),const KFbxVector2& rot = KFbxVector2(0.0,0.0),const KFbxVector2& scal = KFbxVector2(1.0,1.0))$/;"	f	class:ExporterFBX
new_data	vcglib/wrap/gcache/cache.h	/^    mt::atomicInt new_data;$/;"	m	class:vcg::Cache
new_priority	vcglib/wrap/gcache/token.h	/^    Priority new_priority;$/;"	m	class:vcg::Token
newp	vcglib/wrap/gl/trimesh.h	/^        bool newp;$/;"	m	class:vcg::GLW::VertToSplit
newtypenames	vcglib/wrap/ply/plylib.cpp	/^const char * PlyFile::newtypenames[9]=$/;"	m	class:vcg::ply::PlyFile	file:
newtypenames	vcglib/wrap/ply/plylib.h	/^	static const char * newtypenames[9];$/;"	m	class:vcg::ply::PlyFile
next	vcglib/apps/pivoting/pivot.h	/^      std::list<Hinge>::iterator next;            $/;"	m	struct:vcg::tri::Hinge
next	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^      Index next;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
next	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  struct malloc_segment* next;   \/* ptr to next segment *\/$/;"	m	struct:malloc_segment	typeref:struct:malloc_segment::malloc_segment	file:
next	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  std::list<FrontEdge>::iterator next;$/;"	m	class:vcg::tri::FrontEdge
next	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_Chord * next;$/;"	m	struct:vcg::tri::PolychordCollapse::PC_Chord
nextB	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::nextB( ){$/;"	f	class:GLWidget
nextE	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::nextE( ){$/;"	f	class:GLWidget
nextTime	vcglib/wrap/gui/trackrecorder.h	/^	int nextTime,   $/;"	m	struct:vcg::TrackRecorder
nextVfite	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::nextVfite( ){$/;"	f	class:GLWidget
next_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define next_chunk(/;"	d	file:
next_pinuse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define next_pinuse(/;"	d	file:
nextabove	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal nextabove  (const mpreal& x)$/;"	f	namespace:mpfr
nextbelow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal nextbelow  (const mpreal& x)$/;"	f	namespace:mpfr
nextchar	vcglib/wrap/system/getopt.cpp	/^static char *nextchar;$/;"	v	file:
nexttoward	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal nexttoward (const mpreal& x, const mpreal& y)$/;"	f	namespace:mpfr
nfev	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index nfev;$/;"	m	class:Eigen::HybridNonLinearSolver
nfev	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Index nfev;$/;"	m	class:Eigen::LevenbergMarquardt
nfev	vcglib/wrap/minpack/minpack.h	/^	int nfev; 		\/\/ actual number of iterations.$/;"	m	struct:LMDiff::__anon525
nfev	vcglib/wrap/minpack/minpack.h	/^	int nfev; 	\/\/ actual number of iterations.$/;"	m	struct:LMDiff::__anon526
ng	vcglib/apps/trimeshinfo/XMLTree.h	/^	NodeGroup ng;	$/;"	m	class:XMLTree
niceRound	vcglib/wrap/gui/coordinateframe.cpp	/^float CoordinateFrame::niceRound(float val)$/;"	f	class:CoordinateFrame
njev	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index njev;$/;"	m	class:Eigen::HybridNonLinearSolver
njev	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Index njev;$/;"	m	class:Eigen::LevenbergMarquardt
nmbToStr	vcglib/wrap/io_trimesh/export_idtf.h	/^	static std::string nmbToStr(NUMERICTYPE n)$/;"	f	class:TextUtility
nnz	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon434::__anon435
noMoreReferencesTo	vcglib/wrap/glw/context.h	/^		void noMoreReferencesTo(Object * object)$/;"	f	class:glw::Context
no_argument	vcglib/wrap/system/getopt.h	/^#define	no_argument	/;"	d
no_assignment_operator	vcglib/eigenlib/Eigen/src/Core/util/XprHelper.h	/^class no_assignment_operator$/;"	c	namespace:Eigen::internal
noalias	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^NoAlias<Derived,MatrixBase> MatrixBase<Derived>::noalias()$/;"	f	class:Eigen::MatrixBase
nodeId	vcglib/vcg/space/index/kdtree/kdtree.h	/^			unsigned int nodeId;  \/\/ id of the next node$/;"	m	struct:KdTree::QueryNode
node_type	vcglib/apps/trimeshinfo/ClassesNode.h	/^	int node_type;$/;"	m	class:ClassNode
node_type	vcglib/apps/trimeshinfo/ClassesNode.h	/^	int node_type;$/;"	m	class:ClassesNode
node_type	vcglib/apps/trimeshinfo/ClassesNode.h	/^	int node_type;$/;"	m	class:OwnSlotsNode
node_type	vcglib/apps/trimeshinfo/InstancesNode.h	/^	int		node_type;$/;"	m	class:InstanceNode
node_type	vcglib/apps/trimeshinfo/InstancesNode.h	/^	int		node_type;$/;"	m	class:InstancesNode
node_type	vcglib/apps/trimeshinfo/SlotsNode.h	/^	int node_type;$/;"	m	class:EntryNode
node_type	vcglib/apps/trimeshinfo/SlotsNode.h	/^	int node_type;$/;"	m	class:OwnSlotNode
node_type	vcglib/apps/trimeshinfo/SlotsNode.h	/^	int node_type;$/;"	m	class:SlotNode
node_type	vcglib/apps/trimeshinfo/SlotsNode.h	/^	int node_type;$/;"	m	class:SlotsNode
node_type	vcglib/apps/trimeshinfo/SlotsNode.h	/^	int node_type;$/;"	m	class:ValueNode
node_type	vcglib/apps/trimeshinfo/XMLTree.h	/^	int node_type;$/;"	m	class:MainNode
nodes	vcglib/vcg/math/disjoint_set.h	/^		std::vector< DisjointSetNode >				nodes;$/;"	m	class:vcg::DisjointSet
nodes	vcglib/vcg/space/index/octree_template.h	/^	std::vector< Node* > nodes;$/;"	m	class:vcg::OctreeTemplate
nodes	vcglib/wrap/mt/mt.h	/^  std::vector<Node> nodes;$/;"	m	class:vcg::MT
noiseLevel	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    int noiseLevel() const { return m_noise; }$/;"	f	class:Eigen::IterationController
nonZeros	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    inline Index nonZeros() const { return size(); }$/;"	f	class:Eigen::DenseBase
nonZeros	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^_Index AmbiVector<_Scalar,_Index>::nonZeros() const$/;"	f	class:Eigen::internal::AmbiVector
nonZeros	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index nonZeros() const  { return m_nnz; }$/;"	f	class:Eigen::MappedSparseMatrix
nonZeros	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    Index nonZeros() const$/;"	f	class:Eigen::SparseInnerVectorSet
nonZeros	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index nonZeros() const$/;"	f	class:Eigen::SparseMatrix
nonZeros	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index nonZeros() const { return derived().nonZeros(); }$/;"	f	class:Eigen::SparseMatrixBase
nonZeros	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline Index nonZeros() const { return derived().nestedExpression().nonZeros(); }$/;"	f	class:Eigen::TransposeImpl
nonZeros	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Index nonZeros() const  { return static_cast<Index>(m_data.size()); }$/;"	f	class:Eigen::SparseVector
nonZeros	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index nonZeros() const {$/;"	f	class:Eigen::SkylineMatrix
nonZeros	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Index nonZeros() const {$/;"	f	class:Eigen::SkylineMatrixBase
nonZeros	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    Index nonZeros() const$/;"	f	class:Eigen::SparseInnerVectorSet
nonZeros	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    Index nonZeros() const$/;"	f	class:Eigen::DynamicSparseMatrix
nonZeros	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    Index nonZeros() const$/;"	f	class:Eigen::RandomSetter
noncopyable	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^  noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable
noncopyable	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^class noncopyable$/;"	c	namespace:Eigen::internal
nonzeroPivots	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivLU
nonzeroPivots	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::ColPivHouseholderQR
nonzeroPivots	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivHouseholderQR
nonzeroSingularValues	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    Index nonzeroSingularValues() const$/;"	f	class:Eigen::JacobiSVD
norm	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const$/;"	f	class:Eigen::MatrixBase
norm	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_norm,RealScalar>::Type norm() const$/;"	f	class:Eigen::VectorwiseOp
norm	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar norm() const { return m_coeffs.norm(); }$/;"	f	class:Eigen::Quaternion
norm	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar norm() const { return coeffs().norm(); }$/;"	f	class:Eigen::QuaternionBase
norm	vcglib/eigenlib/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::norm() const$/;"	f	class:Eigen::SparseMatrixBase
norm	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^double norm(double x) {return x*x;}$/;"	f
norm	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^float norm(float x) {return x*x;}$/;"	f
norm	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^long double norm(long double x) {return x*x;}$/;"	f
norm	vcglib/wrap/bmt/strip_mesh.h	/^  std::vector<short> norm;$/;"	m	class:vcg::StripMeshBuilder
norm1	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(norm1, Scalar) norm1(const Scalar& x)$/;"	f	namespace:Eigen::internal
norm1_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl$/;"	s	namespace:Eigen::internal
norm1_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
norm1_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal
norm1_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct norm1_retval$/;"	s	namespace:Eigen::internal
normBuckets	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    vector<vector<int> >* normBuckets;          \/\/structure to hold normals bucketing. Needed for normal equalized sampling during consensus$/;"	m	class:OverlapEstimation
normal	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normal	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const NormalReturnType normal() const { return NormalReturnType(*const_cast<Coefficients*>(&m_coeffs),0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normal	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline ConstNormalReturnType normal() const { return ConstNormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normal	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normal	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^		CoordType normal;$/;"	m	class:vcg::AABBBinaryTreeFrustumCull::VFrustumPlane
normalEqualization	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        bool normalEqualization;                        \/\/\/< Allows to use normal equalization sampling in consensus. If set to \\c false uniform sampling is used instead. Uniform sampling is faster but less accurate.$/;"	m	class:OverlapEstimation::Parameters
normalize	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^inline void MatrixBase<Derived>::normalize()$/;"	f	class:Eigen::MatrixBase
normalize	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane
normalize	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline void normalize() { m_coeffs.normalize(); }$/;"	f	class:Eigen::Quaternion
normalize	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane
normalize	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline void normalize() { coeffs().normalize(); }$/;"	f	class:Eigen::QuaternionBase
normalize	vcglib/img/img_filter.h	/^inline void normalize(Image<Channels,ScalarType,Safe> &image)$/;"	f	namespace:img
normalize_vec3	vcglib/vcg/math/quadric5.h	/^  void inline normalize_vec3(ScalarType v[3])$/;"	f	namespace:vcg::math
normalize_vec5	vcglib/vcg/math/quadric5.h	/^  void inline normalize_vec5(ScalarType v[5])$/;"	f	namespace:vcg::math
normalized	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::normalized() const$/;"	f	class:Eigen::MatrixBase
normalized	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion normalized() const { return Quaternion(m_coeffs.normalized()); }$/;"	f	class:Eigen::Quaternion
normalized	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion<Scalar> normalized() const { return Quaternion<Scalar>(coeffs().normalized()); }$/;"	f	class:Eigen::QuaternionBase
normalized	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 & normalized() { return Normalize(); }$/;"	f	class:vcg::Point3
normalmaps	vcglib/vcg/complex/base.h	/^  std::vector<std::string> normalmaps;$/;"	m	class:vcg::tri::TriMesh
np	vcglib/vcg/complex/algorithms/smooth.h	/^    CoordType np;$/;"	m	class:vcg::tri::Smooth::PDVertInfo
nprint	vcglib/wrap/minpack/minpack.h	/^	int nprint; 		\/\/ desired frequency of print outs.$/;"	m	struct:LMDiff::__anon525
nprint	vcglib/wrap/minpack/minpack.h	/^	int nprint; 	\/\/ desired frequency of print outs.$/;"	m	struct:LMDiff::__anon526
nr	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 2,$/;"	e	enum:Eigen::internal::gebp_traits::__anon200
nr	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon201
nr	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon198
nr	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon199
nrows	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int   nrows()    { return  m_A.nrows(); }$/;"	f	class:SparseSystemData
nrows	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int   nrows()    { return m_nrows   ; }$/;"	f	class:SparseMatrixData
nslow1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index nslow1, nslow2;$/;"	m	class:Eigen::HybridNonLinearSolver
nslow2	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Index nslow1, nslow2;$/;"	m	class:Eigen::HybridNonLinearSolver
ntexcoord	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char ntexcoord;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
ntexcoord	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char ntexcoord;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
numCol	vcglib/wrap/io_edgemesh/export_svg.h	/^	int numCol;$/;"	m	class:vcg::tri::io::SVGProperties
numFaces	vcglib/wrap/io_trimesh/import_fbx.h	/^		int numFaces;$/;"	m	class:ImporterFBX::Info
numFaces	vcglib/wrap/io_trimesh/import_obj.h	/^                    int numFaces;$/;"	m	class:vcg::tri::io::ImporterOBJ::Info
numMeshPatches	vcglib/wrap/io_trimesh/import_fbx.h	/^		int numMeshPatches;$/;"	m	class:ImporterFBX::Info
numNormals	vcglib/wrap/io_trimesh/import_obj.h	/^                    int numNormals;$/;"	m	class:vcg::tri::io::ImporterOBJ::Info
numRow	vcglib/wrap/io_edgemesh/export_svg.h	/^	int numRow;$/;"	m	class:vcg::tri::io::SVGProperties
numTexCoords	vcglib/wrap/io_trimesh/import_obj.h	/^                    int numTexCoords;$/;"	m	class:vcg::tri::io::ImporterOBJ::Info
numVertices	vcglib/wrap/io_trimesh/import_fbx.h	/^		int numVertices;$/;"	m	class:ImporterFBX::Info
numVertices	vcglib/wrap/io_trimesh/import_obj.h	/^                    int numVertices;$/;"	m	class:vcg::tri::io::ImporterOBJ::Info
num_constraint_equations	vcglib/wrap/miq/core/poisson_solver.h	/^    unsigned int num_constraint_equations;$/;"	m	class:PoissonSolver
num_cut_constraint	vcglib/wrap/miq/core/poisson_solver.h	/^    unsigned int num_cut_constraint;$/;"	m	class:PoissonSolver
num_integer_cuts	vcglib/wrap/miq/core/vertex_indexing.h	/^    int num_integer_cuts;$/;"	m	struct:MeshSystemInfo
num_pts	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char num_pts;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_RangeGridAux
num_scalar_variables	vcglib/wrap/miq/core/vertex_indexing.h	/^    int num_scalar_variables;$/;"	m	struct:MeshSystemInfo
num_total_vars	vcglib/wrap/miq/core/poisson_solver.h	/^    unsigned int num_total_vars;$/;"	m	class:PoissonSolver
num_vert_variables	vcglib/wrap/miq/core/vertex_indexing.h	/^    int num_vert_variables;$/;"	m	struct:MeshSystemInfo
number	vcglib/wrap/ply/plylib.h	/^	int    number;				\/\/ Numero di elementi di questo tipo$/;"	m	class:vcg::ply::PlyElement
numcomponents	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int numcomponents,Genus;$/;"	m	struct:MeshInfo	file:
numface	vcglib/wrap/io_trimesh/additionalinfo.h	/^	unsigned int numface;$/;"	m	class:AdditionalInfo
numholes	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int count_e,boundary_e,count_fd,count_uv,numholes;$/;"	m	struct:MeshInfo	file:
nummeshes	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  int			nummeshes;			\/\/ number of meshes extracted so far$/;"	v
numvert	vcglib/wrap/io_trimesh/additionalinfo.h	/^	unsigned int numvert;$/;"	m	class:AdditionalInfo
nz	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int&  nz(unsigned int i) { assert(i < m_nrows); return m_nz[i]; }$/;"	f	class:SparseMatrixData
nz	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int*  nz()       { return m_nz      ; }$/;"	f	class:SparseMatrixData
o	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& o() { return data[12];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
o	vcglib/wrap/system/qgetopt.h	/^    char o;$/;"	m	struct:GetOpt::Option
oBegin	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^				ObjPtrVectorIterator oBegin;$/;"	m	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
oEnd	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^				ObjPtrVectorIterator oEnd;$/;"	m	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
oS2	vcglib/apps/metro/sampling.h	/^        MetroMeshOctree oS2;$/;"	m	class:vcg::Sampling
obj	vcglib/vcg/math/disjoint_set.h	/^			OBJECT_TYPE	*obj;$/;"	m	struct:vcg::DisjointSet::DisjointSetNode
object	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^    GLuint object;$/;"	m	class:GLWidget
object	vcglib/vcg/space/index/octree.h	/^            ObjectPointer		object;$/;"	m	struct:vcg::Octree::Neighbour
object	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 ObjectPointer	object;$/;"	m	struct:vcg::PerfectSpatialHashing::Neighbor
object	vcglib/wrap/glw/bookkeeping.h	/^		ObjectType * object(void)$/;"	f	class:glw::detail::ObjectSharedPointer
object	vcglib/wrap/glw/bookkeeping.h	/^		ObjectType * object(void)$/;"	f	class:glw::detail::RefCountedObject
object	vcglib/wrap/glw/bookkeeping.h	/^		const ObjectType * object(void) const$/;"	f	class:glw::detail::ObjectSharedPointer
object	vcglib/wrap/glw/bookkeeping.h	/^		const ObjectType * object(void) const$/;"	f	class:glw::detail::RefCountedObject
object	vcglib/wrap/glw/buffer.h	/^		BufferPtr & object(void)$/;"	f	class:glw::BoundBuffer
object	vcglib/wrap/glw/buffer.h	/^		BufferPtr & object(void)$/;"	f	class:glw::SafeBuffer
object	vcglib/wrap/glw/buffer.h	/^		const BufferPtr & object(void) const$/;"	f	class:glw::BoundBuffer
object	vcglib/wrap/glw/buffer.h	/^		const BufferPtr & object(void) const$/;"	f	class:glw::SafeBuffer
object	vcglib/wrap/glw/fragmentshader.h	/^		FragmentShaderPtr & object(void)$/;"	f	class:glw::BoundFragmentShader
object	vcglib/wrap/glw/fragmentshader.h	/^		FragmentShaderPtr & object(void)$/;"	f	class:glw::SafeFragmentShader
object	vcglib/wrap/glw/fragmentshader.h	/^		const FragmentShaderPtr & object(void) const$/;"	f	class:glw::BoundFragmentShader
object	vcglib/wrap/glw/fragmentshader.h	/^		const FragmentShaderPtr & object(void) const$/;"	f	class:glw::SafeFragmentShader
object	vcglib/wrap/glw/framebuffer.h	/^		FramebufferPtr & object(void)$/;"	f	class:glw::BoundFramebuffer
object	vcglib/wrap/glw/framebuffer.h	/^		FramebufferPtr & object(void)$/;"	f	class:glw::SafeFramebuffer
object	vcglib/wrap/glw/framebuffer.h	/^		const FramebufferPtr & object(void) const$/;"	f	class:glw::BoundFramebuffer
object	vcglib/wrap/glw/framebuffer.h	/^		const FramebufferPtr & object(void) const$/;"	f	class:glw::SafeFramebuffer
object	vcglib/wrap/glw/geometryshader.h	/^		GeometryShaderPtr & object(void)$/;"	f	class:glw::BoundGeometryShader
object	vcglib/wrap/glw/geometryshader.h	/^		GeometryShaderPtr & object(void)$/;"	f	class:glw::SafeGeometryShader
object	vcglib/wrap/glw/geometryshader.h	/^		const GeometryShaderPtr & object(void) const$/;"	f	class:glw::BoundGeometryShader
object	vcglib/wrap/glw/geometryshader.h	/^		const GeometryShaderPtr & object(void) const$/;"	f	class:glw::SafeGeometryShader
object	vcglib/wrap/glw/object.h	/^		ObjectPtr & object(void)$/;"	f	class:glw::BoundObject
object	vcglib/wrap/glw/object.h	/^		ObjectPtr & object(void)$/;"	f	class:glw::SafeObject
object	vcglib/wrap/glw/object.h	/^		const ObjectPtr & object(void) const$/;"	f	class:glw::BoundObject
object	vcglib/wrap/glw/object.h	/^		const ObjectPtr & object(void) const$/;"	f	class:glw::SafeObject
object	vcglib/wrap/glw/program.h	/^		ProgramPtr & object(void)$/;"	f	class:glw::BoundProgram
object	vcglib/wrap/glw/program.h	/^		ProgramPtr & object(void)$/;"	f	class:glw::SafeProgram
object	vcglib/wrap/glw/program.h	/^		const ProgramPtr & object(void) const$/;"	f	class:glw::BoundProgram
object	vcglib/wrap/glw/program.h	/^		const ProgramPtr & object(void) const$/;"	f	class:glw::SafeProgram
object	vcglib/wrap/glw/renderable.h	/^		RenderablePtr & object(void)$/;"	f	class:glw::BoundRenderable
object	vcglib/wrap/glw/renderable.h	/^		RenderablePtr & object(void)$/;"	f	class:glw::SafeRenderable
object	vcglib/wrap/glw/renderable.h	/^		const RenderablePtr & object(void) const$/;"	f	class:glw::BoundRenderable
object	vcglib/wrap/glw/renderable.h	/^		const RenderablePtr & object(void) const$/;"	f	class:glw::SafeRenderable
object	vcglib/wrap/glw/renderbuffer.h	/^		RenderbufferPtr & object(void)$/;"	f	class:glw::BoundRenderbuffer
object	vcglib/wrap/glw/renderbuffer.h	/^		RenderbufferPtr & object(void)$/;"	f	class:glw::SafeRenderbuffer
object	vcglib/wrap/glw/renderbuffer.h	/^		const RenderbufferPtr & object(void) const$/;"	f	class:glw::BoundRenderbuffer
object	vcglib/wrap/glw/renderbuffer.h	/^		const RenderbufferPtr & object(void) const$/;"	f	class:glw::SafeRenderbuffer
object	vcglib/wrap/glw/shader.h	/^		ShaderPtr & object(void)$/;"	f	class:glw::BoundShader
object	vcglib/wrap/glw/shader.h	/^		ShaderPtr & object(void)$/;"	f	class:glw::SafeShader
object	vcglib/wrap/glw/shader.h	/^		const ShaderPtr & object(void) const$/;"	f	class:glw::BoundShader
object	vcglib/wrap/glw/shader.h	/^		const ShaderPtr & object(void) const$/;"	f	class:glw::SafeShader
object	vcglib/wrap/glw/texture.h	/^		TexturePtr & object(void)$/;"	f	class:glw::BoundTexture
object	vcglib/wrap/glw/texture.h	/^		TexturePtr & object(void)$/;"	f	class:glw::SafeTexture
object	vcglib/wrap/glw/texture.h	/^		const TexturePtr & object(void) const$/;"	f	class:glw::BoundTexture
object	vcglib/wrap/glw/texture.h	/^		const TexturePtr & object(void) const$/;"	f	class:glw::SafeTexture
object	vcglib/wrap/glw/texture2d.h	/^		Texture2DPtr & object(void)$/;"	f	class:glw::BoundTexture2D
object	vcglib/wrap/glw/texture2d.h	/^		Texture2DPtr & object(void)$/;"	f	class:glw::SafeTexture2D
object	vcglib/wrap/glw/texture2d.h	/^		const Texture2DPtr & object(void) const$/;"	f	class:glw::BoundTexture2D
object	vcglib/wrap/glw/texture2d.h	/^		const Texture2DPtr & object(void) const$/;"	f	class:glw::SafeTexture2D
object	vcglib/wrap/glw/texturecube.h	/^		TextureCubePtr & object(void)$/;"	f	class:glw::BoundTextureCube
object	vcglib/wrap/glw/texturecube.h	/^		TextureCubePtr & object(void)$/;"	f	class:glw::SafeTextureCube
object	vcglib/wrap/glw/texturecube.h	/^		const TextureCubePtr & object(void) const$/;"	f	class:glw::BoundTextureCube
object	vcglib/wrap/glw/texturecube.h	/^		const TextureCubePtr & object(void) const$/;"	f	class:glw::SafeTextureCube
object	vcglib/wrap/glw/vertexshader.h	/^		VertexShaderPtr & object(void)$/;"	f	class:glw::BoundVertexShader
object	vcglib/wrap/glw/vertexshader.h	/^		VertexShaderPtr & object(void)$/;"	f	class:glw::SafeVertexShader
object	vcglib/wrap/glw/vertexshader.h	/^		const VertexShaderPtr & object(void) const$/;"	f	class:glw::BoundVertexShader
object	vcglib/wrap/glw/vertexshader.h	/^		const VertexShaderPtr & object(void) const$/;"	f	class:glw::SafeVertexShader
objectID	vcglib/wrap/gl/gl_object.h	/^	GLuint objectID;$/;"	m	class:GLObject
object_index	vcglib/vcg/space/index/octree.h	/^            unsigned int	object_index;$/;"	m	struct:vcg::Octree::ObjectPlaceholder
objects	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  ObjectList objects;$/;"	m	class:Eigen::KdBVH
offcl	vcglib/wrap/dae/util_dae.h	/^			int offcl;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
offnm	vcglib/wrap/dae/util_dae.h	/^			int offnm;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
offset	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	vcglib/vcg/complex/algorithms/create/resampler.h	/^		float offset;    \/\/ an offset value that is always added to the returned value. Useful for extrarting isosurface  at a different threshold$/;"	m	class:vcg::tri::Resampler::Walker
offset	vcglib/vcg/complex/algorithms/point_sampling.h	/^float offset;$/;"	m	class:vcg::tri::SurfaceSampling::RRParam
offset	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^		ScalarType offset;$/;"	m	class:vcg::AABBBinaryTreeFrustumCull::VFrustumPlane
offset	vcglib/wrap/bmt/bmt.h	/^    unsigned int offset; $/;"	m	class:vcg::Bmt::Cell
offset	vcglib/wrap/glw/buffer.h	/^		GLintptr   offset;$/;"	m	class:glw::FeedbackBufferBindingParams
offset	vcglib/wrap/glw/buffer.h	/^		GLintptr   offset;$/;"	m	class:glw::UniformBufferBindingParams
offset1	vcglib/wrap/ply/plylib.h	/^	size_t offset1;				\/\/ Offset del valore in memoria$/;"	m	class:vcg::ply::PropDescriptor
offset2	vcglib/wrap/ply/plylib.h	/^	size_t offset2;				\/\/ Offset valore memoria$/;"	m	class:vcg::ply::PropDescriptor
offtx	vcglib/wrap/dae/util_dae.h	/^			int offtx;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
ok_address	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ok_address(/;"	d	file:
ok_inuse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ok_inuse(/;"	d	file:
ok_magic	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ok_magic(/;"	d	file:
ok_next	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ok_next(/;"	d	file:
ok_pinuse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define ok_pinuse(/;"	d	file:
oldBase	vcglib/vcg/complex/allocate.h	/^                SimplexPointerType oldBase;$/;"	m	class:vcg::tri::Allocator::PointerUpdater
oldEnd	vcglib/vcg/complex/allocate.h	/^                SimplexPointerType oldEnd;$/;"	m	class:vcg::tri::Allocator::PointerUpdater
old_hitpoint	vcglib/wrap/gui/trackmode.h	/^  Point3f old_hitpoint;$/;"	m	class:vcg::PathMode
old_start	vcglib/vcg/container/vector_occ.h	/^	VALUE_TYPE * old_start;$/;"	m	class:vcg::vector_occ
old_status	vcglib/wrap/gui/trackmode.h	/^  Point3f old_status;$/;"	m	class:vcg::AreaMode
onTimer	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^bool onTimer(){$/;"	f
oneOverEwaRadius	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		float oneOverEwaRadius;$/;"	m	struct:SplatRenderer::UniformParameters
onlyMaskFlag	vcglib/wrap/io_trimesh/import_gts.h	/^					bool onlyMaskFlag;$/;"	m	struct:vcg::tri::io::ImporterGTS::Options
onlyPoints	vcglib/wrap/io_trimesh/import_gts.h	/^					bool onlyPoints;$/;"	m	struct:vcg::tri::io::ImporterGTS::Options
onlypoints	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  bool			onlypoints;			\/\/ store only points$/;"	v
open	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::open() {$/;"	f	class:GLArea
open	vcglib/wrap/gcache/door.h	/^  void open() {$/;"	f	class:QDoor
open	vcglib/wrap/gcache/door.h	/^  void open(void) {$/;"	f	class:QDoor
openMesh	vcglib/apps/sample/polygonmesh_polychord_collapse/polygonmesh_polychord_collapse.cpp	/^    static int openMesh (PolyMesh &mesh, const char *filename)$/;"	f	class:PolyMesh
openNativeFormat	vcglib/img/img_io.h	/^inline bool openNativeFormat(const char *filename, Image<Channels,ScalarType,Safe> &image)$/;"	f	namespace:img
openQtRGB	vcglib/wrap/qt/img_qt_io.h	/^inline void openQtRGB(const QString filename, Image<3,ScalarType,Safe> &image)$/;"	f	namespace:img
openQtY	vcglib/wrap/qt/img_qt_io.h	/^inline void openQtY(const QString filename, Image<1,ScalarType,Safe> &image)$/;"	f	namespace:img
open_and_normalize_range_RGB	vcglib/wrap/qt/img_qt_io.h	/^inline void open_and_normalize_range_RGB(const QString filename, Image<3,ScalarType,Safe> &range_0_1_image)$/;"	f	namespace:img
open_and_normalize_range_Y	vcglib/wrap/qt/img_qt_io.h	/^inline void open_and_normalize_range_Y(const QString filename, Image<1,ScalarType,Safe> &range_0_1_image)$/;"	f	namespace:img
open_normalize_range_and_SRGB_linearize_RGB	vcglib/wrap/qt/img_qt_io.h	/^inline void open_normalize_range_and_SRGB_linearize_RGB(const QString filename, Image<3,ScalarType,Safe> &linear_image)$/;"	f	namespace:img
operator !	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline bool operator!() const$/;"	f	class:mt::atomicInt
operator !	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline bool operator!() const$/;"	f	class:mt::atomicInt
operator !=	vcglib/apps/pivoting/ring.h	/^    bool operator!=(const iterator& x) const {$/;"	f	class:ring::iterator
operator !=	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	bool operator!=(const ImplicitSphere &sphere)$/;"	f	class:ImplicitSphere
operator !=	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^	bool operator!=(const SphereUnion &sphere_union)$/;"	f	class:SphereUnion
operator !=	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    inline bool operator!=(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
operator !=	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    bool operator!=(const aligned_allocator<T>& ) const$/;"	f	class:Eigen::aligned_allocator
operator !=	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(Scalar s) const$/;"	f	class:Eigen::Cwise
operator !=	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator !=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator!=(const Scalar& a, const AutoDiffScalar& b) { return a != b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator !=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator!=(const Scalar& other) const  { return m_value != other; }$/;"	f	class:Eigen::AutoDiffScalar
operator !=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator!=(const AutoDiffScalar<OtherDerType>& b) const  { return m_value != b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator !=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator != (const mpreal& a, const mpreal& b){	return (mpfr_lessgreater_p(a.mp,b.mp)	!=0);	}$/;"	f	namespace:mpfr
operator !=	vcglib/vcg/complex/algorithms/update/flag.h	/^    inline bool operator != ( const EdgeSorter & pe ) const$/;"	f	class:vcg::tri::UpdateFlags::EdgeSorter
operator !=	vcglib/vcg/complex/algorithms/update/topology.h	/^  inline bool operator != ( const PEdgeTex & pe ) const$/;"	f	class:vcg::tri::UpdateTopology::PEdgeTex
operator !=	vcglib/vcg/complex/algorithms/update/topology.h	/^inline bool operator !=  ( const PVertexEdge & pe ) const { return ( v!=pe.v ); }$/;"	f	class:vcg::tri::UpdateTopology::PVertexEdge
operator !=	vcglib/vcg/connectors/halfedge_pos.h	/^            inline bool operator != ( Pos const & p ) const$/;"	f	class:vcg::hedge::Pos
operator !=	vcglib/vcg/math/matrix44.h	/^template <class T> bool Matrix44<T>::operator!=(const  Matrix44 &m) const {$/;"	f	class:vcg::Matrix44
operator !=	vcglib/vcg/math/old_deprecated_matrix.h	/^			bool operator!=(const Matrix<TYPE> &m) const$/;"	f	class:vcg::ndim::Matrix
operator !=	vcglib/vcg/simplex/edge/pos.h	/^	inline bool operator != ( POSTYPE const & p ) const {$/;"	f	class:vcg::edge::Pos
operator !=	vcglib/vcg/simplex/face/pos.h	/^	inline bool operator != ( PosType const & p ) const {$/;"	f	class:vcg::face::Pos
operator !=	vcglib/vcg/simplex/tetrahedron/pos.h	/^	inline bool operator != ( BasePosType const & p ) const {$/;"	f	class:vcg::tetra::Pos
operator !=	vcglib/vcg/space/box.h	/^	inline bool operator != ( Box const & p ) const$/;"	f	class:vcg::Box
operator !=	vcglib/vcg/space/box3.h	/^    inline bool operator != ( Box3<BoxScalarType> const & p ) const$/;"	f	class:vcg::Box3
operator !=	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator != ( Point2 const & p ) const {$/;"	f	class:vcg::ndim::Point2
operator !=	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator != ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point3
operator !=	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator != ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point4
operator !=	vcglib/vcg/space/deprecated_point2.h	/^	inline bool operator != ( Point2 const & p ) const$/;"	f	class:vcg::Point2
operator !=	vcglib/vcg/space/deprecated_point3.h	/^    inline bool operator != ( Point3 const & p ) const$/;"	f	class:vcg::Point3
operator !=	vcglib/vcg/space/deprecated_point4.h	/^    inline bool operator != ( const Point4 & p ) const$/;"	f	class:vcg::Point4
operator !=	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline bool operator != ( const Link & l ) const{ return i !=  l.i; }$/;"	f	class:vcg::GridStaticPtr::Link
operator !=	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^            bool operator != (const CellIterator & p) const {return t!=p.t;}$/;"	f	struct:vcg::SpatialHashTable2D::CellIterator
operator !=	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				bool operator!=(const EntryIterator &it) const$/;"	f	struct:vcg::PerfectSpatialHashing::UniformGrid::EntryIterator
operator !=	vcglib/vcg/space/index/spatial_hashing.h	/^		bool operator != (const CellIterator & p) const {return t!=p.t;}$/;"	f	struct:vcg::SpatialHashTable::CellIterator
operator !=	vcglib/vcg/space/line2.h	/^	inline bool operator != ( LineType const & p ) const$/;"	f	class:vcg::Line2
operator !=	vcglib/vcg/space/line3.h	/^	inline bool operator != ( LineType const & p ) const$/;"	f	class:vcg::Line3
operator !=	vcglib/vcg/space/plane3.h	/^	bool operator!=(Plane3 const &p) const	{	$/;"	f	class:vcg::Plane3
operator !=	vcglib/vcg/space/ray2.h	/^	inline bool operator != ( RayType const & p ) const$/;"	f	class:vcg::Ray2
operator !=	vcglib/vcg/space/ray3.h	/^	inline bool operator != ( RayType const & p ) const$/;"	f	class:vcg::Ray3
operator !=	vcglib/vcg/space/segment2.h	/^    inline bool operator != ( SegmentType const & p ) const$/;"	f	class:vcg::Segment2
operator !=	vcglib/vcg/space/segment3.h	/^	inline bool operator != ( SegmentType const & p ) const$/;"	f	class:vcg::Segment3
operator !=	vcglib/vcg/space/texcoord2.h	/^  inline bool operator != ( TexCoord2 const & p ) const$/;"	f	class:vcg::TexCoord2
operator !=	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline bool operator!=(int value) const$/;"	f	class:mt::atomicInt
operator !=	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline bool operator!=(int value) const$/;"	f	class:mt::atomicInt
operator %	vcglib/vcg/space/deprecated_point.h	/^	inline S operator % ( Point2 const & p ) const {$/;"	f	class:vcg::ndim::Point2
operator %	vcglib/vcg/space/deprecated_point.h	/^	inline S operator % ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point3
operator %	vcglib/vcg/space/deprecated_point.h	/^	inline S operator % ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point4
operator &&	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator&&(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator ()	vcglib/apps/trimeshinfo/trimeshinfo1.01/trimeshinfo101/main.cpp	/^	inline bool operator() (VertexIterator a, VertexIterator b)$/;"	f	class:DuplicateVert_Compare
operator ()	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType operator()(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index)$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a \/ m_other; }$/;"	f	struct:Eigen::internal::scalar_quotient1_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a && b; }$/;"	f	struct:Eigen::internal::scalar_boolean_and_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a || b; }$/;"	f	struct:Eigen::internal::scalar_boolean_or_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }$/;"	f	struct:Eigen::internal::scalar_cast_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return impl(i); }$/;"	f	struct:Eigen::internal::linspaced_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return m_low+i*m_step; }$/;"	f	struct:Eigen::internal::linspaced_op_impl
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const $/;"	f	struct:Eigen::internal::linspaced_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const { return row==col ? Scalar(1) : Scalar(0); }$/;"	f	struct:Eigen::internal::scalar_identity_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index, Index = 0) const { return m_other; }$/;"	f	struct:Eigen::internal::scalar_constant_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& _x, const Scalar& _y) const$/;"	f	struct:Eigen::internal::scalar_hypot_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return -a; }$/;"	f	struct:Eigen::internal::scalar_opposite_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return internal::conj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }$/;"	f	struct:Eigen::internal::scalar_sum_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a - b; }$/;"	f	struct:Eigen::internal::scalar_difference_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a \/ b; }$/;"	f	struct:Eigen::internal::scalar_quotient_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::max; return (max)(a, b); }$/;"	f	struct:Eigen::internal::scalar_max_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::min; return (min)(a, b); }$/;"	f	struct:Eigen::internal::scalar_min_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }$/;"	f	struct:Eigen::internal::scalar_product_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return internal::abs(a); }$/;"	f	struct:Eigen::internal::scalar_abs_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return internal::abs2(a); }$/;"	f	struct:Eigen::internal::scalar_abs2_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return internal::imag(a); }$/;"	f	struct:Eigen::internal::scalar_imag_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return internal::real(a); }$/;"	f	struct:Eigen::internal::scalar_real_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar1& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple2_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return internal::imag_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_imag_ref_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return internal::real_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_real_ref_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return Scalar(1)\/a; }$/;"	f	struct:Eigen::internal::scalar_inverse_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a + m_other; }$/;"	f	struct:Eigen::internal::scalar_add_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a*a; }$/;"	f	struct:Eigen::internal::scalar_cube_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a; }$/;"	f	struct:Eigen::internal::scalar_square_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return internal::cos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return internal::pow(a, m_exponent); }$/;"	f	struct:Eigen::internal::scalar_pow_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return m_other \/ a; }$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a, const OtherScalar& b) const { return internal::pow(a, b); }$/;"	f	struct:Eigen::internal::scalar_binary_pow_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::acos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::asin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::exp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::log(a); }$/;"	f	struct:Eigen::internal::scalar_log_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::sin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::sqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { return internal::tan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Random.h	/^  inline const Scalar operator() (Index, Index = 0) const { return random<Scalar>(); }$/;"	f	struct:Eigen::internal::scalar_random_op
operator ()	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline Scalar& operator()(Index index)$/;"	f	class:Eigen::Reverse
operator ()	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::Reverse
operator ()	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Index& operator()(Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator ()	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline const Index& operator()(Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator ()	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar operator()(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
operator ()	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::TriangularBase
operator ()	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  inline result_type operator()(const DenseBase<Derived>& mat) const$/;"	f	struct:Eigen::internal::member_redux
operator ()	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::max_coeff_visitor
operator ()	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::min_coeff_visitor
operator ()	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_DONT_INLINE void operator()(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows,$/;"	f	struct:Eigen::internal::gemm_pack_lhs
operator ()	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_DONT_INLINE void operator()(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols,$/;"	f	struct:Eigen::internal::gemm_pack_rhs
operator ()	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha,$/;"	f	struct:Eigen::internal::gebp_kernel
operator ()	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void operator() (Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const$/;"	f	struct:Eigen::internal::gemm_functor
operator ()	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, ResScalar alpha, RhsScalar* workspace)$/;"	f	struct:Eigen::internal::tribb_kernel
operator ()	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)$/;"	f	struct:Eigen::internal::symm_pack_lhs
operator ()	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)$/;"	f	struct:Eigen::internal::symm_pack_rhs
operator ()	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i, Index j)$/;"	f	class:Eigen::internal::blas_data_mapper
operator ()	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i, Index j) const$/;"	f	class:Eigen::internal::const_blas_data_mapper
operator ()	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  inline T operator()(const T& x) { return conj(x); }$/;"	f	struct:Eigen::internal::conj_if
operator ()	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  inline const T& operator()(const T& x) { return x; }$/;"	f	struct:Eigen::internal::conj_if
operator ()	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar operator() (int row, int col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar& operator() (int row, int col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Scalar operator() (Index row, Index col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Scalar& operator() (Index row, Index col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::IncompleteLUT::keep_diag
operator ()	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::SimplicialCholeskyBase::keep_diag
operator ()	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline bool operator() (const Index&, const Index&, const Scalar& value) const$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func
operator ()	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffJacobian.h	/^  void operator() (const InputType& x, ValueType* v, JacobianType* _jac=0) const$/;"	f	class:Eigen::AutoDiffJacobian
operator ()	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    CoeffType operator() (Index i) { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
operator ()	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    const CoeffType operator() (Index i) const { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
operator ()	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^    inline bool operator()(const VIPair &v1, const VIPair &v2) const { return v1.first[dim] < v2.first[dim]; }$/;"	f	struct:Eigen::KdBVH::VectorComparator
operator ()	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  void operator()(const ObjectList &objects, BoxIter boxBegin, BoxIter boxEnd, VolumeList &outBoxes)$/;"	f	struct:Eigen::internal::get_boxes_helper
operator ()	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  void operator()(const ObjectList &objects, int, int, VolumeList &outBoxes)$/;"	f	struct:Eigen::internal::get_boxes_helper
operator ()	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    EIGEN_STRONG_INLINE const _Scalar operator()(Index row, Index col ) const$/;"	f	class:Eigen::internal::companion
operator ()	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    Scalar& operator() (Index row, Index col)$/;"	f	class:Eigen::RandomSetter
operator ()	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^  typename Spline<_Scalar, _Dim, _Degree>::PointType Spline<_Scalar, _Dim, _Degree>::operator()(Scalar u) const$/;"	f	class:Eigen::Spline
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:Bennett5_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:BoxBOD_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:MGH09_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:MGH10_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:MGH17_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:chwirut2_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:eckerle4_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:hahn1_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:lanczos1_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:misra1a_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:misra1d_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:rat42_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:rat43_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &b, VectorXd &fvec)$/;"	f	struct:thurber_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec) const$/;"	f	struct:hybrd_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec) const$/;"	f	struct:lmder_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec) const$/;"	f	struct:lmdif_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec)$/;"	f	struct:hybrj_functor
operator ()	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec)$/;"	f	struct:lmstr_functor
operator ()	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^    int operator()(const VectorXd &x, VectorXd &fvec) const$/;"	f	struct:my_functor
operator ()	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  void operator() (const InputType& x, ValueType* v, JacobianType* _j) const$/;"	f	struct:TestFunc1
operator ()	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  void operator() (const Matrix<T,InputsAtCompileTime,1>& x, Matrix<T,ValuesAtCompileTime,1>* _v) const$/;"	f	struct:TestFunc1
operator ()	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  void operator() (const InputType& x, ValueType* v, JacobianType* _j) const$/;"	f	struct:TestFunc1
operator ()	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  void operator() (const Matrix<T,InputsAtCompileTime,1>& x, Matrix<T,ValuesAtCompileTime,1>* _v) const$/;"	f	struct:TestFunc1
operator ()	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            bool operator () (const dst_trimesh_t & sm, const typename dst_trimesh_t::VertexType & u, const typename dst_trimesh_t::VertexType & v) const$/;"	f	struct:vcg::tri::AttributeSeam::ASCompare
operator ()	vcglib/vcg/complex/algorithms/attribute_seam.h	/^            void operator () (const src_trimesh_t & sm, const typename src_trimesh_t::FaceType & f, int k, const dst_trimesh_t & dm, typename dst_trimesh_t::VertexType & v) const$/;"	f	struct:vcg::tri::AttributeSeam::ASExtract
operator ()	vcglib/vcg/complex/algorithms/clean.h	/^          bool operator ()(FacePointer const& f1, FacePointer const& f2) const {$/;"	f	struct:vcg::tri::Clean::CompareAreaFP
operator ()	vcglib/vcg/complex/algorithms/clean.h	/^    inline bool operator()(VertexPointer const &a, VertexPointer const &b)$/;"	f	class:vcg::tri::Clean::RemoveDuplicateVert_Compare
operator ()	vcglib/vcg/complex/algorithms/clip.h	/^    inline void operator () (const VertexType & v0, const VertexType & v1, const VertexType & v2, const ScalarType & a, const ScalarType & b, VertexType & r) const$/;"	f	class:vcg::tri::GenericVertexInterpolator
operator ()	vcglib/vcg/complex/algorithms/clustering.h	/^    inline	size_t	operator ()(const SimpleTri &p) const {return size_t(p);}$/;"	f	struct:vcg::tri::Clustering::SimpleTriHashFunc
operator ()	vcglib/vcg/complex/algorithms/clustering.h	/^  inline	size_t	operator ()(const vcg::tri::HashedPoint3i &p) const {return size_t(p);}$/;"	f	struct:STDEXT::hash
operator ()	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    bool operator()(PosType ep)$/;"	f	class:vcg::tri::CylinderClipping::CylPred
operator ()	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    void operator()(VertexType &nv, PosType ep)$/;"	f	class:vcg::tri::CylinderClipping::CylMidPoint
operator ()	vcglib/vcg/complex/algorithms/geodesic.h	/^    bool operator()(const VertDist& v0, const VertDist& v1) const$/;"	f	struct:vcg::tri::Geodesic::pred
operator ()	vcglib/vcg/complex/algorithms/geodesic.h	/^  ScalarType operator()( VertexType * v0,  VertexType * v1)$/;"	f	class:vcg::tri::AnisotropicDistance
operator ()	vcglib/vcg/complex/algorithms/geodesic.h	/^  ScalarType operator()( VertexType * v0,  VertexType * v1)$/;"	f	class:vcg::tri::IsotropicDistance
operator ()	vcglib/vcg/complex/algorithms/geodesic.h	/^  ScalarType operator()(const FacePointer f0, const FacePointer f1) const$/;"	f	struct:vcg::tri::EuclideanDistance
operator ()	vcglib/vcg/complex/algorithms/geodesic.h	/^  ScalarType operator()(const VertexType * v0, const VertexType * v1) const$/;"	f	struct:vcg::tri::EuclideanDistance
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^    bool operator()(const Point3<FLT> &p0, const  Point3<FLT> &p1) const$/;"	f	class:vcg::tri::EdgeSplSphere
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^    bool operator()(face::Pos<typename MESH_TYPE::FaceType> ep) const$/;"	f	class:vcg::tri::EdgeLen
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^    typename MESH_TYPE::CoordType operator()(face::Pos<typename MESH_TYPE::FaceType>  ep)$/;"	f	struct:vcg::tri::MidPointArcNaive
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^    typename MESH_TYPE::CoordType operator()(face::Pos<typename MESH_TYPE::FaceType>  ep)$/;"	f	struct:vcg::tri::MidPointButterfly2
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^    typename TRIMESH_TYPE::CoordType operator()(typename TRIMESH_TYPE::FacePointer f){$/;"	f	struct:vcg::tri::CenterPointBarycenter
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^    void operator()(VertexType &nv, PosType  ep){$/;"	f	struct:vcg::tri::MidPoint
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^    void operator()(typename MESH_TYPE::VertexType &nv, face::Pos<typename MESH_TYPE::FaceType>  ep)$/;"	f	struct:vcg::tri::MidPointButterfly
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^    void operator()(typename MESH_TYPE::VertexType &nv, face::Pos<typename MESH_TYPE::FaceType>  ep){$/;"	f	struct:vcg::tri::MidPointSphere
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^    void operator()(typename MESH_TYPE::VertexType &nv, face::Pos<typename MESH_TYPE::FaceType> ep)$/;"	f	struct:vcg::tri::MidPointArc
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^  bool operator()(face::Pos<typename MESH_TYPE::FaceType> ep)$/;"	f	class:vcg::tri::QualityEdgePredicate
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^  void operator()(VertexType &, PosType  ){}$/;"	f	struct:vcg::tri::BaseInterpolator
operator ()	vcglib/vcg/complex/algorithms/refine.h	/^  void operator()(typename MESH_TYPE::VertexType &nv, const face::Pos<typename MESH_TYPE::FaceType> &ep){$/;"	f	class:vcg::tri::QualityMidPointFunctor
operator ()	vcglib/vcg/complex/algorithms/refine_loop.h	/^	void operator()(std::pair<Point3f,Point3f> &nv, face::Pos<typename MESH_TYPE::FaceType>  ep)	{$/;"	f	struct:vcg::tri::EvenPointLoopGeneric
operator ()	vcglib/vcg/complex/algorithms/refine_loop.h	/^	void operator()(typename MESH_TYPE::VertexType &nv, face::Pos<typename MESH_TYPE::FaceType>  ep)	{$/;"	f	struct:vcg::tri::OddPointLoopGeneric
operator ()	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        bool operator() (VertexType* v1, VertexType* v2)$/;"	f	class:vcg::tri::Fitmaps::radSorter
operator ()	vcglib/vcg/complex/base.h	/^        ATTR_TYPE & operator ()(){ return *((Attribute<ATTR_TYPE> *)_handle)->attribute;}$/;"	f	class:vcg::tri::TriMesh::PerMeshAttributeHandle
operator ()	vcglib/vcg/math/base.h	/^        inline bool operator() ( const SCALAR a, const SCALAR b ) { return fabs(a)>fabs(b);  }$/;"	f	class:vcg::math::MagnitudoComparer
operator ()	vcglib/vcg/math/disjoint_set.h	/^			inline	size_t	operator ()(const ObjectPointer &p) const {return size_t(p);}$/;"	f	struct:vcg::DisjointSet::SimpleObjHashFunc
operator ()	vcglib/vcg/math/disjoint_set.h	/^		size_t operator()(const void *ptr) const { return hash<unsigned long>::operator()((unsigned long)ptr); }$/;"	f	class:__gnu_cxx::hash
operator ()	vcglib/vcg/math/spherical_harmonics.h	/^		inline ScalarType operator()(ScalarType theta, ScalarType phi) {return ScalarType(0);}$/;"	f	class:vcg::math::DummyPolarFunctor
operator ()	vcglib/vcg/math/spherical_harmonics.h	/^	ScalarType operator()(ScalarType theta, ScalarType phi)$/;"	f	class:vcg::math::SphericalHarmonics
operator ()	vcglib/vcg/simplex/edge/distance.h	/^		inline bool operator () (const EDGETYPE & e, const Point3<SCALARTYPE> & p, SCALARTYPE & minDist, Point3<SCALARTYPE> & q) {$/;"	f	class:vcg::edge::PointDistanceFunctor
operator ()	vcglib/vcg/simplex/face/distance.h	/^            inline bool operator () (const FACETYPE & f, const Point3<SCALARTYPE> & p, SCALARTYPE & minDist, Point3<SCALARTYPE> & q) {$/;"	f	class:vcg::face::PointDistanceBaseFunctor
operator ()	vcglib/vcg/simplex/face/distance.h	/^        inline bool operator () (const FACETYPE & f, const Point3<SCALARTYPE> & p, SCALARTYPE & minDist, Point3<SCALARTYPE> & q) {$/;"	f	class:vcg::face::PointDistanceEPFunctor
operator ()	vcglib/vcg/simplex/face/distance.h	/^        inline bool operator () (const FACETYPE &f, const typename FACETYPE::VertexType &p,$/;"	f	class:vcg::face::PointNormalDistanceFunctor
operator ()	vcglib/vcg/simplex/vertex/distance.h	/^		inline bool operator () (const VERTEXTYPE & v, const VERTEXTYPE & vp, SCALARTYPE & minDist, Point3<SCALARTYPE> & q) {$/;"	f	class:vcg::vertex::PointNormalDistanceFunctor
operator ()	vcglib/vcg/simplex/vertex/distance.h	/^		inline bool operator () (const VERTEXYPE & p, const QueryType & qp, ScalarType & minDist, Point3<ScalarType> & q) {$/;"	f	class:vcg::vertex::PointScaledDistanceFunctor
operator ()	vcglib/vcg/simplex/vertex/distance.h	/^        inline bool operator ()  (const VERTEXTYPE & v, const Point3<SCALARTYPE> & p, SCALARTYPE & minDist, Point3<SCALARTYPE> & q) const$/;"	f	class:vcg::vertex::PointDistanceFunctor
operator ()	vcglib/vcg/simplex/vertex/distance.h	/^    inline ScalarType operator () (const Point3<ScalarType>& p0, const Point3<ScalarType>& n0,$/;"	f	class:vcg::vertex::ApproximateGeodesicDistanceFunctor
operator ()	vcglib/vcg/simplex/vertex/distance.h	/^    inline bool operator () (const VertexType & v, const VertexType & vp, ScalarType & minDist, Point3<ScalarType> & q) {$/;"	f	class:vcg::vertex::ApproximateGeodesicDistanceFunctor
operator ()	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^			bool operator () (const ClosestObjType & a, const ClosestObjType & b) {$/;"	f	class:vcg::AABBBinaryTreeKClosest::CompareClosest
operator ()	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        bool operator()(const Point2i &s1, const Point2i &s2) const$/;"	f	struct:vcg::HashFunctor2D
operator ()	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^        size_t operator()(const Point2i &p) const$/;"	f	struct:vcg::HashFunctor2D
operator ()	vcglib/vcg/space/index/octree.h	/^            inline bool operator()(const ObjectPlaceholder< LEAF_TYPE > &first, const ObjectPlaceholder< LEAF_TYPE > &second)$/;"	f	struct:vcg::Octree::ObjectSorter
operator ()	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 inline bool operator()(const int i, const int j, const int k)					{ return m_Mask[i][j][k]; }$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
operator ()	vcglib/vcg/space/index/spatial_hashing.h	/^		bool operator()(const Point3i &s1, const Point3i &s2) const$/;"	f	struct:vcg::HashFunctor
operator ()	vcglib/vcg/space/index/spatial_hashing.h	/^		size_t operator()(const Point3i &p) const$/;"	f	struct:vcg::HashFunctor
operator ()	vcglib/vcg/space/intersection3.h	/^	inline bool operator () (const TRIANGLETYPE & f, const Ray3<SCALARTYPE> & ray, SCALARTYPE & t) {$/;"	f	class:vcg::RayTriangleIntersectionFunctor
operator ()	vcglib/vcg/space/rasterized_outline2_packer.h	/^    inline bool operator() ( int a, int b )$/;"	f	class:vcg::ComparisonFunctor
operator ()	vcglib/vcg/space/rect_packer.h	/^  inline bool operator() ( int a, int b )$/;"	f	class:vcg::RectPacker::ComparisonFunctor
operator ()	vcglib/wrap/dae/xmldocumentmanaging.h	/^	void operator()(XMLDocument& doc)$/;"	f	class:XMLDocumentWriter
operator ()	vcglib/wrap/dae/xmldocumentmanaging.h	/^	void operator()(XMLInteriorNode& intnode)$/;"	f	class:XMLDocumentWriter
operator ()	vcglib/wrap/dae/xmldocumentmanaging.h	/^	void operator()(XMLLeafNode& node)$/;"	f	class:XMLDocumentWriter
operator ()	vcglib/wrap/glw/bookkeeping.h	/^template <typename T>             struct DefaultDeleter            { void operator () (T * t) { delete t; }                                  };$/;"	f	struct:glw::detail::DefaultDeleter
operator ()	vcglib/wrap/glw/context.h	/^inline void ObjectDeleter :: operator () (Object * object) const$/;"	f	class:glw::detail::ObjectDeleter
operator ()	vcglib/wrap/miq/quadrangulator.h	/^        bool operator()(vcg::face::Pos<typename MESH_TYPE::FaceType> ep) const$/;"	f	class:Quadrangulator::EdgePredicate
operator ()	vcglib/wrap/miq/quadrangulator.h	/^        void operator()(typename MESH_TYPE::VertexType &nv,$/;"	f	struct:Quadrangulator::SplitMidPoint
operator ()	vcglib/wrap/utils.h	/^	inline T * operator () (T & t) {$/;"	f	class:vcg::GetPointerFunctor
operator ()	vcglib/wrap/utils.h	/^	inline T * operator () (T * & t) {$/;"	f	class:vcg::GetPointerFunctor
operator ()	vcglib/wrap/utils.h	/^	void operator () (const OBJTYPE & obj, Box3<SCALARTYPE> & box) {$/;"	f	class:vcg::GetBox3Functor
operator ()	vcglib/wrap/utils.h	/^	void operator () (const OBJTYPE & obj, Point3<SCALARTYPE> & bar) {$/;"	f	class:vcg::GetBarycenter3Functor
operator *	vcglib/apps/pivoting/ring.h	/^    typename list<T>::reference operator*() const {$/;"	f	class:ring::iterator
operator *	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar) const$/;"	f	class:Eigen::DiagonalBase
operator *	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar, const DiagonalBase& other)$/;"	f	class:Eigen::DiagonalBase
operator *	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^DiagonalBase<DiagonalDerived>::operator*(const MatrixBase<MatrixDerived> &matrix) const$/;"	f	class:Eigen::DiagonalBase
operator *	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^MatrixBase<Derived>::operator*(const DiagonalBase<DiagonalDerived> &diagonal) const$/;"	f	class:Eigen::MatrixBase
operator *	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
operator *	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const PermutationBase<Other>& other) const$/;"	f	class:Eigen::PermutationBase
operator *	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other) const$/;"	f	class:Eigen::PermutationBase
operator *	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)$/;"	f	class:Eigen::PermutationBase
operator *	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix) const$/;"	f	class:Eigen::Transpose
operator *	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)$/;"	f	class:Eigen::Transpose
operator *	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^operator*(const PermutationBase<PermutationDerived> &permutation,$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^operator*(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::RealScalar x)$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^operator*(const ProductBase<Derived,Lhs,Rhs>& prod, typename Derived::Scalar x)$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^operator*(typename Derived::RealScalar x,const ProductBase<Derived,Lhs,Rhs>& prod)$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^operator*(typename Derived::Scalar x,const ProductBase<Derived,Lhs,Rhs>& prod)$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)$/;"	f	class:Eigen::SelfAdjointView
operator *	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SelfAdjointView
operator *	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix) const$/;"	f	class:Eigen::Transpose
operator *	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix, const Transpose& trt)$/;"	f	class:Eigen::Transpose
operator *	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^operator*(const TranspositionsBase<TranspositionDerived> &transpositions,$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const EigenBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView
operator *	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)$/;"	f	class:Eigen::TriangularView
operator *	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView
operator *	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    operator*(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Matrix3 operator* (const Matrix3& other) const$/;"	f	class:Eigen::AngleAxis
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Vector3 operator* (const Vector3& other) const$/;"	f	class:Eigen::AngleAxis
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline friend Matrix3 operator* (const Matrix3& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::operator* (const MatrixBase<Derived>& v) const$/;"	f	class:Eigen::Quaternion
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::operator* (const Quaternion& other) const$/;"	f	class:Eigen::Quaternion
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const Scaling<Scalar,Dim>& s) const$/;"	f	class:Eigen::RotationBase
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Transform<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  friend inline LinearMatrixType operator* (const LinearMatrixType& other, const Scaling& s)$/;"	f	class:Eigen::Scaling
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator* (const LinearMatrixType& other) const$/;"	f	class:Eigen::Scaling
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Scaling
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling operator* (const Scaling& other) const$/;"	f	class:Eigen::Scaling
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Scaling
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Scaling
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TranslationType& t) const$/;"	f	class:Eigen::Scaling
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  friend inline Transform operator*(const LinearMatrixType& mat, const Transform& t)$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const Transform& other) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const ScalingType& s) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  friend inline TransformType operator* (const LinearMatrixType& linear, const Translation& t)$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const LinearMatrixType& linear) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const ScalingType& other) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis
operator *	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis
operator *	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis
operator *	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous
operator *	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Rhs>& rhs) const$/;"	f	class:Eigen::Homogeneous
operator *	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    operator* (const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous
operator *	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::operator* (const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
operator *	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D
operator *	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
operator *	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    friend inline Transform<Scalar,Dim,Affine> operator*(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase
operator *	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const EigenBase<OtherDerived>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase
operator *	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::RotationBase
operator *	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Isometry> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase
operator *	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Mode> operator*(const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::RotationBase
operator *	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    operator*(const EigenBase<OtherDerived>& e) const$/;"	f	class:Eigen::RotationBase
operator *	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  inline Matrix<Scalar,Dim,Dim> operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::UniformScaling
operator *	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?Affine:Mode)> operator* (const Transform<Scalar,Dim, Mode, Options>& t) const$/;"	f	class:Eigen::UniformScaling
operator *	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling operator* (const UniformScaling& other) const$/;"	f	class:Eigen::UniformScaling
operator *	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^  inline typename internal::plain_matrix_type<Derived>::type operator* (const MatrixBase<Derived>& other) const$/;"	f	class:Eigen::UniformScaling
operator *	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^MatrixBase<Derived>::operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::MatrixBase
operator *	vcglib/eigenlib/Eigen/src/Geometry/Scaling.h	/^UniformScaling<Scalar>::operator* (const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::UniformScaling
operator *	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &b) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    operator * (const EigenBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^    operator * (const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?Affine:Isometry)> operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline const Transform operator * (const Transform& other) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  operator * (const EigenBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform
operator *	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline AffineTransformType operator*(const EigenBase<OtherDerived>& linear, const Translation& t)$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline IsometryTransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline Transform<Scalar,Dim,Mode> operator* (const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const EigenBase<OtherDerived>& linear) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const UniformScaling<Scalar>& other) const$/;"	f	class:Eigen::Translation
operator *	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::HouseholderSequence
operator *	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation operator*(const JacobiRotation& other)$/;"	f	class:Eigen::JacobiRotation
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^SparseMatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^SparseMatrixBase<Derived>::operator*(const DiagonalBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)$/;"	f	class:Eigen::SparseMatrixBase
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const Derived& rhs)$/;"	f	class:Eigen::SparseMatrixBase
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^operator*( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const Transpose<PermutationBase<PermDerived> >& tperm)$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const Transpose<PermutationBase<PermDerived> >& tperm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^SparseMatrixBase<Derived>::operator*(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator*(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator *	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const Scalar& scalar) const$/;"	f
operator *	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const Scalar& scalar, const StorageBaseType& matrix)$/;"	f
operator *	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const std::complex<Scalar>& scalar) const$/;"	f
operator *	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const std::complex<Scalar>& scalar, const StorageBaseType& matrix)$/;"	f
operator *	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator*(const AutoDiffScalar<OtherDerType>& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator *	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator*(const Scalar& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator *	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator*(const Scalar& other, const AutoDiffScalar& a)$/;"	f	class:Eigen::AutoDiffScalar
operator *	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  operator*(const Real& other) const$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator *	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  operator*(const Real& other, const AutoDiffScalar<_DerType>& a)$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator *	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator*(const BaseScalar& other) const$/;"	f	class:Eigen::AutoDiffVector
operator *	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator*(const Scalar& other, const AutoDiffVector& v)$/;"	f	class:Eigen::AutoDiffVector
operator *	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^SkylineMatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const {$/;"	f	class:Eigen::SkylineMatrixBase
operator *	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	operator*(const Lhs& lhs, const mpreal& rhs){ return mpreal(rhs) *= lhs;	} $/;"	f	namespace:mpfr
operator *	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	operator*(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) *= rhs;	}$/;"	f	namespace:mpfr
operator *	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator*(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator *	vcglib/vcg/complex/algorithms/clean.h	/^  FacePointer operator *()$/;"	f	class:vcg::tri::ConnectedComponentIterator
operator *	vcglib/vcg/math/matrix33.h	/^    Matrix33 operator * ( const Matrix33< S> & t ) const$/;"	f	class:vcg::Matrix33
operator *	vcglib/vcg/math/matrix33.h	/^    Matrix33 operator * ( const S t ) const$/;"	f	class:vcg::Matrix33
operator *	vcglib/vcg/math/matrix33.h	/^    Point3<S> operator * ( const Point3<S> & v ) const$/;"	f	class:vcg::Matrix33
operator *	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> Matrix44<T>::operator*(const Matrix44 &m) const {$/;"	f	class:vcg::Matrix44
operator *	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> Matrix44<T>::operator*(const T k) const {$/;"	f	class:vcg::Matrix44
operator *	vcglib/vcg/math/matrix44.h	/^template <class T> Point3<T> operator*(const Matrix44<T> &m, const Point3<T> &p) {$/;"	f	namespace:vcg
operator *	vcglib/vcg/math/matrix44.h	/^template <class T> Point4<T> Matrix44<T>::operator*(const Point4<T> &v) const {$/;"	f	class:vcg::Matrix44
operator *	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE> operator*(const Matrix<TYPE> &m) const$/;"	f	class:vcg::ndim::Matrix
operator *	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE> operator*(const MatrixDiagBase &m) const$/;"	f	class:vcg::ndim::Matrix
operator *	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE> operator*(const TYPE k) const$/;"	f	class:vcg::ndim::Matrix
operator *	vcglib/vcg/math/old_deprecated_matrix.h	/^			Point3<TYPE> operator*(Point3<TYPE> &p) const$/;"	f	class:vcg::ndim::Matrix
operator *	vcglib/vcg/math/old_deprecated_matrix.h	/^			ScalarType* operator*(const ScalarType v[]) const$/;"	f	class:vcg::ndim::Matrix
operator *	vcglib/vcg/math/old_matrix44.h	/^	operator * (const Eigen::MatrixBase<OtherDerived> &other) const$/;"	f	class:vcg::Matrix44
operator *	vcglib/vcg/math/quaternion.h	/^template <class S> Quaternion<S> Quaternion<S>::operator*(const Quaternion &q) const {		$/;"	f	class:vcg::Quaternion
operator *	vcglib/vcg/math/quaternion.h	/^template <class S> Quaternion<S> Quaternion<S>::operator*(const S &s) const {$/;"	f	class:vcg::Quaternion
operator *	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Point3<S> operator*(const Similarity<S,RotationType> &m, const Point3<S> &p) {$/;"	f	namespace:vcg
operator *	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Similarity<S,RotationType> Similarity<S,RotationType>::operator*(const Similarity &a) const {$/;"	f	class:vcg::Similarity
operator *	vcglib/vcg/math/similarity2.h	/^Point2<SCALAR_TYPE> operator*(const Similarity2<SCALAR_TYPE> &m, const Point2<SCALAR_TYPE> &p) {$/;"	f	namespace:vcg
operator *	vcglib/vcg/space/box.h	/^	inline Box operator * ( const S s ) const$/;"	f	class:vcg::Box
operator *	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 operator * ( const S s ) const {$/;"	f	class:vcg::ndim::Point2
operator *	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 operator * ( const S s ) const {$/;"	f	class:vcg::ndim::Point3
operator *	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 operator * ( const S s ) const {$/;"	f	class:vcg::ndim::Point4
operator *	vcglib/vcg/space/deprecated_point.h	/^	inline PointType operator * ( const S s ) const$/;"	f	class:vcg::ndim::Point
operator *	vcglib/vcg/space/deprecated_point.h	/^    inline S operator * ( Point2 const & p ) const {$/;"	f	class:vcg::ndim::Point2
operator *	vcglib/vcg/space/deprecated_point.h	/^    inline S operator * ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point3
operator *	vcglib/vcg/space/deprecated_point.h	/^    inline S operator * ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point4
operator *	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 operator * ( const ScalarType s ) const$/;"	f	class:vcg::Point2
operator *	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType operator * ( Point2 const & p ) const$/;"	f	class:vcg::Point2
operator *	vcglib/vcg/space/deprecated_point2.h	/^inline Point2<T> operator * ( const T s, Point2<T> const & p ){$/;"	f	namespace:vcg
operator *	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType operator * ( Point3 const & p ) const$/;"	f	class:vcg::Point3
operator *	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 operator * ( const P3ScalarType s ) const$/;"	f	class:vcg::Point3
operator *	vcglib/vcg/space/deprecated_point4.h	/^	inline T operator * ( const Point4 & p ) const$/;"	f	class:vcg::Point4
operator *	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 operator * ( const T s ) const$/;"	f	class:vcg::Point4
operator *	vcglib/vcg/space/index/grid_static_ptr.h	/^			ObjType &operator *(){return *(t);}$/;"	f	class:vcg::GridStaticPtr::Link
operator *	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^            ObjPtr &operator *(){return (t->second); }$/;"	f	struct:vcg::SpatialHashTable2D::CellIterator
operator *	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^            ObjPtr operator *() const {return (t->second); }$/;"	f	struct:vcg::SpatialHashTable2D::CellIterator
operator *	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				std::vector< ObjectPointer >* operator*()$/;"	f	struct:vcg::PerfectSpatialHashing::UniformGrid::EntryIterator
operator *	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			vcg::Point3i operator*() { return m_CurrentNeighbor; }$/;"	f	struct:vcg::PerfectSpatialHashing::NeighboringEntryIterator
operator *	vcglib/vcg/space/index/space_iterators.h	/^		ObjType &operator *(){return *((*CurrentElem).elem);}$/;"	f	class:vcg::ClosestIterator
operator *	vcglib/vcg/space/index/space_iterators.h	/^		ObjType &operator *(){return *((*CurrentElem).elem);}$/;"	f	class:vcg::RayIterator
operator *	vcglib/vcg/space/index/spatial_hashing.h	/^		ObjPtr &operator *(){return (t->second); }$/;"	f	struct:vcg::SpatialHashTable::CellIterator
operator *	vcglib/vcg/space/index/spatial_hashing.h	/^		ObjPtr operator *() const {return (t->second); }$/;"	f	struct:vcg::SpatialHashTable::CellIterator
operator *	vcglib/vcg/space/line2.h	/^	inline Line2<ScalarType,false> operator * ( const ScalarType s ) const$/;"	f	class:vcg::Line2
operator *	vcglib/vcg/space/line3.h	/^	inline Line3<ScalarType,false> operator * ( const ScalarType s ) const$/;"	f	class:vcg::Line3
operator *	vcglib/vcg/space/ray2.h	/^	inline Ray2<ScalarType,false> operator * ( const ScalarType s ) const$/;"	f	class:vcg::Ray2
operator *	vcglib/vcg/space/ray3.h	/^	inline Ray3<ScalarType,false> operator * ( const ScalarType s ) const$/;"	f	class:vcg::Ray3
operator *	vcglib/vcg/space/segment2.h	/^	inline SegmentType operator * ( const ScalarType s ) const$/;"	f	class:vcg::Segment2
operator *	vcglib/vcg/space/segment3.h	/^	inline SegmentType operator * ( const ScalarType s ) const$/;"	f	class:vcg::Segment3
operator *	vcglib/wrap/glw/bookkeeping.h	/^		ObjectType & operator * (void)$/;"	f	class:glw::detail::ObjectSharedPointer
operator *	vcglib/wrap/glw/bookkeeping.h	/^		const ObjectType & operator * (void) const$/;"	f	class:glw::detail::ObjectSharedPointer
operator *=	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator*=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator *=	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^MatrixBase<Derived>::operator*=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
operator *=	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::DenseBase
operator *=	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView&  operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix * other; }$/;"	f	class:Eigen::TriangularView
operator *=	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator*=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator *=	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator*=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise
operator *=	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator*= (const Quaternion& other)$/;"	f	class:Eigen::Quaternion
operator *=	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D
operator *=	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform
operator *=	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const ScalingType& s) { return scale(s.coeffs()); }$/;"	f	class:Eigen::Transform
operator *=	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform
operator *=	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator*= (const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase
operator *=	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D
operator *=	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const DiagonalMatrix<Scalar,Dim>& s) { linear() *= s; return *this; }$/;"	f	class:Eigen::Transform
operator *=	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const EigenBase<OtherDerived>& other) { return *this = *this * other; }$/;"	f	class:Eigen::Transform
operator *=	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform
operator *=	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform
operator *=	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const UniformScaling<Scalar>& s) { return scale(s.factor()); }$/;"	f	class:Eigen::Transform
operator *=	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase
operator *=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator*=(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
operator *=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator*=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator *=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  inline AutoDiffScalar<_DerType>& operator*=(const Scalar& other)$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator *=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector& operator*=(const AutoDiffVector<OtherValueType,OtherJacobianType>& other)$/;"	f	class:Eigen::AutoDiffVector
operator *=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector& operator*=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffVector
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*= (const mpreal& v)$/;"	f	class:mpfr::mpreal
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const double v)$/;"	f	class:mpfr::mpreal
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const int v)$/;"	f	class:mpfr::mpreal
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const int64_t  u){	*this *= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;	}$/;"	f	class:mpfr::mpreal
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const long double v)$/;"	f	class:mpfr::mpreal
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const long int v)$/;"	f	class:mpfr::mpreal
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const uint64_t u){	*this *= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;	}$/;"	f	class:mpfr::mpreal
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned int v)$/;"	f	class:mpfr::mpreal
operator *=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator*=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
operator *=	vcglib/vcg/math/matrix33.h	/^    Matrix33 & operator *= ( const S t )$/;"	f	class:vcg::Matrix33
operator *=	vcglib/vcg/math/matrix33.h	/^    void operator *=( const Matrix33< S> & t )$/;"	f	class:vcg::Matrix33
operator *=	vcglib/vcg/math/matrix44.h	/^template < class PointType , class T > void operator*=( std::vector<PointType> &vert, const Matrix44<T> & m ) {$/;"	f	namespace:vcg
operator *=	vcglib/vcg/math/matrix44.h	/^template <class T> void Matrix44<T>::operator*=( const Matrix44 & m ) {$/;"	f	class:vcg::Matrix44
operator *=	vcglib/vcg/math/matrix44.h	/^template <class T> void Matrix44<T>::operator*=( const T k ) {$/;"	f	class:vcg::Matrix44
operator *=	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE>& operator*=(const TYPE k)$/;"	f	class:vcg::ndim::Matrix
operator *=	vcglib/vcg/math/old_matrix44.h	/^template < class PointType , class T > void operator*=( std::vector<PointType> &vert, const Matrix44<T> & m ) {$/;"	f	namespace:vcg
operator *=	vcglib/vcg/math/quadric.h	/^  void operator *= ( const ScalarType & w )			\/\/ Amplifica una quadirca$/;"	f	class:vcg::math::Quadric
operator *=	vcglib/vcg/math/quaternion.h	/^template <class S> Quaternion<S> &Quaternion<S>::operator*=(const Quaternion &q) {$/;"	f	class:vcg::Quaternion
operator *=	vcglib/vcg/math/similarity.h	/^template <class S,class RotationType> Similarity<S,RotationType> &Similarity<S,RotationType>::operator*=(const Similarity &a) {  $/;"	f	class:vcg::Similarity
operator *=	vcglib/vcg/space/box.h	/^	inline Box & operator *= ( const S s )$/;"	f	class:vcg::Box
operator *=	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 & operator *= ( const S s ) {$/;"	f	class:vcg::ndim::Point2
operator *=	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 & operator *= ( const S s ) {$/;"	f	class:vcg::ndim::Point3
operator *=	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 & operator *= ( const S s ) {$/;"	f	class:vcg::ndim::Point4
operator *=	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & operator *= ( const S s )$/;"	f	class:vcg::ndim::Point
operator *=	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 & operator *= ( const ScalarType s )$/;"	f	class:vcg::Point2
operator *=	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 & operator *= ( const P3ScalarType s )$/;"	f	class:vcg::Point3
operator *=	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 & operator *= ( const T s )$/;"	f	class:vcg::Point4
operator +	vcglib/apps/pivoting/ring.h	/^    iterator operator+(int i) {$/;"	f	class:ring::iterator
operator +	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    operator+(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator +	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^    operator+(const Scalar& scalar, const Cwise& mat)$/;"	f	class:Eigen::Cwise
operator +	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator+(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise
operator +	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator+(const Scalar& scalar) const$/;"	f
operator +	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator+(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)$/;"	f
operator +	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline const AutoDiffScalar<DerType&> operator+(const Scalar& a, const AutoDiffScalar& b)$/;"	f	class:Eigen::AutoDiffScalar
operator +	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline const AutoDiffScalar<DerType&> operator+(const Scalar& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator +	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator+(const AutoDiffScalar<OtherDerType>& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator +	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  friend inline const AutoDiffScalar<DerType&> operator+(const Real& a, const AutoDiffScalar<_DerType>& b)$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator +	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  inline const AutoDiffScalar<DerType&> operator+(const Real& other) const$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator +	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator+(const AutoDiffVector<OtherValueType,OtherJacobianType>& other) const$/;"	f	class:Eigen::AutoDiffVector
operator +	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	operator+(const Lhs& lhs, const mpreal& rhs){ return mpreal(rhs) += lhs;	} $/;"	f	namespace:mpfr
operator +	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	operator+(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) += rhs;	}$/;"	f	namespace:mpfr
operator +	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal mpreal::operator+()const	{	return mpreal(*this); }$/;"	f	class:mpfr::mpreal
operator +	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator+(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator +	vcglib/vcg/complex/algorithms/hole.h	/^            Weight operator+( const Weight & other ) const {return Weight( std::max( angle(), other.angle() ), area() + other.area());}$/;"	f	class:vcg::tri::Hole::Weight
operator +	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED const ScalarAddReturnType operator+(const Scalar k) { return cwise() + k; }$/;"	f
operator +	vcglib/vcg/math/matrix33.h	/^    Matrix33  operator + ( const Matrix33 &m ) const$/;"	f	class:vcg::Matrix33
operator +	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> Matrix44<T>::operator+(const Matrix44 &m) const {$/;"	f	class:vcg::Matrix44
operator +	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE> operator+(const TYPE k)$/;"	f	class:vcg::ndim::Matrix
operator +	vcglib/vcg/space/box.h	/^	inline Box operator + ( Box const & p) const$/;"	f	class:vcg::Box
operator +	vcglib/vcg/space/color4.h	/^ inline Color4 operator + ( const Color4 & p) const$/;"	f	class:vcg::Color4
operator +	vcglib/vcg/space/color4.h	/^inline Color4<unsigned char> Color4<unsigned char>::operator + ( const Color4<unsigned char>  & p) const$/;"	f	class:vcg::Color4
operator +	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 operator + ( Point2 const & p) const {$/;"	f	class:vcg::ndim::Point2
operator +	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 operator + ( Point3 const & p)  const{$/;"	f	class:vcg::ndim::Point3
operator +	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 operator + ( Point4 const & p) const {$/;"	f	class:vcg::ndim::Point4
operator +	vcglib/vcg/space/deprecated_point.h	/^	inline PointType operator + ( PointType const & p) const$/;"	f	class:vcg::ndim::Point
operator +	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 operator + ( Point2 const & p) const$/;"	f	class:vcg::Point2
operator +	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 operator + ( Point3 const & p) const$/;"	f	class:vcg::Point3
operator +	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 operator + ( const Point4 & p) const$/;"	f	class:vcg::Point4
operator +	vcglib/vcg/space/line2.h	/^	inline Line2<ScalarType,false> operator + ( LineType const & p) const$/;"	f	class:vcg::Line2
operator +	vcglib/vcg/space/line3.h	/^	inline Line3<ScalarType,false> operator + ( LineType const & p) const$/;"	f	class:vcg::Line3
operator +	vcglib/vcg/space/ray2.h	/^	inline Ray2<ScalarType,false> operator + ( RayType const & p) const$/;"	f	class:vcg::Ray2
operator +	vcglib/vcg/space/ray3.h	/^	inline Ray3<ScalarType,false> operator + ( RayType const & p) const$/;"	f	class:vcg::Ray3
operator +	vcglib/vcg/space/segment2.h	/^	inline SegmentType operator + ( SegmentType const & p) const$/;"	f	class:vcg::Segment2
operator +	vcglib/vcg/space/segment3.h	/^	inline SegmentType operator + ( SegmentType const & p) const$/;"	f	class:vcg::Segment3
operator ++	vcglib/apps/pivoting/ring.h	/^    iterator operator++(int) {$/;"	f	class:ring::iterator
operator ++	vcglib/apps/pivoting/ring.h	/^    iterator& operator++() {$/;"	f	class:ring::iterator
operator ++	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Iterator& operator++()$/;"	f	class:Eigen::internal::AmbiVector::Iterator
operator ++	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++() { m_inner++; return *this; }$/;"	f	class:Eigen::DenseBase::InnerIterator
operator ++	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
operator ++	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Derived& operator++()$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
operator ++	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator
operator ++	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator
operator ++	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
operator ++	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
operator ++	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseVector::InnerIterator
operator ++	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseView::InnerIterator
operator ++	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void operator ++() { (*this)++; }$/;"	f	class:Eigen::IterationController
operator ++	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void operator ++(int) { m_nit++; m_written = false; m_resadd += m_res; }$/;"	f	class:Eigen::IterationController
operator ++	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline InnerLowerIterator & operator++() {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
operator ++	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline InnerUpperIterator & operator++() {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
operator ++	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline MatrixMarketIterator& operator++()$/;"	f	class:Eigen::MatrixMarketIterator
operator ++	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal mpreal::operator++ (int)$/;"	f	class:mpfr::mpreal
operator ++	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator++() $/;"	f	class:mpfr::mpreal
operator ++	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  void operator ++ () {$/;"	f	class:vcg::tri::BitQuad::Iterator
operator ++	vcglib/vcg/complex/algorithms/clean.h	/^  void operator ++()$/;"	f	class:vcg::tri::ConnectedComponentIterator
operator ++	vcglib/vcg/simplex/edge/pos.h	/^  VFIEdgeType *operator++() {$/;"	f	class:vcg::edge::VEIterator
operator ++	vcglib/vcg/simplex/face/pos.h	/^  void operator++() {$/;"	f	class:vcg::face::VFIterator
operator ++	vcglib/vcg/simplex/tetrahedron/pos.h	/^void operator++() $/;"	f	class:vcg::tetra::VTIterator
operator ++	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^            void operator ++() {t++;}$/;"	f	struct:vcg::SpatialHashTable2D::CellIterator
operator ++	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				void operator++(int)$/;"	f	struct:vcg::PerfectSpatialHashing::UniformGrid::EntryIterator
operator ++	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			void operator++(int)$/;"	f	struct:vcg::PerfectSpatialHashing::NeighboringEntryIterator
operator ++	vcglib/vcg/space/index/space_iterators.h	/^		void operator ++()$/;"	f	class:vcg::ClosestIterator
operator ++	vcglib/vcg/space/index/space_iterators.h	/^		void operator ++()$/;"	f	class:vcg::RayIterator
operator ++	vcglib/vcg/space/index/spatial_hashing.h	/^		void operator ++() {t++;}$/;"	f	struct:vcg::SpatialHashTable::CellIterator
operator +=	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    Derived& operator+=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase
operator +=	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator+=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase
operator +=	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator+=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator +=	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator+=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator +=	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator +=	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator+=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase
operator +=	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias
operator +=	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias
operator +=	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator +=	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView
operator +=	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView
operator +=	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator+=(const DenseBase<Other>& other) { return *this = m_matrix + other.derived(); }$/;"	f	class:Eigen::TriangularView
operator +=	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator+=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator +=	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator+=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise
operator +=	vcglib/eigenlib/Eigen/src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator+=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase
operator +=	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator+=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator +=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator+=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator +=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator+=(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
operator +=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  inline AutoDiffScalar<_DerType>& operator+=(const Real& other)$/;"	f	struct:Eigen::internal::auto_diff_special_op
operator +=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator+=(const AutoDiffVector<OtherValueType,OtherJacobianType>& other)$/;"	f	class:Eigen::AutoDiffVector
operator +=	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline InnerLowerIterator & operator+=(Index shift) {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
operator +=	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline InnerUpperIterator & operator+=(Index shift) {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+= (const double u)$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+= (const long double u)$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const int u)$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const int64_t  u){	*this += mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;	}$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const long int u)$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpf_t u)$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpq_t u)$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const mpz_t u)$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const uint64_t u){	*this += mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;	}$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned int u)$/;"	f	class:mpfr::mpreal
operator +=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator+=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
operator +=	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED Derived& operator+=(const Scalar k)$/;"	f
operator +=	vcglib/vcg/math/matrix33.h	/^    Matrix33 & operator += ( const Matrix33  &m )$/;"	f	class:vcg::Matrix33
operator +=	vcglib/vcg/math/matrix44.h	/^template <class T> void Matrix44<T>::operator+=(const Matrix44 &m) {$/;"	f	class:vcg::Matrix44
operator +=	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE>& operator+=(const Matrix<TYPE> &m)$/;"	f	class:vcg::ndim::Matrix
operator +=	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE>& operator+=(const TYPE k)$/;"	f	class:vcg::ndim::Matrix
operator +=	vcglib/vcg/math/quadric.h	/^  void operator += ( const Quadric & q )			\/\/ Somma una quadrica$/;"	f	class:vcg::math::Quadric
operator +=	vcglib/vcg/math/quadric5.h	/^	void operator += ( const Quadric5<double> & q )			$/;"	f	class:vcg::Quadric5
operator +=	vcglib/vcg/space/box.h	/^	inline Box & operator += ( Box const & p)$/;"	f	class:vcg::Box
operator +=	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 & operator += ( Point2 const & p ) {$/;"	f	class:vcg::ndim::Point2
operator +=	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 & operator += ( Point3 const & p ) {$/;"	f	class:vcg::ndim::Point3
operator +=	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 & operator += ( Point4 const & p ) {$/;"	f	class:vcg::ndim::Point4
operator +=	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & operator += ( PointType const & p)$/;"	f	class:vcg::ndim::Point
operator +=	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 & operator += ( Point2 const & p)$/;"	f	class:vcg::Point2
operator +=	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 & operator += ( Point3 const & p)$/;"	f	class:vcg::Point3
operator +=	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 & operator += ( const Point4 & p)$/;"	f	class:vcg::Point4
operator ,	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer
operator ,	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer
operator -	vcglib/apps/pivoting/ring.h	/^    iterator operator-(int i) {$/;"	f	class:ring::iterator
operator -	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    operator-(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator -	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator-(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise
operator -	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator-(const Scalar& scalar) const$/;"	f
operator -	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator-(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)$/;"	f
operator -	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator-() const { return derived(); }$/;"	f
operator -	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline const AutoDiffScalar<DerType&> operator-(const Scalar& b) const$/;"	f	class:Eigen::AutoDiffScalar
operator -	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator-() const$/;"	f	class:Eigen::AutoDiffScalar
operator -	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator-(const AutoDiffScalar<OtherDerType>& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator -	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator-(const Scalar& a, const AutoDiffScalar& b)$/;"	f	class:Eigen::AutoDiffScalar
operator -	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator-() const$/;"	f	class:Eigen::AutoDiffVector
operator -	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator-(const AutoDiffVector<OtherValueType,OtherJacobianType>& other) const$/;"	f	class:Eigen::AutoDiffVector
operator -	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^vector<T> operator-(const vector<T> & a,const vector<T> & b )$/;"	f
operator -	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	operator-(const Lhs& lhs, const mpreal& rhs){ return mpreal(lhs) -= rhs;	}$/;"	f	namespace:mpfr
operator -	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	operator-(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) -= rhs;	}$/;"	f	namespace:mpfr
operator -	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal mpreal::operator-()const$/;"	f	class:mpfr::mpreal
operator -	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const double  b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const int b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator -	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const unsigned int b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator-(const unsigned long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator -	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED const ScalarAddReturnType operator-(const Scalar k) { return cwise() - k; }$/;"	f
operator -	vcglib/vcg/math/matrix33.h	/^    Matrix33  operator - ( const Matrix33 &m ) const$/;"	f	class:vcg::Matrix33
operator -	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> Matrix44<T>::operator-() const {$/;"	f	class:vcg::Matrix44
operator -	vcglib/vcg/math/matrix44.h	/^template <class T> Matrix44<T> Matrix44<T>::operator-(const Matrix44 &m) const {$/;"	f	class:vcg::Matrix44
operator -	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE> operator-() const$/;"	f	class:vcg::ndim::Matrix
operator -	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE> operator-(const TYPE k)$/;"	f	class:vcg::ndim::Matrix
operator -	vcglib/vcg/space/box.h	/^	inline Box operator - ( Box const & p) const$/;"	f	class:vcg::Box
operator -	vcglib/vcg/space/box.h	/^	inline Box operator - () const$/;"	f	class:vcg::Box
operator -	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 operator - ( Point2 const & p) const {$/;"	f	class:vcg::ndim::Point2
operator -	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 operator - () const {$/;"	f	class:vcg::ndim::Point2
operator -	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 operator - ( Point3 const & p) const {$/;"	f	class:vcg::ndim::Point3
operator -	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 operator - () const {$/;"	f	class:vcg::ndim::Point3
operator -	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 operator - ( Point4 const & p) const {$/;"	f	class:vcg::ndim::Point4
operator -	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 operator - () const {$/;"	f	class:vcg::ndim::Point4
operator -	vcglib/vcg/space/deprecated_point.h	/^	inline PointType operator - ( PointType const & p) const$/;"	f	class:vcg::ndim::Point
operator -	vcglib/vcg/space/deprecated_point.h	/^	inline PointType operator - () const$/;"	f	class:vcg::ndim::Point
operator -	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 operator - ( Point2 const & p) const$/;"	f	class:vcg::Point2
operator -	vcglib/vcg/space/deprecated_point2.h	/^inline Point2<T> operator - ( Point2<T> const & p ){$/;"	f	namespace:vcg
operator -	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 operator - ( Point3 const & p) const$/;"	f	class:vcg::Point3
operator -	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 operator - () const$/;"	f	class:vcg::Point3
operator -	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 operator - ( const Point4 & p) const$/;"	f	class:vcg::Point4
operator -	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 operator - () const$/;"	f	class:vcg::Point4
operator -	vcglib/vcg/space/line2.h	/^	inline Line2<ScalarType,false> operator - ( LineType const & p) const$/;"	f	class:vcg::Line2
operator -	vcglib/vcg/space/line3.h	/^	inline Line3<ScalarType,false> operator - ( LineType const & p) const$/;"	f	class:vcg::Line3
operator -	vcglib/vcg/space/ray2.h	/^	inline Ray2<ScalarType,false> operator - ( RayType const & p) const$/;"	f	class:vcg::Ray2
operator -	vcglib/vcg/space/ray3.h	/^	inline Ray3<ScalarType,false> operator - ( RayType const & p) const$/;"	f	class:vcg::Ray3
operator -	vcglib/vcg/space/segment2.h	/^	inline SegmentType operator - ( SegmentType const & p) const$/;"	f	class:vcg::Segment2
operator -	vcglib/vcg/space/segment3.h	/^	inline SegmentType operator - ( SegmentType const & p) const$/;"	f	class:vcg::Segment3
operator --	vcglib/apps/pivoting/ring.h	/^    iterator operator--(int) {$/;"	f	class:ring::iterator
operator --	vcglib/apps/pivoting/ring.h	/^    iterator& operator--() {$/;"	f	class:ring::iterator
operator --	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
operator --	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
operator --	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
operator --	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { --m_id; return *this; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
operator --	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator--()$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator
operator --	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
operator --	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal mpreal::operator-- (int)$/;"	f	class:mpfr::mpreal
operator --	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator--() $/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    Derived& operator-=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase
operator -=	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator-=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase
operator -=	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator-=(const ArrayBase<OtherDerived> &other)$/;"	f	class:Eigen::ArrayBase
operator -=	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator-=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
operator -=	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator -=	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator-=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase
operator -=	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias
operator -=	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias
operator -=	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator -=	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView
operator -=	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView
operator -=	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator-=(const DenseBase<Other>& other) { return *this = m_matrix - other.derived(); }$/;"	f	class:Eigen::TriangularView
operator -=	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator-=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator -=	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator-=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise
operator -=	vcglib/eigenlib/Eigen/src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator-=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase
operator -=	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator-=(const SparseMatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator -=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator-=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator -=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator-=(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
operator -=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    operator-=(const AutoDiffVector<OtherValueType,OtherJacobianType>& other)$/;"	f	class:Eigen::AutoDiffVector
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-= (const mpreal& v)$/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const double v)$/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const int v)$/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const int64_t  u){	*this -= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;	}$/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const long double v)$/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const long int v)$/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const uint64_t u){	*this -= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;	}$/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned int v)$/;"	f	class:mpfr::mpreal
operator -=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator-=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
operator -=	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED Derived& operator-=(const Scalar k)$/;"	f
operator -=	vcglib/vcg/math/matrix33.h	/^    Matrix33 & operator -= ( const Matrix33 &m )$/;"	f	class:vcg::Matrix33
operator -=	vcglib/vcg/math/matrix44.h	/^template <class T> void Matrix44<T>::operator-=(const Matrix44 &m) {$/;"	f	class:vcg::Matrix44
operator -=	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE>& operator-=(const Matrix<TYPE> &m)$/;"	f	class:vcg::ndim::Matrix
operator -=	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE>& operator-=(const TYPE k)$/;"	f	class:vcg::ndim::Matrix
operator -=	vcglib/vcg/space/box.h	/^	inline Box & operator -= ( Box const & p)$/;"	f	class:vcg::Box
operator -=	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 & operator -= ( Point2 const & p ) {$/;"	f	class:vcg::ndim::Point2
operator -=	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 & operator -= ( Point3 const & p ) {$/;"	f	class:vcg::ndim::Point3
operator -=	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 & operator -= ( Point4 const & p ) {$/;"	f	class:vcg::ndim::Point4
operator -=	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & operator -= ( PointType const & p)$/;"	f	class:vcg::ndim::Point
operator -=	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 & operator -= ( Point2 const & p)$/;"	f	class:vcg::Point2
operator -=	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 & operator -= ( Point3 const & p)$/;"	f	class:vcg::Point3
operator -=	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 & operator -= ( const Point4 & p )$/;"	f	class:vcg::Point4
operator ->	vcglib/wrap/glw/bookkeeping.h	/^		ObjectType * operator -> (void)$/;"	f	class:glw::detail::ObjectSharedPointer
operator ->	vcglib/wrap/glw/bookkeeping.h	/^		const ObjectType * operator -> (void) const$/;"	f	class:glw::detail::ObjectSharedPointer
operator /	vcglib/eigenlib/Eigen/src/Core/GlobalFunctions.h	/^    operator\/(typename Derived::Scalar s, const Eigen::ArrayBase<Derived>& a)$/;"	f	namespace:Eigen
operator /	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    operator\/(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator /	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator\/(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator /	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator\/(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator /	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator\/(const Scalar& scalar) const$/;"	f
operator /	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator\/(const AutoDiffScalar<OtherDerType>& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator /	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator\/(const Scalar& other) const$/;"	f	class:Eigen::AutoDiffScalar
operator /	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    operator\/(const Scalar& other, const AutoDiffScalar& a)$/;"	f	class:Eigen::AutoDiffScalar
operator /	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	operator\/(const Lhs& lhs, const mpreal& rhs){ return mpreal(lhs) \/= rhs;	}$/;"	f	namespace:mpfr
operator /	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	operator\/(const mpreal& lhs, const Rhs& rhs){ return mpreal(lhs) \/= rhs;	}$/;"	f	namespace:mpfr
operator /	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const double  b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const mpreal& a, const mpreal& b)$/;"	f	namespace:mpfr
operator /	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const unsigned int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator\/(const unsigned long int b, const mpreal& a)$/;"	f	namespace:mpfr
operator /	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE> operator\/(const TYPE k)$/;"	f	class:vcg::ndim::Matrix
operator /	vcglib/vcg/space/box.h	/^	inline Box operator \/ ( const S s ) const$/;"	f	class:vcg::Box
operator /	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 operator \/ ( const S s ) const {$/;"	f	class:vcg::ndim::Point2
operator /	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 operator \/ ( const S s ) const {$/;"	f	class:vcg::ndim::Point3
operator /	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 operator \/ ( const S s ) const {$/;"	f	class:vcg::ndim::Point4
operator /	vcglib/vcg/space/deprecated_point.h	/^	inline PointType operator \/ ( const S s ) const$/;"	f	class:vcg::ndim::Point
operator /	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 operator \/ ( const ScalarType s ) const$/;"	f	class:vcg::Point2
operator /	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 operator \/ ( const P3ScalarType s ) const$/;"	f	class:vcg::Point3
operator /	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 operator \/ ( const T s ) const$/;"	f	class:vcg::Point4
operator /	vcglib/vcg/space/line2.h	/^	inline Line2<ScalarType,false> operator \/ ( const ScalarType s ) const$/;"	f	class:vcg::Line2
operator /	vcglib/vcg/space/line3.h	/^	inline Line3<ScalarType,false> operator \/ ( const ScalarType s ) const$/;"	f	class:vcg::Line3
operator /	vcglib/vcg/space/ray2.h	/^	inline Ray2<ScalarType,false> operator \/ ( const ScalarType s ) const$/;"	f	class:vcg::Ray2
operator /	vcglib/vcg/space/ray3.h	/^	inline Ray3<ScalarType,false> operator \/ ( const ScalarType s ) const$/;"	f	class:vcg::Ray3
operator /	vcglib/vcg/space/segment2.h	/^	inline SegmentType operator \/ ( const ScalarType s ) const$/;"	f	class:vcg::Segment2
operator /	vcglib/vcg/space/segment3.h	/^	inline SegmentType operator \/ ( const ScalarType s ) const$/;"	f	class:vcg::Segment3
operator /=	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator\/=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator /=	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::DenseBase
operator /=	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView&  operator\/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix \/ other; }$/;"	f	class:Eigen::TriangularView
operator /=	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator\/=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator /=	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator\/=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise
operator /=	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase
operator /=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator\/=(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
operator /=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator\/=(const Scalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const double v)$/;"	f	class:mpfr::mpreal
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const int v)$/;"	f	class:mpfr::mpreal
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const int64_t  u){	*this \/= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;	}$/;"	f	class:mpfr::mpreal
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long double v)$/;"	f	class:mpfr::mpreal
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const long int v)$/;"	f	class:mpfr::mpreal
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const uint64_t u){	*this \/= mpreal(u); MPREAL_MSVC_DEBUGVIEW_CODE; return *this;	}$/;"	f	class:mpfr::mpreal
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned int v)$/;"	f	class:mpfr::mpreal
operator /=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator\/=(const unsigned long int v)$/;"	f	class:mpfr::mpreal
operator /=	vcglib/vcg/math/matrix33.h	/^    Matrix33 & operator \/= ( const S &s )$/;"	f	class:vcg::Matrix33
operator /=	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE>& operator\/=(const TYPE k)$/;"	f	class:vcg::ndim::Matrix
operator /=	vcglib/vcg/space/box.h	/^	inline Box & operator \/= ( const S s )$/;"	f	class:vcg::Box
operator /=	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 & operator \/= ( const S s ) {$/;"	f	class:vcg::ndim::Point2
operator /=	vcglib/vcg/space/deprecated_point.h	/^	inline Point3 & operator \/= ( const S s ) {$/;"	f	class:vcg::ndim::Point3
operator /=	vcglib/vcg/space/deprecated_point.h	/^	inline Point4 & operator \/= ( const S s ) {$/;"	f	class:vcg::ndim::Point4
operator /=	vcglib/vcg/space/deprecated_point.h	/^	inline PointType & operator \/= ( const S s )$/;"	f	class:vcg::ndim::Point
operator /=	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 & operator \/= ( const ScalarType s )$/;"	f	class:vcg::Point2
operator /=	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 & operator \/= ( const P3ScalarType s )$/;"	f	class:vcg::Point3
operator /=	vcglib/vcg/space/deprecated_point4.h	/^    inline Point4 & operator \/= ( const T s )$/;"	f	class:vcg::Point4
operator <	vcglib/apps/pivoting/cmesh.h	/^   bool operator<(const CEdge& t) const {$/;"	f	class:CEdge
operator <	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(Scalar s) const$/;"	f	class:Eigen::Cwise
operator <	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator <	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator< (const Scalar& a, const AutoDiffScalar& b) { return a <  b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator <	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator< (const Scalar& other) const  { return m_value <  other; }$/;"	f	class:Eigen::AutoDiffScalar
operator <	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator< (const AutoDiffScalar<OtherDerType>& b) const  { return m_value <  b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator <	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator <  (const mpreal& a, const mpreal& b){	return (mpfr_less_p(a.mp,b.mp)			!=0);	}$/;"	f	namespace:mpfr
operator <	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    const bool operator < (const   Couple & o) const {return dist < o.dist;}$/;"	f	struct:vcg::tri::FourPCS::Couple
operator <	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    inline bool operator <(const Candidate & o) const {return score > o.score;}$/;"	f	struct:vcg::tri::FourPCS::Candidate
operator <	vcglib/vcg/complex/algorithms/clean.h	/^                      bool operator < (const SortedPair &p) const$/;"	f	class:vcg::tri::Clean::SortedPair
operator <	vcglib/vcg/complex/algorithms/clean.h	/^                bool operator < (const SortedTriple &p) const$/;"	f	class:vcg::tri::Clean::SortedTriple
operator <	vcglib/vcg/complex/algorithms/clustering.h	/^    bool operator < ( const SimpleTri &p) const {$/;"	f	class:vcg::tri::Clustering::SimpleTri
operator <	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^        bool operator < (const Signature & b) const {$/;"	f	struct:vcg::tri::Zonohedron::Signature
operator <	vcglib/vcg/complex/algorithms/geodesic.h	/^      bool operator < (const FaceDist &o) const$/;"	f	struct:vcg::tri::Geodesic::FaceDist
operator <	vcglib/vcg/complex/algorithms/geodesic.h	/^    bool operator < (const DIJKDist &o) const$/;"	f	struct:vcg::tri::Geodesic::DIJKDist
operator <	vcglib/vcg/complex/algorithms/hole.h	/^            bool operator <  (const  Info & hh) const {return size <  hh.size;}$/;"	f	class:vcg::tri::Hole::Info
operator <	vcglib/vcg/complex/algorithms/hole.h	/^            bool operator<( const Weight & rhs ) const {return ( angle() < rhs.angle() ||(angle() == rhs.angle() && area() < rhs.area()));	}$/;"	f	class:vcg::tri::Hole::Weight
operator <	vcglib/vcg/complex/algorithms/hole.h	/^          bool operator < (const EdgeToBeAvoided &e)$/;"	f	class:vcg::tri::Hole::EdgeToBeAvoided
operator <	vcglib/vcg/complex/algorithms/hole.h	/^  virtual inline bool operator <  ( const MinimumWeightEar & c ) const$/;"	f	class:vcg::tri::MinimumWeightEar
operator <	vcglib/vcg/complex/algorithms/hole.h	/^  virtual inline bool operator < ( const TrivialEar & c ) const { return quality <  c.quality; }$/;"	f	class:vcg::tri::TrivialEar
operator <	vcglib/vcg/complex/algorithms/local_optimization.h	/^    inline bool operator <(const HeapElem & h) const$/;"	f	struct:vcg::LocalOptimization::HeapElem
operator <	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    bool operator< (const WArc &a) const {return w<a.w;}$/;"	f	class:vcg::tri::PointCloudNormal::WArc
operator <	vcglib/vcg/complex/algorithms/update/flag.h	/^    inline bool operator <  ( const EdgeSorter & pe ) const {$/;"	f	class:vcg::tri::UpdateFlags::EdgeSorter
operator <	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                bool operator <(const VertexPairEdgePtr &o) const {return (v0 == o.v0)? (v1<o.v1):(v0<o.v0);}$/;"	f	struct:vcg::tri::UpdateHalfEdges::VertexPairEdgePtr
operator <	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                bool operator <(const VertexPairEdgePtr &o) const {return (v0 == o.v0)? (v1<o.v1):(v0<o.v0);}$/;"	f	struct:vcg::tri::UpdateIndexed::VertexPairEdgePtr
operator <	vcglib/vcg/complex/algorithms/update/topology.h	/^  inline bool operator <  ( const PEdge & pe ) const$/;"	f	class:vcg::tri::UpdateTopology::PEdge
operator <	vcglib/vcg/complex/algorithms/update/topology.h	/^  inline bool operator <  ( const PEdgeTex & pe ) const$/;"	f	class:vcg::tri::UpdateTopology::PEdgeTex
operator <	vcglib/vcg/complex/algorithms/update/topology.h	/^inline bool operator  <  ( const PVertexEdge & pe ) const { return ( v<pe.v ); }$/;"	f	class:vcg::tri::UpdateTopology::PVertexEdge
operator <	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  bool operator < (const VoronoiEdge &ve) const { return (ve.r0==r0)?ve.r1<r1:ve.r0<r0; }$/;"	f	class:vcg::tri::VoronoiProcessing::VoronoiEdge
operator <	vcglib/vcg/complex/base.h	/^    bool operator<(const  PointerToAttribute    b) const {	return(_name.empty()&&b._name.empty())?(_handle < b._handle):( _name < b._name);}$/;"	f	class:vcg::PointerToAttribute
operator <	vcglib/vcg/container/entries_allocation_table.h	/^const bool EntryCATBase<STL_CONT>:: operator < (const EntryCATBase<STL_CONT> & other) const{$/;"	f	class:vcg::EntryCATBase
operator <	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline bool operator <  (const MatrixBase<OtherDerived>& other) const {$/;"	f
operator <	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator <  ( Point2 const & p ) const{$/;"	f	class:vcg::ndim::Point2
operator <	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator <  ( PointType const & p ) const{$/;"	f	class:vcg::ndim::Point3
operator <	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator <  ( PointType const & p ) const{$/;"	f	class:vcg::ndim::Point4
operator <	vcglib/vcg/space/deprecated_point2.h	/^	inline bool operator <  ( Point2 const & p ) const$/;"	f	class:vcg::Point2
operator <	vcglib/vcg/space/deprecated_point3.h	/^    inline bool operator <  ( Point3 const & p ) const$/;"	f	class:vcg::Point3
operator <	vcglib/vcg/space/deprecated_point4.h	/^    inline bool operator <  ( Point4 const & p ) const$/;"	f	class:vcg::Point4
operator <	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline bool operator <  ( const Link & l ) const{ return i <   l.i; } $/;"	f	class:vcg::GridStaticPtr::Link
operator <	vcglib/vcg/space/index/octree.h	/^            inline bool operator<(const Neighbour &n) const$/;"	f	struct:vcg::Octree::Neighbour
operator <	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				inline bool operator<(const PreImage &second) const { return (cardinality>second.cardinality); }$/;"	f	struct:vcg::PerfectSpatialHashing::OffsetTable::PreImage
operator <	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 inline bool operator<(const Neighbor &second)$/;"	f	struct:vcg::PerfectSpatialHashing::Neighbor
operator <	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline bool operator <(const int value) { return m_CurrentIteration<value; }$/;"	f	struct:vcg::PerfectSpatialHashing::NeighboringEntryIterator
operator <	vcglib/vcg/space/index/space_iterators.h	/^			inline bool operator <  ( const Entry_Type & l ) const{return (dist > l.dist); }$/;"	f	struct:vcg::ClosestIterator::Entry_Type
operator <	vcglib/vcg/space/index/space_iterators.h	/^			inline bool operator <  ( const Entry_Type & l ) const{return (dist > l.dist); }$/;"	f	struct:vcg::RayIterator::Entry_Type
operator <	vcglib/vcg/space/texcoord2.h	/^    inline bool operator < ( TexCoord2 const & p ) const$/;"	f	class:vcg::TexCoord2
operator <	vcglib/wrap/gcache/dheap.h	/^    bool operator<(const Item &i) const { return *value < *i.value; }$/;"	f	class:PtrDHeap::Item
operator <	vcglib/wrap/gcache/token.h	/^    bool operator<(const Token &a) const {$/;"	f	class:vcg::Token
operator <	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline bool operator<(int value) const$/;"	f	class:mt::atomicInt
operator <	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline bool operator<(int value) const$/;"	f	class:mt::atomicInt
operator <<	vcglib/apps/test/quaternion/quat_test.cpp	/^ostream &operator<<(ostream &o, Matrix33f &m) {$/;"	f
operator <<	vcglib/apps/test/quaternion/quat_test.cpp	/^ostream &operator<<(ostream &o, Matrix44f &m) {$/;"	f
operator <<	vcglib/apps/test/quaternion/quat_test.cpp	/^ostream &operator<<(ostream &o, Point3f &q) {$/;"	f
operator <<	vcglib/apps/test/quaternion/quat_test.cpp	/^ostream &operator<<(ostream &o, Quaternionf &q) {$/;"	f
operator <<	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator <<	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)$/;"	f	class:Eigen::DenseBase
operator <<	vcglib/eigenlib/Eigen/src/Core/IO.h	/^    friend std::ostream & operator << (std::ostream & s, const WithFormat& wf)$/;"	f	class:Eigen::WithFormat
operator <<	vcglib/eigenlib/Eigen/src/Core/IO.h	/^std::ostream & operator <<$/;"	f	namespace:Eigen
operator <<	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrix& m)$/;"	f	class:Eigen::SparseMatrix
operator <<	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrixBase& m)$/;"	f	class:Eigen::SparseMatrixBase
operator <<	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseVector& m)$/;"	f	class:Eigen::SparseVector
operator <<	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend  std::ostream & operator << (std::ostream & s, const AutoDiffScalar& a)$/;"	f	class:Eigen::AutoDiffScalar
operator <<	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    friend std::ostream & operator <<(std::ostream & s, const SkylineMatrix & m) {$/;"	f	class:Eigen::SkylineMatrix
operator <<	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    friend std::ostream & operator <<(std::ostream & s, const SkylineMatrixBase& m) {$/;"	f	class:Eigen::SkylineMatrixBase
operator <<	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^ostream& operator<<(ostream& os, const mpreal& v)$/;"	f	namespace:mpfr
operator <<	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const int k)$/;"	f	namespace:mpfr
operator <<	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const long int k)$/;"	f	namespace:mpfr
operator <<	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const unsigned int k)$/;"	f	namespace:mpfr
operator <<	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator<<(const mpreal& v, const unsigned long int k)$/;"	f	namespace:mpfr
operator <<=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator<<=(const int u)$/;"	f	class:mpfr::mpreal
operator <<=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator<<=(const long int u)$/;"	f	class:mpfr::mpreal
operator <<=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator<<=(const unsigned int u)$/;"	f	class:mpfr::mpreal
operator <<=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator<<=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
operator <=	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(Scalar s) const$/;"	f	class:Eigen::Cwise
operator <=	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator <=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator<=(const Scalar& a, const AutoDiffScalar& b) { return a <= b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator <=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator<=(const Scalar& other) const  { return m_value <= other; }$/;"	f	class:Eigen::AutoDiffScalar
operator <=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator<=(const AutoDiffScalar<OtherDerType>& b) const  { return m_value <= b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator <=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator <= (const mpreal& a, const mpreal& b){	return (mpfr_lessequal_p(a.mp,b.mp)		!=0);	}$/;"	f	namespace:mpfr
operator <=	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline bool operator <=  (const MatrixBase<OtherDerived>& other) const {$/;"	f
operator <=	vcglib/vcg/simplex/edge/pos.h	/^	inline bool operator <= ( POSTYPE const & p) const {$/;"	f	class:vcg::edge::Pos
operator <=	vcglib/vcg/simplex/face/pos.h	/^	inline bool operator <= ( PosType const & p) const {$/;"	f	class:vcg::face::Pos
operator <=	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator <= ( Point2 const & p ) {$/;"	f	class:vcg::ndim::Point2
operator <=	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator <= ( PointType const & p ) {$/;"	f	class:vcg::ndim::Point3
operator <=	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator <= ( PointType const & p ) {$/;"	f	class:vcg::ndim::Point4
operator <=	vcglib/vcg/space/deprecated_point2.h	/^	inline bool operator <= ( Point2 const & p ) const$/;"	f	class:vcg::Point2
operator <=	vcglib/vcg/space/deprecated_point3.h	/^    inline bool operator <= ( Point3 const & p ) const$/;"	f	class:vcg::Point3
operator <=	vcglib/vcg/space/deprecated_point4.h	/^    inline bool operator <= ( const Point4 & p ) const$/;"	f	class:vcg::Point4
operator <=	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline bool operator <= ( const Link & l ) const{ return i <=  l.i; }$/;"	f	class:vcg::GridStaticPtr::Link
operator =	vcglib/apps/pivoting/ring.h	/^    iterator &operator=(const iterator& x) {$/;"	f	class:ring::iterator
operator =	vcglib/apps/pivoting/ring.h	/^  ring &operator=(const ring *r) {$/;"	f	class:ring
operator =	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	ImplicitSphere& operator=(const ImplicitSphere &sphere)$/;"	f	class:ImplicitSphere
operator =	vcglib/apps/unsupported/extractors/extractor/SphereUnion.h	/^	SphereUnion& operator=(const SphereUnion &sphere_union)$/;"	f	class:SphereUnion
operator =	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const Array& other)$/;"	f	class:Eigen::Array
operator =	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array
operator =	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array
operator =	vcglib/eigenlib/Eigen/src/Core/ArrayBase.h	/^    Derived& operator=(const ArrayBase& other)$/;"	f	class:Eigen::ArrayBase
operator =	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase& other)$/;"	f	class:Eigen::DenseBase
operator =	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator =	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const MatrixBase& other)$/;"	f	class:Eigen::MatrixBase
operator =	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::DiagonalMatrix
operator =	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalMatrix& other)$/;"	f	class:Eigen::DiagonalMatrix
operator =	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator =	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    Derived& operator=(const MapBase& other)$/;"	f	class:Eigen::MapBase
operator =	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix
operator =	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)$/;"	f	class:Eigen::Matrix
operator =	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix
operator =	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::Matrix
operator =	vcglib/eigenlib/Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator =	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase& other)$/;"	f	class:Eigen::PermutationBase
operator =	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase
operator =	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& tr)$/;"	f	class:Eigen::PermutationBase
operator =	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map
operator =	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::Map
operator =	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::Map
operator =	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::PermutationMatrix
operator =	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationMatrix& other)$/;"	f	class:Eigen::PermutationMatrix
operator =	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix
operator =	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
operator =	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase
operator =	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::PlainObjectBase
operator =	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^      Unusable& operator=(const Unusable&) {return *this;}$/;"	f	class:Eigen::ReturnByValue::Unusable
operator =	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator =	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfAdjointView
operator =	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const TriangularView<OtherMatrixType, OtherMode>& other)$/;"	f	class:Eigen::SelfAdjointView
operator =	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    SelfCwiseBinaryOp& operator=(const Rhs& _rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp
operator =	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase& other)$/;"	f	class:Eigen::TranspositionsBase
operator =	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsBase
operator =	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map
operator =	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    Map& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Map
operator =	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const Transpositions& other)$/;"	f	class:Eigen::Transpositions
operator =	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions
operator =	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsWrapper
operator =	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsWrapper& other)$/;"	f	class:Eigen::TranspositionsWrapper
operator =	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView
operator =	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView
operator =	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularView& other)$/;"	f	class:Eigen::TriangularView
operator =	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView
operator =	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView
operator =	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionType& q)$/;"	f	class:Eigen::AngleAxis
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::Quaternion
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const MatrixBase<Derived>& xpr)$/;"	f	class:Eigen::Quaternion
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const Quaternion& other)$/;"	f	class:Eigen::Quaternion
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling& operator=(const Scaling& other)$/;"	f	class:Eigen::Scaling
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const ScalingType& s)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation
operator =	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis
operator =	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionBase<QuatDerived>& q)$/;"	f	class:Eigen::AngleAxis
operator =	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::QuaternionBase
operator =	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase
operator =	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE QuaternionBase<Derived>& QuaternionBase<Derived>::operator=(const QuaternionBase<Derived>& other)$/;"	f	class:Eigen::QuaternionBase
operator =	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::operator=(const MatrixBase<MatrixDerived>& xpr)$/;"	f	class:Eigen::QuaternionBase
operator =	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
operator =	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  Transform& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform
operator =	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation
operator =	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage& operator=(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet& operator=(const SparseInnerVectorSet& other)$/;"	f	class:Eigen::SparseInnerVectorSet
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    inline SparseInnerVectorSet& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseInnerVectorSet
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_DONT_INLINE SparseMatrix& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrix
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const Derived& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^inline Derived& SparseMatrixBase<Derived>::operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrixBase
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView& src)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView<SrcMatrixType,SrcUpLo>& src)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcUpLo>& permutedMatrix)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseVector
operator =	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseVector& other)$/;"	f	class:Eigen::SparseVector
operator =	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    inline T& operator=(const OtherT& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator =	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support& operator=(const workaround_msvc_stl_support& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator =	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix& operator=(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix
operator =	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator=(const AutoDiffScalar& other)$/;"	f	class:Eigen::AutoDiffScalar
operator =	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline AutoDiffScalar& operator=(const AutoDiffScalar<OtherDerType>& other)$/;"	f	class:Eigen::AutoDiffScalar
operator =	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector& operator=(const AutoDiffVector& other)$/;"	f	class:Eigen::AutoDiffVector
operator =	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline AutoDiffVector& operator=(const AutoDiffVector<OtherValueType, OtherJacobianType>& other)$/;"	f	class:Eigen::AutoDiffVector
operator =	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  minimizer_helper1& operator=(const minimizer_helper1&) {}$/;"	f	struct:Eigen::internal::minimizer_helper1
operator =	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^            inline SkylineMatrix & operator=(const SkylineMatrixBase<OtherDerived>& other) {$/;"	f	class:Eigen::SkylineMatrix
operator =	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline SkylineMatrix & operator=(const SkylineMatrix & other) {$/;"	f	class:Eigen::SkylineMatrix
operator =	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^            inline Derived & operator=(const SkylineMatrixBase<OtherDerived>& other) {$/;"	f	class:Eigen::SkylineMatrixBase
operator =	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Derived & operator=(const Derived& other) {$/;"	f	class:Eigen::SkylineMatrixBase
operator =	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    SkylineStorage & operator=(const SkylineStorage& other) {$/;"	f	class:Eigen::SkylineStorage
operator =	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    inline SparseInnerVectorSet& operator=(const SparseInnerVectorSet& other)$/;"	f	class:Eigen::SparseInnerVectorSet
operator =	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    inline SparseInnerVectorSet& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseInnerVectorSet
operator =	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline DynamicSparseMatrix& operator=(const DynamicSparseMatrix& other)$/;"	f	class:Eigen::DynamicSparseMatrix
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal& mpreal::operator=(const char* s)$/;"	f	class:mpfr::mpreal
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const double v)				$/;"	f	class:mpfr::mpreal
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const int v)$/;"	f	class:mpfr::mpreal
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const long double v)		$/;"	f	class:mpfr::mpreal
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const long int v)			$/;"	f	class:mpfr::mpreal
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const mpf_t v)$/;"	f	class:mpfr::mpreal
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const mpq_t v)$/;"	f	class:mpfr::mpreal
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const mpreal& v)$/;"	f	class:mpfr::mpreal
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const mpz_t v)$/;"	f	class:mpfr::mpreal
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const unsigned int v)		$/;"	f	class:mpfr::mpreal
operator =	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator=(const unsigned long int v)	$/;"	f	class:mpfr::mpreal
operator =	vcglib/img/img_attributes.h	/^  inline ImgAttributes< ScalarType> & operator =(const ImgAttributes<OtherScalarType> &attributes)$/;"	f	class:img::ImgAttributes
operator =	vcglib/img/img_image.h	/^  inline Image< Channels,ScalarType,Safe> & operator =(const Image<Channels,OtherScalarType,OtherSafe> &image)$/;"	f	class:img::Image
operator =	vcglib/vcg/complex/base.h	/^                AttributeHandle operator = ( const PointerToAttribute & pva){$/;"	f	class:vcg::tri::TriMesh::AttributeHandle
operator =	vcglib/vcg/complex/base.h	/^        PerMeshAttributeHandle operator = ( const PerMeshAttributeHandle & pva){$/;"	f	class:vcg::tri::TriMesh::PerMeshAttributeHandle
operator =	vcglib/vcg/complex/base.h	/^  TriMesh operator =(const TriMesh &  \/*m*\/){assert(0);return TriMesh();}$/;"	f	class:vcg::tri::TriMesh
operator =	vcglib/vcg/math/matrix33.h	/^    Matrix33 & operator = ( const Matrix33 & m )$/;"	f	class:vcg::Matrix33
operator =	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix<TYPE>& operator=(const Matrix<TYPE> &m)$/;"	f	class:vcg::ndim::Matrix
operator =	vcglib/vcg/math/quadric.h	/^void operator = ( const Quadric & q )			\/\/ Assegna una quadrica$/;"	f	class:vcg::math::Quadric
operator =	vcglib/vcg/math/quadric5.h	/^	void operator = ( const Quadric5<double> & q )			\/\/ Assegna una quadrica$/;"	f	class:vcg::Quadric5
operator =	vcglib/vcg/simplex/edge/pos.h	/^	inline POSTYPE & operator = ( const POSTYPE & h ){$/;"	f	class:vcg::edge::Pos
operator =	vcglib/vcg/simplex/face/component_ocf.h	/^  inline InfoOcf &operator=(const InfoOcf & \/*other*\/) {$/;"	f	class:vcg::face::InfoOcf
operator =	vcglib/vcg/simplex/face/pos.h	/^	inline PosType & operator = ( const PosType & h ){$/;"	f	class:vcg::face::Pos
operator =	vcglib/vcg/simplex/vertex/component_ocf.h	/^	inline InfoOcf &operator=(const InfoOcf & \/*other*\/) {$/;"	f	class:vcg::vertex::InfoOcf
operator =	vcglib/vcg/space/deprecated_point2.h	/^	inline Point2 & operator =( Point2 const & p)$/;"	f	class:vcg::Point2
operator =	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 & operator =( Point3 const & p )$/;"	f	class:vcg::Point3
operator =	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				void operator =(const EntryIterator &it)$/;"	f	struct:vcg::PerfectSpatialHashing::UniformGrid::EntryIterator
operator =	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			NeighboringEntryIterator& operator =(const NeighboringEntryIterator &it)$/;"	f	struct:vcg::PerfectSpatialHashing::NeighboringEntryIterator
operator =	vcglib/vcg/space/line2.h	/^	inline LineType & operator = ( Line2<ScalarType,!NORM> const &r) $/;"	f	class:vcg::Line2
operator =	vcglib/vcg/space/line3.h	/^	inline LineType & operator = ( Line3<ScalarType,!NORM> const &r) $/;"	f	class:vcg::Line3
operator =	vcglib/vcg/space/ray2.h	/^	inline RayType & operator = ( Ray2<ScalarType,!NORM> const &r) $/;"	f	class:vcg::Ray2
operator =	vcglib/vcg/space/ray3.h	/^	inline RayType & operator = ( Ray3<ScalarType,!NORM> const &r) $/;"	f	class:vcg::Ray3
operator =	vcglib/wrap/glw/bookkeeping.h	/^		ThisType & operator = (const ThisType & other)$/;"	f	class:glw::detail::ObjectSharedPointer
operator =	vcglib/wrap/glw/noncopyable.h	/^		ThisType & operator = (const ThisType & that)$/;"	f	class:glw::detail::NonCopyable
operator =	vcglib/wrap/gui/trackball.h	/^	Trackball operator =(const Trackball &  \/*m*\/){ assert(0); return *this; }$/;"	f	class:vcg::Trackball
operator =	vcglib/wrap/opensg/vertex_component.h	/^	ColorType & operator=( ColorType & c2 ) $/;"	f	class:vcg::vert::OSGColorCore
operator =	vcglib/wrap/opensg/vertex_component.h	/^	CoordType & operator=( CoordType & p2 ) $/;"	f	class:vcg::vert::OSGCoordCore
operator =	vcglib/wrap/opensg/vertex_component.h	/^	NormalType & operator=( NormalType & n2 ) $/;"	f	class:vcg::vert::OSGNormalCore
operator =	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline atomicInt &operator=(int value)$/;"	f	class:mt::atomicInt
operator =	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline atomicInt &operator=(int value)$/;"	f	class:mt::atomicInt
operator ==	vcglib/apps/pivoting/cmesh.h	/^   bool operator==(const CEdge& t) const {$/;"	f	class:CEdge
operator ==	vcglib/apps/pivoting/ring.h	/^    bool operator==(const iterator& x) const {$/;"	f	class:ring::iterator
operator ==	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    inline bool operator==(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
operator ==	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    bool operator==(const aligned_allocator<T>& ) const$/;"	f	class:Eigen::aligned_allocator
operator ==	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(Scalar s) const$/;"	f	class:Eigen::Cwise
operator ==	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator ==	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator==(const Scalar& a, const AutoDiffScalar& b) { return a == b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator ==	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator==(const Scalar& other) const  { return m_value == other; }$/;"	f	class:Eigen::AutoDiffScalar
operator ==	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator==(const AutoDiffScalar<OtherDerType>& b) const  { return m_value == b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator ==	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const double b			){	return (mpfr_cmp_d(a.mp,b)  == 0);	}$/;"	f	namespace:mpfr
operator ==	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const int b				){	return (mpfr_cmp_si(a.mp,b) == 0);	}$/;"	f	namespace:mpfr
operator ==	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const long double b		){	return (mpfr_cmp_ld(a.mp,b) == 0);	}$/;"	f	namespace:mpfr
operator ==	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const long int b			){	return (mpfr_cmp_si(a.mp,b) == 0);	}$/;"	f	namespace:mpfr
operator ==	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const mpreal& b){	return (mpfr_equal_p(a.mp,b.mp)			!=0);	}$/;"	f	namespace:mpfr
operator ==	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const unsigned int b		){	return (mpfr_cmp_ui(a.mp,b) == 0);	}$/;"	f	namespace:mpfr
operator ==	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator == (const mpreal& a, const unsigned long int b	){	return (mpfr_cmp_ui(a.mp,b) == 0);	}$/;"	f	namespace:mpfr
operator ==	vcglib/img/img_attributes.h	/^  bool operator==(const ImgAttributes<ScalarType> &attributes) const$/;"	f	class:img::ImgAttributes
operator ==	vcglib/vcg/complex/algorithms/clean.h	/^                      bool operator == (const SortedPair &s) const$/;"	f	class:vcg::tri::Clean::SortedPair
operator ==	vcglib/vcg/complex/algorithms/clean.h	/^                bool operator == (const SortedTriple &s) const$/;"	f	class:vcg::tri::Clean::SortedTriple
operator ==	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^    bool operator==(const FrontEdge& f) const$/;"	f	class:vcg::tri::FrontEdge
operator ==	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^        bool operator == (const Signature & b) const {$/;"	f	struct:vcg::tri::Zonohedron::Signature
operator ==	vcglib/vcg/complex/algorithms/update/flag.h	/^    inline bool operator == ( const EdgeSorter & pe ) const$/;"	f	class:vcg::tri::UpdateFlags::EdgeSorter
operator ==	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                bool operator ==(const VertexPairEdgePtr &o) const {return (v0 == o.v0)&& (v1==o.v1);}$/;"	f	struct:vcg::tri::UpdateHalfEdges::VertexPairEdgePtr
operator ==	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                bool operator ==(const VertexPairEdgePtr &o) const {return (v0 == o.v0)&& (v1==o.v1);}$/;"	f	struct:vcg::tri::UpdateIndexed::VertexPairEdgePtr
operator ==	vcglib/vcg/complex/algorithms/update/topology.h	/^  inline bool operator == ( const PEdge & pe ) const$/;"	f	class:vcg::tri::UpdateTopology::PEdge
operator ==	vcglib/vcg/complex/algorithms/update/topology.h	/^  inline bool operator == ( const PEdgeTex & pe ) const$/;"	f	class:vcg::tri::UpdateTopology::PEdgeTex
operator ==	vcglib/vcg/complex/algorithms/update/topology.h	/^inline bool operator ==  ( const PVertexEdge & pe ) const { return ( v==pe.v ); }$/;"	f	class:vcg::tri::UpdateTopology::PVertexEdge
operator ==	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  bool operator == (const VoronoiEdge &ve) const {return ve.r0==r0 && ve.r1==r1; }$/;"	f	class:vcg::tri::VoronoiProcessing::VoronoiEdge
operator ==	vcglib/vcg/connectors/halfedge_pos.h	/^            inline bool operator == ( Pos const & p ) const$/;"	f	class:vcg::hedge::Pos
operator ==	vcglib/vcg/math/matrix44.h	/^template <class T> bool Matrix44<T>::operator==(const  Matrix44 &m) const {$/;"	f	class:vcg::Matrix44
operator ==	vcglib/vcg/math/old_deprecated_matrix.h	/^			bool operator==(const Matrix<TYPE> &m) const$/;"	f	class:vcg::ndim::Matrix
operator ==	vcglib/vcg/simplex/edge/pos.h	/^	inline bool operator == ( POSTYPE const & p ) const {$/;"	f	class:vcg::edge::Pos
operator ==	vcglib/vcg/simplex/face/pos.h	/^	inline bool operator == ( PosType const & p ) const {$/;"	f	class:vcg::face::Pos
operator ==	vcglib/vcg/simplex/tetrahedron/pos.h	/^	inline bool operator == ( BasePosType const & p ) const {$/;"	f	class:vcg::tetra::Pos
operator ==	vcglib/vcg/space/box.h	/^	inline bool operator == ( Box const & p ) const$/;"	f	class:vcg::Box
operator ==	vcglib/vcg/space/box2.h	/^	inline bool operator == ( Box2 const & p ) const$/;"	f	class:vcg::Box2
operator ==	vcglib/vcg/space/box3.h	/^    inline bool operator == ( Box3<BoxScalarType> const & p ) const$/;"	f	class:vcg::Box3
operator ==	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator == ( Point2 const & p ) const {$/;"	f	class:vcg::ndim::Point2
operator ==	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator == ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point3
operator ==	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator == ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point4
operator ==	vcglib/vcg/space/deprecated_point2.h	/^	inline bool operator == ( Point2 const & p ) const$/;"	f	class:vcg::Point2
operator ==	vcglib/vcg/space/deprecated_point3.h	/^inline bool operator == ( Point3 const & p ) const$/;"	f	class:vcg::Point3
operator ==	vcglib/vcg/space/deprecated_point4.h	/^    inline bool operator == (  const Point4& p ) const$/;"	f	class:vcg::Point4
operator ==	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline bool operator == ( const Link & l ) const{ return i ==  l.i; }$/;"	f	class:vcg::GridStaticPtr::Link
operator ==	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^				bool operator==(const EntryIterator &it) const$/;"	f	struct:vcg::PerfectSpatialHashing::UniformGrid::EntryIterator
operator ==	vcglib/vcg/space/index/space_iterators.h	/^			inline bool operator ==  ( const Entry_Type & l ) const{return (elem == l.elem); }$/;"	f	struct:vcg::ClosestIterator::Entry_Type
operator ==	vcglib/vcg/space/line2.h	/^	inline bool operator == ( LineType const & p ) const$/;"	f	class:vcg::Line2
operator ==	vcglib/vcg/space/line3.h	/^	inline bool operator == ( LineType const & p ) const$/;"	f	class:vcg::Line3
operator ==	vcglib/vcg/space/plane3.h	/^	bool operator==(Plane3 const &p) const	{	$/;"	f	class:vcg::Plane3
operator ==	vcglib/vcg/space/ray2.h	/^	inline bool operator == ( RayType const & p ) const$/;"	f	class:vcg::Ray2
operator ==	vcglib/vcg/space/ray3.h	/^	inline bool operator == ( RayType const & p ) const$/;"	f	class:vcg::Ray3
operator ==	vcglib/vcg/space/segment2.h	/^    inline bool operator == ( SegmentType const & p ) const$/;"	f	class:vcg::Segment2
operator ==	vcglib/vcg/space/segment3.h	/^	inline bool operator == ( SegmentType const & p ) const$/;"	f	class:vcg::Segment3
operator ==	vcglib/vcg/space/texcoord2.h	/^    inline bool operator == ( TexCoord2 const & p ) const$/;"	f	class:vcg::TexCoord2
operator ==	vcglib/vcg/space/texcoord2.h	/^    inline bool operator == ( TexCoord2Simple const & p ) const$/;"	f	class:vcg::TexCoord2Simple
operator ==	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline bool operator==(int value) const$/;"	f	class:mt::atomicInt
operator ==	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline bool operator==(int value) const$/;"	f	class:mt::atomicInt
operator >	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(Scalar s) const$/;"	f	class:Eigen::Cwise
operator >	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator >	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator> (const Scalar& a, const AutoDiffScalar& b) { return a >  b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator >	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator> (const Scalar& other) const  { return m_value >  other; }$/;"	f	class:Eigen::AutoDiffScalar
operator >	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator> (const AutoDiffScalar<OtherDerType>& b) const  { return m_value >  b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator >	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator >	(const mpreal& a, const mpreal& b){	return (mpfr_greater_p(a.mp,b.mp)		!=0);	}$/;"	f	namespace:mpfr
operator >	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline bool operator >  (const MatrixBase<OtherDerived>& other) const {$/;"	f
operator >	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator >  ( Point2 const & p ) const	{$/;"	f	class:vcg::ndim::Point2
operator >	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator >  ( PointType const & p ) const	{$/;"	f	class:vcg::ndim::Point3
operator >	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator >  ( PointType const & p ) const	{$/;"	f	class:vcg::ndim::Point4
operator >	vcglib/vcg/space/deprecated_point2.h	/^	inline bool operator >  ( Point2 const & p ) const$/;"	f	class:vcg::Point2
operator >	vcglib/vcg/space/deprecated_point3.h	/^    inline bool operator >  ( Point3 const & p ) const$/;"	f	class:vcg::Point3
operator >	vcglib/vcg/space/deprecated_point4.h	/^    inline bool operator >  ( const Point4 & p ) const$/;"	f	class:vcg::Point4
operator >	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline bool operator >  ( const Link & l ) const{ return i >   l.i; }$/;"	f	class:vcg::GridStaticPtr::Link
operator >	vcglib/wrap/gcache/dheap.h	/^    bool operator>(const Item &i) const { return *value > *i.value; }$/;"	f	class:PtrDHeap::Item
operator >	vcglib/wrap/gcache/token.h	/^    bool operator>(const Token &a) const {$/;"	f	class:vcg::Token
operator >	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline bool operator>(int value) const$/;"	f	class:mt::atomicInt
operator >	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline bool operator>(int value) const$/;"	f	class:mt::atomicInt
operator >=	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(Scalar s) const$/;"	f	class:Eigen::Cwise
operator >=	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator >=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    friend inline bool operator>=(const Scalar& a, const AutoDiffScalar& b) { return a >= b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator >=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline bool operator>=(const Scalar& other) const  { return m_value >= other; }$/;"	f	class:Eigen::AutoDiffScalar
operator >=	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    template<typename OtherDerType> inline bool operator>=(const AutoDiffScalar<OtherDerType>& b) const  { return m_value >= b.value(); }$/;"	f	class:Eigen::AutoDiffScalar
operator >=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline bool operator >= (const mpreal& a, const mpreal& b){	return (mpfr_greaterequal_p(a.mp,b.mp)	!=0);	}$/;"	f	namespace:mpfr
operator >=	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline bool operator >=  (const MatrixBase<OtherDerived>& other) const {$/;"	f
operator >=	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator >= ( Point2 const & p ) const {$/;"	f	class:vcg::ndim::Point2
operator >=	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator >= ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point3
operator >=	vcglib/vcg/space/deprecated_point.h	/^	inline bool operator >= ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point4
operator >=	vcglib/vcg/space/deprecated_point2.h	/^	inline bool operator >= ( Point2 const & p ) const$/;"	f	class:vcg::Point2
operator >=	vcglib/vcg/space/deprecated_point3.h	/^    inline bool operator >= ( Point3 const & p ) const$/;"	f	class:vcg::Point3
operator >=	vcglib/vcg/space/deprecated_point4.h	/^    inline bool operator >= ( const Point4 & p ) const$/;"	f	class:vcg::Point4
operator >=	vcglib/vcg/space/index/grid_static_ptr.h	/^			inline bool operator >= ( const Link & l ) const{ return i >=  l.i; }$/;"	f	class:vcg::GridStaticPtr::Link
operator >>	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^istream& operator>>(istream &is, mpreal& v)$/;"	f	namespace:mpfr
operator >>	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const int k)$/;"	f	namespace:mpfr
operator >>	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const long int k)$/;"	f	namespace:mpfr
operator >>	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const unsigned int k)$/;"	f	namespace:mpfr
operator >>	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal operator>>(const mpreal& v, const unsigned long int k)$/;"	f	namespace:mpfr
operator >>=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator>>=(const int u)$/;"	f	class:mpfr::mpreal
operator >>=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator>>=(const long int u)$/;"	f	class:mpfr::mpreal
operator >>=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator>>=(const unsigned int u)$/;"	f	class:mpfr::mpreal
operator >>=	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::operator>>=(const unsigned long int u)$/;"	f	class:mpfr::mpreal
operator EquivVcgType&	vcglib/vcg/math/eigen_matrix_addons.h	/^operator EquivVcgType& () { return *reinterpret_cast<EquivVcgType*>(this); }$/;"	f
operator T&	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    inline operator T& () { return *static_cast<T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator []	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
operator []	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index)$/;"	f	class:Eigen::DenseCoeffsBase
operator []	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Index& operator[](Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator []	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline const Index& operator[](Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator []	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^        Index operator[](Index i) const { return i==m_index ? m_value : 0; }$/;"	f	class:Eigen::SparseMatrix::SingletonVector
operator []	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    CoeffType operator[] (Index i) { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
operator []	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    const CoeffType operator[] (Index i) const { return CoeffType(m_values[i], m_jacobian.col(i)); }$/;"	f	class:Eigen::AutoDiffVector
operator []	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    int & operator[](const int &i){return (i==0)? first : second;}$/;"	f	struct:vcg::tri::FourPCS::Couple
operator []	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    inline PC_Chord & operator[] (const std::pair<size_t, unsigned char> &face_edge) {$/;"	f	class:vcg::tri::PolychordCollapse::PC_Chords
operator []	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    inline const PC_Chord & operator[] (const std::pair<size_t, unsigned char> &face_edge) const {$/;"	f	class:vcg::tri::PolychordCollapse::PC_Chords
operator []	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    inline std::pair<size_t, unsigned char> operator[] (PC_Chord const * const coord) {$/;"	f	class:vcg::tri::PolychordCollapse::PC_Chords
operator []	vcglib/vcg/complex/base.h	/^        ATTR_TYPE & operator [](const RefType  & i){return (*_handle)[i];}$/;"	f	class:vcg::tri::TriMesh::AttributeHandle
operator []	vcglib/vcg/container/simple_temporary_data.h	/^    ATTR_TYPE & operator[](const int & i){return data[i];}$/;"	f	class:vcg::SimpleTempData
operator []	vcglib/vcg/container/simple_temporary_data.h	/^    ATTR_TYPE & operator[](const typename STL_CONT::iterator & cont){return data[&(*cont)-&*c.begin()];}$/;"	f	class:vcg::SimpleTempData
operator []	vcglib/vcg/container/simple_temporary_data.h	/^    ATTR_TYPE & operator[](const typename STL_CONT::value_type & v){return data[&v-&*c.begin()];}$/;"	f	class:vcg::SimpleTempData
operator []	vcglib/vcg/container/simple_temporary_data.h	/^    ATTR_TYPE & operator[](const typename STL_CONT::value_type * v){return data[v-&*c.begin()];}$/;"	f	class:vcg::SimpleTempData
operator []	vcglib/vcg/container/simple_temporary_data.h	/^    bool  & operator [](const int & i){return data[i];}$/;"	f	class:vcg::VectorNBW
operator []	vcglib/vcg/math/matrix33.h	/^    inline S * operator [] ( const int i )$/;"	f	class:vcg::Matrix33
operator []	vcglib/vcg/math/matrix33.h	/^    inline const S * operator [] ( const int i ) const$/;"	f	class:vcg::Matrix33
operator []	vcglib/vcg/math/matrix44.h	/^template <class T> T *Matrix44<T>::operator[](const int i) {$/;"	f	class:vcg::Matrix44
operator []	vcglib/vcg/math/matrix44.h	/^template <class T> const T *Matrix44<T>::operator[](const int i) const {$/;"	f	class:vcg::Matrix44
operator []	vcglib/vcg/math/old_deprecated_matrix.h	/^			inline TYPE* operator[](const unsigned int i)$/;"	f	class:vcg::ndim::Matrix
operator []	vcglib/vcg/math/old_deprecated_matrix.h	/^			inline const TYPE* operator[](const unsigned int i) const $/;"	f	class:vcg::ndim::Matrix
operator []	vcglib/vcg/math/old_matrix.h	/^	inline const typename Base::RowXpr operator[](const unsigned int i) const$/;"	f	class:vcg::ndim::Matrix
operator []	vcglib/vcg/math/old_matrix.h	/^	inline typename Base::RowXpr operator[](const unsigned int i)$/;"	f	class:vcg::ndim::Matrix
operator []	vcglib/vcg/math/old_matrix33.h	/^	inline const typename Base::RowXpr operator[](const unsigned int i) const$/;"	f	class:vcg::Matrix33
operator []	vcglib/vcg/math/old_matrix33.h	/^	inline typename Base::RowXpr operator[](const unsigned int i)$/;"	f	class:vcg::Matrix33
operator []	vcglib/vcg/math/old_matrix44.h	/^	const typename Base::RowXpr operator[](int i) const { return Base::row(i); }$/;"	f	class:vcg::Matrix44
operator []	vcglib/vcg/math/old_matrix44.h	/^	typename Base::RowXpr operator[](int i) { return Base::row(i); }$/;"	f	class:vcg::Matrix44
operator []	vcglib/vcg/space/deprecated_point.h	/^	inline S & operator [] ( const int i )$/;"	f	class:vcg::ndim::Point
operator []	vcglib/vcg/space/deprecated_point.h	/^	inline const S & operator [] ( const int i ) const$/;"	f	class:vcg::ndim::Point
operator []	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType & operator [] ( const int i )$/;"	f	class:vcg::Point2
operator []	vcglib/vcg/space/deprecated_point2.h	/^	inline const ScalarType & operator [] ( const int i ) const$/;"	f	class:vcg::Point2
operator []	vcglib/vcg/space/deprecated_point3.h	/^    inline P3ScalarType & operator [] ( const int i )$/;"	f	class:vcg::Point3
operator []	vcglib/vcg/space/deprecated_point3.h	/^    inline const P3ScalarType & operator [] ( const int i ) const$/;"	f	class:vcg::Point3
operator []	vcglib/vcg/space/deprecated_point4.h	/^    inline T & operator [] ( const int i )$/;"	f	class:vcg::Point4
operator []	vcglib/vcg/space/deprecated_point4.h	/^    inline const T & operator [] ( const int i ) const$/;"	f	class:vcg::Point4
operator []	vcglib/vcg/space/index/kdtree/kdtree.h	/^		inline const DataType& operator[] (int i) const$/;"	f	class:ConstDataWrapper
operator []	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 inline bool operator[](const typename UniformGrid::CellCoordinate &at)	{ return m_Mask[at.X()][at.Y()][at.Z()]; }$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
operator []	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline Data* operator[](const EntryCoordinate &at) const { return m_Table[at.X()][at.Y()][at.Z()]; }$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
operator []	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline OffsetPointer  operator[](const EntryCoordinate &at) const { return m_Table[at.X()][at.Y()][at.Z()]; } $/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
operator []	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			inline OffsetPointer& operator[](const EntryCoordinate &at)				{ return m_Table[at.X()][at.Y()][at.Z()]; } $/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
operator []	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			std::vector< ObjectPointer >* operator[](const CellCoordinate &at)							{ return &m_Grid[at.X()][at.Y()][at.Z()];}$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
operator []	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		std::vector< ObjectPointer >* operator[](const CoordinateType &query)$/;"	f	class:vcg::PerfectSpatialHashing
operator []	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		std::vector< ObjectPointer >* operator[](const typename UniformGrid::CellCoordinate  &query)$/;"	f	class:vcg::PerfectSpatialHashing
operator []	vcglib/vcg/space/segment3.h	/^  inline PointType &operator[] (const int i) {return i==0?_p0:_p1;}$/;"	f	class:vcg::Segment3
operator []	vcglib/vcg/space/segment3.h	/^  inline const PointType &operator[] (const int i) const {return i==0?_p0:_p1;}$/;"	f	class:vcg::Segment3
operator []	vcglib/wrap/gcache/dheap.h	/^  T &operator[](int i) {$/;"	f	class:PtrDHeap
operator []	vcglib/wrap/glw/framebuffer.h	/^		GLuint & operator [] (GLuint attachmentIndex)$/;"	f	class:glw::RenderTargetBinding
operator []	vcglib/wrap/glw/framebuffer.h	/^		GLuint operator [] (GLuint attachmentIndex) const$/;"	f	class:glw::RenderTargetBinding
operator []	vcglib/wrap/glw/framebuffer.h	/^		RenderTarget & operator [] (GLuint attachmentIndex)$/;"	f	class:glw::RenderTargetMapping
operator []	vcglib/wrap/glw/framebuffer.h	/^		const RenderTarget & operator [] (GLuint attachmentIndex) const$/;"	f	class:glw::RenderTargetMapping
operator []	vcglib/wrap/glw/program.h	/^		GLuint & operator [] (const std::string & attributeName)$/;"	f	class:glw::VertexAttributeBinding
operator []	vcglib/wrap/glw/program.h	/^		GLuint & operator [] (const std::string & outName)$/;"	f	class:glw::FragmentOutputBinding
operator []	vcglib/wrap/glw/program.h	/^		GLuint operator [] (const std::string & attributeName) const$/;"	f	class:glw::VertexAttributeBinding
operator []	vcglib/wrap/glw/program.h	/^		GLuint operator [] (const std::string & outName) const$/;"	f	class:glw::FragmentOutputBinding
operator ^	vcglib/vcg/math/eigen_matrixbase_addons.h	/^EIGEN_DEPRECATED inline PlainMatrixType operator ^ (const Derived& p ) const { return this->cross(p); }$/;"	f
operator ^	vcglib/vcg/space/deprecated_point.h	/^	inline PointType operator ^ ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point3
operator ^	vcglib/vcg/space/deprecated_point.h	/^	inline PointType operator ^ ( PointType const & p ) const {$/;"	f	class:vcg::ndim::Point4
operator ^	vcglib/vcg/space/deprecated_point2.h	/^	inline ScalarType operator ^ ( Point2 const & p ) const$/;"	f	class:vcg::Point2
operator ^	vcglib/vcg/space/deprecated_point3.h	/^    inline Point3 operator ^ ( Point3 const & p ) const$/;"	f	class:vcg::Point3
operator ^	vcglib/vcg/space/deprecated_point4.h	/^  inline Point4 operator ^ (  const Point4& \/*p*\/ ) const$/;"	f	class:vcg::Point4
operator ^	vcglib/vcg/space/point2.h	/^	inline Scalar operator ^ ( Point2 const & p ) const$/;"	f	class:vcg::Point2
operator ^	vcglib/vcg/space/point4.h	/^	inline Point4 operator ^ (  const Point4& p ) const$/;"	f	class:vcg::Point4
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    operator bool() const { return m_cachedIndex>=0; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_inner < m_end && m_inner>=0; }$/;"	f	class:Eigen::DenseBase::InnerIterator
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end) && (m_id>=m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id <= m_end) && (m_id>m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return (m_lhsIter && m_rhsIter); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_id>=0; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_lhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_rhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseVector::InnerIterator
operator bool	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
operator bool	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline operator bool() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
operator bool	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline operator bool() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
operator bool	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline operator bool() const { return m_isvalid;}$/;"	f	class:Eigen::MatrixMarketIterator
operator bool	vcglib/wrap/glw/bookkeeping.h	/^		operator bool (void) const$/;"	f	class:glw::detail::ObjectSharedPointer
operator const EquivVcgType&	vcglib/vcg/math/eigen_matrix_addons.h	/^operator const EquivVcgType& () const { return *reinterpret_cast<const EquivVcgType*>(this); }$/;"	f
operator const ExpressionType&	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::ForceAlignedAccess
operator const ExpressionType&	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::NestByValue
operator const PlainObject&	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    operator const PlainObject& () const$/;"	f	class:Eigen::ProductBase
operator const PlainObject&	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE operator const PlainObject& () const$/;"	f	class:Eigen::CoeffBasedProduct
operator const T&	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    inline operator const T& () const { return *static_cast<const T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator const typename Base::Scalar	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    operator const typename Base::Scalar() const {$/;"	f	class:Eigen::GeneralProduct
operator int	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline operator int() const$/;"	f	class:mt::atomicInt
operator int	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline operator int() const$/;"	f	class:mt::atomicInt
operator size_t	vcglib/vcg/complex/algorithms/clustering.h	/^    operator size_t () const$/;"	f	class:vcg::tri::Clustering::SimpleTri
operator size_t	vcglib/vcg/complex/algorithms/clustering.h	/^  operator size_t () const$/;"	f	class:vcg::tri::HashedPoint3i
operator ||	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator||(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator ~	vcglib/vcg/space/deprecated_point.h	/^	inline Point2 operator ~ () const {$/;"	f	class:vcg::ndim::Point2
operatorInverseSqrt	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorInverseSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
operatorNorm	vcglib/eigenlib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::operatorNorm() const$/;"	f	class:Eigen::MatrixBase
operatorNorm	vcglib/eigenlib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::operatorNorm() const$/;"	f	class:Eigen::SelfAdjointView
operatorSqrt	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
opp_vert	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static VertexPointer opp_vert(HEdgePointer hp)$/;"	f	class:vcg::tri::HalfEdgeTopology
opposite	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE opposite(int k) {$/;"	f	struct:vcg::tri::ContinuityLoopWeight
opposite	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE opposite(int k) {$/;"	f	struct:vcg::tri::RegularLoopWeight
opposite	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline SCALAR_TYPE opposite(int) {$/;"	f	struct:vcg::tri::LoopWeight
optarg	vcglib/wrap/system/getopt.cpp	/^char *optarg = 0;$/;"	v
opterr	vcglib/wrap/system/getopt.cpp	/^int opterr = 1;$/;"	v
optind	vcglib/wrap/system/getopt.cpp	/^int optind = 0;$/;"	v
option	vcglib/wrap/system/getopt.h	/^struct option$/;"	s
optional_argument	vcglib/wrap/system/getopt.h	/^#define optional_argument	/;"	d
options	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline superlu_options_t& options() { return m_sluOptions; }$/;"	f	class:Eigen::SuperLUBase
options	vcglib/wrap/system/qgetopt.h	/^  QList<Option> options;$/;"	m	class:GetOpt
optopt	vcglib/wrap/system/getopt.cpp	/^int optopt = '?';$/;"	v
ordblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MALLINFO_FIELD_TYPE ordblks;  \/* number of free chunks *\/$/;"	m	struct:mallinfo	file:
ordblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^  MALLINFO_FIELD_TYPE ordblks;  \/* number of free chunks *\/$/;"	m	struct:mallinfo
ordered_pair	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^static std::pair<genericType, genericType> ordered_pair(const genericType &a, const genericType &b)$/;"	f	class:vcg::tri::VoronoiProcessing
ordering	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::ordering(const MatrixType& a, CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase
ordering	vcglib/wrap/system/getopt.cpp	/^} ordering;$/;"	v	typeref:enum:__anon528	file:
orderingMethod	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    int orderingMethod() const {$/;"	f	class:Eigen::SkylineInplaceLU
orig	vcglib/vcg/complex/algorithms/clustering.h	/^  VertexType *orig;$/;"	m	class:vcg::tri::NearestToCenter
origin	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
origin	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
origin	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
origin	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
origin	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    CoordType origin,end;$/;"	m	class:vcg::tri::CylinderClipping::CylPred
origin	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        VertexType* origin;$/;"	m	class:vcg::tri::Fitmaps::radSorter
originalMatrix	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  inline const MatrixType& originalMatrix() const { return m_originalMatrix; }$/;"	f	struct:Eigen::internal::image_retval_base
other	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^        typedef aligned_allocator<U> other;$/;"	t	struct:Eigen::aligned_allocator::rebind
other	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^      typedef aligned_allocator_indirection<U> other;$/;"	t	struct:Eigen::aligned_allocator_indirection::rebind
out	vcglib/wrap/mt/mt.h	/^    std::vector<Node *> out;$/;"	m	struct:vcg::MT::Node
outer	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon40
outer	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon41
outer	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    outer = Start \/ Derived::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon229
outer	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^    outer = index \/ int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon231
outer	vcglib/eigenlib/Eigen/src/Core/Stride.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::Stride
outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
outer	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
outerInd	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *outerInd;$/;"	m	struct:Eigen::SluMatrix::__anon434
outerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix
outerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix
outerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    inline Index* outerIndexPtr()$/;"	f	class:Eigen::SparseInnerVectorSet
outerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Index* outerIndexPtr() const$/;"	f	class:Eigen::SparseInnerVectorSet
outerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix
outerIndexPtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix
outerSize	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    Index outerSize() const$/;"	f	class:Eigen::DenseBase
outerSize	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix
outerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::SparseMatrix
outerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index outerSize() const { return (int(Flags)&RowMajorBit) ? this->rows() : this->cols(); }$/;"	f	class:Eigen::SparseMatrixBase
outerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index outerSize() const { return 1; }$/;"	f	class:Eigen::SparseVector
outerSize	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  inline Index outerSize() const { return m_matrix.outerSize(); }$/;"	f	class:Eigen::SparseView
outerSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index outerSize() const {$/;"	f	class:Eigen::SkylineMatrix
outerSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    Index outerSize() const {$/;"	f	class:Eigen::SkylineMatrixBase
outerSize	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index outerSize() const { return static_cast<Index>(m_data.size()); }$/;"	f	class:Eigen::DynamicSparseMatrix
outerStride	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Array
outerStride	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ArrayWrapper
outerStride	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::MatrixWrapper
outerStride	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Block
outerStride	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl
outerStride	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::DenseCoeffsBase
outerStride	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Diagonal
outerStride	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::Flagged
outerStride	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess
outerStride	vcglib/eigenlib/Eigen/src/Core/Map.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Map
outerStride	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Matrix
outerStride	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::NestByValue
outerStride	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfAdjointView
outerStride	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp
outerStride	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::SwapWrapper
outerStride	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline Index outerStride() const { return derived().nestedExpression().outerStride(); }$/;"	f	class:Eigen::TransposeImpl
outerStride	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return derived().outerStride(); }$/;"	f	class:Eigen::TriangularBase
outerStride	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::TriangularView
outer_product_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<> struct outer_product_selector<ColMajor> {$/;"	s	namespace:Eigen::internal
outer_product_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<> struct outer_product_selector<RowMajor> {$/;"	s	namespace:Eigen::internal
outer_stride_at_compile_time	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time$/;"	s	namespace:Eigen::internal
outer_stride_at_compile_time	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
outproduct5	vcglib/vcg/math/quadric5.h	/^  void inline outproduct5(const ScalarType a[5], const ScalarType b[5], ScalarType r[5][5])$/;"	f	namespace:vcg::math
over	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  bool over;$/;"	m	class:vcg::tri::BitQuad::Iterator
overhead_for	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define overhead_for(/;"	d	file:
overlap	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^   bool overlap;$/;"	m	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam
own_slot	vcglib/apps/trimeshinfo/ClassesNode.h	/^	NodeGroup	own_slot;$/;"	m	class:OwnSlotsNode
own_slot	vcglib/apps/trimeshinfo/SlotsNode.h	/^	NodeGroup	own_slot;$/;"	m	class:SlotNode
own_slots	vcglib/apps/trimeshinfo/ClassesNode.h	/^	OwnSlotsNode own_slots;$/;"	m	class:ClassNode
own_slots	vcglib/apps/trimeshinfo/InstancesNode.h	/^	OwnSlotsNode own_slots;$/;"	m	class:InstanceNode
p	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  VectorType p;$/;"	m	struct:BallPointStuff	file:
p	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    FourPoints  p;$/;"	m	struct:vcg::tri::FourPCS::Candidate
p	vcglib/vcg/complex/algorithms/clip.h	/^    CoordType p;$/;"	m	class:vcg::tri::TriMeshClipper::EdgeIsect
p	vcglib/vcg/complex/algorithms/clustering.h	/^  CoordType p;$/;"	m	class:vcg::tri::AverageColorCell
p	vcglib/vcg/complex/algorithms/hole.h	/^            PosType p;$/;"	m	class:vcg::tri::Hole::Info
p	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& p() { return data[13];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
p	vcglib/vcg/space/index/space_iterators.h	/^		CoordType p;							\/\/initial point$/;"	m	class:vcg::ClosestIterator
p	vcglib/wrap/io_tetramesh/import_ply.h	/^	S p[3];$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_VertAux
p	vcglib/wrap/io_trimesh/import_ply.h	/^	S p[3];$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
p16uc_COMPLEX_IM	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_IM   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 1), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_RE	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_RE   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_REV	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV  = vec_sld(p16uc_REVERSE, p16uc_REVERSE, 8);\/\/{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_REV2	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV2 = vec_sld(p16uc_FORWARD, p16uc_FORWARD, 8);\/\/{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_DUPLICATE	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_DUPLICATE = {0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7};$/;"	m	namespace:Eigen::internal
p16uc_FORWARD	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_FORWARD = vec_lvsl(0, (float*)0);$/;"	m	namespace:Eigen::internal
p16uc_PSET_HI	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_HI = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 1));\/\/{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_PSET_LO	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_LO = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 2), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 3));\/\/{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_REVERSE = {12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3};$/;"	m	namespace:Eigen::internal
p2ui_CONJ_XOR	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^static uint32x2_t p2ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET2(0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
p4f_COUNTDOWN	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_COUNTDOWN = { 3.0, 2.0, 1.0, 0.0 };$/;"	m	namespace:Eigen::internal
p4f_ONE	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ONE = vec_ctf(p4i_ONE, 0);$/;"	m	namespace:Eigen::internal
p4f_ZERO_	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ZERO_ = (Packet4f) vec_sl((Packet4ui)p4i_MINUS1, (Packet4ui)p4i_MINUS1);$/;"	m	namespace:Eigen::internal
p4i_COUNTDOWN	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4i p4i_COUNTDOWN = { 3, 2, 1, 0 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet4ui  p4ui_CONJ_XOR = vec_mergeh((Packet4ui)p4i_ZERO, (Packet4ui)p4f_ZERO_);\/\/{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^static uint32x4_t p4ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET4(0x00000000, 0x80000000, 0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
pMark	vcglib/vcg/space/index/octree.h	/^            unsigned char *pMark;$/;"	m	struct:vcg::Octree::ObjectReference
pObj	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^			ObjPtr pObj;$/;"	m	class:vcg::AABBBinaryTreeKClosest::ClosestObjType
pObject	vcglib/vcg/space/index/octree.h	/^            ObjectPointer  pObject;$/;"	m	struct:vcg::Octree::ObjectReference
pObjects	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		ObjPtrVector pObjects;$/;"	m	class:vcg::AABBBinaryTree
pRoot	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^		NodeType * pRoot;$/;"	m	class:vcg::AABBBinaryTree
pVertexIndex	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^		unsigned int pVertexIndex[3];$/;"	m	class:vcg::AABBBinaryTreeFrustumCull::VFrustumPlane
pabs	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pabs(const Packet& a) { return abs(a); }$/;"	f	namespace:Eigen::internal
pabs	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vabsq_f32(a); }$/;"	f	namespace:Eigen::internal
pabs	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vabsq_s32(a); }$/;"	f	namespace:Eigen::internal
pabs	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a)$/;"	f	namespace:Eigen::internal
pabs	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pabs	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a)$/;"	f	namespace:Eigen::internal
pack	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void pack(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)$/;"	f	struct:Eigen::internal::symm_pack_lhs
pack_attempt_num	vcglib/vcg/space/rect_packer.h	/^    int pack_attempt_num;$/;"	m	class:vcg::RectPacker::Stat
pack_attempt_time	vcglib/vcg/space/rect_packer.h	/^    float pack_attempt_time;$/;"	m	class:vcg::RectPacker::Stat
pack_total_time	vcglib/vcg/space/rect_packer.h	/^    float pack_total_time;$/;"	m	class:vcg::RectPacker::Stat
packedMatrix	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const MatrixType& packedMatrix() const$/;"	f	class:Eigen::HessenbergDecomposition
packedMatrix	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline const MatrixType& packedMatrix() const$/;"	f	class:Eigen::Tridiagonalization
packet	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ArrayWrapper
packet	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::MatrixWrapper
packet	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ArrayWrapper
packet	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::MatrixWrapper
packet	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::Block
packet	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Block
packet	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl
packet	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CwiseBinaryOpImpl
packet	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp
packet	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CwiseNullaryOp
packet	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl
packet	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryOpImpl
packet	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
packet	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
packet	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct
packet	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Flagged
packet	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Flagged
packet	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess
packet	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess
packet	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::MapBase
packet	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::MapBase
packet	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::NestByValue
packet	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::NestByValue
packet	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::PlainObjectBase
packet	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::PlainObjectBase
packet	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    inline PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Replicate
packet	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Reverse
packet	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Reverse
packet	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::TransposeImpl
packet	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::TransposeImpl
packet	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct
packetByOuterInner	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packetByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const { return impl.packetOp(i); }$/;"	f	struct:Eigen::internal::linspaced_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const$/;"	f	struct:Eigen::internal::linspaced_op_impl
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index row, Index col) const$/;"	f	struct:Eigen::internal::linspaced_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index) const { return m_base = padd(m_base,m_packetStep); }$/;"	f	struct:Eigen::internal::linspaced_op_impl
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index, Index = 0) const { return internal::pset1<Packet>(m_other); }$/;"	f	struct:Eigen::internal::scalar_constant_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs2_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_multiple_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_opposite_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_quotient1_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_difference_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_max_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_min_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_product_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_quotient_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_sum_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::plog(a); }$/;"	f	struct:Eigen::internal::scalar_log_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_add_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_cube_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_op
packetOp	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_square_op
packet_impl	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::false_type) const$/;"	f	class:Eigen::DiagonalProduct
packet_impl	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::true_type) const$/;"	f	class:Eigen::DiagonalProduct
packet_traits	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename T> struct packet_traits : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packingfield	vcglib/vcg/space/rasterized_outline2_packer.h	/^      packingfield(vcg::Point2i size, const Parameters& par)$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
packingfield	vcglib/vcg/space/rasterized_outline2_packer.h	/^  class packingfield$/;"	c	class:vcg::RasterizedOutline2Packer
pacos	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^Packet pacos(const Packet& a) { return acos(a); }$/;"	f	namespace:Eigen::internal
pad_request	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define pad_request(/;"	d	file:
padd	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^padd(const Packet& a,$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_add(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vaddq_f32(a,b); }$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vaddq_s32(a,b); }$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_add_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_add_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }$/;"	f	namespace:Eigen::internal
padd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }$/;"	f	namespace:Eigen::internal
padding	vcglib/vcg/container/simple_temporary_data.h	/^    int padding;$/;"	m	class:vcg::SimpleTempData
pade13	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^EIGEN_STRONG_INLINE void MatrixExponential<MatrixType>::pade13(const MatrixType &A)$/;"	f	class:Eigen::MatrixExponential
pade17	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^EIGEN_STRONG_INLINE void MatrixExponential<MatrixType>::pade17(const MatrixType &A)$/;"	f	class:Eigen::MatrixExponential
pade3	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^EIGEN_STRONG_INLINE void MatrixExponential<MatrixType>::pade3(const MatrixType &A)$/;"	f	class:Eigen::MatrixExponential
pade5	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^EIGEN_STRONG_INLINE void MatrixExponential<MatrixType>::pade5(const MatrixType &A)$/;"	f	class:Eigen::MatrixExponential
pade7	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^EIGEN_STRONG_INLINE void MatrixExponential<MatrixType>::pade7(const MatrixType &A)$/;"	f	class:Eigen::MatrixExponential
pade9	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^EIGEN_STRONG_INLINE void MatrixExponential<MatrixType>::pade9(const MatrixType &A)$/;"	f	class:Eigen::MatrixExponential
pageSizeCm	vcglib/wrap/io_edgemesh/export_svg.h	/^	Point2f pageSizeCm() \/\/ This is automatically computed from the above values $/;"	f	class:vcg::tri::io::SVGProperties
page_align	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define page_align(/;"	d	file:
page_size	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t page_size;$/;"	m	struct:malloc_params	file:
paint	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        bool paint;                                     \/\/\/< Allows painting of \\c mMov according to consensus. See Paint() for details.$/;"	m	class:OverlapEstimation::Parameters
paintGL	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::paintGL() {   $/;"	f	class:GLArea
paintGL	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::paintGL ()$/;"	f	class:GLArea
paintGL	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void GLWidget::paintGL ()$/;"	f	class:GLWidget
paintGL	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^void GLWidget::paintGL()$/;"	f	class:GLWidget
palign	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^inline void palign(PacketType& first, const PacketType& second)$/;"	f	namespace:Eigen::internal
palign_impl	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^struct palign_impl$/;"	s	namespace:Eigen::internal
palign_impl	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
palign_impl	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
palign_impl	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pand(const Packet& a, const Packet& b) { return a & b; }$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vandq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_and_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_and_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }$/;"	f	namespace:Eigen::internal
pand	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pandnot(const Packet& a, const Packet& b) { return a & (!b); }$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v, vec_nor(b.v,b.v))); }$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vbicq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_andnot_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_andnot_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }$/;"	f	namespace:Eigen::internal
par	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar par, sum;$/;"	m	class:Eigen::LevenbergMarquardt
par	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  Param par;	\/\/\/ parameters$/;"	m	class:vcg::tri::FourPCS
parallelize_gemm	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^void parallelize_gemm(const Functor& func, Index rows, Index cols, bool transpose)$/;"	f	namespace:Eigen::internal
parameters	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Parameters parameters;$/;"	m	class:Eigen::HybridNonLinearSolver
parameters	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Parameters parameters;$/;"	m	class:Eigen::LevenbergMarquardt
params	vcglib/vcg/space/rasterized_outline2_packer.h	/^      Parameters params;$/;"	m	class:vcg::RasterizedOutline2Packer::packingfield
pardisoInit	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoInit(int type)$/;"	f	class:Eigen::PardisoImpl
pardisoParameterArray	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ParameterType& pardisoParameterArray()$/;"	f	class:Eigen::PardisoImpl
pardisoRelease	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoRelease()$/;"	f	class:Eigen::PardisoImpl
pardiso_run_selector	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector$/;"	s	namespace:Eigen::internal
pardiso_run_selector	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector<long long int>$/;"	s	namespace:Eigen::internal
pardiso_traits	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLDLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
parent	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  struct malloc_tree_chunk* parent;$/;"	m	struct:malloc_tree_chunk	typeref:struct:malloc_tree_chunk::malloc_tree_chunk	file:
parent	vcglib/vcg/complex/algorithms/geodesic.h	/^    VertexPointer parent;$/;"	m	struct:vcg::tri::Geodesic::TempData
parent	vcglib/vcg/math/disjoint_set.h	/^			OBJECT_TYPE *parent;$/;"	m	struct:vcg::DisjointSet::DisjointSetNode
parent	vcglib/vcg/space/index/octree_template.h	/^		NodePointer parent;$/;"	m	struct:vcg::OctreeTemplate::Node
parentMax	vcglib/wrap/gcache/dheap.h	/^  int parentMax(int i) const { return (((i+2)>>2)<<1) - 1; }$/;"	f	class:DHeap
parentMin	vcglib/wrap/gcache/dheap.h	/^  int parentMin(int i) const { return (((i+2)>>2)<<1) - 2; }$/;"	f	class:DHeap
parse	vcglib/wrap/system/qgetopt.cpp	/^bool GetOpt::parse(QString &error) {$/;"	f	class:GetOpt
parse	vcglib/wrap/system/qgetopt.cpp	/^void GetOpt::parse() {$/;"	f	class:GetOpt
parseOption	vcglib/wrap/system/qgetopt.cpp	/^bool GetOpt::parseOption(GetOpt::Option &o, const QString &arg) {$/;"	f	class:GetOpt
parseparams	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^void parseparams(int argn, char** argvect)$/;"	f
part	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^    const DiagonalWrapper<ConstDiagonalReturnType> part() const$/;"	f	class:Eigen::MatrixBase
part	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^const typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part() const$/;"	f	class:Eigen::MatrixBase
part	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part()$/;"	f	class:Eigen::MatrixBase
partialPivLu	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::partialPivLu() const$/;"	f	class:Eigen::MatrixBase
partial_lu_impl	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^struct partial_lu_impl$/;"	s	namespace:Eigen::internal
partial_lu_inplace	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)$/;"	f	namespace:Eigen::internal
partitionEigenvalues	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void MatrixFunction<MatrixType,AtomicType,1>::partitionEigenvalues()$/;"	f	class:Eigen::MatrixFunction
pasin	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^Packet pasin(const Packet& a) { return asin(a); }$/;"	f	namespace:Eigen::internal
pasin	vcglib/eigenlib/unsupported/Eigen/src/MoreVectorization/MathFunctions.h	/^template<> EIGEN_DONT_INLINE Packet4f pasin(Packet4f x)$/;"	f	namespace:Eigen::internal
pasin	vcglib/eigenlib/unsupported/Eigen/src/MoreVectorization/MathFunctions.h	/^template<typename Packet> inline static Packet pasin(Packet a) { return std::asin(a); }$/;"	f	namespace:Eigen::internal
pastix_traits	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLDLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
path	vcglib/wrap/gui/trackmode.h	/^  std::vector < Point3f > path;$/;"	m	class:vcg::AreaMode
pathWithoutFileName	vcglib/wrap/io_trimesh/export_idtf.h	/^	static QString pathWithoutFileName(const QString& filepath)$/;"	f	namespace:vcg::tri::io::QtUtilityFunctions
path_length	vcglib/wrap/gui/trackmode.h	/^  float path_length;$/;"	m	class:vcg::PathMode
pause	vcglib/wrap/gcache/controller.h	/^  void pause() {$/;"	f	class:vcg::Controller
paused	vcglib/wrap/gcache/controller.h	/^  bool paused;$/;"	m	class:vcg::Controller
pb_access	vcglib/wrap/ply/plylib.cpp	/^#define pb_access /;"	d	file:
pb_access	vcglib/wrap/ply/plystuff.h	/^#define pb_access /;"	d
pb_close	vcglib/wrap/ply/plylib.cpp	/^#define pb_close /;"	d	file:
pb_close	vcglib/wrap/ply/plystuff.h	/^#define pb_close /;"	d
pb_fclose	vcglib/wrap/ply/plylib.cpp	/^#define pb_fclose /;"	d	file:
pb_fgets	vcglib/wrap/ply/plylib.cpp	/^#define pb_fgets(/;"	d	file:
pb_fopen	vcglib/wrap/ply/plylib.cpp	/^#define pb_fopen /;"	d	file:
pb_fread	vcglib/wrap/ply/plylib.cpp	/^#define pb_fread(/;"	d	file:
pb_fstat	vcglib/wrap/ply/plystuff.h	/^#define pb_fstat /;"	d
pb_mkdir	vcglib/wrap/ply/plylib.cpp	/^#define pb_mkdir(/;"	d	file:
pb_mkdir	vcglib/wrap/ply/plystuff.h	/^#define pb_mkdir(/;"	d
pb_open	vcglib/wrap/ply/plylib.cpp	/^#define pb_open /;"	d	file:
pb_open	vcglib/wrap/ply/plystuff.h	/^#define pb_open /;"	d
pb_stat	vcglib/wrap/ply/plylib.cpp	/^#define pb_stat /;"	d	file:
pb_stat	vcglib/wrap/ply/plystuff.h	/^#define pb_stat /;"	d
pconj	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pconj(const Packet& a) { return conj(a); }$/;"	f	namespace:Eigen::internal
pconj	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a) { return Packet2cf((Packet4f)vec_xor((Packet4ui)a.v, p4ui_CONJ_XOR)); }$/;"	f	namespace:Eigen::internal
pconj	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pconj	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pconj	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pconj	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  inline T pconj(const T& x) { return internal::pconj(x); }$/;"	f	struct:Eigen::internal::conj_if
pconj	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  inline const T& pconj(const T& x) { return x; }$/;"	f	struct:Eigen::internal::conj_if
pcos	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^Packet pcos(const Packet& a) { return cos(a); }$/;"	f	namespace:Eigen::internal
pcos	vcglib/eigenlib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pcos<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pcplxflip	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet pcplxflip(const Packet& a)$/;"	f	namespace:Eigen::internal
pcplxflip	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& x)$/;"	f	namespace:Eigen::internal
pcplxflip	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pcplxflip	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet2cf pcplxflip\/*<Packet2cf>*\/(const Packet2cf& x)$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pdiv(const Packet& a,$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pds	vcglib/vcg/complex/algorithms/point_sampling.h	/^  Stat *pds;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
penWidth	vcglib/wrap/qt/Outline2ToQImage.h	/^      float penWidth;$/;"	m	class:Outline2Dumper::Param
perElementLHS	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void perElementLHS(FaceType *f,$/;"	f	class:vcg::tri::PoissonSolver
perElementLHS	vcglib/wrap/miq/core/poisson_solver.h	/^	void perElementLHS(FaceType *f,$/;"	f	class:PoissonSolver
perElementRHS	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    void perElementRHS(FaceType *f,$/;"	f	class:vcg::tri::PoissonSolver
perElementRHS	vcglib/wrap/miq/core/poisson_solver.h	/^	void perElementRHS(FaceType *f,$/;"	f	class:PoissonSolver
performFrancisQRStep	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)$/;"	f	class:Eigen::RealSchur
permut_matrix_product_retval	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    permut_matrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_matrix_product_retval
permut_matrix_product_retval	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^struct permut_matrix_product_retval$/;"	s	namespace:Eigen::internal
permut_sparsematrix_product_retval	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    permut_sparsematrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval
permut_sparsematrix_product_retval	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^struct permut_sparsematrix_product_retval$/;"	s	namespace:Eigen::internal
permutation	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    PermutationMatrix<Dynamic,Dynamic> permutation;$/;"	m	class:Eigen::LevenbergMarquardt
permutationP	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline const PermutationPType& permutationP() const$/;"	f	class:Eigen::FullPivLU
permutationP	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    inline const PermutationType& permutationP() const$/;"	f	class:Eigen::PartialPivLU
permutationP	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationP() const$/;"	f	class:Eigen::SimplicialCholeskyBase
permutationP	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::SuperLU
permutationP	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::UmfPackLU
permutationPinv	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationPinv() const$/;"	f	class:Eigen::SimplicialCholeskyBase
permutationQ	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline const PermutationQType& permutationQ() const$/;"	f	class:Eigen::FullPivLU
permutationQ	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::SuperLU
permutationQ	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::UmfPackLU
permuteSchur	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void MatrixFunction<MatrixType,AtomicType,1>::permuteSchur()$/;"	f	class:Eigen::MatrixFunction
permute_symm_to_fullsymm	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal
permute_symm_to_symm	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal
pexp	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^Packet pexp(const Packet& a) { return exp(a); }$/;"	f	namespace:Eigen::internal
pexp	vcglib/eigenlib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type pfirst(const Packet& a)$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vst1q_f32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vst1q_s32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double x = _mm_cvtsd_f64(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return a.m128d_f64[0]; }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float x = _mm_cvtss_f32(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return a.m128_f32[0]; }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }$/;"	f	namespace:Eigen::internal
pi	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    int pi;		\/\/index to R[1|2]$/;"	m	struct:vcg::tri::FourPCS::EPoint
pi	vcglib/wrap/miq/core/auxmath.h	/^static const double pi = 3.1415926535897932384626433;$/;"	v
pic_x	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		int ScreenH,ScreenW,pic_x,pic_y,keypress;$/;"	m	class:GLWidget
pic_y	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		int ScreenH,ScreenW,pic_x,pic_y,keypress;$/;"	m	class:GLWidget
pinuse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define pinuse(/;"	d	file:
pivot	vcglib/apps/pivoting/glarea.h	/^    Pivot<CMesh> *pivot;$/;"	m	class:GLArea
pivot	vcglib/apps/pivoting/pivot.h	/^    bool pivot(Hinge &Hinge, int &candidate, Point3f &end_pivot, std::vector<int> &targets) {$/;"	f	class:vcg::tri::Pivot
pl0	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    Plane3x pl0,pl1;$/;"	m	class:vcg::tri::CylinderClipping::CylPred
pl1	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    Plane3x pl0,pl1;$/;"	m	class:vcg::tri::CylinderClipping::CylPred
placePoly	vcglib/vcg/space/rasterized_outline2_packer.h	/^      void placePoly(RasterizedOutline2& poly, Point2i pos, int rast_i) {$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
placeholder	vcglib/wrap/io_trimesh/import_vmi.h	/^    template <int N> struct DummyType{ char placeholder[N]; };$/;"	m	struct:vcg::tri::io::DummyType
plain_array	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^  plain_array() { EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(0xf) }$/;"	f	struct:Eigen::internal::plain_array
plain_array	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^  plain_array() {}$/;"	f	struct:Eigen::internal::plain_array
plain_array	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) {}$/;"	f	struct:Eigen::internal::plain_array
plain_array	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^struct plain_array$/;"	s	namespace:Eigen::internal
plain_array	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>$/;"	s	namespace:Eigen::internal
plain_array	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 16>$/;"	s	namespace:Eigen::internal
plain_matrix_type	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct plain_matrix_type<T,Sparse>$/;"	s	namespace:Eigen::internal
plane	vcglib/vcg/simplex/face/component_ep.h	/^	::vcg::Plane3<typename CoordType::ScalarType> plane;$/;"	m	struct:vcg::face::EdgePlaneInfo
plane	vcglib/wrap/gui/trackmode.h	/^  Plane3f plane;$/;"	m	class:vcg::AreaMode
plane	vcglib/wrap/gui/trackmode.h	/^  Plane3f plane;$/;"	m	class:vcg::PlaneMode
planes	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^		VFrustumPlane planes[6];$/;"	m	class:vcg::AABBBinaryTreeFrustumCull::VFrustum
planes	vcglib/wrap/gui/frustum.h	/^  Plane3<T> planes[6];  $/;"	m	class:vcg::Frustum
pload	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pload(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*   from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>(&real_ref(*from))); }$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }$/;"	f	namespace:Eigen::internal
pload	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^ploaddup(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*     from)$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
ploaddup	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploadt	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^inline Packet ploadt(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^ploadu(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)   { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>(&real_ref(*from))); }$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_pd(from); }$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*    from) { EIGEN_DEBUG_UNALIGNED_LOAD return _mm_loadu_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
ploadu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal
plog	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^Packet plog(const Packet& a) { return log(a); }$/;"	f	namespace:Eigen::internal
plog	vcglib/eigenlib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f plog<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
plset	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^plset(const Scalar& a) { return a; }$/;"	f	namespace:Eigen::internal
plset	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return vec_add(pset1<Packet4f>(a), p4f_COUNTDOWN); }$/;"	f	namespace:Eigen::internal
plset	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)     { return vec_add(pset1<Packet4i>(a), p4i_COUNTDOWN); }$/;"	f	namespace:Eigen::internal
plset	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a)$/;"	f	namespace:Eigen::internal
plset	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)$/;"	f	namespace:Eigen::internal
plset	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<double>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }$/;"	f	namespace:Eigen::internal
plset	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }$/;"	f	namespace:Eigen::internal
plset	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }$/;"	f	namespace:Eigen::internal
ply	vcglib/wrap/ply/plylib.cpp	/^  namespace ply{$/;"	n	namespace:vcg	file:
ply	vcglib/wrap/ply/plylib.h	/^namespace ply {$/;"	n	namespace:vcg
ply	vcglib/wrap/ply/plystuff.h	/^namespace ply {$/;"	n	namespace:vcg
pm	vcglib/apps/sample/polygonmesh_base/polygonmesh.cpp	/^MyPolyMesh pm;$/;"	v
pmadd	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pmadd(const Packet&  a,$/;"	f	namespace:Eigen::internal
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vec_madd(a, b, c); }$/;"	f	namespace:Eigen::internal
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vmlaq_f32(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return vmlaq_s32(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal
pmadd	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const RealScalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const RealScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const { return internal::pmadd(x,y,c); }$/;"	f	struct:Eigen::internal::conj_helper
pmadd	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmax	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pmax(const Packet& a,$/;"	f	namespace:Eigen::internal
pmax	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmax	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmax	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmaxq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmax	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmaxq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmax	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmax	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmax	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmin	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pmin(const Packet& a,$/;"	f	namespace:Eigen::internal
pmin	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmin	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmin	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vminq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmin	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vminq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmin	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmin	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmin	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pmul(const Packet& a,$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<double> pmul(const std::complex<double>& a, const std::complex<double>& b)$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<float> pmul(const std::complex<float>& a, const std::complex<float>& b)$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_madd(a,b,p4f_ZERO); }$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmulq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmulq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& x, const Packet2d& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet2d& x, const Packet1cd& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& x, const Packet4f& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet4f& x, const Packet2cf& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmul	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const RealScalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const RealScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const { return internal::pmul(x,y); }$/;"	f	struct:Eigen::internal::conj_helper
pmul	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pnegate	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pnegate(const Packet& a) { return -a; }$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return psub<Packet4f>(p4f_ZERO, a); }$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return psub<Packet4i>(p4i_ZERO, a); }$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate<Packet4f>(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return vnegq_f32(a); }$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return vnegq_s32(a); }$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pnegate	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)$/;"	f	namespace:Eigen::internal
pnorm	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar pnorm, xnorm, fnorm1;$/;"	m	class:Eigen::HybridNonLinearSolver
pnorm	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
point	vcglib/vcg/space/index/octree.h	/^            CoordType				point;$/;"	m	struct:vcg::Octree::Neighbour
point2d	vcglib/wrap/tsai/tsaimethods.h	/^	vcg::Point2d point2d;$/;"	m	struct:TsaiCorrelation
point3d	vcglib/wrap/tsai/tsaimethods.h	/^	vcg::Point3d point3d;$/;"	m	struct:TsaiCorrelation
pointAt	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::pointAt( _Scalar t ) const$/;"	f	class:Eigen::ParametrizedLine
pointToPick	vcglib/apps/sample/trimesh_ant_qt/glwidget.h	/^     Point2i pointToPick;$/;"	m	class:GLWidget
pointcull	vcglib/wrap/io_trimesh/import_ptx.h	/^			bool pointcull;$/;"	m	class:vcg::tri::io::ImporterPTX::Info
pointer	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator
pointer	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator_indirection
points	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector<Point2f> points;$/;"	m	class:vcg::RasterizedOutline2
points	vcglib/wrap/gui/trackmode.h	/^  std::vector < Point3f > points;$/;"	m	class:vcg::AreaMode
points	vcglib/wrap/gui/trackmode.h	/^  std::vector < Point3f > points;$/;"	m	class:vcg::PathMode
pointsonly	vcglib/wrap/io_trimesh/import_ptx.h	/^			bool pointsonly;$/;"	m	class:vcg::tri::io::ImporterPTX::Info
poison_disk_sampling	vcg_mesh.cpp	/^void poison_disk_sampling(MyMesh& vcg_mesh,$/;"	f	namespace:vcg::MyAlgorithms
poisson_disk	utils_sampling.cpp	/^void poisson_disk(float radius,$/;"	f	namespace:Utils_sampling
poly_eval	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^T poly_eval( const Polynomials& poly, const T& x )$/;"	f	namespace:Eigen
poly_eval_horner	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^T poly_eval_horner( const Polynomials& poly, const T& x )$/;"	f	namespace:Eigen
polygons	vcglib/wrap/miq/quadrangulator.h	/^    std::vector<std::vector<TriVertexType *> > polygons;$/;"	m	class:Quadrangulator
polynomialsolver	vcglib/eigenlib/unsupported/test/polynomialsolver.cpp	/^void polynomialsolver(int deg)$/;"	f
pop	vcglib/vcg/complex/algorithms/update/selection.h	/^  bool pop()$/;"	f	class:vcg::tri::SelectionStack
popMax	vcglib/wrap/gcache/dheap.h	/^  T *popMax() { Item i = heap.popMax(); return i.value; }$/;"	f	class:PtrDHeap
popMax	vcglib/wrap/gcache/dheap.h	/^  T popMax() {$/;"	f	class:DHeap
popMin	vcglib/wrap/gcache/dheap.h	/^  T *popMin() { Item i = heap.popMin(); return i.value; }$/;"	f	class:PtrDHeap
popMin	vcglib/wrap/gcache/dheap.h	/^  T popMin() {$/;"	f	class:DHeap
pop_back	vcglib/vcg/container/vector_occ.h	/^void vector_occ<VALUE_TYPE>::pop_back(){$/;"	f	class:vcg::vector_occ
por	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^por(const Packet& a, const Packet& b) { return a | b; }$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_or(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vorrq_s32(a,b); }$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_or_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_or_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }$/;"	f	namespace:Eigen::internal
por	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }$/;"	f	namespace:Eigen::internal
pos	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		vcg::face::Pos< MyStraightMesh::FaceType> pos;$/;"	m	class:GLWidget
pos	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    vcg::Point3<ScalarType> pos;$/;"	m	struct:vcg::tri::FourPCS::EPoint
pos	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^PosType pos;$/;"	m	class:vcg::tetra::TetraEdgeCollapse
pos	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^  VertexPair pos;$/;"	m	class:vcg::tri::TriEdgeCollapse
pos	vcglib/wrap/io_trimesh/export_vmi.h	/^        static unsigned int & pos(){static unsigned int  p = 0; return p;}$/;"	f	class:vcg::tri::io::ExporterVMI
pos	vcglib/wrap/io_trimesh/import_vmi.h	/^        static unsigned int & pos(){static unsigned int  p = 0; return p;}$/;"	f	class:vcg::tri::io::ImporterVMI
position	vcglib/wrap/gui/coordinateframe.h	/^  Point3f position;$/;"	m	class:vcg::MovableCoordinateFrame
positionQuality	vcglib/wrap/io_trimesh/export_u3d.h	/^		int positionQuality;$/;"	m	struct:vcg::tri::io::u3dparametersclasses::IDTFConverterParameters
positionQuality	vcglib/wrap/io_trimesh/export_u3d.h	/^		int positionQuality;$/;"	m	struct:vcg::tri::io::u3dparametersclasses::Movie15Parameters
post	vcglib/wrap/system/multithreading/semaphore.h	/^  void post(void)$/;"	f	class:mt::semaphore
postLink	vcglib/wrap/glw/program.h	/^		void postLink(void)$/;"	f	class:glw::Program
pow	vcglib/eigenlib/Eigen/src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<Derived>& exponents) $/;"	f	namespace:std
pow	vcglib/eigenlib/Eigen/src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent) {$/;"	f	namespace:std
pow	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(pow, Scalar) pow(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal
pow	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::pow(const Scalar& exponent) const$/;"	f	class:Eigen::Cwise
pow	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^pow(const Scalar& exponent) const$/;"	f
pow	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^pow(const Eigen::AutoDiffScalar<DerType>& x, typename Eigen::internal::traits<DerType>::Scalar y)$/;"	f	namespace:Eigen
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const double a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long double a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const long int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const mpz_t b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const mpreal& a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const long double b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const mpreal& b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const unsigned int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal pow(const unsigned long int a, const unsigned long int b, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
pow_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct pow_default_impl$/;"	s	namespace:Eigen::internal
pow_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct pow_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
pow_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct pow_impl : pow_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
pow_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct pow_retval$/;"	s	namespace:Eigen::internal
pp	vcglib/vcg/complex/algorithms/local_optimization.h	/^  BaseParameterClass *pp;$/;"	m	class:vcg::LocalOptimization
pp0	vcglib/wrap/gl/tetramesh.h	/^			Point3x pp0;$/;"	m	class:vcg::tetra::GlTetramesh::ClipPlane
pp1	vcglib/wrap/gl/tetramesh.h	/^			Point3x pp1;$/;"	m	class:vcg::tetra::GlTetramesh::ClipPlane
pp2	vcglib/wrap/gl/tetramesh.h	/^			Point3x pp2;$/;"	m	class:vcg::tetra::GlTetramesh::ClipPlane
pp3	vcglib/wrap/gl/tetramesh.h	/^			Point3x	pp3;$/;"	m	class:vcg::tetra::GlTetramesh::ClipPlane
preComputeRadius	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		float preComputeRadius;$/;"	m	struct:SplatRenderer::UniformParameters
preGenFlag	vcglib/vcg/complex/algorithms/point_sampling.h	/^  bool preGenFlag;        \/\/ when generating a poisson distribution, you can initialize the set of computed points with ALL the vertices of another mesh. Useful for building progressive refinements.$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
preGenMesh	vcglib/vcg/complex/algorithms/point_sampling.h	/^  MetroMesh *preGenMesh;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
pre_image	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^													*	pre_image;		\/*!< The set of entries in the uniform grid whose image through \\f$h_1\\f$ is this entry.*\/$/;"	m	struct:vcg::PerfectSpatialHashing::OffsetTable::PreImage
precision	vcglib/apps/test/camerashot/camerashot_test.cpp	/^static double precision = 0.000000001;  \/\/ 1e-9$/;"	v	file:
precision	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  int precision;$/;"	m	struct:Eigen::IOFormat
precision	vcglib/eigenlib/Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T precision () { return NumTraits<T>::dummy_precision(); }$/;"	f	namespace:Eigen
precision	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    RealScalar precision() const {$/;"	f	class:Eigen::SkylineInplaceLU
precompteAllCrosses	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    void precompteAllCrosses(){$/;"	f	class:vcg::tri::Zonohedron
precomputedCross	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    std::vector< Vec3 > precomputedCross;$/;"	m	class:vcg::tri::Zonohedron
preconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner& preconditioner() { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase
preconditioner	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Preconditioner& preconditioner() const { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase
pred	vcglib/vcg/complex/algorithms/geodesic.h	/^    pred(){}$/;"	f	struct:vcg::tri::Geodesic::pred
pred	vcglib/vcg/complex/algorithms/geodesic.h	/^  struct pred: public std::binary_function<VertDist,VertDist,bool>{$/;"	s	class:vcg::tri::Geodesic
predux	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_max_op
predux	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_min_op
predux	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_sum_op
predux	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_product_op
predux	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux(const Packet& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) { return pfirst(_mm_hadd_pd(a, a)); }$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_max(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_max	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_max	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_min(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_min	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_min	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_mul(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^preduxp(const Packet* vecs) { return vecs[0]; }$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar> inline void prefetch(const Scalar* addr)$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { vec_dstt((float *)addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { __pld((float *)addr); }$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { __pld(addr); }$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { __pld(addr); }$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prepare_attrib	vcglib/wrap/gui/trackutils.h	/^void prepare_attrib()$/;"	f	namespace:vcg::trackutils
prepend_alloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void* prepend_alloc(mstate m, char* newbase, char* oldbase,$/;"	f	file:
prered	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar actred, prered;$/;"	m	class:Eigen::HybridNonLinearSolver
prered	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
prerotate	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
prerotate	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
prescale	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
prescale	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::prescale(Scalar s)$/;"	f	class:Eigen::Transform
prescale	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
prescale	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::prescale(Scalar s)$/;"	f	class:Eigen::Transform
preserveFixedSeed	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  bool preserveFixedSeed;       \/\/\/ If true the 'fixed' seeds are not moved during relaxation.$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
preshear	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::preshear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform
preshear	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::preshear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform
pretranslate	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
pretranslate	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
prev	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_Chord * prev;$/;"	m	struct:vcg::tri::PolychordCollapse::PC_Chord
prev_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define prev_chunk(/;"	d	file:
prev_foot	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t                    prev_foot;$/;"	m	struct:malloc_tree_chunk	file:
prev_foot	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t               prev_foot;  \/* Size of previous chunk (if free).  *\/$/;"	m	struct:malloc_chunk	file:
preventUpdateFlag	vcglib/vcg/complex/allocate.h	/^                bool preventUpdateFlag; \/\/\/ when true no update is considered necessary.$/;"	m	class:vcg::tri::Allocator::PointerUpdater
preverse	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet preverse(const Packet& a)$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) { return (Packet4f)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) { return (Packet4i)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) {$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) {$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a) { return Packet2cf(_mm_castpd_ps(preverse(_mm_castps_pd(a.v)))); }$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal
preverse	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal
previous	vcglib/apps/pivoting/pivot.h	/^      std::list<Hinge>::iterator previous;$/;"	m	struct:vcg::tri::Hinge
previous	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  std::list<FrontEdge>::iterator previous;$/;"	m	class:vcg::tri::FrontEdge
pri	vcglib/vcg/complex/algorithms/local_optimization.h	/^    float pri;$/;"	m	struct:vcg::LocalOptimization::HeapElem
print	vcglib/vcg/math/matrix44.h	/^	void print() {$/;"	f	class:vcg::Matrix44
print	vcglib/vcg/math/old_matrix44.h	/^	void print() {std::cout << *this << "\\n\\n";}$/;"	f	class:vcg::Matrix44
printInfoLog	vcglib/eigenlib/unsupported/test/openglsupport.cpp	/^void printInfoLog(GLuint objectID)$/;"	f
printNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^void ClassNode::printNode()$/;"	f	class:ClassNode
printNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^void ClassesNode::printNode()$/;"	f	class:ClassesNode
printNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^void OwnSlotsNode::printNode()$/;"	f	class:OwnSlotsNode
printNode	vcglib/apps/trimeshinfo/InstancesNode.h	/^void InstanceNode::printNode()$/;"	f	class:InstanceNode
printNode	vcglib/apps/trimeshinfo/InstancesNode.h	/^void InstancesNode::printNode()$/;"	f	class:InstancesNode
printNode	vcglib/apps/trimeshinfo/Node.h	/^void NodeGroup::printNode()$/;"	f	class:NodeGroup
printNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^void EntryNode::printNode()$/;"	f	class:EntryNode
printNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^void OwnSlotNode::printNode()$/;"	f	class:OwnSlotNode
printNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^void SlotNode::printNode()$/;"	f	class:SlotNode
printNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^void SlotsNode::printNode()$/;"	f	class:SlotsNode
printNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^void ValueNode::printNode()$/;"	f	class:ValueNode
printNode	vcglib/apps/trimeshinfo/XMLTree.h	/^void MainNode::printNode()$/;"	f	class:MainNode
printVector	vcglib/vcg/space/rasterized_outline2_packer.h	/^    static void printVector(std::vector<int>& vec) {$/;"	f	class:vcg::RasterizedOutline2Packer
printXMLTree	vcglib/apps/trimeshinfo/XMLTree.h	/^void XMLTree::printXMLTree()$/;"	f	class:XMLTree
print_every_n_elements	vcglib/apps/metro/sampling.h	/^		int print_every_n_elements         ;$/;"	m	class:vcg::Sampling
print_matrix	vcglib/eigenlib/Eigen/src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)$/;"	f	namespace:Eigen::internal
printhelp	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^void printhelp()$/;"	f
priority	vcglib/wrap/gcache/token.h	/^    Priority priority;$/;"	m	class:vcg::Token
prod	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::prod() const$/;"	f	class:Eigen::DenseBase
prod	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_prod>::Type prod() const$/;"	f	class:Eigen::VectorwiseOp
prod_matvec5	vcglib/vcg/math/quadric5.h	/^  void inline prod_matvec5(const ScalarType m[5][5], const ScalarType v[5], ScalarType r[5])$/;"	f	namespace:vcg::math
prod_vecmat5	vcglib/vcg/math/quadric5.h	/^  void inline prod_vecmat5(ScalarType v[5],ScalarType m[5][5], ScalarType r[5])$/;"	f	namespace:vcg::math
product_coeff_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, 0, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,1>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,RhsCols>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,LhsRows,1>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_unroller	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_unroller	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller<0, Lhs, Rhs, Packet>$/;"	s	namespace:Eigen::internal
product_packet_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_size_category	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<int Size, int MaxSize> struct product_size_category$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,LhsIsTriangular,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,false,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,true,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix_trmm	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^struct product_triangular_matrix_matrix_trmm :$/;"	s	namespace:Eigen::internal
product_type	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<typename Lhs, typename Rhs> struct product_type$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	s	namespace:Eigen::internal
prog	vcglib/wrap/gl/shaders.h	/^	Program prog;$/;"	m	class:ProgramVF
proj	vcglib/vcg/complex/algorithms/refine_loop.h	/^	Projection proj;$/;"	m	struct:vcg::tri::EvenPointLoopGeneric
proj	vcglib/vcg/complex/algorithms/refine_loop.h	/^	Projection proj;$/;"	m	struct:vcg::tri::OddPointLoopGeneric
proj	vcglib/wrap/gui/view.h	/^  Matrix44<T> proj;$/;"	m	class:vcg::View
projCenter	vcglib/wrap/io_edgemesh/export_svg.h	/^	Point3f projCenter; \/\/ the 3d point that after projection will fall exactly in the center of the ViewBox.$/;"	m	class:vcg::tri::io::SVGProperties
projDir	vcglib/wrap/io_edgemesh/export_svg.h	/^	Point3f projDir;	  \/\/ Direction of the Projection$/;"	m	class:vcg::tri::io::SVGProperties
projUp	vcglib/wrap/io_edgemesh/export_svg.h	/^	Point3f projUp;$/;"	m	class:vcg::tri::io::SVGProperties
project	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline void project(std::pair<Point3f,Point3f> &nv) const {$/;"	f	struct:vcg::tri::Centroid
project	vcglib/vcg/complex/algorithms/refine_loop.h	/^	void project(std::pair<Point3f,Point3f>  &nv) const {$/;"	f	struct:vcg::tri::LS3Projection
project	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static CoordType project(VertexType* v, VertexType* vp)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
projectLocal	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static CoordType projectLocal(VertexType* v, VertexType* vp, CoordType ppn)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
projection	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane
projection	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
projection	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane
projection	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
projective_transform_inverse	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse$/;"	s	namespace:Eigen::internal
projective_transform_inverse	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse<TransformType, Projective>$/;"	s	namespace:Eigen::internal
promote	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^complex<long double>  promote(complex<T> x) { return complex<long double>(x.real(),x.imag()); }$/;"	f
promote	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^complex<long double>  promote(double x) { return complex<long double>( x); }$/;"	f
promote	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^complex<long double>  promote(float x) { return complex<long double>( x); }$/;"	f
promote	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^complex<long double>  promote(long double x) { return complex<long double>( x); }$/;"	f
promote_index_type	vcglib/eigenlib/Eigen/src/Core/util/XprHelper.h	/^struct promote_index_type$/;"	s	namespace:Eigen::internal
promote_storage_type	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Dense,Sparse>$/;"	s	namespace:Eigen::internal
promote_storage_type	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Sparse,Dense>$/;"	s	namespace:Eigen::internal
propname	vcglib/wrap/ply/plylib.h	/^	const char * propname;			\/\/ Nome della propieta'$/;"	m	class:vcg::ply::PropDescriptor
props	vcglib/wrap/ply/plylib.h	/^  std::vector<PlyProperty> props;	\/\/ Vettore dinamico delle property$/;"	m	class:vcg::ply::PlyElement
provider	vcglib/wrap/gcache/controller.h	/^  Provider<Token> provider;$/;"	m	class:vcg::Controller
prune	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::internal::CompressedStorage
prune	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseMatrix
prune	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(const KeepFunc& keep = KeepFunc())$/;"	f	class:Eigen::SparseMatrix
prune	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseVector
prune	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    void prune(Scalar reference, RealScalar epsilon = dummy_precision<RealScalar > ()) {$/;"	f	class:Eigen::SkylineMatrix
prune	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    void prune(Scalar reference, RealScalar epsilon = dummy_precision<RealScalar>()) {$/;"	f	class:Eigen::SkylineStorage
prune	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    void prune(Scalar reference, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::DynamicSparseMatrix
pruneTime	vcglib/vcg/complex/algorithms/point_sampling.h	/^    int pruneTime;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam::Stat
pruned	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    SparseSparseProduct pruned(Scalar reference = 0, RealScalar epsilon = NumTraits<RealScalar>::dummy_precision()) const$/;"	f	class:Eigen::SparseSparseProduct
pset1	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pset1(const typename unpacket_traits<Packet>::type& a) { return a; }$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) {$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   {$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return vdupq_n_f32(from); }$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   { return vdupq_n_s32(from); }$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set_pd(from,from); }$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set1_ps(from); }$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps(from,from,from,from); }$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set1_epi32(from); }$/;"	f	namespace:Eigen::internal
pset1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set_epi32(from,from,from,from); }$/;"	f	namespace:Eigen::internal
pseudoEigenvalueMatrix	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^MatrixType EigenSolver<MatrixType>::pseudoEigenvalueMatrix() const$/;"	f	class:Eigen::EigenSolver
pseudoEigenvectors	vcglib/eigenlib/Eigen/src/Eigenvalues/EigenSolver.h	/^    const MatrixType& pseudoEigenvectors() const$/;"	f	class:Eigen::EigenSolver
pseudo_inverse	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/ConstrainedConjGrad.h	/^void pseudo_inverse(const CMatrix &C, CINVMatrix &CINV)$/;"	f	namespace:Eigen::internal
psin	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^Packet psin(const Packet& a) { return sin(a); }$/;"	f	namespace:Eigen::internal
psin	vcglib/eigenlib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psin<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
psqrt	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^Packet psqrt(const Packet& a) { return sqrt(a); }$/;"	f	namespace:Eigen::internal
psqrt	vcglib/eigenlib/Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstore(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }$/;"	f	namespace:Eigen::internal
pstore	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<Packet4i*>(to), from); }$/;"	f	namespace:Eigen::internal
pstore1	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^inline void pstore1(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)$/;"	f	namespace:Eigen::internal
pstore1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet2d>(double* to, const double& a)$/;"	f	namespace:Eigen::internal
pstore1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet4f>(float* to, const float& a)$/;"	f	namespace:Eigen::internal
pstoret	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^inline void pstoret(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstoreu(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from)$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from)$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) {$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castps_pd(from)); }$/;"	f	namespace:Eigen::internal
pstoreu	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castsi128_pd(from)); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^psub(const Packet& a,$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_sub(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vsubq_f32(a,b); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vsubq_s32(a,b); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_sub_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_sub_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }$/;"	f	namespace:Eigen::internal
psub	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }$/;"	f	namespace:Eigen::internal
ptan	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^Packet ptan(const Packet& a) { return tan(a); }$/;"	f	namespace:Eigen::internal
pthread_acquire_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static FORCEINLINE int pthread_acquire_lock (MLOCK_T *sl) {$/;"	f	file:
pthread_init_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static int pthread_init_lock (MLOCK_T *sl) {$/;"	f	file:
pthread_mlock_t	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^struct pthread_mlock_t {$/;"	s	file:
pthread_mutexattr_settype	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define pthread_mutexattr_settype(/;"	d	file:
pthread_release_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static FORCEINLINE void pthread_release_lock (MLOCK_T *sl) {$/;"	f	file:
pthread_try_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static FORCEINLINE int pthread_try_lock (MLOCK_T *sl) {$/;"	f	file:
ptrValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^					void * ptrValue;$/;"	m	union:vcg::AABBBinaryTree::AABBBinaryTreeNode::SharedDataUnion
pts	vcglib/wrap/io_trimesh/import_ply.h	/^	int pts[5];$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_RangeGridAux
punpackp	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^EIGEN_STRONG_INLINE void punpackp(Packet4f* vecs)$/;"	f	namespace:Eigen::internal
push	vcglib/vcg/complex/algorithms/update/selection.h	/^  bool push()$/;"	f	class:vcg::tri::SelectionStack
push	vcglib/wrap/gcache/dheap.h	/^  T *push(T *t) {$/;"	f	class:PtrDHeap
push	vcglib/wrap/gcache/dheap.h	/^  void push(const T& elt) {$/;"	f	class:DHeap
pushPriorities	vcglib/wrap/gcache/provider.h	/^  void pushPriorities() {$/;"	f	class:vcg::Provider
pushPriority	vcglib/wrap/gcache/token.h	/^    void pushPriority() {$/;"	f	class:vcg::Token
push_back	vcglib/apps/pivoting/ring.h	/^  iterator push_back(const T& x) {$/;"	f	class:ring
push_back	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^  void push_back(const value_type& x)$/;"	f	class:std::deque
push_back	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^    void push_back(const value_type& x)$/;"	f	class:std::list
push_back	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^  void push_back(const value_type& x)$/;"	f	class:std::vector
push_back	vcglib/vcg/container/simple_temporary_data.h	/^    void push_back(const bool & v)	{ resize(datasize+1); data[datasize] = v;}$/;"	f	class:vcg::VectorNBW
push_back	vcglib/vcg/container/vector_occ.h	/^void vector_occ<VALUE_TYPE>::push_back(const VALUE_TYPE & v){$/;"	f	class:vcg::vector_occ
push_back	vcglib/vcg/simplex/face/component_ocf.h	/^    void push_back(const VALUE_TYPE & v)$/;"	f	class:vcg::face::vector_ocf
push_back	vcglib/vcg/simplex/vertex/component_ocf.h	/^  void push_back(const VALUE_TYPE & v)$/;"	f	class:vcg::vertex::vector_ocf
push_back	vcglib/wrap/gcache/dheap.h	/^  void push_back(T *t) {$/;"	f	class:PtrDHeap
push_front	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^  void push_front(const value_type& x)$/;"	f	class:std::deque
putMarketHeader	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void putMarketHeader(std::string& header,int sym)$/;"	f	namespace:Eigen::internal
putVectorElt	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void putVectorElt(Scalar value, std::ofstream& out)$/;"	f	namespace:Eigen::internal
putVectorElt	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^  inline void putVectorElt(std::complex<Scalar> value, std::ofstream& out)$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^pxor(const Packet& a, const Packet& b) { return a ^ b; }$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_xor(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return veorq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_xor_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_xor_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }$/;"	f	namespace:Eigen::internal
pxor	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }$/;"	f	namespace:Eigen::internal
pythagora	vcglib/vcg/math/old_lin_algebra.h	/^	inline static TYPE pythagora(TYPE a, TYPE b)$/;"	f	namespace:vcg
q	vcglib/apps/tridecimator/tridecimator.cpp	/^  math::Quadric<double> q;$/;"	m	class:MyVertex	file:
q	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^    PC_ResultCode q;$/;"	m	struct:vcg::tri::PolychordCollapse::PC_Chord
q	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& q() { return data[14];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
q	vcglib/wrap/io_tetramesh/import_ply.h	/^	float q;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
q	vcglib/wrap/io_tetramesh/import_ply.h	/^	float q;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_VertAux
q	vcglib/wrap/io_trimesh/import_ply.h	/^	float q; \/\/ the confidence$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
q	vcglib/wrap/io_trimesh/import_ply.h	/^	float q;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
qFont	vcglib/wrap/qt/gl_label.h	/^      QFont qFont;$/;"	m	class:vcg::glLabel::Mode
qr	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^MatrixBase<Derived>::qr() const$/;"	f	class:Eigen::MatrixBase
qr_preconditioner_impl	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^> struct qr_preconditioner_impl {};$/;"	s	namespace:Eigen::internal
qr_preconditioner_impl	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, QRPreconditioner, Case, false>$/;"	c	namespace:Eigen::internal
qr_preconditioner_should_do_anything	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^struct qr_preconditioner_should_do_anything$/;"	s	namespace:Eigen::internal
qrsolv	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/qrsolv.h	/^void qrsolv($/;"	f	namespace:Eigen::internal
qt_cursor	vcglib/wrap/gui/rubberband.h	/^  QPoint qt_cursor;$/;"	m	class:vcg::Rubberband
qtf	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::HybridNonLinearSolver
qtf	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType  fvec, qtf, diag;$/;"	m	class:Eigen::LevenbergMarquardt
quadQuality	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static ScalarType quadQuality(FaceType *f, int edgeInd){$/;"	f	class:vcg::tri::BitQuad
quadQuality	vcglib/vcg/complex/algorithms/bitquad_support.h	/^static ScalarType quadQuality(const CoordType &a, const CoordType &b, const CoordType &c, const CoordType &d){$/;"	f	class:vcg::tri::BitQuad
qualifyNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^int ClassNode::qualifyNode()$/;"	f	class:ClassNode
qualifyNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^int ClassesNode::qualifyNode()$/;"	f	class:ClassesNode
qualifyNode	vcglib/apps/trimeshinfo/ClassesNode.h	/^int OwnSlotsNode::qualifyNode()$/;"	f	class:OwnSlotsNode
qualifyNode	vcglib/apps/trimeshinfo/InstancesNode.h	/^int InstanceNode::qualifyNode()$/;"	f	class:InstanceNode
qualifyNode	vcglib/apps/trimeshinfo/InstancesNode.h	/^int InstancesNode::qualifyNode()$/;"	f	class:InstancesNode
qualifyNode	vcglib/apps/trimeshinfo/Node.h	/^int NodeGroup::qualifyNode()$/;"	f	class:NodeGroup
qualifyNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^int EntryNode::qualifyNode()$/;"	f	class:EntryNode
qualifyNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^int OwnSlotNode::qualifyNode()$/;"	f	class:OwnSlotNode
qualifyNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^int SlotNode::qualifyNode()$/;"	f	class:SlotNode
qualifyNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^int SlotsNode::qualifyNode()$/;"	f	class:SlotsNode
qualifyNode	vcglib/apps/trimeshinfo/SlotsNode.h	/^int ValueNode::qualifyNode()$/;"	f	class:ValueNode
qualifyNode	vcglib/apps/trimeshinfo/XMLTree.h	/^int MainNode::qualifyNode()$/;"	f	class:MainNode
quality	vcglib/vcg/complex/algorithms/hole.h	/^  ScalarType quality;$/;"	m	class:vcg::tri::TrivialEar
quat_product	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^template<int Arch, class Derived1, class Derived2, typename Scalar, int _Options> struct quat_product$/;"	s	namespace:Eigen::internal
quat_product	vcglib/eigenlib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, double, Aligned>$/;"	s	namespace:Eigen::internal
quat_product	vcglib/eigenlib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, float, Aligned>$/;"	s	namespace:Eigen::internal
quaternionbase_assign_impl	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,3,3>$/;"	s	namespace:Eigen::internal
quaternionbase_assign_impl	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,4,1>$/;"	s	namespace:Eigen::internal
queryCacheSizes	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_amd	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel_codes	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_codes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel_direct	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_direct(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryL1CacheSize	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline int queryL1CacheSize()$/;"	f	namespace:Eigen::internal
queryTopLevelCacheSize	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline int queryTopLevelCacheSize()$/;"	f	namespace:Eigen::internal
quit	vcglib/wrap/gcache/cache.h	/^    bool quit;$/;"	m	class:vcg::Cache
r	vcglib/apps/pivoting/ring.h	/^    list<T>* r;$/;"	m	class:ring::iterator
r	vcglib/vcg/complex/algorithms/smooth.h	/^    unsigned int r;$/;"	m	class:vcg::tri::Smooth::ColorSmoothInfo
r	vcglib/vcg/complex/algorithms/update/color.h	/^    unsigned int r;$/;"	m	class:vcg::tri::UpdateColor::ColorAvgInfo
r	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        double& r() { return data[15];}$/;"	f	class:vcg::tri::Fitmaps::Bicubic
r	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^		Ray3<ScalarType> r;$/;"	m	class:vcg::AABBBinaryTreeRay::Ray3Ex
r	vcglib/vcg/space/index/space_iterators.h	/^		RayType r;							\/\/ray to find intersections$/;"	m	class:vcg::RayIterator
r	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char r;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
r	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char r;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_VertAux
r	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char r;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
r	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char r;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
r0	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  VertexPointer r0,r1;$/;"	m	class:vcg::tri::VoronoiProcessing::VoronoiEdge
r1	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  ScalarType r1,r2;$/;"	m	class:vcg::tri::FourPCS
r1	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  VertexPointer r0,r1;$/;"	m	class:vcg::tri::VoronoiProcessing::VoronoiEdge
r1mpyq	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/r1mpyq.h	/^void r1mpyq(DenseIndex m, DenseIndex n, Scalar *a, const std::vector<JacobiRotation<Scalar> > &v_givens, const std::vector<JacobiRotation<Scalar> > &w_givens)$/;"	f	namespace:Eigen::internal
r1updt	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/r1updt.h	/^void r1updt($/;"	f	namespace:Eigen::internal
r2	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  ScalarType r1,r2;$/;"	m	class:vcg::tri::FourPCS
radSorter	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^        radSorter(VertexType* v)$/;"	f	class:vcg::tri::Fitmaps::radSorter
radSorter	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    class radSorter$/;"	c	class:vcg::tri::Fitmaps
radius	vcglib/apps/pivoting/glarea.h	/^    float radius;$/;"	m	class:GLArea
radius	vcglib/apps/pivoting/pivot.h	/^    float radius;  \/\/default 1 (not meaningful$/;"	m	class:vcg::tri::Pivot
radius	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  double radius;$/;"	m	struct:Ball	file:
radius	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  ScalarType radius;$/;"	m	class:vcg::tri::FourPCS
radius	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  float radius;          \/\/radius of the ball$/;"	m	class:vcg::tri::BallPivoting
radius	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    ScalarType radius;$/;"	m	class:vcg::tri::CylinderClipping::CylPred
radius	vcglib/vcg/space/index/space_iterators.h	/^		ScalarType radius;			  \/\/curret radius for sphere expansion$/;"	m	class:vcg::ClosestIterator
radius	vcglib/wrap/gui/trackball.h	/^  float radius; $/;"	m	class:vcg::Transform
radius	vcglib/wrap/io_trimesh/import_ply.h	/^	float radius;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
radiusScale	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		float radiusScale;$/;"	m	struct:SplatRenderer::UniformParameters
radiusSph	vcglib/vcg/complex/algorithms/symmetry.h	/^    int radiusSph;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
radiusVariance	vcglib/vcg/complex/algorithms/point_sampling.h	/^  float radiusVariance;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam
radix	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^T radix(){ return 2; }$/;"	f	namespace:Eigen::internal
radix2	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^T radix2(){ return radix<T>()*radix<T>(); }$/;"	f	namespace:Eigen::internal
random	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()$/;"	f	namespace:Eigen::internal
random	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal
random	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal random(unsigned int seed)$/;"	f	namespace:mpfr
random2	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal random2 (mp_size_t size, mp_exp_t exp)$/;"	f	namespace:mpfr
randomColor	vcglib/wrap/qt/Outline2ToQImage.h	/^      bool randomColor;$/;"	m	class:Outline2Dumper::Param
randomMatrixWithImagEivals	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^struct randomMatrixWithImagEivals$/;"	s	file:
randomMatrixWithImagEivals	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^struct randomMatrixWithImagEivals<MatrixType, 0>$/;"	s	file:
randomMatrixWithImagEivals	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^struct randomMatrixWithImagEivals<MatrixType, 1>$/;"	s	file:
randomMatrixWithRealEivals	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^MatrixType randomMatrixWithRealEivals(const typename MatrixType::Index size)$/;"	f
randomTest	vcglib/eigenlib/unsupported/test/matrix_exponential.cpp	/^void randomTest(const MatrixType& m, double tol)$/;"	f
random_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl {};$/;"	s	namespace:Eigen::internal
random_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
random_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
random_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
random_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
random_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^template<> struct random_impl<bool>$/;"	s	namespace:Eigen::internal
random_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct random_retval$/;"	s	namespace:Eigen::internal
range	vcglib/wrap/gui/frustum.h	/^template <class T> T Frustum<T>::range(Point3<T> &point, T radius, T &closest, T &farthest) {$/;"	f	class:vcg::Frustum
rank	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivLU
rank	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::ColPivHouseholderQR
rank	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivHouseholderQR
rank	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::image_retval_base
rank	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::kernel_retval_base
rank	vcglib/vcg/math/disjoint_set.h	/^			int					 rank;$/;"	m	struct:vcg::DisjointSet::DisjointSetNode
rankUpdate	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::rankUpdate(const MatrixBase<Derived>& w,typename NumTraits<typename MatrixType::Scalar>::Real sigma)$/;"	f	class:Eigen::LDLT
rankUpdate	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)$/;"	f	struct:Eigen::internal::llt_inplace
rankUpdate	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^LLT<_MatrixType,_UpLo> LLT<_MatrixType,_UpLo>::rankUpdate(const VectorType& v, const RealScalar& sigma)$/;"	f	class:Eigen::LLT
rankUpdate	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointProduct.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, Scalar alpha)$/;"	f	class:Eigen::SelfAdjointView
rankUpdate	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, Scalar alpha)$/;"	f	class:Eigen::SelfAdjointView
rankUpdate	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<MatrixType,UpLo>::rankUpdate(const SparseMatrixBase<DerivedU>& u, Scalar alpha)$/;"	f	class:Eigen::SparseSelfAdjointView
rasterSettings	vcglib/wrap/glw/program.h	/^		RasterizerSettings         rasterSettings;$/;"	m	class:glw::ProgramArguments
rasterize	vcglib/wrap/qt/outline2_rasterizer.cpp	/^void QtOutline2Rasterizer::rasterize(RasterizedOutline2 &poly,$/;"	f	class:QtOutline2Rasterizer
rat42_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    rat42_functor(void) : Functor<double>(3,9) {}$/;"	f	struct:rat42_functor
rat42_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct rat42_functor : Functor<double>$/;"	s	file:
rat43_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    rat43_functor(void) : Functor<double>(4,15) {}$/;"	f	struct:rat43_functor
rat43_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct rat43_functor : Functor<double>$/;"	s	file:
ratio	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar ratio;$/;"	m	class:Eigen::HybridNonLinearSolver
ratio	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar ratio;$/;"	m	class:Eigen::LevenbergMarquardt
rawMatrix	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const CholMatrixType rawMatrix() const {$/;"	f	class:Eigen::SimplicialCholesky
rayCastParameter1	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		vcg::Point3f rayCastParameter1;$/;"	m	struct:SplatRenderer::UniformParameters
rayCastParameter2	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^		vcg::Point3f rayCastParameter2;$/;"	m	struct:SplatRenderer::UniformParameters
readColorPixels	vcglib/wrap/glw/framebuffer.h	/^		bool readColorPixels(GLenum target, GLint unit, GLint index, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * data)$/;"	f	class:glw::Framebuffer
readColorPixels	vcglib/wrap/glw/framebuffer.h	/^		bool readColorPixels(GLint index, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * data)$/;"	f	class:glw::BoundReadDrawFramebuffer
readColorPixels	vcglib/wrap/glw/framebuffer.h	/^		bool readColorPixels(GLint index, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * data)$/;"	f	class:glw::BoundReadFramebuffer
readDepthPixels	vcglib/wrap/glw/framebuffer.h	/^		bool readDepthPixels(GLenum target, GLint unit, GLint x, GLint y, GLsizei width, GLsizei height, GLenum type, GLvoid * data)$/;"	f	class:glw::Framebuffer
readDepthPixels	vcglib/wrap/glw/framebuffer.h	/^		bool readDepthPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type, GLvoid * data)$/;"	f	class:glw::BoundReadDrawFramebuffer
readDepthPixels	vcglib/wrap/glw/framebuffer.h	/^		bool readDepthPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type, GLvoid * data)$/;"	f	class:glw::BoundReadFramebuffer
readPTX	vcglib/wrap/io_trimesh/import_ptx.h	/^		static bool readPTX( OpenMeshType &m, FILE *fp, Info importparams, CallBackPos *cb=NULL)$/;"	f	class:vcg::tri::io::ImporterPTX
readStencilPixels	vcglib/wrap/glw/framebuffer.h	/^		bool readStencilPixels(GLenum target, GLint unit, GLint x, GLint y, GLsizei width, GLsizei height, GLenum type, GLvoid * data)$/;"	f	class:glw::Framebuffer
readStencilPixels	vcglib/wrap/glw/framebuffer.h	/^		bool readStencilPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type, GLvoid * data)$/;"	f	class:glw::BoundReadDrawFramebuffer
readStencilPixels	vcglib/wrap/glw/framebuffer.h	/^		bool readStencilPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type, GLvoid * data)$/;"	f	class:glw::BoundReadFramebuffer
readTextFile	vcglib/wrap/glw/utility.h	/^inline std::string readTextFile(const char * fileName)$/;"	f	namespace:glw
readTextFile	vcglib/wrap/glw/utility.h	/^inline std::string readTextFile(const std::string & fileName)$/;"	f	namespace:glw
read_fitmaps	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^bool read_fitmaps(CMesh &m, const char *fn)$/;"	f
readelemcb	vcglib/wrap/ply/plylib.h	/^typedef bool (* readelemcb) ( GZFILE fp, void * mem, PropDescriptor * p );$/;"	t	namespace:vcg::ply
readline	vcglib/wrap/io_trimesh/import_nvm.h	/^static void readline(FILE *fp, char *line, int max=1000){$/;"	f	class:vcg::tri::io::ImporterNVM
readline	vcglib/wrap/io_trimesh/import_out.h	/^static void readline(FILE *fp, char *line, int max=100){$/;"	f	class:vcg::tri::io::ImporterOUT
readmesh	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^int readmesh(FILE* fp)$/;"	f
real	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real, Scalar) real(const Scalar& x)$/;"	f	namespace:Eigen::internal
real	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^real() const { return derived(); }$/;"	f
real	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^real() { return derived(); }$/;"	f
real	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^inline const AutoDiffScalar<DerType>& real(const AutoDiffScalar<DerType>& x)  { return x; }$/;"	f	namespace:Eigen
realRoots	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline void realRoots( Stl_back_insertion_sequence& bi_seq,$/;"	f	class:Eigen::PolynomialSolverBase
realRoots_to_monicPolynomial_scalar	vcglib/eigenlib/unsupported/test/polynomialutils.cpp	/^template<typename _Scalar> void realRoots_to_monicPolynomial_scalar()$/;"	f
realRoots_to_monicPolynomial_test	vcglib/eigenlib/unsupported/test/polynomialutils.cpp	/^void realRoots_to_monicPolynomial_test(int deg)$/;"	f
real_2x2_jacobi_svd	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^void real_2x2_jacobi_svd(const MatrixType& matrix, Index p, Index q,$/;"	f	namespace:Eigen::internal
real_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct real_impl$/;"	s	namespace:Eigen::internal
real_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct real_impl<std::complex<RealScalar> >$/;"	s	namespace:Eigen::internal
real_ref	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) real_ref(Scalar& x)$/;"	f	namespace:Eigen::internal
real_ref	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline typename add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) >::type real_ref(const Scalar& x)$/;"	f	namespace:Eigen::internal
real_ref_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct real_ref_impl$/;"	s	namespace:Eigen::internal
real_ref_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct real_ref_retval$/;"	s	namespace:Eigen::internal
real_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct real_retval$/;"	s	namespace:Eigen::internal
real_twiddles	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    Complex * real_twiddles(int ncfft2)$/;"	f	struct:Eigen::internal::kissfft_impl
reallocate	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    void reallocate(Index size)$/;"	f	class:Eigen::internal::AmbiVector
reallocate	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline void reallocate(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage
reallocate	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline void reallocate(Index diagSize, Index upperProfileSize, Index lowerProfileSize, Index upperSize, Index lowerSize) {$/;"	f	class:Eigen::SkylineStorage
reallocateSparse	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    void reallocateSparse()$/;"	f	class:Eigen::internal::AmbiVector
rebind	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator
rebind	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator_indirection
rebuild	vcglib/wrap/gcache/dheap.h	/^  void rebuild() { $/;"	f	class:DHeap
rebuild	vcglib/wrap/gcache/dheap.h	/^  void rebuild() { heap.rebuild(); }$/;"	f	class:PtrDHeap
rebuild	vcglib/wrap/gcache/provider.h	/^  void rebuild() {$/;"	f	class:vcg::Provider
rec_sqrt	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal rec_sqrt(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
reconstructedMatrix	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^MatrixType LDLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LDLT
reconstructedMatrix	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^MatrixType LLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LLT
reconstructedMatrix	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^MatrixType FullPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::FullPivLU
reconstructedMatrix	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^MatrixType PartialPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::PartialPivLU
rectSetToOutline2Vec	vcglib/wrap/qt/Outline2ToQImage.cpp	/^void Outline2Dumper::rectSetToOutline2Vec(vector< Box2f > &rectVec, vector< vector<Point2f> > &outline2Vec)$/;"	f	class:Outline2Dumper
recursiveStep	vcglib/wrap/dae/xmldocumentmanaging.h	/^	void recursiveStep(XMLInteriorNode& intnode)$/;"	f	class:XMLDocumentWriter
reduceNoiseLevel	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void reduceNoiseLevel() { if (m_noise > 0) m_noise--; }$/;"	f	class:Eigen::IterationController
reduceToTriangularForm	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^void ComplexSchur<MatrixType>::reduceToTriangularForm(bool computeU)$/;"	f	class:Eigen::ComplexSchur
redux	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::redux(const Func& func) const$/;"	f	class:Eigen::DenseBase
redux	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    redux(const BinaryOp& func = BinaryOp()) const$/;"	f	class:Eigen::VectorwiseOp
redux_impl	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, SliceVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_impl<Func,Derived, DefaultTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller$/;"	s	namespace:Eigen::internal
redux_novec_unroller	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 0>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
redux_traits	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_traits$/;"	s	namespace:Eigen::internal
redux_vec_unroller	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_vec_unroller$/;"	s	namespace:Eigen::internal
redux_vec_unroller	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^struct redux_vec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
ref	vcglib/wrap/glw/bookkeeping.h	/^		void ref(void)$/;"	f	class:glw::detail::RefCountedObject
ref	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline bool ref()$/;"	f	class:mt::atomicInt
ref	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline bool ref()$/;"	f	class:mt::atomicInt
refCount	vcglib/wrap/glw/bookkeeping.h	/^		int refCount(void) const$/;"	f	class:glw::detail::RefCountedObject
refIlluminant	vcglib/vcg/space/colorspace.h	/^	static Illuminant refIlluminant(RGBSpaces rgb_space)$/;"	f	class:vcg::ColorSpace
refMesh	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            static TriMeshType* &refMesh()$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
refObject	vcglib/wrap/glw/bookkeeping.h	/^		RefCountedObjectType * refObject(void) const$/;"	f	class:glw::detail::ObjectSharedPointer
refX	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline VectorType& refX() $/;"	f	class:Eigen::MatrixMarketIterator
reference	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator
reference	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar reference;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func
reference	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator_indirection
referenceToANodeAttribute	vcglib/wrap/dae/util_dae.h	/^		inline static void referenceToANodeAttribute(const QDomNode n,const QString& attr,QString& url_st)$/;"	f	class:vcg::tri::io::UtilDAE
referredBit	vcglib/apps/metro/sampling.h	/^		int referredBit                    ;$/;"	m	class:vcg::Sampling
refinementRatio	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  float refinementRatio;        \/\/\/ It defines how much the input mesh has to be refined in order to have a supporting$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
regionNum	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^     int regionNum;$/;"	m	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam::Stat
release	vcglib/wrap/glw/context.h	/^		void release(void)$/;"	f	class:glw::Context
release	vcglib/wrap/system/multithreading/semaphore.h	/^  void release(int n=1)$/;"	f	class:mt::semaphore
release_checks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t     release_checks;$/;"	m	struct:malloc_state	file:
release_unused_segments	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static size_t release_unused_segments(mstate m) {$/;"	f	file:
relerr	vcglib/eigenlib/unsupported/test/matrix_exponential.cpp	/^double relerr(const MatrixBase<Derived>& A, const MatrixBase<OtherDerived>& B)$/;"	f
remainder	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal remainder (const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
remap	vcglib/vcg/complex/allocate.h	/^                std::vector<size_t> remap; \/\/ this vector keep the new position of an element. Uninitialized elements have max_int value to denote an element that has not to be remapped.$/;"	m	class:vcg::tri::Allocator::PointerUpdater
remove	vcglib/wrap/gcache/token.h	/^    bool remove() {$/;"	f	class:vcg::Token
removeAllColorTargets	vcglib/wrap/glw/framebuffer.h	/^		bool removeAllColorTargets(GLenum target, GLint unit)$/;"	f	class:glw::Framebuffer
removeAllColorTargets	vcglib/wrap/glw/framebuffer.h	/^		bool removeAllColorTargets(void)$/;"	f	class:glw::BoundFramebuffer
removeAllTargets	vcglib/wrap/glw/framebuffer.h	/^		bool removeAllTargets(GLenum target, GLint unit)$/;"	f	class:glw::Framebuffer
removeAllTargets	vcglib/wrap/glw/framebuffer.h	/^		bool removeAllTargets(void)$/;"	f	class:glw::BoundFramebuffer
removeChildNode	vcglib/wrap/dae/util_dae.h	/^		inline static bool removeChildNode(QDomNode node,const QString& tag = "", const QString& attribname = "", const QString& attribvalue = "")$/;"	f	class:vcg::tri::io::UtilDAE
removeChildNodeList	vcglib/wrap/dae/util_dae.h	/^		inline static bool removeChildNodeList(QDomNodeList& nodelst,const QString& tag = "", const QString& attribname = "", const QString& attribvalue = "")$/;"	f	class:vcg::tri::io::UtilDAE
removeColorTarget	vcglib/wrap/glw/framebuffer.h	/^		bool removeColorTarget(GLenum target, GLint unit, GLint index)$/;"	f	class:glw::Framebuffer
removeColorTarget	vcglib/wrap/glw/framebuffer.h	/^		bool removeColorTarget(GLint index)$/;"	f	class:glw::BoundFramebuffer
removeConvertedTGATextures	vcglib/wrap/io_trimesh/export_idtf.h	/^	static void removeConvertedTGATextures(const QStringList& convfile)$/;"	f	class:vcg::tri::io::ExporterIDTF
removeConvertedTexturesFiles	vcglib/wrap/io_trimesh/export_idtf.h	/^	static void removeConvertedTexturesFiles(const QStringList& conv_file)$/;"	f	class:vcg::tri::io::TGA_Exporter
removeDepthTarget	vcglib/wrap/glw/framebuffer.h	/^		bool removeDepthTarget(GLenum target, GLint unit)$/;"	f	class:glw::Framebuffer
removeDepthTarget	vcglib/wrap/glw/framebuffer.h	/^		bool removeDepthTarget(void)$/;"	f	class:glw::BoundFramebuffer
removeStencilTarget	vcglib/wrap/glw/framebuffer.h	/^		bool removeStencilTarget(GLenum target, GLint unit)$/;"	f	class:glw::Framebuffer
removeStencilTarget	vcglib/wrap/glw/framebuffer.h	/^		bool removeStencilTarget(void)$/;"	f	class:glw::BoundFramebuffer
removeTokens	vcglib/wrap/gcache/controller.h	/^  template<class FUNCTOR> void removeTokens(FUNCTOR functor) {$/;"	f	class:vcg::Controller
remove_all	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_all	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_const	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	s	namespace:Eigen::internal
remove_const	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	s	namespace:Eigen::internal
remove_doublet	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static FacePointer remove_doublet(MeshType &m, FacePointer fp, queue<FacePointer> *q = NULL)$/;"	f	class:vcg::tri::HalfedgeQuadClean
remove_doublets	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static int remove_doublets(MeshType &m)$/;"	f	class:vcg::tri::HalfedgeQuadClean
remove_doublets	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static void remove_doublets(MeshType &m, set<FacePointer> &faces)$/;"	f	class:vcg::tri::HalfedgeQuadClean
remove_doublets	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static void remove_doublets(MeshType &m, set<FacePointer> &faces, queue<FacePointer> &q)$/;"	f	class:vcg::tri::HalfedgeQuadClean
remove_doublets	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static void remove_doublets(MeshType &m, set<FacePointer> &faces, vector<VertexPointer> vertices)$/;"	f	class:vcg::tri::HalfedgeQuadClean
remove_doublets	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static void remove_doublets(MeshType &m, vector<VertexPointer> vertices)$/;"	f	class:vcg::tri::HalfedgeQuadClean
remove_face	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static bool remove_face(MeshType &m, FacePointer fp)$/;"	f	class:vcg::tri::HalfEdgeTopology
remove_face_unsafe	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static void remove_face_unsafe (MeshType &m, FacePointer fp)$/;"	f	class:vcg::tri::HalfEdgeTopology
remove_pointer	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_singlets	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            static int remove_singlets(MeshType &m)$/;"	f	class:vcg::tri::HalfedgeQuadClean
remquo	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^const mpreal remquo (long* q, const mpreal& x, const mpreal& y, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
render	vcglib/wrap/qt/gl_label.h	/^    static void render(QPainter *painter, const vcg::Point3d &p, const QString &text)$/;"	f	class:vcg::glLabel
render	vcglib/wrap/qt/gl_label.h	/^    static void render(QPainter *painter, const vcg::Point3d &p, const QString &text, Mode &m)$/;"	f	class:vcg::glLabel
render	vcglib/wrap/qt/gl_label.h	/^    static void render(QPainter *painter, const vcg::Point3f &p, const QString &text)$/;"	f	class:vcg::glLabel
render	vcglib/wrap/qt/gl_label.h	/^    static void render(QPainter *painter, const vcg::Point3f &p, const QString &text, Mode &m)$/;"	f	class:vcg::glLabel
render2D	vcglib/wrap/qt/gl_label.h	/^    static void render2D(QPainter *painter, const LabelPosition pos, const QString &text, const Mode &m=Mode())$/;"	f	class:vcg::glLabel
render2D	vcglib/wrap/qt/gl_label.h	/^    static void render2D(QPainter *painter, const LabelPosition pos, int linePos, const QString &text, const Mode &m=Mode())$/;"	f	class:vcg::glLabel
render2D	vcglib/wrap/qt/gl_label.h	/^    static void render2D(QPainter *painter, const vcg::Point2f &p, const QString &text, const Mode &m)$/;"	f	class:vcg::glLabel
renderTargets	vcglib/wrap/gl/fbo.h	/^	RTMap renderTargets;$/;"	m	class:FrameBuffer
renderbufferTarget	vcglib/wrap/glw/framebuffer.h	/^inline RenderTarget renderbufferTarget(RenderbufferHandle & handle)$/;"	f	namespace:glw
rendering_settings	vcglib/vcg/space/index/octree.h	/^        OcreeRenderingSetting					rendering_settings;$/;"	m	namespace:vcg
replace_dv	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define replace_dv(/;"	d	file:
replicate	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^DenseBase<Derived>::replicate() const$/;"	f	class:Eigen::DenseBase
replicate	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^DenseBase<Derived>::replicate(Index rowFactor,Index colFactor) const$/;"	f	class:Eigen::DenseBase
replicate	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^VectorwiseOp<ExpressionType,Direction>::replicate(Index factor) const$/;"	f	class:Eigen::VectorwiseOp
replicate	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    replicate(Index factor = Factor) const$/;"	f	class:Eigen::VectorwiseOp
request2size	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define request2size(/;"	d	file:
requireExtension	vcglib/wrap/glw/utility.h	/^		ThisType & requireExtension(const std::string & ext)$/;"	f	class:glw::ShaderHeaderBuilder
required_argument	vcglib/wrap/system/getopt.h	/^#define required_argument	/;"	d
res	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  Scalar res;$/;"	m	struct:Eigen::internal::coeff_visitor
reserve	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    void reserve(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage
reserve	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(Index reserveSize)$/;"	f	class:Eigen::SparseMatrix
reserve	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::Scalar& enableif =$/;"	f	class:Eigen::SparseMatrix
reserve	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = typename SizesType::value_type())$/;"	f	class:Eigen::SparseMatrix
reserve	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline void reserve(Index reserveSize) { m_data.reserve(reserveSize); }$/;"	f	class:Eigen::SparseVector
reserve	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline void reserve(Index reserveSize, Index reserveUpperSize, Index reserveLowerSize) {$/;"	f	class:Eigen::SkylineMatrix
reserve	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    void reserve(Index size, Index upperProfileSize, Index lowerProfileSize, Index upperSize, Index lowerSize) {$/;"	f	class:Eigen::SkylineStorage
reserve	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    void reserve(Index reserveSize = 1000)$/;"	f	class:Eigen::DynamicSparseMatrix
reserve	vcglib/vcg/container/simple_temporary_data.h	/^    void reserve (const int & sz)	{$/;"	f	class:vcg::VectorNBW
reserve	vcglib/vcg/container/vector_occ.h	/^void vector_occ<VALUE_TYPE>::reserve(const unsigned int & size){$/;"	f	class:vcg::vector_occ
reserve	vcglib/vcg/simplex/face/component_ocf.h	/^  void reserve(const unsigned int & _size)$/;"	f	class:vcg::face::vector_ocf
reserve	vcglib/vcg/simplex/vertex/component_ocf.h	/^	void reserve(const unsigned int & _size)$/;"	f	class:vcg::vertex::vector_ocf
reserve	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void reserve(int nnz){  $/;"	f	class:SparseMatrixData
reserveInnerVectors	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserveInnerVectors(const SizesType& reserveSizes)$/;"	f	class:Eigen::SparseMatrix
reset	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline void reset() {$/;"	f	class:Eigen::SkylineStorage
reset	vcglib/img/img_attributes.h	/^  inline void reset()$/;"	f	class:img::ImgAttributes
reset	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline void reset() {$/;"	f	struct:vcg::tri::Centroid
reset	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline void reset() {$/;"	f	struct:vcg::tri::LS3Projection
resetParameters	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    void resetParameters(void) { parameters = Parameters(); }$/;"	f	class:Eigen::HybridNonLinearSolver
resetParameters	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    void resetParameters(void) { parameters = Parameters(); }$/;"	f	class:Eigen::LevenbergMarquardt
resetState	vcglib/vcg/space/rasterized_outline2_packer.h	/^    void resetState(int totalRasterizationsNum) {$/;"	f	class:vcg::RasterizedOutline2
reset_on_error	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void reset_on_error(mstate m) {$/;"	f	file:
residual	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double residual() const { return m_res; }$/;"	f	class:Eigen::IterationController
resize	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index nbRows, Index nbCols) { m_expression.const_cast_derived().resize(nbRows,nbCols); }$/;"	f	class:Eigen::ArrayWrapper
resize	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index nbRows, Index nbCols) { m_expression.const_cast_derived().resize(nbRows,nbCols); }$/;"	f	class:Eigen::MatrixWrapper
resize	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.const_cast_derived().resize(newSize); }$/;"	f	class:Eigen::ArrayWrapper
resize	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.const_cast_derived().resize(newSize); }$/;"	f	class:Eigen::MatrixWrapper
resize	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
resize	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    void resize(Index size)$/;"	f	class:Eigen::DenseBase
resize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex rows, DenseIndex)$/;"	f	class:Eigen::DenseStorage
resize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage
resize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex, DenseIndex rows, DenseIndex cols) { m_rows = rows; m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
resize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex, DenseIndex rows, DenseIndex) { m_rows = rows; }$/;"	f	class:Eigen::DenseStorage
resize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex, DenseIndex, DenseIndex cols) { m_cols = cols; }$/;"	f	class:Eigen::DenseStorage
resize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void resize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage
resize	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    void resize(DenseIndex size, DenseIndex rows, DenseIndex cols)$/;"	f	class:Eigen::DenseStorage
resize	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline void resize(Index size) { m_diagonal.resize(size); }$/;"	f	class:Eigen::DiagonalMatrix
resize	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PermutationBase
resize	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resize(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
resize	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index rows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase
resize	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PlainObjectBase
resize	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(NoChange_t, Index cols)$/;"	f	class:Eigen::PlainObjectBase
resize	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline void resize(int size)$/;"	f	class:Eigen::TranspositionsBase
resize	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    void resize(Index size)$/;"	f	class:Eigen::internal::AmbiVector
resize	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    void resize(size_t size, float reserveSizeFactor = 0)$/;"	f	class:Eigen::internal::CompressedStorage
resize	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix
resize	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::SparseVector
resize	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseVector
resize	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size)$/;"	f	class:std::deque
resize	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::deque
resize	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size)$/;"	f	class:std::list
resize	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size, const value_type& x)$/;"	f	class:std::list
resize	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size)$/;"	f	class:std::vector
resize	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::vector
resize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    void resize(size_t rows, size_t cols) {$/;"	f	class:Eigen::SkylineMatrix
resize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    void resize(Index diagSize, Index upperProfileSize, Index lowerProfileSize, Index upperSize, Index lowerSize, float reserveSizeFactor = 0) {$/;"	f	class:Eigen::SkylineStorage
resize	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::DynamicSparseMatrix
resize	vcglib/vcg/container/simple_temporary_data.h	/^    void resize  (const int & sz)	{$/;"	f	class:vcg::VectorNBW
resize	vcglib/vcg/container/vector_occ.h	/^void vector_occ<VALUE_TYPE>::resize(const unsigned int & size){$/;"	f	class:vcg::vector_occ
resize	vcglib/vcg/simplex/face/component_ocf.h	/^  void resize(const unsigned int & _size)$/;"	f	class:vcg::face::vector_ocf
resize	vcglib/vcg/simplex/vertex/component_ocf.h	/^	void resize(const unsigned int & _size)$/;"	f	class:vcg::vertex::vector_ocf
resize	vcglib/wrap/gcache/dheap.h	/^  void resize(int n) { assert(n <= (int)heap.size()); return heap.resize(n, Item(NULL)); }$/;"	f	class:PtrDHeap
resizeAndKeepData	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    void resizeAndKeepData(Index rows, Index cols)$/;"	f	class:Eigen::DynamicSparseMatrix
resizeGL	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::resizeGL(int w, int h) {   $/;"	f	class:GLArea
resizeGL	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::resizeGL (int w, int h)$/;"	f	class:GLArea
resizeGL	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void GLWidget::resizeGL (int w, int h)$/;"	f	class:GLWidget
resizeGL	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^ void GLWidget::resizeGL(int w,int h){$/;"	f	class:GLWidget
resizeLike	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)$/;"	f	class:Eigen::PlainObjectBase
resizeNonZeros	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    void resizeNonZeros(Index size)$/;"	f	class:Eigen::SparseMatrix
resizeNonZeros	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    void resizeNonZeros(Index size) { m_data.resize(size); }$/;"	f	class:Eigen::SparseVector
resizeNonZeros	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    void resizeNonZeros(Index size) {$/;"	f	class:Eigen::SkylineMatrix
resolution	vcglib/wrap/gui/frustum.h	/^  T resolution;  $/;"	m	class:vcg::Frustum
restart	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::restart()$/;"	f	class:Eigen::internal::AmbiVector
restoreConvertedTextures	vcglib/wrap/io_trimesh/export_idtf.h	/^	static void restoreConvertedTextures(SaveMeshType& mesh_with_textures_to_be_restored,const QStringList& textures_to_be_restored)$/;"	f	class:vcg::tri::io::ExporterIDTF
result_of	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType)> {$/;"	s	namespace:Eigen::internal
result_of	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType0,ArgType1)> {$/;"	s	namespace:Eigen::internal
result_of	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct result_of {};$/;"	s	namespace:Eigen::internal
result_type	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef NewType result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op
result_type	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs2_op
result_type	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs_op
result_type	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_op
result_type	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_ref_op
result_type	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_op
result_type	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_ref_op
result_type	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_conj_product_op
result_type	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_product_op
result_type	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<Scalar1,Scalar2>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_multiple2_op
result_type	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^                   >::type  result_type;$/;"	t	struct:Eigen::internal::member_redux
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<double>				{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<int64_t  >			{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<int>					{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<long double>			{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<long int>			{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<mpq_t>				{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<mpreal>				{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<mpz_t>				{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<uint64_t >			{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<unsigned int>		{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<unsigned long int>	{typedef mpreal type;};	$/;"	s	namespace:mpfr::internal
result_type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <typename ArgumentType> struct result_type {};	$/;"	s	namespace:mpfr::internal
resume	vcglib/wrap/gcache/controller.h	/^  void resume() {$/;"	f	class:vcg::Controller
ret	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon61
ret	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon63
ret	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::InnerStrideAtCompileTime };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon60
ret	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::OuterStrideAtCompileTime };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon62
ret	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_allows_mixing_real_and_complex { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_allows_mixing_real_and_complex::__anon102
ret	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon100
ret	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_allows_mixing_real_and_complex::__anon104
ret	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_allows_mixing_real_and_complex<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_allows_mixing_real_and_complex::__anon103
ret	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon101
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon147
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon155
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon154
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon156
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon149
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon153
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon158
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon157
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon163
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon166
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon161
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon164
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon152
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon151
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon159
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon148
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon162
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon165
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon160
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon150
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon146
ret	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon145
ret	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  enum { ret =    bool(blas_traits<DerivedA>::IsTransposed) != DestIsTransposed$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon250
ret	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  enum { ret = bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed };$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon249
ret	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { ret = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0 };$/;"	e	enum:Eigen::internal::has_direct_access::__anon267
ret	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^    enum { ret = meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::internal::__anon313
ret	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:Eigen::meta_sqrt::__anon314
ret	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^{ enum { ret = false }; };$/;"	e	enum:Eigen::is_diagonal::__anon315
ret	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon316
ret	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon317
ret	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon318
ret	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^    enum { ret = ei_meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::__anon346
ret	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^class ei_meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:ei_meta_sqrt::__anon347
ret	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_meta_false::__anon343
ret	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	t	struct:Eigen::ei_meta_if
ret	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	t	struct:Eigen::ei_meta_if
ret	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_meta_true::__anon342
ret	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon344
ret	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon345
ret	vcglib/eigenlib/Eigen/src/Householder/Householder.h	/^    ret = n==Dynamic ? n : n-1$/;"	e	enum:Eigen::internal::decrement_size::__anon381
ret	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^         ret = !( (QRPreconditioner == NoQRPreconditioner) ||$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon437
ret	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^{ typedef Sparse ret; };$/;"	t	struct:Eigen::internal::promote_storage_type
ret	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    ret = (Size == Dynamic) ? Dynamic : Size-1 };$/;"	e	enum:Eigen::internal::decrement_if_fixed_size::__anon448
ret	vcglib/eigenlib/unsupported/test/polynomialsolver.cpp	/^    ret = (Size == Dynamic) ? Dynamic : Size+1$/;"	e	enum:Eigen::internal::increment_if_fixed_size::__anon477	file:
ret	vcglib/eigenlib/unsupported/test/polynomialutils.cpp	/^    ret = (Size == Dynamic) ? Dynamic : Size+1$/;"	e	enum:Eigen::internal::increment_if_fixed_size::__anon478	file:
ret	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            VertexPointer ret;$/;"	m	class:vcg::tri::QuadDiagonalCollapseBase
retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::atan2_default_impl
retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::pow_default_impl
reverse	vcglib/apps/pivoting/ring.h	/^  void reverse() { lst.reverse(); }$/;"	f	class:ring
reverse	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^DenseBase<Derived>::reverse() const$/;"	f	class:Eigen::DenseBase
reverse	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^DenseBase<Derived>::reverse()$/;"	f	class:Eigen::DenseBase
reverse	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const Reverse<ExpressionType, Direction> reverse() const$/;"	f	class:Eigen::VectorwiseOp
reverseInPlace	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^inline void DenseBase<Derived>::reverseInPlace()$/;"	f	class:Eigen::DenseBase
reverse_packet	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    typedef internal::reverse_packet_cond<PacketScalar,ReversePacket> reverse_packet;$/;"	t	class:Eigen::Reverse
reverse_packet_cond	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^template<typename PacketScalar, bool ReversePacket> struct reverse_packet_cond$/;"	s	namespace:Eigen::internal
reverse_packet_cond	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^template<typename PacketScalar> struct reverse_packet_cond<PacketScalar,false>$/;"	s	namespace:Eigen::internal
rgbChMask	vcglib/vcg/complex/algorithms/update/color.h	/^enum rgbChMask {ALL_CHANNELS = 7, RED_CHANNEL = 4, GREEN_CHANNEL = 2, BLUE_CHANNEL = 1, NO_CHANNELS = 0 };$/;"	g	class:vcg::tri::UpdateColor
rhs	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CwiseBinaryOp
rhs	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	class:Product
rhs	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::ProductBase
rhs	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CoeffBasedProduct
rhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct
rhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDiagonalProduct
rhs	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseSparseProduct
rhs	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::solve_retval_base
rhs	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
rhs	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const {$/;"	f	class:Eigen::internal::SkylineProduct
rhs	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline VectorType& rhs() $/;"	f	class:Eigen::MatrixMarketIterator
rhsNorm	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    double rhsNorm() const { return m_rhsn; }$/;"	f	class:Eigen::IterationController
rhs_length	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^  Index rhs_length;$/;"	m	struct:Eigen::internal::GemmParallelInfo
rhs_start	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^  Index rhs_start;$/;"	m	struct:Eigen::internal::GemmParallelInfo
rightAlign	vcglib/wrap/qt/gl_label.h	/^      bool rightAlign;$/;"	m	class:vcg::glLabel::Mode
rightCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr rightCols(Index n)$/;"	f
rightCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr rightCols(Index n) const$/;"	f
rightCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type rightCols() const$/;"	f
rightCols	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type rightCols()$/;"	f
rightHouseholderSequence	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType,OnTheRight> rightHouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen
ring	vcglib/apps/pivoting/ring.h	/^class ring {$/;"	c
rint	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal rint(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
rint_ceil	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal rint_ceil (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
rint_floor	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal rint_floor(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
rint_round	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal rint_round(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
rint_trunc	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal rint_trunc(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
rms	vcglib/vcg/math/histogram.h	/^	ScalarType rms; 	\/\/! Root mean square.$/;"	m	class:vcg::Histogram
rms	vcglib/vcg/math/histogram.h	/^	double rms;$/;"	m	class:vcg::Distribution
room	vcglib/wrap/gcache/door.h	/^  mt::mutex room;     \/\/lock when entering. unlock when exiting$/;"	m	class:QDoor
room	vcglib/wrap/gcache/door.h	/^  mt::mutex room;$/;"	m	class:QDoor
root	vcglib/apps/trimeshinfo/XMLTree.h	/^	NodeGroup root;$/;"	m	class:XMLTree
root	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal root(const mpreal& v, unsigned long int k, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
roots	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RootsType& roots() const { return m_roots; }$/;"	f	class:Eigen::PolynomialSolverBase
roots_to_monicPolynomial	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialUtils.h	/^void roots_to_monicPolynomial( const RootVector& rv, Polynomial& poly )$/;"	f	namespace:Eigen
rot	vcglib/vcg/math/shot.h	/^      RotoType rot;	 \/\/ rotation$/;"	m	class:vcg::Shot::ReferenceFrame
rot	vcglib/vcg/math/similarity.h	/^  RotationType rot;$/;"	m	class:vcg::Similarity
rotRad	vcglib/vcg/math/similarity2.h	/^  SCALAR_TYPE rotRad;$/;"	m	class:vcg::Similarity2
rot_snap_rad	vcglib/wrap/gui/activecoordinateframe.h	/^  float rot_snap_rad,mov_snap;$/;"	m	class:vcg::ActiveCoordinateFrame
rotate	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
rotate	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
rotateGridCWise	vcglib/wrap/qt/outline2_rasterizer.cpp	/^vector<vector<int> > QtOutline2Rasterizer::rotateGridCWise(vector< vector<int> >& inGrid) {$/;"	f	class:QtOutline2Rasterizer
rotate_button	vcglib/wrap/gui/activecoordinateframe.h	/^  const int move_button,rotate_button;$/;"	m	class:vcg::ActiveCoordinateFrame
rotation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotation() const$/;"	f	class:Eigen::Transform
rotation	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotation() const$/;"	f	class:Eigen::Transform
rotation	vcglib/wrap/gui/coordinateframe.h	/^  Quaternionf rotation;$/;"	m	class:vcg::MovableCoordinateFrame
rotationNum	vcglib/vcg/space/rasterized_outline2_packer.h	/^      int rotationNum;$/;"	m	class:vcg::RasterizedOutline2Packer::Parameters
rotation_base_generic_product_selector	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector< RotationDerived, DiagonalMatrix<Scalar,Dim,MaxDim>, false >$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,MatrixType,false>$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,OtherVectorType,true>$/;"	s	namespace:Eigen::internal
rotx	vcglib/wrap/gui/activecoordinateframe.h	/^  int movx,movy,movz,rotx,roty,rotz;$/;"	m	class:vcg::ActiveCoordinateFrame
roty	vcglib/wrap/gui/activecoordinateframe.h	/^  int movx,movy,movz,rotx,roty,rotz;$/;"	m	class:vcg::ActiveCoordinateFrame
rotz	vcglib/wrap/gui/activecoordinateframe.h	/^  int movx,movy,movz,rotx,roty,rotz;$/;"	m	class:vcg::ActiveCoordinateFrame
round	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal round(const mpreal& v)$/;"	f	namespace:mpfr
row	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::all_unroller::__anon51
row	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::any_unroller::__anon52
row	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon241
row	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon242
row	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon254
row	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::visitor_impl::__anon326
row	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor
row	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::DenseBase::InnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::SparseInnerVectorSet::ReverseInnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::row(Index i)$/;"	f	class:Eigen::SparseMatrixBase
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^const SparseInnerVectorSet<Derived,1> SparseMatrixBase<Derived>::row(Index i) const$/;"	f	class:Eigen::SparseMatrixBase
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return Lhs::IsRowMajor ? m_lhsIter.row() : index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_lhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_rhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index row() const { return Transpose ? Base::row() : m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index row() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseTranspose.h	/^    inline typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return Base::row(); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return Base::row(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^  const Index& row() const { return m_row; }$/;"	f	class:Eigen::Triplet
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::InnerIterator
row	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
row	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowXpr row(Index i) const$/;"	f
row	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline RowXpr row(Index i)$/;"	f
row	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index row() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
row	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index row() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
row	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::SparseInnerVectorSet::InnerIterator
row	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : Base::index(); }$/;"	f	class:Eigen::DynamicSparseMatrix::InnerIterator
row	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : Base::index(); }$/;"	f	class:Eigen::DynamicSparseMatrix::ReverseInnerIterator
rowIndexByOuterInner	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
rowOffset	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value()>0 ? 0 : -m_index.value(); }$/;"	f	class:Eigen::Diagonal
rowPrefix	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowSeparator	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowSpacer	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowStride	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index rowStride() const$/;"	f	class:Eigen::DenseCoeffsBase
rowSuffix	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowind	vcglib/wrap/miq/core/sparsesystemdata.h	/^  unsigned int*  rowind()   { return m_rowind  ; }$/;"	f	class:SparseMatrixData
rows	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LDLT
rows	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LLT
rows	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline Index rows() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase
rows	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ArrayWrapper
rows	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::MatrixWrapper
rows	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrix
rows	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
rows	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline Index rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::Block
rows	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::CwiseBinaryOp
rows	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::CwiseNullaryOp
rows	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::CwiseUnaryOp
rows	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::CwiseUnaryView
rows	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex rows(void) const {return _Rows;}$/;"	f	class:Eigen::DenseStorage
rows	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline DenseIndex rows(void) const {return m_rows;}$/;"	f	class:Eigen::DenseStorage
rows	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    static inline DenseIndex rows(void) {return _Rows;}$/;"	f	class:Eigen::DenseStorage
rows	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^    inline Index rows() const$/;"	f	class:Eigen::Diagonal
rows	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline Index rows() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase
rows	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::DiagonalProduct
rows	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  inline Index rows() const { return derived().rows(); }$/;"	f	struct:Eigen::EigenBase
rows	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Flagged
rows	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ForceAlignedAccess
rows	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::MapBase
rows	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::NestByValue
rows	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline Index rows() const { return indices().size(); }$/;"	f	class:Eigen::PermutationBase
rows	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval
rows	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline int rows() const { return m_permutation.rows(); }$/;"	f	class:Eigen::Transpose
rows	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }$/;"	f	class:Eigen::PlainObjectBase
rows	vcglib/eigenlib/Eigen/src/Core/Product.h	/^    inline Index rows() const { return m_lhs.rows(); }$/;"	f	class:Product
rows	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    inline Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::ProductBase
rows	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^    inline Index rows() const { return m_matrix.rows() * m_rowFactor.value(); }$/;"	f	class:Eigen::Replicate
rows	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^    inline Index rows() const { return static_cast<const Derived*>(this)->rows(); }$/;"	f	class:Eigen::ReturnByValue
rows	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Reverse
rows	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    Index rows() const { return m_condition.rows(); }$/;"	f	class:Eigen::Select
rows	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfAdjointView
rows	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp
rows	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  inline Index rows() const { return m_rhs.rows(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval
rows	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::SwapWrapper
rows	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline Index rows() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Transpose
rows	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval
rows	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::TriangularBase
rows	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::TriangularView
rows	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    Index rows() const { return (Direction==Vertical   ? 1 : m_matrix.rows()); }$/;"	f	class:Eigen::PartialReduxExpr
rows	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::CoeffBasedProduct
rows	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^    inline Index rows() const { return m_matrix.rows() - 1; }$/;"	f	class:Eigen::Minor
rows	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index rows() const { return m_hess.packedMatrix().rows(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
rows	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
rows	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^    inline Index rows() const { return m_matrix.rows() + (int(Direction)==Vertical   ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous
rows	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
rows	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
rows	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    Index rows() const { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }$/;"	f	class:Eigen::HouseholderSequence
rows	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index rows() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner
rows	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::IncompleteLUT
rows	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index rows() const { return mp_matrix ? mp_matrix->rows() : 0; }$/;"	f	class:Eigen::IterativeSolverBase
rows	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::FullPivLU
rows	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::inverse_impl
rows	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::PartialPivLU
rows	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PastixBase
rows	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl
rows	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::ColPivHouseholderQR
rows	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
rows	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::FullPivHouseholderQR
rows	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::HouseholderQR
rows	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    inline Index rows() const { return m_rows; }$/;"	f	class:Eigen::JacobiSVD
rows	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SimplicialCholeskyBase
rows	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::SparseInnerVectorSet
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return Tr ? m_rhs.rows() : m_lhs.rows(); }$/;"	f	class:Eigen::SparseDenseOuterProduct
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseDiagonalProduct
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::SparseMatrix
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::SparseMatrixBase
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseSparseProduct
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSelfAdjointView
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseTriangularView
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsColVector ? m_size : 1; }$/;"	f	class:Eigen::SparseVector
rows	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseView
rows	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SuperLUBase
rows	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index rows() const { return m_copyMatrix.rows(); }$/;"	f	class:Eigen::UmfPackLU
rows	vcglib/eigenlib/Eigen/src/misc/Image.h	/^  inline Index rows() const { return m_dec.rows(); }$/;"	f	struct:Eigen::internal::image_retval_base
rows	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::kernel_retval_base
rows	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base
rows	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess
rows	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
rows	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::IncompleteLU
rows	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^    Index rows() const { return m_src.rows(); }$/;"	f	struct:Eigen::MatrixExponentialReturnValue
rows	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    Index rows() const { return m_A.rows(); }$/;"	f	class:Eigen::MatrixFunctionReturnValue
rows	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  Index rows() const { return m_A.rows(); }$/;"	f	class:Eigen::MatrixLogarithmReturnValue
rows	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^    Index rows() const { return m_src.rows(); }$/;"	f	class:Eigen::MatrixSquareRootReturnValue
rows	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index rows() const {$/;"	f	class:Eigen::SkylineMatrix
rows	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Index rows() const {$/;"	f	class:Eigen::SkylineMatrixBase
rows	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::internal::SkylineProduct
rows	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/BlockOfDynamicSparseMatrix.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::SparseInnerVectorSet
rows	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? outerSize() : m_innerSize; }$/;"	f	class:Eigen::DynamicSparseMatrix
rowsTranspositions	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    const IntColVectorType& rowsTranspositions() const$/;"	f	class:Eigen::FullPivHouseholderQR
rows_select	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    rows_select = product_size_category<Rows,MaxRows>::value,$/;"	e	enum:Eigen::internal::product_type::__anon143
rowwise	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise() const$/;"	f	class:Eigen::DenseBase
rowwise	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise()$/;"	f	class:Eigen::DenseBase
rubberband_handle	vcglib/wrap/gui/trackmode.h	/^  Point3f rubberband_handle ;$/;"	m	class:vcg::AreaMode
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_DONT_INLINE void run(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)$/;"	f	struct:Eigen::internal::unaligned_assign_impl
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }$/;"	f	struct:Eigen::internal::assign_selector
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.eval()); }$/;"	f	struct:Eigen::internal::assign_selector
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose()); }$/;"	f	struct:Eigen::internal::assign_selector
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose().eval()); }$/;"	f	struct:Eigen::internal::assign_selector
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, int) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, int) {}$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, int outer)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, int outer)$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index) {}$/;"	f	struct:Eigen::internal::unaligned_assign_impl
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static inline void run(Derived1 &, const Derived2 &) { }$/;"	f	struct:Eigen::internal::assign_impl
run	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl
run	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^  static inline void run(Derived1& dst, const CwiseUnaryOp<UnaryOp, Derived2>& src)$/;"	f	struct:Eigen::internal::vml_assign_impl
run	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::all_unroller
run	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::any_unroller
run	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat) { return mat.coeff(0, 0); }$/;"	f	struct:Eigen::internal::all_unroller
run	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat) { return mat.coeff(0, 0); }$/;"	f	struct:Eigen::internal::any_unroller
run	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::all_unroller
run	vcglib/eigenlib/Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::any_unroller
run	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& m)$/;"	f	struct:Eigen::internal::setIdentity_impl
run	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived& m)$/;"	f	struct:Eigen::internal::first_aligned_impl
run	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived&)$/;"	f	struct:Eigen::internal::first_aligned_impl
run	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^  static inline RealScalar run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector
run	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^  static inline ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)$/;"	f	struct:Eigen::internal::dot_nocheck
run	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^  static inline typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector
run	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)$/;"	f	struct:Eigen::internal::isApprox_selector
run	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector
run	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, typename Derived::RealScalar)$/;"	f	struct:Eigen::internal::isApprox_selector
run	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived&, typename Derived::RealScalar)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector
run	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar& y, typename Derived::RealScalar prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector
run	vcglib/eigenlib/Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar&, typename Derived::RealScalar)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector
run	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  static EIGEN_DONT_INLINE void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha) {$/;"	f	struct:Eigen::internal::outer_product_selector
run	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  static inline void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)$/;"	f	struct:Eigen::internal::gemv_selector
run	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  static void run(const ProductType& prod, Dest& dest, typename ProductType::Scalar alpha)$/;"	f	struct:Eigen::internal::gemv_selector
run	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^  static inline void run(PacketType&, const PacketType&) {}$/;"	f	struct:Eigen::internal::palign_impl
run	vcglib/eigenlib/Eigen/src/Core/IO.h	/^  static inline int run()$/;"	f	struct:Eigen::internal::significant_decimals_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline NewType run(const OldType& x)$/;"	f	struct:Eigen::internal::cast_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::hypot_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::abs2_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::imag_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::real_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run()$/;"	f	struct:Eigen::internal::random_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar x, Scalar y)$/;"	f	struct:Eigen::internal::pow_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::conj_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::sqrt_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::atan2_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::pow_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::random_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::sqrt_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar&, const Scalar&)$/;"	f	struct:Eigen::internal::atan2_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline bool run()$/;"	f	struct:Eigen::internal::random_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline const Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  static inline std::complex<RealScalar> run(const std::complex<RealScalar>& x)$/;"	f	struct:Eigen::internal::conj_impl
run	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^  static inline void run(MatrixTypeA& a, MatrixTypeB& b)$/;"	f	struct:Eigen::internal::matrix_swap_impl
run	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index rows, Index cols)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index size)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_vec_unroller
run	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_vec_unroller
run	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived&, const Func&) { return Scalar(); }$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^  static Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return preverse(x); }$/;"	f	struct:Eigen::internal::reverse_packet_cond
run	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return x; }$/;"	f	struct:Eigen::internal::reverse_packet_cond
run	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector
run	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector
run	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_selector
run	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_unroller
run	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs&, Rhs&) {}$/;"	f	struct:Eigen::internal::triangular_solver_unroller
run	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    static void run(const Derived& dst, const OtherDerived& other)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl
run	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    static void run(const Derived&, const OtherDerived&)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl
run	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector
run	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const OtherDerived& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector
run	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  static void run(MatrixType& m) {$/;"	f	struct:Eigen::internal::inplace_transpose_selector
run	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector
run	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector
run	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived &mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl
run	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived& mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl
run	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl
run	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE static void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl
run	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl
run	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl
run	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector
run	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector
run	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector
run	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)$/;"	f	struct:Eigen::internal::product_packet_impl
run	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)$/;"	f	struct:Eigen::internal::product_packet_impl
run	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl
run	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)$/;"	f	struct:Eigen::internal::product_coeff_impl
run	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_unroller
run	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl
run	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector
run	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, A& a, B& b, C& c, T& \/*t*\/)$/;"	f	struct:Eigen::internal::gebp_madd_selector
run	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, T& a, T& b, T& c, T& t)$/;"	f	struct:Eigen::internal::gebp_madd_selector
run	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::general_matrix_matrix_product
run	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^static void run(Index rows, Index cols, Index depth,$/;"	f	struct:Eigen::internal::general_matrix_matrix_product
run	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product
run	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product
run	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE static void run($/;"	f	struct:Eigen::internal::general_matrix_vector_product
run	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix
run	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix
run	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::selfadjoint_matrix_vector_product
run	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(Index size, Scalar* mat, Index stride, const Scalar* vec, Scalar alpha)$/;"	f	struct:Eigen::selfadjoint_rank1_update
run	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(MatrixType& mat, const OtherType& other, typename MatrixType::Scalar alpha)$/;"	f	struct:Eigen::selfadjoint_product_selector
run	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, Scalar alpha)$/;"	f	struct:Eigen::internal::selfadjoint_rank2_update_selector
run	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix
run	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix
run	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^  static EIGEN_DONT_INLINE  void run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::triangular_matrix_vector_product
run	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^  static void run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::triangular_matrix_vector_product
run	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^  static void run(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar alpha)$/;"	f	struct:Eigen::internal::trmv_selector
run	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^  static EIGEN_DONT_INLINE void run($/;"	f	struct:Eigen::internal::triangular_solve_matrix
run	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverVector.h	/^  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)$/;"	f	struct:Eigen::internal::triangular_solve_vector
run	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE To run(const From& x) { return x; }$/;"	f	struct:Eigen::internal::get_factor
run	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE typename NumTraits<Scalar>::Real run(const Scalar& x) { return real(x); }$/;"	f	struct:Eigen::internal::get_factor
run	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  static const typename T::Scalar* run(const T& m)$/;"	f	struct:Eigen::internal::extract_data_selector
run	vcglib/eigenlib/Eigen/src/Core/util/BlasUtil.h	/^  static typename T::Scalar* run(const T&) { return 0; }$/;"	f	struct:Eigen::internal::extract_data_selector
run	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^  static inline void run(const T* start, const T* end, T* target)$/;"	f	struct:Eigen::internal::smart_copy_helper
run	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& mat)$/;"	f	struct:Eigen::ei_quaternion_assign_impl
run	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& vec)$/;"	f	struct:Eigen::ei_quaternion_assign_impl
run	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^    static inline void run(Transform *transform, const MatrixBase<OtherDerived>& other)$/;"	f	struct:Eigen::Transform::construct_from_matrix
run	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  static ResultType run(const TransformType& tr, const Other& other)$/;"	f	struct:Eigen::ei_transform_product_impl
run	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^  static void run(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)$/;"	f	struct:Eigen::internal::complex_schur_reduce_to_hessenberg
run	vcglib/eigenlib/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^  run(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::internal::eigenvalues_selector::MatrixBase
run	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& eig, const typename SolverType::MatrixType& A, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
run	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& solver, const MatrixType& mat, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
run	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector
run	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector
run	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  static const type& run (const TransformType& x) { return x.matrix(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  static const type& run(const type &x) { return x; }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  static type run (const TransformType& x) { return x.affine(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl
run	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^  static inline VectorType run(const Derived& src)$/;"	f	struct:Eigen::internal::unitOrthogonal_selector
run	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  static EIGEN_STRONG_INLINE Quaternion<Scalar> run(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b){$/;"	f	struct:Eigen::internal::quat_product
run	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& mat)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl
run	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& vec)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl
run	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^  static EIGEN_STRONG_INLINE ReturnType run(const RotationDerived& r, const OtherVectorType& v)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const MatrixType& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)$/;"	f	struct:Eigen::internal::transform_right_product_impl
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::transform_transform_product_impl
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other, const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other,const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static inline AffinePart run(MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static inline ConstAffinePart run(const MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static inline MatrixType& run(MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static inline const MatrixType& run(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static inline void run(const TransformType& m, TransformType& res)$/;"	f	struct:Eigen::internal::projective_transform_inverse
run	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  static inline void run(const TransformType&, TransformType&)$/;"	f	struct:Eigen::internal::projective_transform_inverse
run	vcglib/eigenlib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl
run	vcglib/eigenlib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<double> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product
run	vcglib/eigenlib/Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<float> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product
run	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^  static inline typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl
run	vcglib/eigenlib/Eigen/src/LU/Determinant.h	/^  static typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl
run	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check
run	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  static inline void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse
run	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4
run	vcglib/eigenlib/Eigen/src/LU/arch/Inverse_SSE.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4
run	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    static Index run( _MKL_DSS_HANDLE_t pt, Index maxfct, Index mnum, Index type, Index phase, Index n, void *a,$/;"	f	struct:Eigen::internal::pardiso_run_selector
run	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  static void run(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q)$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
run	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^  static void run(typename SVD::WorkMatrixType&, SVD&, Index, Index) {}$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
run	vcglib/eigenlib/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	struct:Eigen::internal::conservative_sparse_sparse_product_selector
run	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, typename Res::Scalar alpha)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl
run	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res, RealScalar tolerance)$/;"	f	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
run	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_selector
run	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
run	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static void run(MatrixType& mat, SluMatrix& res)$/;"	f	struct:Eigen::SluMatrixMapHelper
run	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  static void run(A& a, B& b) {$/;"	f	struct:Eigen::internal::make_coherent_impl
run	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^  static void run(A&, B&) {}$/;"	f	struct:Eigen::internal::make_coherent_impl
run	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^    static void run(const Lhs& lhs, const Rhs& rhs, ResultType & res) {$/;"	f	struct:Eigen::internal::skyline_product_selector
run	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^  static MatrixType run(const typename MatrixType::Index size)$/;"	f	struct:randomMatrixWithImagEivals
run	vcglib/eigenlib/unsupported/test/matrix_square_root.cpp	/^  static void run(MatrixType& result, typename MatrixType::Index size)$/;"	f	struct:generateTestMatrix
run	vcglib/vcg/math/eigen.h	/^	static void run(Derived1& a, const Derived2& b) { a = b; }$/;"	f	struct:Eigen::ei_import_selector
run	vcglib/vcg/math/eigen.h	/^	static void run(Derived1& a, const Derived2& b)$/;"	f	struct:Eigen::ei_import_selector
run	vcglib/vcg/math/old_matrix44.h	/^	static ResultType run(const Matrix44<Scalar>& tr, const Other& other)$/;"	f	struct:vcg::ei_matrix44_product_impl
run	vcglib/vcg/math/old_matrix44.h	/^	static ResultType run(const Matrix44<Scalar>& tr, const Other& p)$/;"	f	struct:vcg::ei_matrix44_product_impl
run	vcglib/wrap/gcache/cache.h	/^    void run() {$/;"	f	class:vcg::Cache
run	vcglib/wrap/system/multithreading/thread.h	/^            virtual void run(void)$/;"	f	class:mt::thread
rw	vcglib/wrap/system/multithreading/rw_lock.h	/^		pthread_rwlock_t rw;$/;"	m	class:mt::rw_lock
rw	vcglib/wrap/system/multithreading/scoped_read_lock.h	/^		rw_lock & rw;$/;"	m	class:mt::scoped_read_lock
rw	vcglib/wrap/system/multithreading/scoped_write_lock.h	/^		rw_lock & rw;$/;"	m	class:mt::scoped_write_lock
rw_lock	vcglib/wrap/system/multithreading/rw_lock.h	/^		rw_lock(void)$/;"	f	class:mt::rw_lock
rw_lock	vcglib/wrap/system/multithreading/rw_lock.h	/^class rw_lock$/;"	c	namespace:mt
rwupdt	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/rwupdt.h	/^void rwupdt($/;"	f	namespace:Eigen::internal
s	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar s() const { return m_s; }$/;"	f	class:Eigen::JacobiRotation
s	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    Scalar& s() { return m_s; }$/;"	f	class:Eigen::JacobiRotation
s	vcglib/wrap/system/multithreading/semaphore.h	/^sem_t s;$/;"	m	class:mt::semaphore
s_curr	vcglib/wrap/gcache/cache.h	/^    uint64_t s_curr;$/;"	m	class:vcg::Cache
s_max	vcglib/wrap/gcache/cache.h	/^    uint64_t s_max;$/;"	m	class:vcg::Cache
same_or_left_bits	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define same_or_left_bits(/;"	d	file:
sample	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType sample() const$/;"	f	class:Eigen::AlignedBox
sample001_open_save_color	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample001_open_save_color(QString input_file, QString output_file)$/;"	f
sample002_open_save_grayscale	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample002_open_save_grayscale(QString input_file, QString output_file)$/;"	f
sample003_normalize	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample003_normalize(QString input_file, QString output_file)$/;"	f
sample004_boxfilter	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample004_boxfilter(QString input_file, QString output_file)$/;"	f
sample005_gaussiansmooth	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample005_gaussiansmooth(QString input_file, QString output_file)$/;"	f
sample006_medianfilter	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample006_medianfilter(QString input_file, QString output_file)$/;"	f
sample007_unsharpmask	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample007_unsharpmask(QString input_file, QString output_file)$/;"	f
sample008_laplacianfilter	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample008_laplacianfilter(QString input_file, QString output_file)$/;"	f
sample009_logfilter	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample009_logfilter(QString input_file, QString output_file)$/;"	f
sample010_dogfilter	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample010_dogfilter(QString input_file, QString output_file)$/;"	f
sample011_general_convolutions	vcglib/apps/sample/img_filters/img_filters.cpp	/^void sample011_general_convolutions(QString input_file, QString output_dir,QString output_suffix)$/;"	f
sampleNum	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^   int sampleNum;$/;"	m	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam
sampleNum	vcglib/vcg/complex/algorithms/point_sampling.h	/^    int sampleNum;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam::Stat
sampleVec	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        vector<VertexType*> sampleVec;$/;"	m	class:OverlapEstimation::VertexPointerSampler
sampleVec	vcglib/vcg/complex/algorithms/point_sampling.h	/^  std::vector<CoordType> *sampleVec;$/;"	m	class:vcg::tri::TrivialSampler
sampleVec	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  std::vector<VertexType *> &sampleVec;$/;"	m	class:vcg::tri::ClusteringSampler
sampler	vcglib/wrap/glw/texture2d.h	/^		TextureSampleMode sampler;$/;"	m	class:glw::Texture2DArguments
sampler	vcglib/wrap/glw/texturecube.h	/^		TextureSampleMode sampler;$/;"	m	class:glw::TextureCubeArguments
samples	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        int samples;                                    \/\/\/< Number of samples to check to compute the overlap. Higher values get more accurancy but requires more time.$/;"	m	class:OverlapEstimation::Parameters
samplingTime	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^     int samplingTime;$/;"	m	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam::Stat
save	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::save() {$/;"	f	class:GLArea
saveMarket	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^bool saveMarket(const SparseMatrixType& mat, const std::string& filename, int sym = 0)$/;"	f	namespace:Eigen
saveMarketVector	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MarketIO.h	/^bool saveMarketVector (const VectorType& vec, const std::string& filename)$/;"	f	namespace:Eigen
saveMesh	vcglib/apps/sample/polygonmesh_polychord_collapse/polygonmesh_polychord_collapse.cpp	/^    static int saveMesh (PolyMesh &mesh, const char *filename) {$/;"	f	class:PolyMesh
saveNativeFormat	vcglib/img/img_io.h	/^inline bool saveNativeFormat(const Image<Channels,ScalarType,Safe> &image, const char *filename)$/;"	f	namespace:img
savePGM	vcglib/wrap/qt/img_qt_io.h	/^inline bool savePGM(const Image<1,ScalarType,Safe> &image, const QString filename)$/;"	f	namespace:img
saveQtRGB	vcglib/wrap/qt/img_qt_io.h	/^inline bool saveQtRGB(const Image<3,ScalarType,Safe> &image,const QString filename)$/;"	f	namespace:img
saveQtY	vcglib/wrap/qt/img_qt_io.h	/^inline bool saveQtY(const Image<1,ScalarType,Safe> &image,const QString filename)$/;"	f	namespace:img
saveall	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  bool          saveall;			\/\/ all elements are keeped (even invalids)$/;"	v
savecolor	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  bool			savecolor;			\/\/ if has color, save it on 3dmesh$/;"	v
savecolor	vcglib/wrap/io_trimesh/import_ptx.h	/^			bool savecolor;$/;"	m	class:vcg::tri::io::ImporterPTX::Info
sbinptr	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef struct malloc_chunk* sbinptr;  \/* The type of bins of chunks *\/$/;"	t	typeref:struct:malloc_chunk	file:
sca	vcglib/vcg/math/similarity.h	/^  S sca;  $/;"	m	class:vcg::Similarity
sca	vcglib/vcg/math/similarity2.h	/^  SCALAR_TYPE sca;$/;"	m	class:vcg::Similarity2
scalarValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^					ScalarType scalarValue;$/;"	m	union:vcg::AABBBinaryTree::AABBBinaryTreeNode::SharedDataUnion
scalar_abs2_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs2_op {$/;"	s	namespace:Eigen::internal
scalar_abs_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs_op {$/;"	s	namespace:Eigen::internal
scalar_acos_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_acos_op {$/;"	s	namespace:Eigen::internal
scalar_add_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline scalar_add_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_add_op
scalar_add_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline scalar_add_op(const scalar_add_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_add_op
scalar_add_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_add_op {$/;"	s	namespace:Eigen::internal
scalar_asin_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_asin_op {$/;"	s	namespace:Eigen::internal
scalar_binary_pow_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar, typename OtherScalar> struct scalar_binary_pow_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_and_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_boolean_and_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_or_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_boolean_or_op {$/;"	s	namespace:Eigen::internal
scalar_cast_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_cast_op {$/;"	s	namespace:Eigen::internal
scalar_conj_product_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_conj_product_op {$/;"	s	namespace:Eigen::internal
scalar_conjugate_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_conjugate_op {$/;"	s	namespace:Eigen::internal
scalar_constant_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op
scalar_constant_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op
scalar_constant_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_constant_op {$/;"	s	namespace:Eigen::internal
scalar_cos_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_cos_op {$/;"	s	namespace:Eigen::internal
scalar_cube_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_cube_op {$/;"	s	namespace:Eigen::internal
scalar_difference_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_difference_op {$/;"	s	namespace:Eigen::internal
scalar_exp_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_exp_op {$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl {};$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_impl : scalar_fuzzy_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
scalar_fuzzy_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^template<> struct scalar_fuzzy_impl<bool>$/;"	s	namespace:Eigen::internal
scalar_hypot_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_hypot_op {$/;"	s	namespace:Eigen::internal
scalar_identity_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_identity_op {$/;"	s	namespace:Eigen::internal
scalar_imag_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_imag_op {$/;"	s	namespace:Eigen::internal
scalar_imag_ref_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_imag_ref_op {$/;"	s	namespace:Eigen::internal
scalar_inverse_mult_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  scalar_inverse_mult_op(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op
scalar_inverse_mult_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_inverse_mult_op {$/;"	s	namespace:Eigen::internal
scalar_inverse_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_inverse_op {$/;"	s	namespace:Eigen::internal
scalar_log_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_log_op {$/;"	s	namespace:Eigen::internal
scalar_max_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_max_op {$/;"	s	namespace:Eigen::internal
scalar_max_op	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_max_op)$/;"	f	class:Eigen::Cwise
scalar_min_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_min_op {$/;"	s	namespace:Eigen::internal
scalar_min_op	vcglib/eigenlib/Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_min_op)$/;"	f	class:Eigen::Cwise
scalar_multiple2_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const Scalar2& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op
scalar_multiple2_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const scalar_multiple2_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op
scalar_multiple2_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_multiple2_op {$/;"	s	namespace:Eigen::internal
scalar_multiple_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op
scalar_multiple_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op
scalar_multiple_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_multiple_op {$/;"	s	namespace:Eigen::internal
scalar_opposite_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_opposite_op {$/;"	s	namespace:Eigen::internal
scalar_pow_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline scalar_pow_op(const Scalar& exponent) : m_exponent(exponent) {}$/;"	f	struct:Eigen::internal::scalar_pow_op
scalar_pow_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  inline scalar_pow_op(const scalar_pow_op& other) : m_exponent(other.m_exponent) { }$/;"	f	struct:Eigen::internal::scalar_pow_op
scalar_pow_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_pow_op {$/;"	s	namespace:Eigen::internal
scalar_product_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_product_op {$/;"	s	namespace:Eigen::internal
scalar_product_traits	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,T>$/;"	s	namespace:Eigen
scalar_product_traits	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,std::complex<T> >$/;"	s	namespace:Eigen
scalar_product_traits	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<std::complex<T>, T>$/;"	s	namespace:Eigen
scalar_product_traits	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^struct scalar_product_traits<AutoDiffScalar<DerType>,typename DerType::Scalar>$/;"	s	namespace:Eigen::internal
scalar_product_traits	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^template<typename A_Scalar, int A_Rows, int A_Cols, int A_Options, int A_MaxRows, int A_MaxCols> struct scalar_product_traits<A_Scalar, Matrix<A_Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols> >$/;"	s	namespace:Eigen::internal
scalar_product_traits	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^template<typename A_Scalar, int A_Rows, int A_Cols, int A_Options, int A_MaxRows, int A_MaxCols> struct scalar_product_traits<Matrix<A_Scalar, A_Rows, A_Cols, A_Options, A_MaxRows, A_MaxCols>,A_Scalar>$/;"	s	namespace:Eigen::internal
scalar_quotient1_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_op(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_quotient1_op
scalar_quotient1_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_op(const scalar_quotient1_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_quotient1_op
scalar_quotient1_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_quotient1_op {$/;"	s	namespace:Eigen::internal
scalar_quotient_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_quotient_op {$/;"	s	namespace:Eigen::internal
scalar_random_op	vcglib/eigenlib/Eigen/src/Core/Random.h	/^template<typename Scalar> struct scalar_random_op {$/;"	s	namespace:Eigen::internal
scalar_real_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_real_op {$/;"	s	namespace:Eigen::internal
scalar_real_ref_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_real_ref_op {$/;"	s	namespace:Eigen::internal
scalar_sin_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sin_op {$/;"	s	namespace:Eigen::internal
scalar_sqrt_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sqrt_op {$/;"	s	namespace:Eigen::internal
scalar_square_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^struct scalar_square_op {$/;"	s	namespace:Eigen::internal
scalar_sum_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sum_op {$/;"	s	namespace:Eigen::internal
scalar_tan_op	vcglib/eigenlib/Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_tan_op {$/;"	s	namespace:Eigen::internal
scalar_type	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef double scalar_type;$/;"	t	struct:Eigen::internal::fftw_plan
scalar_type	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef float scalar_type;$/;"	t	struct:Eigen::internal::fftw_plan
scalar_type	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      typedef long double scalar_type;$/;"	t	struct:Eigen::internal::fftw_plan
scale	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
scale	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::scale(Scalar s)$/;"	f	class:Eigen::Transform
scale	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
scale	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::scale(Scalar s)$/;"	f	class:Eigen::Transform
scale	vcglib/wrap/io_edgemesh/export_svg.h	/^	float scale;$/;"	m	class:vcg::tri::io::SVGProperties
scaleAndAddTo	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::GeneralProduct
scaleAndAddTo	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	class:Eigen::GeneralProduct
scaleAndAddTo	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    inline void scaleAndAddTo(Dest& dst,Scalar alpha) const { derived().scaleAndAddTo(dst,alpha); }$/;"	f	class:Eigen::ProductBase
scaleAndAddTo	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    inline void scaleAndAddTo(Dest& dst,Scalar alpha) const { m_prod.derived().scaleAndAddTo(dst,alpha * m_alpha); }$/;"	f	class:Eigen::ScaledProduct
scaleAndAddTo	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	class:Eigen::GeneralProduct
scaleAndAddTo	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix
scaleAndAddTo	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix
scaleAndAddTo	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	struct:Eigen::TriangularProduct
scaleAndAddTo	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, Scalar alpha) const$/;"	f	struct:Eigen::TriangularProduct
scaleAndAddTo	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::DenseTimeSparseProduct
scaleAndAddTo	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::SparseTimeDenseProduct
scaleAndAddTo	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& \/*dest*\/, Scalar \/*alpha*\/) const$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct
scaleAndAddTo	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, Scalar alpha) const$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct
scalex	vcglib/wrap/io_trimesh/import_ply.h	/^	float scalex;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
scaley	vcglib/wrap/io_trimesh/import_ply.h	/^	float scaley;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
scaling_factor	vcglib/vcg/math/spherical_harmonics.h	/^	static ScalarType scaling_factor(unsigned l, unsigned m)$/;"	f	class:vcg::math::SphericalHarmonics
scomplex	vcglib/eigenlib/Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<float>  scomplex;$/;"	t	namespace:Eigen
scoped_mutex_lock	vcglib/wrap/system/multithreading/scoped_mutex_lock.h	/^            scoped_mutex_lock(mutex & m) : mtx(m)$/;"	f	class:mt::scoped_mutex_lock
scoped_mutex_lock	vcglib/wrap/system/multithreading/scoped_mutex_lock.h	/^            scoped_mutex_lock(mutex * m) : mtx( *m )$/;"	f	class:mt::scoped_mutex_lock
scoped_mutex_lock	vcglib/wrap/system/multithreading/scoped_mutex_lock.h	/^class scoped_mutex_lock$/;"	c	namespace:mt
scoped_read_lock	vcglib/wrap/system/multithreading/scoped_read_lock.h	/^		scoped_read_lock(rw_lock & rwl) : rw(rwl)$/;"	f	class:mt::scoped_read_lock
scoped_read_lock	vcglib/wrap/system/multithreading/scoped_read_lock.h	/^class scoped_read_lock$/;"	c	namespace:mt
scoped_write_lock	vcglib/wrap/system/multithreading/scoped_write_lock.h	/^		scoped_write_lock(rw_lock & rwl) : rw(rwl)$/;"	f	class:mt::scoped_write_lock
scoped_write_lock	vcglib/wrap/system/multithreading/scoped_write_lock.h	/^class scoped_write_lock$/;"	c	namespace:mt
score	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    int score;$/;"	m	struct:vcg::tri::FourPCS::Candidate
scoreAln	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    int scoreAln;       \/\/ how good must be the alignement	to end the process successfully$/;"	m	struct:vcg::tri::FourPCS::Param
scoreFeet	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    int scoreFeet;      \/\/ how many of the feetsize points must match (max feetsize*4) to try an early interrupt$/;"	m	struct:vcg::tri::FourPCS::Param
screen	vcglib/apps/test/trackball/main.cpp	/^SDL_Surface *screen = NULL;$/;"	v
sdlLoop	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^int sdlLoop() {$/;"	f
sdl_idle	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^int sdl_idle() {$/;"	f
searchLowerIndex	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(Index key) const$/;"	f	class:Eigen::internal::CompressedStorage
searchLowerIndex	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(size_t start, size_t end, Index key) const$/;"	f	class:Eigen::internal::CompressedStorage
sec	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sec(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sech	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sech (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
second	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket second;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket
second	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  int second;$/;"	m	struct:Eigen::internal::vector_int_pair
second_coord_kept	vcglib/wrap/gui/trackmode.h	/^  int second_coord_kept;$/;"	m	class:vcg::AreaMode
section	vcglib/wrap/gl/tetramesh.h	/^	ClipPlane section;$/;"	m	class:vcg::tetra::GlTetramesh
seed	vcglib/apps/pivoting/pivot.h	/^    bool seed(bool outside = true, int start = -1) {         $/;"	f	class:vcg::tri::Pivot
seg	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  msegment   seg;$/;"	m	struct:malloc_state	file:
seg	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^    Segment3x seg;$/;"	m	class:vcg::tri::CylinderClipping::CylPred
segment	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start) const$/;"	f	class:Eigen::DenseBase
segment	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start)$/;"	f	class:Eigen::DenseBase
segment	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start, Index size) const$/;"	f	class:Eigen::DenseBase
segment	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::segment(Index start, Index size)$/;"	f	class:Eigen::DenseBase
segment_holding	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static msegmentptr segment_holding(mstate m, char* addr) {$/;"	f	file:
segment_holds	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define segment_holds(/;"	d	file:
select	vcglib/eigenlib/Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase
select	vcglib/eigenlib/Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(typename ElseDerived::Scalar thenScalar,$/;"	f	class:Eigen::DenseBase
selectBestDiag	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^static void selectBestDiag(FaceType *fi){$/;"	f	class:vcg::tri::BitQuadCreation
selectComplexRoot_withRespectToNorm	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RootType& selectComplexRoot_withRespectToNorm( squaredNormBinaryPredicate& pred ) const$/;"	f	class:Eigen::PolynomialSolverBase
selectDrawMode	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::selectDrawMode(int mode){$/;"	f	class:GLArea
selectRealRoot_withRespectToAbsRealPart	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& selectRealRoot_withRespectToAbsRealPart($/;"	f	class:Eigen::PolynomialSolverBase
selectRealRoot_withRespectToRealPart	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& selectRealRoot_withRespectToRealPart($/;"	f	class:Eigen::PolynomialSolverBase
selector	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^  typedef product_type_selector<rows_select, cols_select, depth_select> selector;$/;"	t	struct:Eigen::internal::product_type
selfadjointView	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::MatrixBase
selfadjointView	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::MatrixBase
selfadjointView	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView()$/;"	f	class:Eigen::TriangularView
selfadjointView	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    const SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView() const$/;"	f	class:Eigen::TriangularView
selfadjointView	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::SparseMatrixBase
selfadjointView	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^const SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::SparseMatrixBase
selfadjoint_matrix_vector_product	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_matrix_vector_product$/;"	s	namespace:Eigen::internal
selfadjoint_matrix_vector_product_symv	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^struct selfadjoint_matrix_vector_product_symv :$/;"	s	namespace:Eigen::internal
selfadjoint_product_selector	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,false>$/;"	s	namespace:Eigen
selfadjoint_product_selector	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,true>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,ColMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank2_update_selector	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Lower>$/;"	s	namespace:Eigen::internal
selfadjoint_rank2_update_selector	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Upper>$/;"	s	namespace:Eigen::internal
semaphore	vcglib/wrap/system/multithreading/mt.h	/^  typedef QSemaphore semaphore;$/;"	t	namespace:mt
semaphore	vcglib/wrap/system/multithreading/semaphore.h	/^  semaphore(int value)$/;"	f	class:mt::semaphore
semaphore	vcglib/wrap/system/multithreading/semaphore.h	/^  semaphore(void)$/;"	f	class:mt::semaphore
semaphore	vcglib/wrap/system/multithreading/semaphore.h	/^class semaphore$/;"	c	namespace:mt
sendRedraw	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^void sendRedraw() {$/;"	f
separation	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^    static const RealScalar separation() { return static_cast<RealScalar>(0.1); }$/;"	f	class:Eigen::MatrixFunction
set	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^        Signature& set(VecIndex i, bool value){$/;"	f	struct:vcg::tri::Zonohedron::Signature
set	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^        Signature& set(VecIndex i, bool valueI, VecIndex j, bool valueJ){$/;"	f	struct:vcg::tri::Zonohedron::Signature
set	vcglib/wrap/gl/gl_surface.h	/^		bool set(int width, int height, const std::vector<GLenum> & color_formats, GLenum depth_format)$/;"	f	class:vcg::gl_surface
set	vcglib/wrap/io_trimesh/import_obj.h	/^                    void set(const int & num){v.resize(num);n.resize(num); t.resize(num);}$/;"	f	struct:vcg::tri::io::ImporterOBJ::ObjIndexedFace
setBounds	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    void setBounds(Index start, Index end) { m_start = start; m_end = end; }$/;"	f	class:Eigen::internal::AmbiVector
setCallback	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setCallback(void (*t)(const IterationController&))$/;"	f	class:Eigen::IterationController
setCapacity	vcglib/wrap/gcache/cache.h	/^    void setCapacity(uint64_t c) { s_max = c; }$/;"	f	class:vcg::Cache
setColor	vcglib/wrap/io_trimesh/import_fbx.h	/^			void setColor(const ColorType& col) {color = col;hascolor= true;}$/;"	f	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
setColorTarget	vcglib/wrap/glw/framebuffer.h	/^		bool setColorTarget(GLenum target, GLint unit, GLint index, const RenderTarget & renderTarget)$/;"	f	class:glw::Framebuffer
setColorTarget	vcglib/wrap/glw/framebuffer.h	/^		bool setColorTarget(GLint index, const RenderTarget & renderTarget)$/;"	f	class:glw::BoundFramebuffer
setColorspace	vcglib/img/img_attributes.h	/^  void setColorspace(COLORSPACE arg_colorspace)$/;"	f	class:img::ImgAttributes
setColorspace	vcglib/img/img_attributes.h	/^  void setColorspace(const ImgAttributes<ScalarType> &attributes)$/;"	f	class:img::ImgAttributes
setConstant	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setConstant(const Scalar& value)$/;"	f	class:Eigen::DenseBase
setConstant	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index rows, Index cols, const Scalar& value)$/;"	f	class:Eigen::PlainObjectBase
setConstant	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index size, const Scalar& value)$/;"	f	class:Eigen::PlainObjectBase
setConstant	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setConstant(const Scalar& value)$/;"	f	class:Eigen::TriangularView
setCpuCacheSizes	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void setCpuCacheSizes(std::ptrdiff_t l1, std::ptrdiff_t l2)$/;"	f	namespace:Eigen
setData	vcglib/wrap/glw/buffer.h	/^		void setData(GLenum target, GLint unit, const GLsizeiptr size, GLenum usage, const GLvoid * data)$/;"	f	class:glw::Buffer
setData	vcglib/wrap/glw/buffer.h	/^		void setData(const GLsizeiptr size, GLenum usage, const GLvoid * data)$/;"	f	class:glw::BoundBuffer
setDefaultMapping	vcglib/wrap/gui/trackball.cpp	/^void Trackball::setDefaultMapping () {$/;"	f	class:Trackball
setDepthTarget	vcglib/wrap/glw/framebuffer.h	/^		bool setDepthTarget(GLenum target, GLint unit, const RenderTarget & renderTarget)$/;"	f	class:glw::Framebuffer
setDepthTarget	vcglib/wrap/glw/framebuffer.h	/^		bool setDepthTarget(const RenderTarget & renderTarget)$/;"	f	class:glw::BoundFramebuffer
setDroptol	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setDroptol(RealScalar droptol)$/;"	f	class:Eigen::IncompleteLUT
setEmpty	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline void setEmpty()$/;"	f	class:Eigen::AlignedBox
setEntry	vcglib/apps/trimeshinfo/SlotsNode.h	/^void EntryNode::setEntry(EntryNode en)$/;"	f	class:EntryNode
setFillfactor	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setFillfactor(int fillfactor)$/;"	f	class:Eigen::IncompleteLUT
setFlags	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    void setFlags(int f) {$/;"	f	class:Eigen::SkylineInplaceLU
setFromTriplets	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::setFromTriplets(const InputIterators& begin, const InputIterators& end)$/;"	f	class:Eigen::SparseMatrix
setFromTwoVectors	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion
setFromTwoVectors	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::QuaternionBase
setGamma	vcglib/img/img_attributes.h	/^  void setGamma(ScalarType arg_gamma)$/;"	f	class:img::ImgAttributes
setGamma	vcglib/img/img_attributes.h	/^  void setGamma(const ImgAttributes<ScalarType> &attributes)$/;"	f	class:img::ImgAttributes
setHeight	vcglib/img/img_image.h	/^   inline void setHeight(int height)$/;"	f	class:img::Image
setHelp	vcglib/wrap/system/qgetopt.h	/^  void setHelp(QString &_help) { help = _help; }$/;"	f	class:GetOpt
setIdentity	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity()$/;"	f	class:Eigen::MatrixBase
setIdentity	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity(Index rows, Index cols)$/;"	f	class:Eigen::MatrixBase
setIdentity	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity() { m_diagonal.setOnes(); }$/;"	f	class:Eigen::DiagonalMatrix
setIdentity	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity(Index size) { m_diagonal.setOnes(size); }$/;"	f	class:Eigen::DiagonalMatrix
setIdentity	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity()$/;"	f	class:Eigen::PermutationBase
setIdentity	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity(Index size)$/;"	f	class:Eigen::PermutationBase
setIdentity	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    void setIdentity()$/;"	f	class:Eigen::TranspositionsBase
setIdentity	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion& setIdentity() { m_coeffs << 0, 0, 0, 1; return *this; }$/;"	f	class:Eigen::Quaternion
setIdentity	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform
setIdentity	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline QuaternionBase& setIdentity() { coeffs() << 0, 0, 0, 1; return *this; }$/;"	f	class:Eigen::QuaternionBase
setIdentity	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform
setIdentity_impl	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^struct setIdentity_impl<Derived, true>$/;"	s	namespace:Eigen::internal
setImage	vcglib/wrap/glw/texture2d.h	/^		void setImage(GLenum target, GLint unit, GLint level, GLsizei width, GLsizei height, GLenum dataFormat, GLenum dataType, const void * data)$/;"	f	class:glw::Texture2D
setImage	vcglib/wrap/glw/texture2d.h	/^		void setImage(GLint level, GLsizei width, GLsizei height, GLenum dataFormat, GLenum dataType, const void * data)$/;"	f	class:glw::BoundTexture2D
setImage	vcglib/wrap/glw/texturecube.h	/^		void setImage(GLenum face, GLint level, GLsizei size, GLenum dataFormat, GLenum dataType, const void * data)$/;"	f	class:glw::BoundTextureCube
setImage	vcglib/wrap/glw/texturecube.h	/^		void setImage(GLenum target, GLint unit, GLint level, GLsizei size, GLenum dataFormat, GLenum dataType, const void * data)$/;"	f	class:glw::TextureCube
setInf	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::setInf(int sign) $/;"	f	class:mpfr::mpreal
setInputCache	vcglib/wrap/gcache/cache.h	/^    void setInputCache(Provider<Token> *p) { input = p; }$/;"	f	class:vcg::Cache
setInvalidKey	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  static void setInvalidKey(Type& map, const KeyType& k)$/;"	f	struct:Eigen::GoogleDenseHashMapTraits
setInvalidKey	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  static void setInvalidKey(Type&, const KeyType&) {}$/;"	f	struct:Eigen::GoogleSparseHashMapTraits
setInvalidKey	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  static void setInvalidKey(Type&, const KeyType&) {}$/;"	f	struct:Eigen::StdMapTraits
setInvalidKey	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^  static void setInvalidKey(Type&, const KeyType&) {}$/;"	f	struct:Eigen::StdUnorderedMapTraits
setIteration	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setIteration(size_t i) { m_nit = i; }$/;"	f	class:Eigen::IterationController
setLength	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setLength(Index length)$/;"	f	class:Eigen::HouseholderSequence
setLinSpaced	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
setLinSpaced	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
setMaxIterations	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setMaxIterations(int maxIters)$/;"	f	class:Eigen::IterativeSolverBase
setMaxIterations	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setMaxIterations(size_t i) { m_maxiter = i; }$/;"	f	class:Eigen::IterationController
setMaxNofNeighbors	vcglib/vcg/space/index/kdtree/kdtree.h	/^void KdTree<Scalar>::setMaxNofNeighbors(unsigned int k)$/;"	f	class:KdTree
setMaxResidual	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setMaxResidual(double r) { m_resmax = r; }$/;"	f	class:Eigen::IterationController
setMaxSize	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^	inline void setMaxSize(int maxSize)$/;"	f	class:HeapMaxPriorityQueue
setMaxTokens	vcglib/wrap/gcache/controller.h	/^  void setMaxTokens(int m) {$/;"	f	class:vcg::Controller
setMode	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    void setMode(CholmodMode mode)$/;"	f	class:Eigen::CholmodDecomposition
setMode	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& setMode(SimplicialCholeskyMode mode)$/;"	f	class:Eigen::SimplicialCholesky
setName	vcglib/apps/trimeshinfo/SlotsNode.h	/^	void setName(const char* s){name = s;};$/;"	f	class:OwnSlotNode
setName	vcglib/apps/trimeshinfo/XMLTree.h	/^void XMLTree::setName(const char *name)$/;"	f	class:XMLTree
setNan	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::setNan() $/;"	f	class:mpfr::mpreal
setNbThreads	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^inline void setNbThreads(int v)$/;"	f	namespace:Eigen
setNoiseLevel	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setNoiseLevel(int n) { m_noise = n; }$/;"	f	class:Eigen::IterationController
setNull	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline void setNull()$/;"	f	class:Eigen::AlignedBox
setNull	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline void setNull() { setEmpty(); }$/;"	f	class:Eigen::AlignedBox
setNull	vcglib/wrap/glw/bookkeeping.h	/^		void setNull(bool deleteObject)$/;"	f	class:glw::detail::RefCountedObject
setNull	vcglib/wrap/glw/bookkeeping.h	/^		void setNull(void)$/;"	f	class:glw::detail::ObjectSharedPointer
setOnes	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setOnes()$/;"	f	class:Eigen::DenseBase
setOnes	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
setOnes	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index size)$/;"	f	class:Eigen::PlainObjectBase
setOnes	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setOnes() { return setConstant(Scalar(1)); }$/;"	f	class:Eigen::TriangularView
setOrderingMethod	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    void setOrderingMethod(int m) {$/;"	f	class:Eigen::SkylineInplaceLU
setPixel	vcglib/img/img_image.h	/^  inline void setPixel(int x, int y, const ScalarType (& pixel)[Channels])$/;"	f	class:img::Image
setPoints	vcglib/vcg/space/rasterized_outline2_packer.h	/^    void setPoints(std::vector<Point2f>& newpoints) { points = newpoints; }$/;"	f	class:vcg::RasterizedOutline2
setPolynomial	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/Companion.h	/^    void setPolynomial( const VectorType& poly )$/;"	f	class:Eigen::internal::companion
setPolynomial	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline void setPolynomial( const OtherPolynomial& poly ){$/;"	f	class:Eigen::PolynomialSolverBase
setPrecision	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    void setPrecision(RealScalar v) {$/;"	f	class:Eigen::SkylineInplaceLU
setPrecision	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::setPrecision(int Precision, mp_rnd_t RoundingMode)$/;"	f	class:mpfr::mpreal
setPriority	vcglib/wrap/gcache/token.h	/^    void setPriority(const Priority &p) {$/;"	f	class:vcg::Token
setRHSCmplx	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void setRHSCmplx(unsigned int i, Cmplx val) { $/;"	f	class:SparseSystemData
setRadius	vcglib/apps/pivoting/glarea.h	/^    void setRadius(double _radius) {$/;"	f	class:GLArea
setRandom	vcglib/eigenlib/Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
setRandom	vcglib/eigenlib/Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index size)$/;"	f	class:Eigen::PlainObjectBase
setRandom	vcglib/eigenlib/Eigen/src/Core/Random.h	/^inline Derived& DenseBase<Derived>::setRandom()$/;"	f	class:Eigen::DenseBase
setRange	vcglib/img/img_attributes.h	/^  void setRange(ScalarType arg_range_min, ScalarType arg_range_max)$/;"	f	class:img::ImgAttributes
setRange	vcglib/img/img_attributes.h	/^  void setRange(const ImgAttributes<ScalarType> &attributes)$/;"	f	class:img::ImgAttributes
setRawValue	vcglib/img/img_image.h	/^  inline void setRawValue(int i, ScalarType value)$/;"	f	class:img::Image
setReferenceWhite	vcglib/img/img_attributes.h	/^  void setReferenceWhite(ScalarType arg_reference_white_x, ScalarType arg_reference_white_y, ScalarType arg_reference_white_z)$/;"	f	class:img::ImgAttributes
setReferenceWhite	vcglib/img/img_attributes.h	/^  void setReferenceWhite(const ImgAttributes<ScalarType> &attributes)$/;"	f	class:img::ImgAttributes
setRhsNorm	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IterationController.h	/^    void setRhsNorm(double r) { m_rhsn = r; }$/;"	f	class:Eigen::IterationController
setSampleMode	vcglib/wrap/glw/texture2d.h	/^		void setSampleMode(GLenum target, GLint unit, const TextureSampleMode & sampler)$/;"	f	class:glw::Texture2D
setSampleMode	vcglib/wrap/glw/texture2d.h	/^		void setSampleMode(const TextureSampleMode & sampler)$/;"	f	class:glw::BoundTexture2D
setSampleMode	vcglib/wrap/glw/texturecube.h	/^		void setSampleMode(GLenum target, GLint unit, const TextureSampleMode & sampler)$/;"	f	class:glw::TextureCube
setSampleMode	vcglib/wrap/glw/texturecube.h	/^		void setSampleMode(const TextureSampleMode & sampler)$/;"	f	class:glw::BoundTextureCube
setScalarType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setScalarType()$/;"	f	struct:Eigen::SluMatrix
setShift	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setShift(Index shift)$/;"	f	class:Eigen::HouseholderSequence
setShift	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& setShift(const RealScalar& offset, const RealScalar& scale = 1)$/;"	f	class:Eigen::SimplicialCholeskyBase
setSign	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal& mpreal::setSign(int sign, mp_rnd_t RoundingMode)$/;"	f	class:mpfr::mpreal
setStencilTarget	vcglib/wrap/glw/framebuffer.h	/^		bool setStencilTarget(GLenum target, GLint unit, const RenderTarget & renderTarget)$/;"	f	class:glw::Framebuffer
setStencilTarget	vcglib/wrap/glw/framebuffer.h	/^		bool setStencilTarget(const RenderTarget & renderTarget)$/;"	f	class:glw::BoundFramebuffer
setStorage	vcglib/wrap/glw/renderbuffer.h	/^		void setStorage(GLenum format, GLsizei width, GLsizei height)$/;"	f	class:glw::BoundRenderbuffer
setStorage	vcglib/wrap/glw/renderbuffer.h	/^		void setStorage(GLenum target, GLint unit, GLenum format, GLsizei width, GLsizei height)$/;"	f	class:glw::Renderbuffer
setStorageType	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setStorageType(Stype_t t)$/;"	f	struct:Eigen::SluMatrix
setSubData	vcglib/wrap/glw/buffer.h	/^		void setSubData(GLenum target, GLint unit, GLintptr offset, GLsizeiptr size, const GLvoid * data)$/;"	f	class:glw::Buffer
setSubData	vcglib/wrap/glw/buffer.h	/^		void setSubData(GLintptr offset, GLsizeiptr size, const GLvoid * data)$/;"	f	class:glw::BoundBuffer
setSubImage	vcglib/wrap/glw/texture2d.h	/^		void setSubImage(GLenum target, GLint unit, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum dataFormat, GLenum dataType, const void * data)$/;"	f	class:glw::Texture2D
setSubImage	vcglib/wrap/glw/texture2d.h	/^		void setSubImage(GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum dataFormat, GLenum dataType, const void * data)$/;"	f	class:glw::BoundTexture2D
setSubImage	vcglib/wrap/glw/texturecube.h	/^		void setSubImage(GLenum face, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum dataFormat, GLenum dataType, const void * data)$/;"	f	class:glw::BoundTextureCube
setSubImage	vcglib/wrap/glw/texturecube.h	/^		void setSubImage(GLenum target, GLint unit, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum dataFormat, GLenum dataType, const void * data)$/;"	f	class:glw::TextureCube
setSurfaceMaterial	vcglib/wrap/io_trimesh/import_fbx.h	/^			void setSurfaceMaterial(KFbxSurfaceMaterial* mat) {surfMat = mat;}$/;"	f	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
setTargetInputs	vcglib/wrap/glw/framebuffer.h	/^		bool setTargetInputs(GLenum target, GLint unit, const RenderTargetBinding & targetInputs)$/;"	f	class:glw::Framebuffer
setTargetInputs	vcglib/wrap/glw/framebuffer.h	/^		bool setTargetInputs(const RenderTargetBinding & targetInputs)$/;"	f	class:glw::BoundFramebuffer
setTextureIndex	vcglib/wrap/io_trimesh/import_fbx.h	/^			void setTextureIndex(const int i) {textindex = i;}$/;"	f	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
setThr	vcglib/vcg/complex/algorithms/refine.h	/^    void setThr(FLT threshold) {squaredThr = threshold*threshold; }$/;"	f	class:vcg::tri::EdgeLen
setThreshold	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivLU
setThreshold	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivLU
setThreshold	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::ColPivHouseholderQR
setThreshold	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::ColPivHouseholderQR
setThreshold	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivHouseholderQR
setThreshold	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivHouseholderQR
setTolerance	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setTolerance(RealScalar tolerance)$/;"	f	class:Eigen::IterativeSolverBase
setTolerance	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    void setTolerance(double tol)$/;"	f	class:Scaling
setTot	vcglib/apps/pivoting/glarea.h	/^    void setTot(int n) { tot = n; }$/;"	f	class:GLArea
setTrans	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setTrans(bool trans)$/;"	f	class:Eigen::HouseholderSequence
setValenceAttr	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline void setValenceAttr(ValenceAttr *valence) {$/;"	f	struct:vcg::tri::EvenPointLoopGeneric
setValenceAttr	vcglib/vcg/complex/algorithms/refine_loop.h	/^	inline void setValenceAttr(ValenceAttr *valence) {$/;"	f	struct:vcg::tri::OddPointLoopGeneric
setValue	vcglib/apps/trimeshinfo/SlotsNode.h	/^	void setValue(ValueNode vn){value = vn.value;};$/;"	f	class:ValueNode
setValue	vcglib/apps/trimeshinfo/SlotsNode.h	/^	void setValue(const char* cvn){value = cvn;};$/;"	f	class:ValueNode
setValue	vcglib/img/img_image.h	/^  inline void setValue(int x, int y, int channel, ScalarType value)$/;"	f	class:img::Image
setValues	vcglib/img/img_image.h	/^  inline void setValues(ScalarType* data)$/;"	f	class:img::Image
setVerboseMode	vcglib/apps/trimeshinfo/XMLTree.h	/^void XMLTree::setVerboseMode(bool flag)$/;"	f	class:XMLTree
setWidth	vcglib/img/img_image.h	/^  inline void setWidth(int width)$/;"	f	class:img::Image
setZero	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    void setZero()$/;"	f	class:Eigen::LDLT
setZero	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setZero()$/;"	f	class:Eigen::DenseBase
setZero	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
setZero	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index size)$/;"	f	class:Eigen::PlainObjectBase
setZero	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero() { m_diagonal.setZero(); }$/;"	f	class:Eigen::DiagonalMatrix
setZero	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero(Index size) { m_diagonal.setZero(size); }$/;"	f	class:Eigen::DiagonalMatrix
setZero	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setZero() { return setConstant(Scalar(0)); }$/;"	f	class:Eigen::TriangularView
setZero	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::setZero()$/;"	f	class:Eigen::internal::AmbiVector
setZero	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void setZero()$/;"	f	class:Eigen::SparseMatrix
setZero	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline void setZero() { m_data.clear(); }$/;"	f	class:Eigen::SparseVector
setZero	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline void setZero() {$/;"	f	class:Eigen::SkylineMatrix
setZero	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    void setZero()$/;"	f	class:Eigen::DynamicSparseMatrix
setZero	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline mpreal&	mpreal::setZero(int sign)$/;"	f	class:mpfr::mpreal
setZero	vcglib/img/img_image.h	/^  inline void setZero(int arg_width, int arg_height)$/;"	f	class:img::Image
set_color_only	vcglib/wrap/gl/gl_surface.h	/^		bool set_color_only(int width, int height, GLenum color_format)$/;"	f	class:vcg::gl_surface
set_color_only	vcglib/wrap/gl/gl_surface.h	/^		bool set_color_only(int width, int height, const std::vector<GLenum> & color_formats)$/;"	f	class:vcg::gl_surface
set_color_pixels	vcglib/wrap/gl/gl_surface.h	/^		bool set_color_pixels(int attachment, GLenum format, GLenum type, const void * pixels)$/;"	f	class:vcg::gl_surface
set_custom_malloc	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^	inline void mpreal::set_custom_malloc(void)$/;"	f	class:mpfr::mpreal
set_default_base	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline void mpreal::set_default_base(int base)$/;"	f	class:mpfr::mpreal
set_default_prec	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline void mpreal::set_default_prec(mp_prec_t prec)$/;"	f	class:mpfr::mpreal
set_default_rnd	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline void mpreal::set_default_rnd(mp_rnd_t rnd_mode)$/;"	f	class:mpfr::mpreal
set_depth_only	vcglib/wrap/gl/gl_surface.h	/^		bool set_depth_only(int width, int height, GLenum depth_format)$/;"	f	class:vcg::gl_surface
set_depth_pixels	vcglib/wrap/gl/gl_surface.h	/^		bool set_depth_pixels(GLenum format, GLenum type, const void * pixels)$/;"	f	class:vcg::gl_surface
set_double_bits	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline void mpreal::set_double_bits(int dbits)$/;"	f	class:mpfr::mpreal
set_emax	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int mpreal::set_emax (mp_exp_t exp)$/;"	f	class:mpfr::mpreal
set_emin	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int mpreal::set_emin (mp_exp_t exp)$/;"	f	class:mpfr::mpreal
set_exp	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int mpreal::set_exp (mp_exp_t e)$/;"	f	class:mpfr::mpreal
set_foot	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define set_foot(/;"	d	file:
set_free_with_pinuse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define set_free_with_pinuse(/;"	d	file:
set_from_triplets	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^void set_from_triplets(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, int Options = 0)$/;"	f	namespace:Eigen::internal
set_inuse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define set_inuse(/;"	d	file:
set_inuse_and_pinuse	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define set_inuse_and_pinuse(/;"	d	file:
set_is_malloc_allowed	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline bool set_is_malloc_allowed(bool new_value) { return is_malloc_allowed_impl(true, new_value); }$/;"	f	namespace:Eigen::internal
set_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define set_lock(/;"	d	file:
set_normals	vcg_mesh.cpp	/^void MyMesh::set_normals(const float* normals)$/;"	f	class:vcg::MyMesh
set_prec	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline void mpreal::set_prec(mp_prec_t prec, mp_rnd_t rnd_mode)$/;"	f	class:mpfr::mpreal
set_restart	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  void set_restart(const int restart) { m_restart=restart; }$/;"	f	class:Eigen::GMRES
set_simple	vcglib/wrap/gl/gl_surface.h	/^		bool set_simple(int width, int height)$/;"	f	class:vcg::gl_surface
set_size_and_pinuse_of_free_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define set_size_and_pinuse_of_free_chunk(/;"	d	file:
set_size_and_pinuse_of_inuse_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define set_size_and_pinuse_of_inuse_chunk(/;"	d	file:
setupUniforms	vcglib/wrap/glw/program.h	/^		void setupUniforms(void)$/;"	f	class:glw::Program
sf	vcglib/vcg/complex/algorithms/clean.h	/^  std::stack<FacePointer> sf;$/;"	m	class:vcg::tri::ConnectedComponentIterator
sf	vcglib/vcg/math/spherical_harmonics.h	/^	static ScalingFactor sf;$/;"	m	class:vcg::math::ScalingFactor
sf	vcglib/vcg/math/spherical_harmonics.h	/^ScalingFactor<ScalarType, MAX_BAND> ScalingFactor<ScalarType, MAX_BAND>::sf;$/;"	m	class:vcg::math::ScalingFactor
sflags	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  flag_t       sflags;           \/* mmap and extern flag *\/$/;"	m	struct:malloc_segment	file:
sgn	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int sgn(const mpreal& v)$/;"	f	namespace:mpfr
shaderType	vcglib/wrap/glw/fragmentshader.h	/^		virtual GLenum shaderType(void) const$/;"	f	class:glw::FragmentShader
shaderType	vcglib/wrap/glw/geometryshader.h	/^		virtual GLenum shaderType(void) const$/;"	f	class:glw::GeometryShader
shaderType	vcglib/wrap/glw/vertexshader.h	/^		virtual GLenum shaderType(void) const$/;"	f	class:glw::VertexShader
shaders	vcglib/wrap/gl/shaders.h	/^	std::set<Shader *> shaders;$/;"	m	class:Program
shaders	vcglib/wrap/glw/program.h	/^		ShaderHandleVector         shaders;$/;"	m	class:glw::ProgramArguments
sharedData	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^				SharedDataUnion sharedData;$/;"	m	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
shear	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::shear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform
shear	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::shear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform
shift	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    Index shift() const { return m_shift; }    \/**< \\brief Returns the shift of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence
shot	vcglib/vcg/complex/base.h	/^    Shot<ScalarType> shot;		\/\/ intrinsic && extrinsic$/;"	m	class:vcg::tri::TriMesh
should_trim	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define should_trim(/;"	d	file:
show	vcglib/vcg/math/old_matrix33.h	/^	void show(FILE * fp)$/;"	f	class:vcg::Matrix33
showTextDetails	vcglib/wrap/io_edgemesh/export_svg.h	/^	bool showTextDetails;$/;"	m	class:vcg::tri::io::SVGProperties
shrink_factor	vcglib/wrap/gl/tetramesh.h	/^	ScalarType shrink_factor;$/;"	m	class:vcg::tetra::GlTetramesh
side	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  ScalarType side;									\/\/ side$/;"	m	class:vcg::tri::FourPCS
sign	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^#define sign(/;"	d
sign	vcglib/vcg/math/old_lin_algebra.h	/^	inline static TYPE sign(TYPE a, TYPE b)$/;"	f	namespace:vcg
sign	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^		unsigned char sign[3];$/;"	m	class:vcg::AABBBinaryTreeRay::Ray3Ex
signOf_IxJoK	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    bool signOf_IxJoK(VecIndex i, VecIndex j, VecIndex k){$/;"	f	class:vcg::tri::Zonohedron
signal	vcglib/wrap/system/multithreading/condition.h	/^		void signal(void)$/;"	f	class:mt::condition
signature	vcglib/wrap/bmt/bmt.h	/^  unsigned int signature;$/;"	m	class:vcg::Bmt
signature	vcglib/wrap/bmt/bmt.h	/^  unsigned int signature;$/;"	m	class:vcg::BmtBuilder
signedDistance	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return p.eigen2_dot(normal()) + offset(); }$/;"	f	class:Eigen::Hyperplane
signedDistance	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return normal().dot(p) + offset(); }$/;"	f	class:Eigen::Hyperplane
signedDistance	vcglib/wrap/gui/trackutils.h	/^float signedDistance(Line3f line,Point3f pt,Point3f positive_dir)$/;"	f	namespace:vcg::trackutils
significant_decimals_default_impl	vcglib/eigenlib/Eigen/src/Core/IO.h	/^struct significant_decimals_default_impl$/;"	s	namespace:Eigen::internal
significant_decimals_default_impl	vcglib/eigenlib/Eigen/src/Core/IO.h	/^struct significant_decimals_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
significant_decimals_impl	vcglib/eigenlib/Eigen/src/Core/IO.h	/^struct significant_decimals_impl$/;"	s	namespace:Eigen::internal
sin	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sin() const$/;"	f	class:Eigen::Cwise
sin	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sin() const$/;"	f
sin	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^const MatrixFunctionReturnValue<Derived> MatrixBase<Derived>::sin() const$/;"	f	class:Eigen::MatrixBase
sin	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^    static Scalar sin(Scalar x, int n)$/;"	f	class:Eigen::StdStemFunctions
sin	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sin(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sin_cos	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int sin_cos(mpreal& s, mpreal& c, const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sinf	vcglib/vcg/math/base.h	/^    float sinf  (float v) {return sin(v);}$/;"	f
sing	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    bool sing;$/;"	m	class:Eigen::HybridNonLinearSolver
singlemap	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  int			singlemap;			\/\/ single map mode, which map is to be saved. if -1 then all map are saved$/;"	v
singlet_remove_quad	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static HEdgePointer singlet_remove_quad(MeshType &m, FacePointer fp)$/;"	f	class:vcg::tri::HalfEdgeTopology
singularValues	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^    const SingularValuesType& singularValues() const { return m_sigma; }$/;"	f	class:Eigen::SVD
singularValues	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    const SingularValuesType& singularValues() const$/;"	f	class:Eigen::JacobiSVD
sinh	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^const MatrixFunctionReturnValue<Derived> MatrixBase<Derived>::sinh() const$/;"	f	class:Eigen::MatrixBase
sinh	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/StemFunction.h	/^    static Scalar sinh(Scalar x, int n)$/;"	f	class:Eigen::StdStemFunctions
sinh	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sinh (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sinh_cosh	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int sinh_cosh(mpreal& s, mpreal& c, const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
siz	vcglib/vcg/space/index/grid_util.h	/^	Point3i siz;		\/\/\/ Number of cells forming the grid$/;"	m	class:vcg::BasicGrid
siz	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		Point2i siz;		\/\/\/ Number of cells forming the grid$/;"	m	class:vcg::BasicGrid2D
size	vcglib/apps/pivoting/ring.h	/^  int size() { return lst.size(); }$/;"	f	class:ring
size	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  inline Index size() const { return rows() * cols(); }$/;"	f	struct:Eigen::EigenBase
size	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon169
size	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline Index size() const { return indices().size(); }$/;"	f	class:Eigen::PermutationBase
size	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Index size() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase
size	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline int size() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose
size	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon8
size	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon9
size	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon11
size	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon10
size	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon12
size	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon13
size	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon14
size	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon15
size	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon16
size	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon17
size	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon18
size	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon19
size	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon22
size	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon20
size	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon23
size	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon21
size	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon28
size	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon29
size	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon27
size	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon31
size	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon30
size	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon32
size	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Index size() const { return m_size; }$/;"	f	class:Eigen::internal::AmbiVector
size	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline size_t size() const { return m_size; }$/;"	f	class:Eigen::internal::CompressedStorage
size	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index size() const { return rows() * cols(); }$/;"	f	class:Eigen::SparseMatrixBase
size	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    Index size() const { return m_values.size(); }$/;"	f	class:Eigen::AutoDiffVector
size	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline size_t size() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
size	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline size_t size() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
size	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    inline Index size() const {$/;"	f	class:Eigen::SkylineMatrixBase
size	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t       size;             \/* allocated size *\/$/;"	m	struct:malloc_segment	file:
size	vcglib/vcg/complex/algorithms/hole.h	/^            int size;$/;"	m	class:vcg::tri::Hole::Info
size	vcglib/vcg/container/simple_temporary_data.h	/^    unsigned int  size() const { return datasize;}$/;"	f	class:vcg::VectorNBW
size	vcglib/vcg/space/index/grid_static_obj.h	/^	 int size() const { return this->siz[0]*this->siz[1]*this->siz[2];}$/;"	f	class:vcg::GridStaticObj
size	vcglib/vcg/space/index/kdtree/kdtree.h	/^				unsigned short size;$/;"	m	struct:KdTree::Node::__anon507::__anon509
size	vcglib/vcg/space/index/kdtree/kdtree.h	/^		inline size_t size() const { return mSize; }$/;"	f	class:ConstDataWrapper
size	vcglib/vcg/space/index/octree_template.h	/^	int						size;$/;"	m	class:vcg::OctreeTemplate
size	vcglib/vcg/space/rasterized_outline2_packer.h	/^      vcg::Point2i& size() { return mSize; }$/;"	f	class:vcg::RasterizedOutline2Packer::packingfield
size	vcglib/wrap/gcache/cache.h	/^    uint64_t size() { return s_curr; }$/;"	f	class:vcg::Cache
size	vcglib/wrap/gcache/dheap.h	/^  int size() { return heap.size(); }$/;"	f	class:PtrDHeap
size	vcglib/wrap/glw/buffer.h	/^		GLsizeiptr   size;$/;"	m	class:glw::BufferArguments
size	vcglib/wrap/glw/buffer.h	/^		GLsizeiptr size(void) const$/;"	f	class:glw::Buffer
size	vcglib/wrap/glw/buffer.h	/^		GLsizeiptr size(void) const$/;"	f	class:glw::SafeBuffer
size	vcglib/wrap/glw/buffer.h	/^		GLsizeiptr size;$/;"	m	class:glw::FeedbackBufferBindingParams
size	vcglib/wrap/glw/buffer.h	/^		GLsizeiptr size;$/;"	m	class:glw::UniformBufferBindingParams
size	vcglib/wrap/glw/program.h	/^				GLint       size;$/;"	m	class:glw::Program::UniformInfo
size	vcglib/wrap/glw/texturecube.h	/^		GLsizei           size;$/;"	m	class:glw::TextureCubeArguments
size	vcglib/wrap/glw/texturecube.h	/^		GLsizei size(void) const$/;"	f	class:glw::SafeTextureCube
size	vcglib/wrap/glw/texturecube.h	/^		GLsizei size(void) const$/;"	f	class:glw::TextureCube
size	vcglib/wrap/gui/coordinateframe.h	/^  float size;$/;"	m	class:vcg::CoordinateFrame
size	vcglib/wrap/io_tetramesh/import_ply.h	/^	unsigned char size;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
size	vcglib/wrap/io_trimesh/import_ply.h	/^	int size;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_TristripAux
size	vcglib/wrap/io_trimesh/import_ply.h	/^	unsigned char size;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
sizeCm	vcglib/wrap/io_edgemesh/export_svg.h	/^	Point2f sizeCm; \/\/ The size, in the drawing, of each ViewBox (in cm)$/;"	m	class:vcg::tri::io::SVGProperties
sizeHint	vcglib/apps/sample/trimesh_ant_qt/glwidget.h	/^    QSize sizeHint() const {$/;"	f	class:GLWidget
sizeHint	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^QSize GLWidget::sizeHint() const$/;"	f	class:GLWidget
size_t	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^            typedef unsigned int				size_t;$/;"	t	class:vcg::tri::ExtendedMarchingCubes
size_t	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef _W64 unsigned int   size_t;$/;"	t	class:vcg::tri::MarchingCubes
size_t	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef unsigned __int64    size_t;$/;"	t	class:vcg::tri::MarchingCubes
size_t	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^            typedef unsigned int				size_t;$/;"	t	class:vcg::tri::MarchingCubes
size_type	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator
size_type	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator_indirection
sizes	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline const CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> sizes() const$/;"	f	class:Eigen::AlignedBox
skipmesh	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^int skipmesh(FILE* fp)$/;"	f
skipmesh	vcglib/wrap/io_trimesh/import_ptx.h	/^		static bool skipmesh(FILE* fp, CallBackPos *cb=NULL)$/;"	f	class:vcg::tri::io::ImporterPTX
skyline_col_major_time_dense_product	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^EIGEN_DONT_INLINE void skyline_col_major_time_dense_product(const Lhs& lhs, const Rhs& rhs, Dest& dst) {$/;"	f	namespace:Eigen::internal
skyline_product_selector	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^struct skyline_product_selector<Lhs, Rhs, ResultType, ColMajor> {$/;"	s	namespace:Eigen::internal
skyline_product_selector	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^struct skyline_product_selector<Lhs, Rhs, ResultType, RowMajor> {$/;"	s	namespace:Eigen::internal
skyline_row_major_time_dense_product	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^EIGEN_DONT_INLINE void skyline_row_major_time_dense_product(const Lhs& lhs, const Rhs& rhs, Dest& dst) {$/;"	f	namespace:Eigen::internal
sleep_ms	vcglib/wrap/system/multithreading/util.h	/^inline void sleep_ms(unsigned int msecs)$/;"	f	namespace:mt
slerp	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar> Quaternion<Scalar>::slerp(Scalar t, const Quaternion& other) const$/;"	f	class:Eigen::Quaternion
slerp	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(Scalar t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
slerp	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::slerp(Scalar t, const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
slerp	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(Scalar t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
slot	vcglib/apps/trimeshinfo/SlotsNode.h	/^	NodeGroup slot;$/;"	m	class:SlotsNode
small_index	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define small_index(/;"	d	file:
small_index2size	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define small_index2size(/;"	d	file:
smallbin_at	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define smallbin_at(/;"	d	file:
smallbins	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  mchunkptr  smallbins[(NSMALLBINS+1)*2];$/;"	m	struct:malloc_state	file:
smallestChild	vcglib/wrap/gcache/dheap.h	/^  int smallestChild(int i) {$/;"	f	class:DHeap
smallestRealRoot	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RealScalar& smallestRealRoot($/;"	f	class:Eigen::PolynomialSolverBase
smallestRoot	vcglib/eigenlib/unsupported/Eigen/src/Polynomials/PolynomialSolver.h	/^    inline const RootType& smallestRoot() const$/;"	f	class:Eigen::PolynomialSolverBase
smallmap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  binmap_t   smallmap;$/;"	m	struct:malloc_state	file:
smallmap_is_marked	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define smallmap_is_marked(/;"	d	file:
smart_copy	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T> void smart_copy(const T* start, const T* end, T* target)$/;"	f	namespace:Eigen::internal
smart_copy_helper	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,false> {$/;"	s	namespace:Eigen::internal
smart_copy_helper	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,true> {$/;"	s	namespace:Eigen::internal
smblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MALLINFO_FIELD_TYPE smblks;   \/* always 0 *\/$/;"	m	struct:mallinfo	file:
smblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^  MALLINFO_FIELD_TYPE smblks;   \/* always 0 *\/$/;"	m	struct:mallinfo
smooth	vcglib/apps/pivoting/glarea.h	/^    bool smooth;$/;"	m	class:GLArea
smoothingIterNum	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    int smoothingIterNum; \/\/\/ number of itaration of a simple normal smoothing (use the same number of ajdacent of fittingAdjNjm)$/;"	m	struct:vcg::tri::PointCloudNormal::Param
smoothing_iterations	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            static unsigned int &smoothing_iterations()$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
sn	vcglib/apps/trimeshinfo/XMLTree.h	/^	SlotNode sn;$/;"	m	class:XMLTree
snap	vcglib/wrap/gui/trackmode.h	/^  float snap;$/;"	m	class:vcg::CylinderMode
solve	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LDLT
solve	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LDLT
solve	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LLT
solve	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LLT
solve	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase
solve	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase
solve	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^TriangularView<Derived,Mode>::solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView
solve	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView
solve	vcglib/eigenlib/Eigen/src/Eigen2Support/LU.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LU
solve	vcglib/eigenlib/Eigen/src/Eigen2Support/QR.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::QR
solve	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^bool SVD<MatrixType>::solve(const MatrixBase<OtherDerived> &b, ResultType* result) const$/;"	f	class:Eigen::SVD
solve	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    inline const Rhs& solve(const Rhs& b) const { return b; }$/;"	f	class:Eigen::IdentityPreconditioner
solve	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::DiagonalPreconditioner
solve	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^     solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IncompleteLUT
solve	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase
solve	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase
solve	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivLU
solve	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PartialPivLU
solve	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase
solve	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase
solve	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl
solve	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl
solve	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::ColPivHouseholderQR
solve	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivHouseholderQR
solve	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::HouseholderQR
solve	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::JacobiSVD
solve	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase
solve	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase
solve	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^SparseTriangularView<ExpressionType,Mode>::solve(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView
solve	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const internal::solve_retval<SuperLUBase, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SuperLUBase
solve	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const internal::solve_retval<UmfPackLU, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::UmfPackLU
solve	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IncompleteLU
solve	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solve(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solve	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^bool SkylineInplaceLU<MatrixType>::solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>* x, const int transposed) const {$/;"	f	class:Eigen::SkylineInplaceLU
solveAuxiliaryEquation	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^     ::solveAuxiliaryEquation(SmallMatrixType& X, const SmallMatrixType& A,$/;"	f	class:Eigen::MatrixSquareRootQuasiTriangular
solveInPlace	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^bool LDLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LDLT
solveInPlace	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^void LLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LLT
solveInPlace	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^void TriangularView<MatrixType,Mode>::solveInPlace(const MatrixBase<OtherDerived>& _other) const$/;"	f	class:Eigen::TriangularView
solveInPlace	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularView
solveInPlace	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView
solveInPlace	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView
solveInit	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solveInit(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solveNumericalDiff	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solveNumericalDiff(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solveNumericalDiffInit	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solveNumericalDiffInit(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solveNumericalDiffOneStep	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solveNumericalDiffOneStep(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solveOneStep	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^HybridNonLinearSolver<FunctorType,Scalar>::solveOneStep(FVectorType  &x)$/;"	f	class:Eigen::HybridNonLinearSolver
solveTriangular	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^Flagged<ExpressionType,Added,Removed>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged
solveTriangular	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^SparseMatrixBase<Derived>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
solveTriangularInPlace	vcglib/eigenlib/Eigen/src/Eigen2Support/TriangularSolver.h	/^void Flagged<ExpressionType,Added,Removed>::solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged
solveTriangularInPlace	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^void SparseMatrixBase<Derived>::solveTriangularInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
solveTriangularSylvester	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^typename MatrixFunction<MatrixType,AtomicType,1>::DynMatrixType MatrixFunction<MatrixType,AtomicType,1>::solveTriangularSylvester($/;"	f	class:Eigen::MatrixFunction
solveWithGuess	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::BiCGSTAB
solveWithGuess	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::ConjugateGradient
solveWithGuess	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::GMRES
solve_retval	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^struct solve_retval<LDLT<_MatrixType,_UpLo>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^struct solve_retval<LLT<_MatrixType, UpLo>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^struct solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^struct solve_retval<DiagonalPreconditioner<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^struct solve_retval<BiCGSTAB<_MatrixType, _Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^struct solve_retval<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^struct solve_retval<IncompleteLUT<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^struct solve_retval<FullPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^struct solve_retval<PartialPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^struct solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^struct solve_retval<PardisoImpl<_Derived>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^struct solve_retval<ColPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^struct solve_retval<FullPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/QR/HouseholderQR.h	/^struct solve_retval<HouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^struct solve_retval<JacobiSVD<_MatrixType, QRPreconditioner>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^struct solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^struct solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^struct solve_retval<GMRES<_MatrixType, _Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/IncompleteLU.h	/^struct solve_retval<IncompleteLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval_base	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^  solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::solve_retval_base
solve_retval_base	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^template<typename _DecompositionType, typename Rhs> struct solve_retval_base$/;"	s	namespace:Eigen::internal
solve_retval_with_guess	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  solve_retval_with_guess(const DecompositionType& dec, const Rhs& rhs, const Guess& guess)$/;"	f	struct:Eigen::internal::solve_retval_with_guess
solve_retval_with_guess	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^template<typename DecompositionType, typename Rhs, typename Guess> struct solve_retval_with_guess$/;"	s	namespace:Eigen::internal
son	vcglib/wrap/dae/xmldocumentmanaging.cpp	/^XMLNode* XMLInteriorNode::son(int ii)$/;"	f	class:XMLInteriorNode
sons	vcglib/vcg/space/index/octree_template.h	/^		NodePointer sons[8];$/;"	m	struct:vcg::OctreeTemplate::InnerNode
sons	vcglib/wrap/dae/xmldocumentmanaging.cpp	/^QVector< XMLNode* > XMLInteriorNode::sons()$/;"	f	class:XMLInteriorNode
sort	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^SVD<MatrixType>& SVD<MatrixType>::sort()$/;"	f	class:Eigen::SVD
sort	vcglib/vcg/complex/algorithms/clustering.h	/^    void sort()$/;"	f	class:vcg::tri::Clustering::SimpleTri
sortEigenvalues	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::sortEigenvalues(bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver
sortOrient	vcglib/vcg/complex/algorithms/clustering.h	/^    void sortOrient()$/;"	f	class:vcg::tri::Clustering::SimpleTri
sorted_dataset	vcglib/vcg/space/index/octree.h	/^        std::vector< ObjectReference >	sorted_dataset;$/;"	m	class:vcg::Octree
source	vcglib/vcg/complex/algorithms/geodesic.h	/^    VertexPointer source;\/\/closest source$/;"	m	struct:vcg::tri::Geodesic::TempData
source	vcglib/wrap/gl/shaders.h	/^	std::string source;$/;"	m	class:Shader
source	vcglib/wrap/glw/shader.h	/^		const std::string & source(void) const$/;"	f	class:glw::SafeShader
source	vcglib/wrap/glw/shader.h	/^		const std::string & source(void) const$/;"	f	class:glw::Shader
source	vcglib/wrap/glw/shader.h	/^		std::string source;$/;"	m	class:glw::ShaderArguments
span	vcglib/eigenlib/unsupported/Eigen/src/Splines/Spline.h	/^  DenseIndex Spline<_Scalar, _Dim, _Degree>::span(Scalar u) const$/;"	f	class:Eigen::Spline
sparseView	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^const SparseView<Derived> MatrixBase<Derived>::sparseView(const Scalar& m_reference,$/;"	f	class:Eigen::MatrixBase
sparse_cwise_binary_op_inner_iterator_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE sparse_cwise_binary_op_inner_iterator_selector(const CwiseBinaryXpr& xpr, Index outer)$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
sparse_cwise_binary_op_inner_iterator_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<BinaryOp, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Dense, Sparse>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Dense>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
sparse_diagonal_product_inner_iterator_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline sparse_diagonal_product_inner_iterator_selector($/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
sparse_diagonal_product_inner_iterator_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^class sparse_diagonal_product_inner_iterator_selector$/;"	c	namespace:Eigen::internal
sparse_eval	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Cols> struct sparse_eval<T,1,Cols> {$/;"	s	namespace:Eigen::internal
sparse_eval	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows,int Cols> struct sparse_eval {$/;"	s	namespace:Eigen::internal
sparse_eval	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows> struct sparse_eval<T,Rows,1> {$/;"	s	namespace:Eigen::internal
sparse_eval	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct sparse_eval<T,1,1> {$/;"	s	namespace:Eigen::internal
sparse_extra	vcglib/eigenlib/unsupported/test/sparse_extra.cpp	/^template<typename SparseMatrixType> void sparse_extra(const SparseMatrixType& ref)$/;"	f
sparse_solve_retval	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^struct sparse_solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^struct sparse_solve_retval<IterativeSolverBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^struct sparse_solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^struct sparse_solve_retval<PardisoImpl<Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^struct sparse_solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct sparse_solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^struct sparse_solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval_base	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^  sparse_solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
sparse_solve_retval_base	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^template<typename _DecompositionType, typename Rhs> struct sparse_solve_retval_base$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_sparse_selector	vcglib/eigenlib/Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_sparse_selector<Lhs,Rhs,Mode,UpLo,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_impl	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^static void sparse_sparse_product_with_pruning_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, typename ResultType::RealScalar tolerance)$/;"	f	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	vcglib/eigenlib/Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^inline void sparse_time_dense_product(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	namespace:Eigen::internal
sparse_time_dense_product_impl	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, true>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, true>$/;"	s	namespace:Eigen::internal
speed	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  ScalarType speed;$/;"	m	class:vcg::tri::AreaPreservingTextureOptimizer
sph	vcglib/vcg/complex/algorithms/refine.h	/^    Sphere3<typename MESH_TYPE::ScalarType> sph;$/;"	m	struct:vcg::tri::MidPointSphere
sph	vcglib/vcg/complex/algorithms/refine.h	/^  Sphere3<FLT> sph;$/;"	m	class:vcg::tri::EdgeSplSphere
sphere	vcglib/vcg/complex/algorithms/symmetry.h	/^    TriMeshType *sphere;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
sphere	vcglib/wrap/bmt/bmt.h	/^    Sphere3f sphere;$/;"	m	class:vcg::Bmt::Cell
sphere	vcglib/wrap/bmt/bmt.h	/^  Sphere3f sphere;$/;"	m	class:vcg::Bmt
sphere	vcglib/wrap/bmt/bmt.h	/^  Sphere3f sphere;$/;"	m	class:vcg::BmtBuilder
spin	vcglib/wrap/gui/trackball.h	/^  Quaternionf spin;$/;"	m	class:vcg::Trackball
spinnable	vcglib/wrap/gui/trackball.h	/^  bool spinnable;$/;"	m	class:vcg::Trackball
spinning	vcglib/wrap/gui/trackball.h	/^  bool spinning;$/;"	m	class:vcg::Trackball
spline3d	vcglib/eigenlib/unsupported/test/splines.cpp	/^Spline<double, 3, Dynamic> spline3d()$/;"	f
split	vcglib/vcg/space/index/kdtree/kdtree.h	/^unsigned int KdTree<Scalar>::split(int start, int end, unsigned int dim, float splitValue)$/;"	f	class:KdTree
splitAxis	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^				unsigned char splitAxis;$/;"	m	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
splitFilePath	vcglib/wrap/io_trimesh/export_idtf.h	/^	static void splitFilePath(const QString& filepath,QStringList& trim_path)$/;"	f	namespace:vcg::tri::io::QtUtilityFunctions
splitMeshInTexturedPatches	vcglib/wrap/dae/colladaformat.h	/^	static void splitMeshInTexturedPatches(const MESHMODELTYPE& m,QVector<QVector<int> >& patches)$/;"	f	class:Collada::DocumentManager
splitOffTwoRows	vcglib/eigenlib/Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::splitOffTwoRows(Index iu, bool computeU, Scalar exshift)$/;"	f	class:Eigen::RealSchur
splitValue	vcglib/vcg/space/index/kdtree/kdtree.h	/^				Scalar splitValue;$/;"	m	struct:KdTree::Node::__anon507::__anon508
sq	vcglib/vcg/space/index/kdtree/kdtree.h	/^			Scalar sq;            \/\/ squared distance to the next node$/;"	m	struct:KdTree::QueryNode
sqr	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqr(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqr	vcglib/vcg/math/old_lin_algebra.h	/^  inline static TYPE sqr(TYPE a)$/;"	f	namespace:vcg
sqr	vcglib/wrap/miq/core/auxmath.h	/^template <class T> T sqr( const T& a ) { return a*a; }$/;"	f
sqrdAvg	vcglib/vcg/math/histogram.h	/^	double sqrdAvg;$/;"	m	class:vcg::Distribution
sqrdValSum	vcglib/vcg/math/histogram.h	/^	double sqrdValSum; $/;"	m	class:vcg::Distribution
sqrt	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(sqrt, Scalar) sqrt(const Scalar& x)$/;"	f	namespace:Eigen::internal
sqrt	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sqrt() const$/;"	f	class:Eigen::Cwise
sqrt	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sqrt() const$/;"	f
sqrt	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^const MatrixSquareRootReturnValue<Derived> MatrixBase<Derived>::sqrt() const$/;"	f	class:Eigen::MatrixBase
sqrt	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const double v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqrt	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const int v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqrt	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const long double v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqrt	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const long int v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqrt	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqrt	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const unsigned int v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqrt	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal sqrt(const unsigned long int v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sqrt_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct sqrt_default_impl$/;"	s	namespace:Eigen::internal
sqrt_default_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct sqrt_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
sqrt_impl	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct sqrt_impl : sqrt_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
sqrt_retval	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^struct sqrt_retval$/;"	s	namespace:Eigen::internal
sqrtf	vcglib/vcg/math/base.h	/^    float sqrtf (float v) {return sqrt(v);}$/;"	f
square	vcglib/eigenlib/Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::square() const$/;"	f	class:Eigen::Cwise
square	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^square() const$/;"	f
squaredDistance	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
squaredDistance	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
squaredExteriorDistance	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbiantDim>::squaredExteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox
squaredExteriorDistance	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
squaredExteriorDistance	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox
squaredNorm	vcglib/eigenlib/Eigen/src/Core/Dot.h	/^EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::MatrixBase
squaredNorm	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_squaredNorm,RealScalar>::Type squaredNorm() const$/;"	f	class:Eigen::VectorwiseOp
squaredNorm	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return m_coeffs.squaredNorm(); }$/;"	f	class:Eigen::Quaternion
squaredNorm	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return coeffs().squaredNorm(); }$/;"	f	class:Eigen::QuaternionBase
squaredNorm	vcglib/eigenlib/Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::SparseMatrixBase
squaredThr	vcglib/vcg/complex/algorithms/refine.h	/^    FLT squaredThr;$/;"	m	class:vcg::tri::EdgeLen
squeeze	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    void squeeze()$/;"	f	class:Eigen::internal::CompressedStorage
squeeze	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline void squeeze() {$/;"	f	class:Eigen::SkylineMatrix
squeeze	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    void squeeze() {$/;"	f	class:Eigen::SkylineStorage
src	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    VertexPointer src;$/;"	m	class:vcg::tri::PointCloudNormal::WArc
stableNorm	vcglib/eigenlib/Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::stableNorm() const$/;"	f	class:Eigen::MatrixBase
stableNorm	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_stableNorm,RealScalar>::Type stableNorm() const$/;"	f	class:Eigen::VectorwiseOp
stable_dot	vcglib/vcg/space/deprecated_point3.h	/^double stable_dot ( Point3<P3ScalarType> const & p0, Point3<P3ScalarType> const & p1 )$/;"	f	namespace:vcg
stable_dot	vcglib/vcg/space/point3.h	/^double stable_dot ( Point3<Scalar> const & p0, Point3<Scalar> const & p1 )$/;"	f	namespace:vcg
stable_norm_kernel	vcglib/eigenlib/Eigen/src/Core/StableNorm.h	/^inline void stable_norm_kernel(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)$/;"	f	namespace:Eigen::internal
star	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^      LCVertexStar star;          \/\/ edge star$/;"	m	struct:vcg::tri::PolychordCollapse::LinkConditions::LCEdge
star	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^      LCVertexStar star;  \/\/ vertex star$/;"	m	struct:vcg::tri::PolychordCollapse::LinkConditions::LCVertex
start	vcglib/eigenlib/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start() const$/;"	f	class:Eigen::MatrixBase
start	vcglib/eigenlib/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start()$/;"	f	class:Eigen::MatrixBase
start	vcglib/eigenlib/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size) const$/;"	f	class:Eigen::MatrixBase
start	vcglib/eigenlib/Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size)$/;"	f	class:Eigen::MatrixBase
start	vcglib/vcg/complex/algorithms/bitquad_support.h	/^  Pos  start, cur;$/;"	m	class:vcg::tri::BitQuad::Iterator
start	vcglib/vcg/complex/algorithms/clean.h	/^  void start(MeshType &m, FacePointer p)$/;"	f	class:vcg::tri::ConnectedComponentIterator
start	vcglib/vcg/complex/algorithms/local_optimization.h	/^  clock_t	start;$/;"	m	class:vcg::LocalOptimization
start	vcglib/vcg/space/index/kdtree/kdtree.h	/^				unsigned int start;$/;"	m	struct:KdTree::Node::__anon507::__anon509
start	vcglib/vcg/space/index/space_iterators.h	/^		CoordType start;$/;"	m	class:vcg::RayIterator
start	vcglib/wrap/gcache/controller.h	/^  void start() {$/;"	f	class:vcg::Controller
start	vcglib/wrap/gl/trimesh.h	/^        int start;$/;"	m	class:vcg::GLW::GLAElem
start	vcglib/wrap/gui/rubberband.h	/^  Point3f start, end;$/;"	m	class:vcg::Rubberband
start	vcglib/wrap/system/multithreading/thread.h	/^            virtual bool start(void)$/;"	f	class:mt::thread
startCol	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    Index startCol() const $/;"	f	class:Eigen::Block
startFill	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void startFill(Index reserve)$/;"	f	class:Eigen::SparseVector
startFill	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    EIGEN_DEPRECATED void startFill(Index reserveSize = 1000)$/;"	f	class:Eigen::DynamicSparseMatrix
startRow	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    Index startRow() const $/;"	f	class:Eigen::Block
startTime	vcglib/wrap/gui/trackrecorder.h	/^			startTime;  $/;"	m	struct:vcg::TrackRecorder
startVec	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseMatrix
startVec	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseVector
startVec	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline void startVec(Index \/*outer*\/) {}$/;"	f	class:Eigen::DynamicSparseMatrix
stat	vcglib/vcg/space/rect_packer.h	/^  static Stat &stat() { static Stat _s; return _s; }$/;"	f	class:vcg::RectPacker
static_assertion	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion {};$/;"	s	namespace:Eigen::internal
static_assertion	vcglib/eigenlib/Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion<true>$/;"	s	namespace:Eigen::internal
static_n	vcglib/vcg/space/texcoord2.h	/^    inline short & static_n() const$/;"	f	class:vcg::TexCoord2Simple
status	vcglib/wrap/gui/trackmode.h	/^  Point3f status;$/;"	m	class:vcg::AreaMode
status	vcglib/wrap/io_tetramesh/io_ply.h	/^  int status;$/;"	m	class:vcg::tetra::io::PlyInfo
status	vcglib/wrap/io_trimesh/io_ply.h	/^  int status;$/;"	m	class:vcg::tri::io::PlyInfo
std	vcglib/eigenlib/Eigen/src/Core/GlobalFunctions.h	/^namespace std$/;"	n
std	vcglib/eigenlib/Eigen/src/StlSupport/StdDeque.h	/^namespace std {$/;"	n
std	vcglib/eigenlib/Eigen/src/StlSupport/StdList.h	/^namespace std$/;"	n
std	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^namespace std {$/;"	n
std	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^namespace std$/;"	n
stem_function	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^struct stem_function$/;"	s	namespace:Eigen::internal
stencilTarget	vcglib/wrap/glw/framebuffer.h	/^		RenderTarget         stencilTarget;$/;"	m	class:glw::FramebufferArguments
step_current	vcglib/wrap/gui/trackmode.h	/^	float step_current, step_last, step_x;$/;"	m	class:vcg::NavigatorWasdMode
step_height	vcglib/wrap/gui/trackmode.h	/^	float step_height, step_length; \/\/ height of steps$/;"	m	class:vcg::NavigatorWasdMode
step_last	vcglib/wrap/gui/trackmode.h	/^	float step_current, step_last, step_x;$/;"	m	class:vcg::NavigatorWasdMode
step_length	vcglib/wrap/gui/trackmode.h	/^	float step_height, step_length; \/\/ height of steps$/;"	m	class:vcg::NavigatorWasdMode
step_size	vcglib/vcg/space/index/space_iterators.h	/^		ScalarType step_size;		  \/\/radius step$/;"	m	class:vcg::ClosestIterator
step_x	vcglib/wrap/gui/trackmode.h	/^	float step_current, step_last, step_x;$/;"	m	class:vcg::NavigatorWasdMode
stepbound	vcglib/wrap/minpack/minpack.h	/^	double stepbound; 	\/\/ initial bound to steps in the outer loop.$/;"	m	struct:LMDiff::__anon525
stop	vcglib/wrap/gcache/controller.h	/^  void stop() {$/;"	f	class:vcg::Controller
stop	vcglib/wrap/minpack/minpack.h	/^	int stop; 	\/\/ if set to a nonzero value, minimization will stop.$/;"	m	struct:LMDiff::__anon526
stopped	vcglib/wrap/gcache/controller.h	/^  bool stopped;$/;"	m	class:vcg::Controller
storage	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  } storage;$/;"	m	struct:Eigen::SluMatrix	typeref:struct:Eigen::SluMatrix::__anon434
store_fitmaps	vcglib/apps/sample/polygonmesh_quadsimpl/polygonmesh_quadsimpl.cpp	/^bool store_fitmaps(CMesh &m, const char *fn)$/;"	f
stored	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Object1 stored;$/;"	m	struct:Eigen::internal::intersector_helper2
stored	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Object1 stored;$/;"	m	struct:Eigen::internal::minimizer_helper2
stored	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Object2 stored;$/;"	m	struct:Eigen::internal::intersector_helper1
stored	vcglib/eigenlib/unsupported/Eigen/src/BVH/BVAlgorithms.h	/^  Object2 stored;$/;"	m	struct:Eigen::internal::minimizer_helper1
stotype1	vcglib/wrap/ply/plylib.h	/^	int	stotype1;				\/\/ Tipo dell'elemento su file    (se lista tipo degli elementi della lista)$/;"	m	class:vcg::ply::PropDescriptor
stotype2	vcglib/wrap/ply/plylib.h	/^	int stotype2;				\/\/ Tipo del numero di elementi della lista su file$/;"	m	class:vcg::ply::PropDescriptor
stotypename	vcglib/wrap/ply/plylib.cpp	/^const char *PropDescriptor::stotypename() const {return PlyFile::typenames[stotype1];}$/;"	f	class:vcg::ply::PropDescriptor
stotypesize	vcglib/wrap/ply/plylib.cpp	/^size_t PropDescriptor::stotypesize() const {return TypeSize[stotype1];}$/;"	f	class:vcg::ply::PropDescriptor
stride	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index stride() const$/;"	f	class:Eigen::DenseCoeffsBase
stridecl	vcglib/wrap/dae/util_dae.h	/^			int stridecl;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
stridetx	vcglib/wrap/dae/util_dae.h	/^			int stridetx;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
string_value	vcglib/wrap/system/qgetopt.h	/^    QString *string_value;$/;"	m	struct:GetOpt::Option
strip	vcglib/wrap/bmt/strip_mesh.h	/^  std::vector<unsigned short> strip;$/;"	m	class:vcg::StripMeshBuilder
strokeColor	vcglib/wrap/io_edgemesh/export_svg.h	/^	std::string strokeColor; 	\/\/ Stroke color (see StrokeColor).$/;"	m	class:vcg::tri::io::SVGProperties
strokeLineCap	vcglib/wrap/io_edgemesh/export_svg.h	/^	std::string strokeLineCap;\/\/ Stroke linecap (see StrokeLineCap).$/;"	m	class:vcg::tri::io::SVGProperties
strtok_r	vcglib/wrap/ply/plylib.cpp	/^#define strtok_r /;"	d	file:
sub	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<-1>::Type sub() const$/;"	f	class:Eigen::internal::TridiagonalMatrix
sub	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<-1>::Type sub()$/;"	f	class:Eigen::internal::TridiagonalMatrix
subDiagonal	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::subDiagonal() const$/;"	f	class:Eigen::Tridiagonalization
subTo	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    void subTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase
subTo	vcglib/eigenlib/Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void subTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
subTo	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    inline void subTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(-1)); }$/;"	f	class:Eigen::ScaledProduct
subTo	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^    inline void subTo(Dest& dst) const { scaleAndAddTo(dst,Scalar(-1)); }$/;"	f	class:Eigen::ProductBase
subVector	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    SubVector subVector(Index i)$/;"	f	class:Eigen::VectorwiseOp
subVectors	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    Index subVectors() const$/;"	f	class:Eigen::VectorwiseOp
sub_mat5	vcglib/vcg/math/quadric5.h	/^  void inline sub_mat5(ScalarType dest[5][5],ScalarType m[5][5])$/;"	f	namespace:vcg::math
sub_symmat5	vcglib/vcg/math/quadric5.h	/^  void inline sub_symmat5(ScalarType dest[15],ScalarType m[15])$/;"	f	namespace:vcg::math
sub_vec5	vcglib/vcg/math/quadric5.h	/^  void inline sub_vec5(const ScalarType a[5], const ScalarType b[5], ScalarType r[5])$/;"	f	namespace:vcg::math
subdiagonalEntryIsNeglegible	vcglib/eigenlib/Eigen/src/Eigenvalues/ComplexSchur.h	/^inline bool ComplexSchur<MatrixType>::subdiagonalEntryIsNeglegible(Index i)$/;"	f	class:Eigen::ComplexSchur
subnormalize	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int mpreal::subnormalize (int t,mp_rnd_t rnd_mode)$/;"	f	class:mpfr::mpreal
subs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return derived().subs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
subs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrix
subs	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
subsetP	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  std::vector<VertexType*> subsetP; \/\/ random selection on P$/;"	m	class:vcg::tri::FourPCS
substituteChar	vcglib/wrap/io_trimesh/export_u3d.h	/^	static void substituteChar(QString& st,const QChar& ch_remove,const QString& sub)$/;"	f	class:vcg::tri::io::ExporterU3D
succeeded	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineInplaceLU.h	/^    inline bool succeeded(void) const {$/;"	f	class:Eigen::SkylineInplaceLU
sum	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^DenseBase<Derived>::sum() const$/;"	f	class:Eigen::DenseBase
sum	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_sum>::Type sum() const$/;"	f	class:Eigen::VectorwiseOp
sum	vcglib/eigenlib/Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrix<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseMatrix
sum	vcglib/eigenlib/Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrixBase<Derived>::sum() const$/;"	f	class:Eigen::SparseMatrixBase
sum	vcglib/eigenlib/Eigen/src/SparseCore/SparseRedux.h	/^SparseVector<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseVector
sum	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    Scalar sum() const { \/*std::cerr << "sum \\n\\n";*\/ \/*std::cerr << m_jacobian.rowwise().sum() << "\\n\\n";*\/ return Scalar(m_values.sum(), m_jacobian.rowwise().sum()); }$/;"	f	class:Eigen::AutoDiffVector
sum	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar sum;$/;"	m	class:Eigen::HybridNonLinearSolver
sum	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar par, sum;$/;"	m	class:Eigen::LevenbergMarquardt
sum	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^const mpreal sum (const mpreal tab[], unsigned long int n, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
sum	vcglib/vcg/complex/algorithms/smooth.h	/^    CoordType sum;$/;"	m	class:vcg::tri::Smooth::HCSmoothInfo
sum	vcglib/vcg/complex/algorithms/smooth.h	/^    CoordType sum;$/;"	m	class:vcg::tri::Smooth::LaplacianInfo
sum	vcglib/vcg/complex/algorithms/smooth.h	/^    ScalarType sum;$/;"	m	class:vcg::tri::Smooth::QualitySmoothInfo
sum	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  SimpleTempData<typename MESH_TYPE::VertContainer, Point2<ScalarType> > sum;$/;"	m	class:vcg::tri::AreaPreservingTextureOptimizer
sumDotPN	vcglib/vcg/complex/algorithms/refine_loop.h	/^	LScalar sumDotPN;$/;"	m	struct:vcg::tri::LS3Projection
sumDotPP	vcglib/vcg/complex/algorithms/refine_loop.h	/^	LScalar sumDotPP;$/;"	m	struct:vcg::tri::LS3Projection
sumN	vcglib/vcg/complex/algorithms/refine_loop.h	/^	LVector sumN;$/;"	m	struct:vcg::tri::LS3Projection
sumP	vcglib/vcg/complex/algorithms/refine_loop.h	/^	LVector sumP;$/;"	m	struct:vcg::tri::Centroid
sumP	vcglib/vcg/complex/algorithms/refine_loop.h	/^	LVector sumP;$/;"	m	struct:vcg::tri::LS3Projection
sumW	vcglib/vcg/complex/algorithms/refine_loop.h	/^	LScalar sumW;$/;"	m	struct:vcg::tri::Centroid
sumW	vcglib/vcg/complex/algorithms/refine_loop.h	/^	LScalar sumW;$/;"	m	struct:vcg::tri::LS3Projection
sumupDuplicates	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::sumupDuplicates()$/;"	f	class:Eigen::SparseMatrix
super	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<1>::Type super() const$/;"	f	class:Eigen::internal::TridiagonalMatrix
super	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<1>::Type super()$/;"	f	class:Eigen::internal::TridiagonalMatrix
supers	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return derived().supers(); }$/;"	f	class:Eigen::internal::BandMatrixBase
supers	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrix
supers	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
surfMat	vcglib/wrap/io_trimesh/import_fbx.h	/^			KFbxSurfaceMaterial* surfMat;$/;"	m	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
svd	vcglib/eigenlib/Eigen/src/Eigen2Support/SVD.h	/^MatrixBase<Derived>::svd() const$/;"	f	class:Eigen::MatrixBase
svd_precondition_2x2_block_to_be_real	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real {};$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, false>$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	vcglib/eigenlib/Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>$/;"	s	namespace:Eigen::internal
swap	vcglib/eigenlib/Eigen/src/Core/Array.h	/^    void swap(ArrayBase<OtherDerived> const & other)$/;"	f	class:Eigen::Array
swap	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    void swap(PlainObjectBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
swap	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    void swap(const DenseBase<OtherDerived>& other,$/;"	f	class:Eigen::DenseBase
swap	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& ) {}$/;"	f	class:Eigen::DenseStorage
swap	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }$/;"	f	class:Eigen::DenseStorage
swap	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }$/;"	f	class:Eigen::DenseStorage
swap	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }$/;"	f	class:Eigen::DenseStorage
swap	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline void swap(DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
swap	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::Matrix
swap	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView
swap	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    void swap(TriangularBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView
swap	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    void swap(CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
swap	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline void swap(SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
swap	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline void swap(SparseVector& other)$/;"	f	class:Eigen::SparseVector
swap	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline void swap(SkylineMatrix & other) {$/;"	f	class:Eigen::SkylineMatrix
swap	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    void swap(SkylineStorage& other) {$/;"	f	class:Eigen::SkylineStorage
swap	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline void swap(DynamicSparseMatrix& other)$/;"	f	class:Eigen::DynamicSparseMatrix
swap	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	inline void swap(mpfr::mpreal& x, mpfr::mpreal& y) $/;"	f	namespace:std
swap	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline void swap(mpreal& a, mpreal& b) $/;"	f	namespace:mpfr
swap	vcglib/vcg/complex/algorithms/refine.h	/^    int swap[2][2]; \/\/ the two diagonals to test for swapping$/;"	m	class:vcg::tri::Split
swap	vcglib/wrap/gcache/dheap.h	/^  void swap(int a, int b) { T tmp = at(a); at(a) = at(b); at(b) = tmp; }$/;"	f	class:DHeap
swapEntriesInSchur	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^void MatrixFunction<MatrixType,AtomicType,1>::swapEntriesInSchur(Index index)$/;"	f	class:Eigen::MatrixFunction
swapv	vcglib/vcg/math/quadric5.h	/^	void swapv(ScalarType *vv, ScalarType *ww)$/;"	f	class:vcg::Quadric5
switchside	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  bool			switchside;			\/\/ inverse triangulation order (swaping row->cols)$/;"	v
switchside	vcglib/wrap/io_trimesh/import_ptx.h	/^			bool switchside;$/;"	m	class:vcg::tri::io::ImporterPTX::Info
sx	vcglib/apps/unsupported/shadevis/simplepic.h	/^   int sx,sy;$/;"	m	class:vcg::SimplePic
sy	vcglib/apps/unsupported/shadevis/simplepic.h	/^   int sx,sy;$/;"	m	class:vcg::SimplePic
sym	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    inline int sym() { return m_sym; }$/;"	f	class:Eigen::MatrixMarketIterator
symm_pack_lhs	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_lhs$/;"	s	namespace:Eigen::internal
symm_pack_rhs	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_rhs$/;"	s	namespace:Eigen::internal
symmetrize	vcglib/wrap/miq/core/sparsesystemdata.h	/^  void symmetrize(unsigned int startind, unsigned int endind) { $/;"	f	class:SparseMatrixData
symprod_vvt5	vcglib/vcg/math/quadric5.h	/^  void inline symprod_vvt5(ScalarType dest[15],ScalarType v[5])$/;"	f	namespace:vcg::math
sync	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^  int volatile sync;$/;"	m	struct:Eigen::internal::GemmParallelInfo
sys_alloc	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void* sys_alloc(mstate m, size_t nb) {$/;"	f	file:
sys_trim	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static int sys_trim(mstate m, size_t pad) {$/;"	f	file:
system_size	vcglib/wrap/miq/core/poisson_solver.h	/^	unsigned int system_size;$/;"	m	class:PoissonSolver
sz	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^  Point3i sz;   \/\/\/ Dimensioni griglia come numero di celle per lato$/;"	m	class:vcg::SimpleVolume
sz	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^  Point3i sz;   \/\/\/ Dimensioni griglia come numero di celle per lato$/;"	m	class:vcg::SimpleVolume
sz	vcglib/vcg/math/gen_normal.h	/^    int sz;$/;"	m	class:vcg::GenNormal::OctaLevel
t	vcglib/vcg/space/index/grid_static_ptr.h	/^			ObjPtr t;$/;"	m	class:vcg::GridStaticPtr::Link
t	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^            HashIterator t;$/;"	m	struct:vcg::SpatialHashTable2D::CellIterator
t	vcglib/vcg/space/index/space_iterators.h	/^		CoordType t;$/;"	m	class:vcg::RayIterator
t	vcglib/vcg/space/index/spatial_hashing.h	/^		HashIterator t;$/;"	m	struct:vcg::SpatialHashTable::CellIterator
t	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline Point2<T> & t() { return _t[0]; }$/;"	f	class:vcg::TexCoord2
t	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline Point2<T> & t(const int i) { return _t[i]; }$/;"	f	class:vcg::TexCoord2
t	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline Point2<T> t() const { return _t[0]; }$/;"	f	class:vcg::TexCoord2
t	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline Point2<T> t(const int i) const { return _t[i]; }$/;"	f	class:vcg::TexCoord2
t	vcglib/vcg/space/texcoord2.h	/^    inline Point2<T>   t() const { return _t; }$/;"	f	class:vcg::TexCoord2Simple
t	vcglib/vcg/space/texcoord2.h	/^    inline Point2<T>   t(const int i) const { (void)i; assert(i==0); return _t; }$/;"	f	class:vcg::TexCoord2Simple
t	vcglib/vcg/space/texcoord2.h	/^    inline Point2<T> & t()       { return _t; }$/;"	f	class:vcg::TexCoord2Simple
t	vcglib/vcg/space/texcoord2.h	/^    inline Point2<T> & t(const int i)       { (void)i; assert(i==0); return _t; }$/;"	f	class:vcg::TexCoord2Simple
t	vcglib/wrap/io_trimesh/import_obj.h	/^                    std::vector<int> t;$/;"	m	struct:vcg::tri::io::ImporterOBJ::ObjIndexedFace
tInd	vcglib/wrap/io_trimesh/import_obj.h	/^                    int tInd;$/;"	m	struct:vcg::tri::io::ImporterOBJ::ObjIndexedFace
tS2	vcglib/apps/metro/sampling.h	/^    MetroMeshAABB   tS2;$/;"	m	class:vcg::Sampling
tail	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail() const$/;"	f	class:Eigen::DenseBase
tail	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail()$/;"	f	class:Eigen::DenseBase
tail	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail(Index size) const$/;"	f	class:Eigen::DenseBase
tail	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^DenseBase<Derived>::tail(Index size)$/;"	f	class:Eigen::DenseBase
take_affine_part	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  typedef internal::transform_take_affine_part<Transform> take_affine_part;$/;"	t	class:Eigen::Transform
take_matrix_for_product	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product$/;"	s	namespace:Eigen::internal
take_matrix_for_product	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Mode, Options> >$/;"	s	namespace:Eigen::internal
take_matrix_for_product	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Projective, Options> >$/;"	s	namespace:Eigen::internal
tan	vcglib/eigenlib/Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^tan() const$/;"	f
tan	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal tan(const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
tanh	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal tanh (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
target	vcglib/wrap/glw/framebuffer.h	/^		RenderableHandle target;$/;"	m	class:glw::RenderTarget
target	vcglib/wrap/glw/object.h	/^		GLenum target(void) const$/;"	f	class:glw::BoundObject
target	vcglib/wrap/glw/object.h	/^		GLenum target;$/;"	m	class:glw::ObjectBindingParams
targetInputs	vcglib/wrap/glw/framebuffer.h	/^		RenderTargetBinding  targetInputs;$/;"	m	class:glw::FramebufferArguments
targetMetric	vcglib/vcg/complex/algorithms/local_optimization.h	/^	ScalarType targetMetric;$/;"	m	class:vcg::LocalOptimization
taylorConverged	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunctionAtomic.h	/^bool MatrixFunctionAtomic<MatrixType>::taylorConverged(Index s, const MatrixType& F,$/;"	f	class:Eigen::MatrixFunctionAtomic
tbinptr	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef struct malloc_tree_chunk* tbinptr; \/* The type of bins of trees *\/$/;"	t	typeref:struct:malloc_tree_chunk	file:
tchunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef struct malloc_tree_chunk  tchunk;$/;"	t	typeref:struct:malloc_tree_chunk	file:
tchunkptr	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^typedef struct malloc_tree_chunk* tchunkptr;$/;"	t	typeref:struct:malloc_tree_chunk	file:
temp	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar temp;$/;"	m	class:Eigen::HybridNonLinearSolver
temp	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar temp, temp1, temp2;$/;"	m	class:Eigen::LevenbergMarquardt
temp1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar temp, temp1, temp2;$/;"	m	class:Eigen::LevenbergMarquardt
temp2	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar temp, temp1, temp2;$/;"	m	class:Eigen::LevenbergMarquardt
terminateTarget	vcglib/wrap/glw/context.h	/^		void terminateTarget(const TBindingParams & params)$/;"	f	class:glw::Context
terminateTargets	vcglib/wrap/glw/context.h	/^		void terminateTargets(void)$/;"	f	class:glw::Context
tess_prim_data	vcglib/wrap/gl/glu_tesselator.h	/^                tess_prim_data(GLenum t) : type(t) { }$/;"	f	class:vcg::glu_tesselator::tess_prim_data
tess_prim_data	vcglib/wrap/gl/glu_tesselator.h	/^                tess_prim_data(void) { }$/;"	f	class:vcg::glu_tesselator::tess_prim_data
tess_prim_data	vcglib/wrap/gl/glu_tesselator.h	/^        class tess_prim_data$/;"	c	class:vcg::glu_tesselator
tess_prim_data_vec	vcglib/wrap/gl/glu_tesselator.h	/^        typedef std::vector<tess_prim_data> tess_prim_data_vec;$/;"	t	class:vcg::glu_tesselator
tesselate	vcglib/wrap/gl/glu_tesselator.h	/^        static inline void tesselate(const std::vector< std::vector<point_type> > & outlines, std::vector<int> & indices)$/;"	f	class:vcg::glu_tesselator
test1	vcglib/apps/test/camerashot/camerashot_test.cpp	/^bool test1(vcg::Shotd shot1, vcg::Shotd shot2, vcg::Point3d p1, vcg::Point3d p2)$/;"	f
test10	vcglib/apps/test/camerashot/camerashot_test.cpp	/^bool test10(vcg::Shotd shot1, vcg::Shotd shot2, vcg::Point3d p1, vcg::Point3d p2)$/;"	f
test2	vcglib/apps/test/camerashot/camerashot_test.cpp	/^bool test2(vcg::Shotd shot1, vcg::Shotd shot2, vcg::Point3d p1, vcg::Point3d p2)$/;"	f
test2dHyperbolicRotation	vcglib/eigenlib/unsupported/test/matrix_exponential.cpp	/^void test2dHyperbolicRotation(double tol)$/;"	f
test2dRotation	vcglib/eigenlib/unsupported/test/matrix_exponential.cpp	/^void test2dRotation(double tol)$/;"	f
test3	vcglib/apps/test/camerashot/camerashot_test.cpp	/^bool test3(vcg::Shotd shot1, vcg::Shotd shot2, vcg::Point3d p1, vcg::Point3d p2)$/;"	f
test4	vcglib/apps/test/camerashot/camerashot_test.cpp	/^bool test4(vcg::Shotd shot, vcg::Point3d p1)$/;"	f
test5	vcglib/apps/test/camerashot/camerashot_test.cpp	/^bool test5(vcg::Shotd shot, vcg::Point3d p1, vcg::Point3d p2)$/;"	f
test6	vcglib/apps/test/camerashot/camerashot_test.cpp	/^bool test6(vcg::Shotd shot1, vcg::Shotd shot2, vcg::Point3d p1, vcg::Point3d p2)$/;"	f
test7	vcglib/apps/test/camerashot/camerashot_test.cpp	/^bool test7(vcg::Shotd shot1, vcg::Point3d p1, vcg::Point3d p2)$/;"	f
test8	vcglib/apps/test/camerashot/camerashot_test.cpp	/^bool test8(vcg::Shotd shot1, vcg::Shotd shot2, vcg::Point3d p1, vcg::Point3d p2)$/;"	f
test9	vcglib/apps/test/camerashot/camerashot_test.cpp	/^bool test9(vcg::Shotd shot1, vcg::Shotd shot2, vcg::Point3d p1, vcg::Point3d p2)$/;"	f
testAndSetOrdered	vcglib/wrap/system/multithreading/atomic_int_apple.h	/^  inline bool testAndSetOrdered(int expectedValue, int newValue)$/;"	f	class:mt::atomicInt
testAndSetOrdered	vcglib/wrap/system/multithreading/atomic_int_generic.h	/^  inline bool testAndSetOrdered(int expectedValue, int newValue)$/;"	f	class:mt::atomicInt
testChkder	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testChkder()$/;"	f
testGonioFunctions	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^void testGonioFunctions(const MatrixType& A)$/;"	f
testHybrd	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testHybrd()$/;"	f
testHybrd1	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testHybrd1()$/;"	f
testHybrj	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testHybrj()$/;"	f
testHybrj1	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testHybrj1()$/;"	f
testHyperbolicFunctions	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^void testHyperbolicFunctions(const MatrixType& A)$/;"	f
testIntersect1	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  void testIntersect1()$/;"	f	struct:TreeTest
testIntersect2	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  void testIntersect2()$/;"	f	struct:TreeTest
testLmder	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testLmder()$/;"	f
testLmder1	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testLmder1()$/;"	f
testLmdif	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testLmdif()$/;"	f
testLmdif1	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testLmdif1()$/;"	f
testLmstr	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testLmstr()$/;"	f
testLmstr1	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testLmstr1()$/;"	f
testMatrix	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^void testMatrix(const MatrixType& A)$/;"	f
testMatrixExponential	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^void testMatrixExponential(const MatrixType& A)$/;"	f
testMatrixLogarithm	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^void testMatrixLogarithm(const MatrixType& A)$/;"	f
testMatrixSqrt	vcglib/eigenlib/unsupported/test/matrix_square_root.cpp	/^void testMatrixSqrt(const MatrixType& m)$/;"	f
testMatrixType	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^void testMatrixType(const MatrixType& m)$/;"	f
testMinimize1	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  void testMinimize1()$/;"	f	struct:TreeTest
testMinimize2	vcglib/eigenlib/unsupported/test/BVH.cpp	/^  void testMinimize2()$/;"	f	struct:TreeTest
testNistBennett5	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistBennett5(void)$/;"	f
testNistBoxBOD	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistBoxBOD(void)$/;"	f
testNistChwirut2	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistChwirut2(void)$/;"	f
testNistEckerle4	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistEckerle4(void)$/;"	f
testNistHahn1	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistHahn1(void)$/;"	f
testNistLanczos1	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistLanczos1(void)$/;"	f
testNistMGH09	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistMGH09(void)$/;"	f
testNistMGH10	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistMGH10(void)$/;"	f
testNistMGH17	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistMGH17(void)$/;"	f
testNistMisra1a	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistMisra1a(void)$/;"	f
testNistMisra1d	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistMisra1d(void)$/;"	f
testNistRat42	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistRat42(void)$/;"	f
testNistRat43	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistRat43(void)$/;"	f
testNistThurber	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void testNistThurber(void)$/;"	f
testPascal	vcglib/eigenlib/unsupported/test/matrix_exponential.cpp	/^void testPascal(double tol)$/;"	f
testSharp	vcglib/wrap/dae/colladaformat.h	/^	static const QString testSharp(const QString& str)$/;"	f	namespace:Collada::Tags
test_BVH	vcglib/eigenlib/unsupported/test/BVH.cpp	/^void test_BVH()$/;"	f
test_FFTW	vcglib/eigenlib/unsupported/test/FFT.cpp	/^#define test_FFTW /;"	d	file:
test_FFTW	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^void test_FFTW()$/;"	f
test_NonLinearOptimization	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^void test_NonLinearOptimization()$/;"	f
test_NumericalDiff	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^void test_NumericalDiff()$/;"	f
test_alignedvector3	vcglib/eigenlib/unsupported/test/alignedvector3.cpp	/^void test_alignedvector3()$/;"	f
test_autodiff	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^void test_autodiff()$/;"	f
test_autodiff_jacobian	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^void test_autodiff_jacobian()$/;"	f
test_autodiff_scalar	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^void test_autodiff_scalar()$/;"	f
test_autodiff_vector	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^void test_autodiff_vector()$/;"	f
test_central	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^void test_central()$/;"	f
test_complex	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^void test_complex(int nfft)$/;"	f
test_complex_generic	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^void test_complex_generic(int nfft)$/;"	f
test_forward	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^void test_forward()$/;"	f
test_forward_adolc	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^void test_forward_adolc()$/;"	f
test_gmres	vcglib/eigenlib/unsupported/test/gmres.cpp	/^void test_gmres()$/;"	f
test_gmres_T	vcglib/eigenlib/unsupported/test/gmres.cpp	/^template<typename T> void test_gmres_T()$/;"	f
test_isApprox_abs	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^inline bool test_isApprox_abs(const Type1& a, const Type2& b)$/;"	f
test_kronecker_product	vcglib/eigenlib/unsupported/test/kronecker_product.cpp	/^void test_kronecker_product()$/;"	f
test_matrix_exponential	vcglib/eigenlib/unsupported/test/matrix_exponential.cpp	/^void test_matrix_exponential()$/;"	f
test_matrix_function	vcglib/eigenlib/unsupported/test/matrix_function.cpp	/^void test_matrix_function()$/;"	f
test_matrix_square_root	vcglib/eigenlib/unsupported/test/matrix_square_root.cpp	/^void test_matrix_square_root()$/;"	f
test_mpreal_support	vcglib/eigenlib/unsupported/test/mpreal_support.cpp	/^void test_mpreal_support()$/;"	f
test_openglsupport	vcglib/eigenlib/unsupported/test/openglsupport.cpp	/^void test_openglsupport()$/;"	f
test_polynomialsolver	vcglib/eigenlib/unsupported/test/polynomialsolver.cpp	/^void test_polynomialsolver()$/;"	f
test_polynomialutils	vcglib/eigenlib/unsupported/test/polynomialutils.cpp	/^void test_polynomialutils()$/;"	f
test_random_setter	vcglib/eigenlib/unsupported/test/sparse_extra.cpp	/^bool test_random_setter(DynamicSparseMatrix<T>& sm, const DenseType& ref, const std::vector<Vector2i>& nonzeroCoords)$/;"	f
test_random_setter	vcglib/eigenlib/unsupported/test/sparse_extra.cpp	/^bool test_random_setter(SparseMatrix<Scalar,Options>& sm, const DenseType& ref, const std::vector<Vector2i>& nonzeroCoords)$/;"	f
test_return_by_value	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^void test_return_by_value(int len)$/;"	f
test_scalar	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^void test_scalar(int nfft)$/;"	f
test_scalar_generic	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^void test_scalar_generic(int nfft)$/;"	f
test_sparse_extra	vcglib/eigenlib/unsupported/test/sparse_extra.cpp	/^void test_sparse_extra()$/;"	f
test_splines	vcglib/eigenlib/unsupported/test/splines.cpp	/^void test_splines()$/;"	f
tetra	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^namespace tetra{$/;"	n	namespace:vcg
tetra	vcglib/vcg/simplex/tetrahedron/component.h	/^  namespace tetra {$/;"	n	namespace:vcg
tetra	vcglib/vcg/simplex/tetrahedron/pos.h	/^  namespace tetra {$/;"	n	namespace:vcg
tetra	vcglib/wrap/gl/tetramesh.h	/^	CONT_TETRA	* tetra;	$/;"	m	class:vcg::tetra::GlTetramesh
tetra	vcglib/wrap/gl/tetramesh.h	/^namespace tetra {$/;"	n	namespace:vcg
tetra	vcglib/wrap/io_tetramesh/export_ply.h	/^namespace tetra {$/;"	n	namespace:vcg
tetra	vcglib/wrap/io_tetramesh/export_ts.h	/^namespace tetra {$/;"	n	namespace:vcg
tetra	vcglib/wrap/io_tetramesh/import_ply.h	/^namespace tetra {$/;"	n	namespace:vcg
tetra	vcglib/wrap/io_tetramesh/import_ts.h	/^namespace tetra {$/;"	n	namespace:vcg
tetra	vcglib/wrap/io_tetramesh/io_ply.h	/^namespace tetra {$/;"	n	namespace:vcg
tex	vcglib/wrap/gl/fbo.h	/^	Texture2D * tex;$/;"	m	class:TextureRenderTarget
texcoord	vcglib/wrap/io_tetramesh/import_ply.h	/^	float texcoord[32];$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
texcoord	vcglib/wrap/io_trimesh/import_ply.h	/^	float texcoord[32];$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
texcoordind	vcglib/wrap/io_tetramesh/import_ply.h	/^	int texcoordind;$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
texcoordind	vcglib/wrap/io_trimesh/import_ply.h	/^	int texcoordind;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
texelFetch	vcglib/wrap/glw/texture.h	/^		static TextureSampleMode texelFetch(void)$/;"	f	class:glw::TextureSampleMode
text	vcglib/wrap/glw/utility.h	/^		ThisType & text(const std::string & txt)$/;"	f	class:glw::ShaderHeaderBuilder
textindex	vcglib/wrap/io_trimesh/import_fbx.h	/^			int textindex;$/;"	m	class:ImporterFBX::VCGMaterialBridge::MaterialInfo
texture2DTarget	vcglib/wrap/glw/framebuffer.h	/^inline RenderTarget texture2DTarget(Texture2DHandle & handle, GLint level = 0)$/;"	f	namespace:glw
textureCubeTarget	vcglib/wrap/glw/framebuffer.h	/^inline RenderTarget textureCubeTarget(TextureCubeHandle & handle, GLenum face = GL_TEXTURE_CUBE_MAP_POSITIVE_X, GLint level = 0)$/;"	f	namespace:glw
textureFinder	vcglib/wrap/dae/util_dae.h	/^		inline static QDomNode textureFinder(QString& boundMaterialName, QString &textureFileName, const QDomDocument doc)$/;"	f	class:vcg::tri::io::UtilDAE
textureIdMap	vcglib/wrap/dae/util_dae.h	/^		QMap<QString,int> textureIdMap;$/;"	m	class:vcg::tri::io::InfoDAE
textureSampleMode	vcglib/wrap/glw/texture.h	/^inline TextureSampleMode textureSampleMode(GLenum minFilter = GLW_DONT_CARE, GLenum magFilter = GLW_DONT_CARE, GLenum wrapS = GLW_DONT_CARE, GLenum wrapT = GLW_DONT_CARE, GLenum wrapR = GLW_DONT_CARE)$/;"	f	namespace:glw
textures	vcglib/vcg/complex/base.h	/^  std::vector<std::string> textures;$/;"	m	class:vcg::tri::TriMesh
tf	vcglib/vcg/complex/algorithms/local_optimization.h	/^	int tf;$/;"	m	class:vcg::LocalOptimization
thenMatrix	vcglib/eigenlib/Eigen/src/Core/Select.h	/^    const ThenMatrixType& thenMatrix() const$/;"	f	class:Eigen::Select
theta	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  int theta;$/;"	m	class:vcg::tri::AreaPreservingTextureOptimizer
this_type	vcglib/wrap/gl/gl_surface.h	/^		typedef gl_surface this_type;$/;"	t	class:vcg::gl_surface
this_type	vcglib/wrap/gl/glu_tesselator.h	/^                typedef tess_prim_data this_type;$/;"	t	class:vcg::glu_tesselator::tess_prim_data
this_type	vcglib/wrap/gl/glu_tesselator.h	/^        typedef glu_tesselator this_type;$/;"	t	class:vcg::glu_tesselator
this_type	vcglib/wrap/system/multithreading/condition.h	/^		typedef condition this_type;$/;"	t	class:mt::condition
this_type	vcglib/wrap/system/multithreading/mutex.h	/^		typedef mutex this_type;$/;"	t	class:mt::mutex
this_type	vcglib/wrap/system/multithreading/rw_lock.h	/^		typedef rw_lock this_type;$/;"	t	class:mt::rw_lock
this_type	vcglib/wrap/system/multithreading/scoped_mutex_lock.h	/^            typedef scoped_mutex_lock this_type;$/;"	t	class:mt::scoped_mutex_lock
this_type	vcglib/wrap/system/multithreading/scoped_read_lock.h	/^		typedef scoped_read_lock this_type;$/;"	t	class:mt::scoped_read_lock
this_type	vcglib/wrap/system/multithreading/scoped_write_lock.h	/^		typedef scoped_write_lock this_type;$/;"	t	class:mt::scoped_write_lock
this_type	vcglib/wrap/system/multithreading/semaphore.h	/^  typedef semaphore this_type;$/;"	t	class:mt::semaphore
this_type	vcglib/wrap/system/multithreading/thread.h	/^            typedef thread this_type;$/;"	t	class:mt::thread
thr	vcglib/vcg/complex/algorithms/refine.h	/^  ScalarType thr;$/;"	m	class:vcg::tri::QualityEdgePredicate
thr	vcglib/vcg/complex/algorithms/refine.h	/^  ScalarType thr;$/;"	m	class:vcg::tri::QualityMidPointFunctor
thread	vcglib/wrap/system/multithreading/mt.h	/^  typedef QThread thread;$/;"	t	namespace:mt
thread	vcglib/wrap/system/multithreading/thread.h	/^            thread(void) : flags(0)$/;"	f	class:mt::thread
thread	vcglib/wrap/system/multithreading/thread.h	/^class thread$/;"	c	namespace:mt
thread_flags	vcglib/wrap/system/multithreading/thread.h	/^            enum thread_flags$/;"	g	class:mt::thread
thread_func	vcglib/wrap/system/multithreading/thread.h	/^            static void * thread_func(void * param)$/;"	f	class:mt::thread
thread_none	vcglib/wrap/system/multithreading/thread.h	/^                    thread_none    = (     0),$/;"	e	enum:mt::thread::thread_flags
thread_running	vcglib/wrap/system/multithreading/thread.h	/^                    thread_running = (1 << 1)$/;"	e	enum:mt::thread::thread_flags
thread_started	vcglib/wrap/system/multithreading/thread.h	/^                    thread_started = (1 << 0),$/;"	e	enum:mt::thread::thread_flags
threadid	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  long threadid;$/;"	m	struct:win32_mlock_t	file:
threadid	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  pthread_t threadid;$/;"	m	struct:pthread_mlock_t	file:
threshold	vcglib/eigenlib/Eigen/src/LU/FullPivLU.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivLU
threshold	vcglib/eigenlib/Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::ColPivHouseholderQR
threshold	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivHouseholderQR
threshold	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        float threshold;                                \/\/\/< Consensus percentage requested to win consensus. Used to paint \\c mMov. If the overlap overcames the \\c threshold (and \\c bestScore), \\c mMov is painted.$/;"	m	class:OverlapEstimation::Parameters
throw_std_bad_alloc	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^inline void throw_std_bad_alloc()$/;"	f	namespace:Eigen::internal
thurber_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    thurber_functor(void) : Functor<double>(7,37) {}$/;"	f	struct:thurber_functor
thurber_functor	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^struct thurber_functor : Functor<double>$/;"	s	file:
tid	vcglib/wrap/system/multithreading/thread.h	/^            pthread_t tid;$/;"	m	class:mt::thread
timeBudget	vcglib/vcg/complex/algorithms/local_optimization.h	/^	float	timeBudget;$/;"	m	class:vcg::LocalOptimization
timerCallback	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^Uint32 timerCallback(Uint32 interval, void *param){ $/;"	f
tipo	vcglib/wrap/ply/plylib.h	/^	int    tipo;				\/\/ Tipo di dato$/;"	m	class:vcg::ply::PlyProperty
tipoindex	vcglib/wrap/ply/plylib.h	/^	int    tipoindex;			\/\/ Tipo del contatore della lista$/;"	m	class:vcg::ply::PlyProperty
tm	vcglib/vcg/space/index/space_iterators.h	/^		TMARKER tm;$/;"	m	class:vcg::ClosestIterator
tm	vcglib/vcg/space/index/space_iterators.h	/^		TMARKER tm;$/;"	m	class:vcg::RayIterator
tmalloc_large	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void* tmalloc_large(mstate m, size_t nb) {$/;"	f	file:
tmalloc_small	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static void* tmalloc_small(mstate m, size_t nb) {$/;"	f	file:
toDense	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^      Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> toDense() const$/;"	f	class:Eigen::SparseMatrixBase
toDense	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrixBase.h	/^    Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime> toDense() const {$/;"	f	class:Eigen::SkylineMatrixBase
toDenseMatrix	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::internal::BandMatrixBase
toDenseMatrix	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return derived(); }$/;"	f	class:Eigen::DiagonalBase
toDenseMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return *this; }$/;"	f	class:Eigen::Transpose
toDenseMatrix	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::PermutationBase
toDenseMatrix	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::TriangularBase
toDouble	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline double			mpreal::toDouble()	const	{	return mpfr_get_d(mp,default_rnd);	}$/;"	f	class:mpfr::mpreal
toInt64	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline int64_t	 mpreal::toInt64()	const{	return mpfr_get_sj(mp,GMP_RNDZ);	}$/;"	f	class:mpfr::mpreal
toLDouble	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline long double		mpreal::toLDouble()	const	{	return mpfr_get_ld(mp,default_rnd);	}$/;"	f	class:mpfr::mpreal
toLong	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline long				mpreal::toLong()	const	{	return mpfr_get_si(mp,GMP_RNDZ);	}$/;"	f	class:mpfr::mpreal
toPos	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    Vec3 toPos(const Signature &s) const{$/;"	f	class:vcg::tri::Zonohedron
toQMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim>::toQMatrix(void) const$/;"	f	class:Eigen::Transform
toQMatrix	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim,Mode,Options>::toQMatrix(void) const$/;"	f	class:Eigen::Transform
toQTransform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim>::toQTransform(void) const$/;"	f	class:Eigen::Transform
toQTransform	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim,Mode,Options>::toQTransform(void) const$/;"	f	class:Eigen::Transform
toRotationMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis
toRotationMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Quaternion
toRotationMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D
toRotationMatrix	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase
toRotationMatrix	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis
toRotationMatrix	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::toRotationMatrix(void) const$/;"	f	class:Eigen::QuaternionBase
toRotationMatrix	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D
toRotationMatrix	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase
toRotationMatrix	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen::internal
toRotationMatrix	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen::internal
toRotationMatrix	vcglib/eigenlib/Eigen/src/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen::internal
toString	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^std::string mpreal::toString(const std::string& format) const$/;"	f	class:mpfr::mpreal
toString	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^std::string mpreal::toString(int n, int b, mp_rnd_t mode) const$/;"	f	class:mpfr::mpreal
toString	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^std::string toString(T t, std::ios_base & (*f)(std::ios_base&))$/;"	f	namespace:mpfr
toString	vcglib/wrap/glw/utility.h	/^		std::string toString(void) const$/;"	f	class:glw::ShaderHeaderBuilder
toString	vcglib/wrap/qt/to_string.h	/^inline QString toString( const vcg::Point2f& p ){$/;"	f
toString	vcglib/wrap/qt/to_string.h	/^inline QString toString( const vcg::Point2i& p ){$/;"	f
toString	vcglib/wrap/qt/to_string.h	/^inline QString toString( const vcg::Point3f& p ){$/;"	f
toString	vcglib/wrap/qt/to_string.h	/^inline QString toString( const vcg::Point4f& p ){$/;"	f
toString	vcglib/wrap/qt/to_string.h	/^inline QString toString(vcg::Matrix44f& m){$/;"	f
toUInt64	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline uint64_t	 mpreal::toUInt64()	const{	return mpfr_get_uj(mp,GMP_RNDZ);	}$/;"	f	class:mpfr::mpreal
toULong	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline unsigned long	mpreal::toULong()	const	{	return mpfr_get_ui(mp,GMP_RNDZ);	}$/;"	f	class:mpfr::mpreal
to_explore	vcglib/vcg/space/index/space_iterators.h	/^		vcg::Box3i to_explore;		\/\/current bounding box explored$/;"	m	class:vcg::ClosestIterator
to_fix	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    std::vector<VertexType *> to_fix;$/;"	m	class:vcg::tri::PoissonSolver
todump	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  int			todump;$/;"	v
tokens	vcglib/wrap/gcache/controller.h	/^  std::vector<Token *> tokens;$/;"	m	class:vcg::Controller
tolerance	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar tolerance() const { return m_tolerance; }$/;"	f	class:Eigen::IterativeSolverBase
tolerance	vcglib/wrap/miq/quadrangulator.h	/^        ScalarType tolerance;$/;"	m	class:Quadrangulator::EdgePredicate
tolerance	vcglib/wrap/miq/quadrangulator.h	/^        ScalarType tolerance;$/;"	m	struct:Quadrangulator::SplitMidPoint
tomap	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  int			tomap;				\/\/ skip all maps AFTER this index$/;"	v
top	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  mchunkptr  top;$/;"	m	struct:malloc_state	file:
topLeftCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topLeftCorner()$/;"	f
topLeftCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> topLeftCorner(Index cRows, Index cCols)$/;"	f
topLeftCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topLeftCorner() const$/;"	f
topLeftCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> topLeftCorner(Index cRows, Index cCols) const$/;"	f
topRightCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topRightCorner()$/;"	f
topRightCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> topRightCorner(Index cRows, Index cCols)$/;"	f
topRightCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topRightCorner() const$/;"	f
topRightCorner	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> topRightCorner(Index cRows, Index cCols) const$/;"	f
topRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr topRows(Index n) const$/;"	f
topRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr topRows(Index n)$/;"	f
topRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type topRows() const$/;"	f
topRows	vcglib/eigenlib/Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type topRows()$/;"	f
topSpeedH	vcglib/wrap/gui/trackmode.h	/^	float accX, accY, accZ, dumping, topSpeedH, topSpeedV;$/;"	m	class:vcg::NavigatorWasdMode
topSpeedV	vcglib/wrap/gui/trackmode.h	/^	float accX, accY, accZ, dumping, topSpeedH, topSpeedV;$/;"	m	class:vcg::NavigatorWasdMode
topsize	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t     topsize;$/;"	m	struct:malloc_state	file:
tot	vcglib/apps/pivoting/glarea.h	/^    int tot;      $/;"	m	class:GLArea
totArea	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  ScalarType totArea;$/;"	m	class:vcg::tri::AreaPreservingTextureOptimizer
totalTime	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^     int totalTime;$/;"	m	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam::Stat
totalTime	vcglib/vcg/complex/algorithms/point_sampling.h	/^    int totalTime;$/;"	m	struct:vcg::tri::SurfaceSampling::PoissonDiskParam::Stat
total_size	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    unsigned int total_size;$/;"	m	class:vcg::tri::PoissonSolver
touches	vcglib/apps/pivoting/pivot.h	/^    std::list<Hinge>::iterator touches(int v, std::list<Hinge>::iterator e) {$/;"	f	class:vcg::tri::Pivot
tra	vcglib/vcg/math/shot.h	/^      Point3<S> tra; \/\/ viewpoint$/;"	m	class:vcg::Shot::ReferenceFrame
tra	vcglib/vcg/math/similarity.h	/^  Point3<S> tra;$/;"	m	class:vcg::Similarity
tra	vcglib/vcg/math/similarity2.h	/^  Point2<SCALAR_TYPE> tra;$/;"	m	class:vcg::Similarity2
trace	vcglib/eigenlib/Eigen/src/Core/Redux.h	/^MatrixBase<Derived>::trace() const$/;"	f	class:Eigen::MatrixBase
track	vcglib/apps/sample/trimesh_QT/glarea.h	/^  vcg::Trackball track;$/;"	m	class:GLArea
track	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^vcg::Trackball track;$/;"	v
track	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^vcg::Trackball track;     \/\/\/ the active manipulator$/;"	v
track	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		vcg::Trackball track;$/;"	m	class:GLWidget
track	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^vcg::Trackball track;$/;"	v
track	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^vcg::Trackball track;$/;"	v
track	vcglib/wrap/gui/trackball.h	/^  Similarityf track;$/;"	m	class:vcg::Transform
trackball	vcglib/apps/pivoting/glarea.h	/^    vcg::Trackball trackball;$/;"	m	class:GLArea
trackballMode	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^int trackballMode=1;$/;"	v
trackfile	vcglib/wrap/gui/trackrecorder.h	/^	FILE * trackfile;$/;"	m	struct:vcg::TrackRecorder
trackutils	vcglib/wrap/gui/trackutils.h	/^namespace trackutils {$/;"	n	namespace:vcg
traits	vcglib/eigenlib/Eigen/src/Core/Array.h	/^struct traits<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > : traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^struct traits<ArrayWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^struct traits<MatrixWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Block.h	/^struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel, HasDirectAccess> > : traits<XprType>$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/CwiseBinaryOp.h	/^struct traits<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/CwiseNullaryOp.h	/^struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType> > : traits<PlainObjectType>$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryOp.h	/^struct traits<CwiseUnaryOp<UnaryOp, XprType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/CwiseUnaryView.h	/^struct traits<CwiseUnaryView<ViewOp, MatrixType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Diagonal.h	/^struct traits<Diagonal<MatrixType,DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalMatrix<_Scalar,SizeAtCompileTime,MaxSizeAtCompileTime> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalWrapper<_DiagonalVectorType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/DiagonalProduct.h	/^struct traits<DiagonalProduct<MatrixType, DiagonalType, ProductOrder> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^struct traits<Flagged<ExpressionType, Added, Removed> > : traits<ExpressionType>$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^struct traits<ForceAlignedAccess<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemvProduct> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,InnerProduct> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,OuterProduct> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Map.h	/^struct traits<Map<PlainObjectType, MapOptions, StrideType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Matrix.h	/^struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^struct traits<NestByValue<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^struct traits<Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^struct traits<Transpose<PermutationBase<Derived> > >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^struct traits<permut_matrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Product.h	/^struct traits<Product<Lhs, Rhs> >$/;"	s	namespace:internal
traits	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^struct traits<ProductBase<Derived,_Lhs,_Rhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^struct traits<ScaledProduct<NestedProduct> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Replicate.h	/^struct traits<Replicate<MatrixType,RowFactor,ColFactor> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^struct traits<ReturnByValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^struct traits<Reverse<MatrixType, Direction> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Select.h	/^struct traits<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^struct traits<SelfAdjointView<MatrixType, UpLo> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/SelfCwiseBinaryOp.h	/^struct traits<SelfCwiseBinaryOp<BinaryOp,Lhs,Rhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^struct traits<triangular_solve_retval<Side, TriangularType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Swap.h	/^struct traits<SwapWrapper<ExpressionType> > : traits<ExpressionType> {};$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^struct traits<Transpose<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^struct traits<Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^struct traits<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^struct traits<TranspositionsWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^struct traits<transposition_matrix_product_retval<TranspositionType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct traits<TriangularView<MatrixType, _Mode> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/VectorBlock.h	/^struct traits<VectorBlock<VectorType, Size> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^struct traits<PartialReduxExpr<MatrixType, MemberOp, Direction> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^struct traits<CoeffBasedProduct<LhsNested,RhsNested,NestingFlags> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemmProduct> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,true> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,true,Rhs,false> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename T> struct traits<const T> : traits<T> {};$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Eigen2Support/Minor.h	/^struct traits<Minor<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^struct traits<HessenbergDecompositionMatrixHReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct traits<TridiagonalizationMatrixTReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Geometry/AngleAxis.h	/^template<typename _Scalar> struct traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^struct traits<Homogeneous<MatrixType,Direction> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<Quaternion<_Scalar>, _Options> >:$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<const Quaternion<_Scalar>, _Options> >:$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^struct traits<Quaternion<_Scalar,_Options> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Geometry/Rotation2D.h	/^template<typename _Scalar> struct traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^struct traits<HouseholderSequence<VectorsType,CoeffsType,Side> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^struct traits<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^struct traits<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/LU/Inverse.h	/^struct traits<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/QR/FullPivHouseholderQR.h	/^struct traits<FullPivHouseholderQRMatrixQReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo> struct traits<SimplicialCholesky<_MatrixType,_UpLo> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo> struct traits<SimplicialLLT<_MatrixType,_UpLo> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType,int _UpLo> struct traits<SimplicialLDLT<_MatrixType,_UpLo> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^struct traits<MappedSparseMatrix<_Scalar, _Flags, _Index> > : traits<SparseMatrix<_Scalar, _Flags, _Index> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^struct traits<SparseInnerVectorSet<MatrixType, Size> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<DenseTimeSparseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseDenseOuterProduct<Lhs,Rhs,Tr> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseTimeDenseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct traits<SparseDiagonalProduct<Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<Diagonal<const SparseMatrix<_Scalar, _Options, _Index>, DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<SparseMatrix<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparsePermutation.h	/^struct traits<permut_sparsematrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseProduct.h	/^struct traits<SparseSparseProduct<LhsNested, RhsNested> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<DenseTimeSparseSelfAdjointProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointTimeDenseProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointView<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSymmetricPermutationProduct<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^struct traits<SparseTriangularView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^struct traits<SparseVector<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/SparseCore/SparseView.h	/^struct traits<SparseView<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/misc/Image.h	/^struct traits<image_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/misc/Kernel.h	/^struct traits<kernel_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/misc/Solve.h	/^struct traits<solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^struct traits<solve_retval_with_guess<DecompositionType, Rhs, Guess> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/Eigen/src/misc/SparseSolve.h	/^struct traits<sparse_solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^struct traits<GMRES<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixExponential.h	/^struct traits<MatrixExponentialReturnValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixFunction.h	/^struct traits<MatrixFunctionReturnValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixLogarithm.h	/^  struct traits<MatrixLogarithmReturnValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/unsupported/Eigen/src/MatrixFunctions/MatrixSquareRoot.h	/^struct traits<MatrixSquareRootReturnValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^struct traits<SkylineMatrix<_Scalar, _Options> > {$/;"	s	namespace:Eigen::internal
traits	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineProduct.h	/^struct internal::traits<SkylineProduct<LhsNested, RhsNested, ProductMode> > {$/;"	s	class:Eigen::internal
traits	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^struct traits<DynamicSparseMatrix<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
trans	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    bool trans() const { return m_trans; }     \/**< \\brief Returns the transpose flag. *\/$/;"	f	class:Eigen::HouseholderSequence
transfers	vcglib/wrap/gcache/cache.h	/^    std::vector<Transfer<Token> *> transfers;$/;"	m	class:vcg::Cache
transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane
transform	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime>& t,$/;"	f	class:Eigen::Hyperplane
transform	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane
transform	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t,$/;"	f	class:Eigen::Hyperplane
transform_construct_from_matrix	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_product_result	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_product_result$/;"	s	namespace:Eigen::internal
transform_right_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 0 >$/;"	s	namespace:Eigen::internal
transform_right_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 1 >$/;"	s	namespace:Eigen::internal
transform_right_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 2 >$/;"	s	namespace:Eigen::internal
transform_take_affine_part	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_take_affine_part<Transform<Scalar,Dim,AffineCompact, Options> > {$/;"	s	namespace:Eigen::internal
transform_take_affine_part	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^template<typename TransformType> struct transform_take_affine_part {$/;"	s	namespace:Eigen::internal
transform_traits	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_traits$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,AffineCompact,LhsOptions>,Transform<Scalar,Dim,Projective,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,false >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,Projective,LhsOptions>,Transform<Scalar,Dim,AffineCompact,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
translate	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const VectorType& t)$/;"	f	class:Eigen::AlignedBox
translate	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
translate	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const MatrixBase<Derived>& a_t)$/;"	f	class:Eigen::AlignedBox
translate	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
translation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform
translation	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline TranslationPart translation() { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform
translation	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return ConstTranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform
translation	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline TranslationPart translation() { return TranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform
translation	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  VectorType& translation() { return m_coeffs; }$/;"	f	class:Eigen::Translation
translation	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  const VectorType& translation() const { return m_coeffs; }$/;"	f	class:Eigen::Translation
translationExt	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt()$/;"	f	class:Eigen::Transform
translationExt	vcglib/eigenlib/Eigen/src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt() const$/;"	f	class:Eigen::Transform
transpose	vcglib/eigenlib/Eigen/src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> transpose() const$/;"	f	class:Eigen::PermutationBase
transpose	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose() const$/;"	f	class:Eigen::DenseBase
transpose	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose()$/;"	f	class:Eigen::DenseBase
transpose	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> transpose() const$/;"	f	class:Eigen::TranspositionsBase
transpose	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView<Transpose<MatrixType>,TransposeMode> transpose()$/;"	f	class:Eigen::TriangularView
transpose	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<Transpose<MatrixType>,TransposeMode> transpose() const$/;"	f	class:Eigen::TriangularView
transpose	vcglib/eigenlib/Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence transpose() const$/;"	f	class:Eigen::HouseholderSequence
transpose	vcglib/eigenlib/Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation transpose() const { return JacobiRotation(m_c, -internal::conj(m_s)); }$/;"	f	class:Eigen::JacobiRotation
transpose	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    Transpose<Derived> transpose() { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase
transpose	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    const Transpose<const Derived> transpose() const { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase
transpose	vcglib/vcg/math/matrix33.h	/^    Matrix33 transpose() const$/;"	f	class:vcg::Matrix33
transpose	vcglib/vcg/math/matrix44.h	/^	Matrix44 transpose() const$/;"	f	class:vcg::Matrix44
transpose	vcglib/vcg/math/old_deprecated_matrix.h	/^			Matrix transpose()$/;"	f	class:vcg::ndim::Matrix
transposeInPlace	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^inline void DenseBase<Derived>::transposeInPlace()$/;"	f	class:Eigen::DenseBase
transposeInPlace	vcglib/vcg/math/matrix33.h	/^    void transposeInPlace() { this->Transpose(); }$/;"	f	class:vcg::Matrix33
transposeInPlace	vcglib/vcg/math/matrix44.h	/^	void transposeInPlace() { Transpose(*this); }$/;"	f	class:vcg::Matrix44
transposeInPlace	vcglib/vcg/math/old_deprecated_matrix.h	/^			void transposeInPlace() { Transpose(); }$/;"	f	class:vcg::ndim::Matrix
transposition_matrix_product_retval	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^    transposition_matrix_product_retval(const TranspositionType& tr, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval
transposition_matrix_product_retval	vcglib/eigenlib/Eigen/src/Core/Transpositions.h	/^struct transposition_matrix_product_retval$/;"	s	namespace:Eigen::internal
transpositionsP	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    inline const TranspositionType& transpositionsP() const$/;"	f	class:Eigen::LDLT
traverse_and_check	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static size_t traverse_and_check(mstate m) {$/;"	f	file:
tree	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  KdTree<float> *tree;$/;"	m	class:vcg::tri::BallPivoting
tree	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^	TreeType tree;$/;"	m	class:vcg::AABBBinaryTreeIndex
treebin_at	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define treebin_at(/;"	d	file:
treebins	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  tbinptr    treebins[NTREEBINS];$/;"	m	struct:malloc_state	file:
treemap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  binmap_t   treemap;$/;"	m	struct:malloc_state	file:
treemap_is_marked	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define treemap_is_marked(/;"	d	file:
tref	vcglib/vcg/complex/algorithms/clip.h	/^    unsigned int tref;$/;"	m	class:vcg::tri::TriMeshClipper::VertexClipInfo
trg	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    VertexPointer trg;$/;"	m	class:vcg::tri::PointCloudNormal::WArc
tri	vcglib/apps/pivoting/pivot.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/attribute_seam.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^namespace vcg{namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^namespace vcg{namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/bitquad_support.h	/^namespace vcg{namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/clean.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/clip.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/closest.h	/^	namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/clustering.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/clustering.h	/^} namespace vcg{ namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/crease_cut.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/emc_lookup_table.h	/^	namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^    namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/extrude.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^    namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^	namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/platonic.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/resampler.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/edge_collapse.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/geodesic.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^    namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/harmonic.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/hole.h	/^    namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/inertia.h	/^  namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/inside.h	/^	namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^    namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/nring.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/outline_support.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^	namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^	namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^	namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/point_sampling.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/polygon_support.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/refine.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/refine_loop.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/smooth.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/stat.h	/^namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/symmetry.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/bounding.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/color.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/component_ep.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/curvature.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^namespace vcg { namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/flag.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^    namespace tri{$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^    namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/normal.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/position.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/quality.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/selection.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/texture.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/update/topology.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/allocate.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/append.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/complex/base.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/vcg/simplex/face/component_occ.h	/^	namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/simplex/face/component_ocf.h	/^  namespace tri$/;"	n	namespace:vcg
tri	vcglib/vcg/simplex/vertex/component_ocf.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/wrap/dae/poly_triangulator.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/dae/util_dae.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/gl/glu_tessellator_cap.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_edgemesh/export_svg.h	/^  namespace tri$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_3ds.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_ctm.h	/^    namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_dae.h	/^namespace tri$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_dxf.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_field.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_gts.h	/^	namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_idtf.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_obj.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_off.h	/^	namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_ply.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_smf.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_stl.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_u3d.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_vmi.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/export_vrml.h	/^	namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_asc.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_ctm.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_dae.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_field.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_gts.h	/^	namespace tri$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_nvm.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_obj.h	/^    namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_off.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_out.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_ply.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_ptx.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_raw.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_smf.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_stl.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/import_vmi.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/io_fan_tessellator.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/io_mask.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/io_material.h	/^namespace tri {$/;"	n	namespace:vcg
tri	vcglib/wrap/io_trimesh/io_ply.h	/^namespace tri {$/;"	n	namespace:vcg
tri_mesh	vcglib/vcg/complex/algorithms/symmetry.h	/^    TriMeshType &tri_mesh;$/;"	m	class:vcg::tri::ExtrinsicPlaneSymmetry
tri_tri_intersect_with_isectline	vcglib/vcg/space/intersection/triangle_triangle3.h	/^bool tri_tri_intersect_with_isectline(	Point3<T> V0,Point3<T> V1,Point3<T> V2,$/;"	f	namespace:vcg
triangularView	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::MatrixBase
triangularView	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView()$/;"	f	class:Eigen::MatrixBase
triangularView	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^SparseMatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::SparseMatrixBase
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Lower), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Upper), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Mode, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,ColMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,RowMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product_trmv	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^struct triangular_matrix_vector_product_trmv :$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_retval	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^  triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solve_retval
triangular_solve_retval	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval$/;"	s	namespace:Eigen::internal
triangular_solve_vector	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	vcglib/eigenlib/Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheRight, Mode, Conjugate, StorageOrder>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,false> {$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,true> {$/;"	s	namespace:Eigen::internal
triangulate	vcglib/vcg/complex/algorithms/hole.h	/^    static void triangulate(MESH &m, FaceIterator &f,int i, int j,$/;"	f	class:vcg::tri::Hole
triangulate	vcglib/wrap/dae/poly_triangulator.h	/^		void triangulate(TRIMESH& mesh)$/;"	f	class:vcg::tri::io::PolygonalMesh
triangulateRegion	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  bool triangulateRegion;       \/\/\/ If true when building the voronoi diagram mesh each region is a$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
tribb_kernel	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct tribb_kernel$/;"	s	namespace:Eigen::internal
trickleDownMax	vcglib/wrap/gcache/dheap.h	/^  void trickleDownMax(int i) {$/;"	f	class:DHeap
trickleDownMin	vcglib/wrap/gcache/dheap.h	/^  void trickleDownMin(int i) {$/;"	f	class:DHeap
tridiagonal_qr_step	vcglib/eigenlib/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace_selector	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,1,IsComplex>$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	vcglib/eigenlib/Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,3,false>$/;"	s	namespace:Eigen::internal
trim_check	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t     trim_check;$/;"	m	struct:malloc_state	file:
trim_threshold	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  size_t trim_threshold;$/;"	m	struct:malloc_params	file:
tripleProduct	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    static Scalar tripleProduct( const Vec3 &a, const Vec3 &b, const Vec3 & c){$/;"	f	class:vcg::tri::Zonohedron
trmv_selector	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<ColMajor>$/;"	s	namespace:Eigen::internal
trmv_selector	vcglib/eigenlib/Eigen/src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<RowMajor>$/;"	s	namespace:Eigen::internal
trolltechGreen	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^    QColor trolltechGreen;$/;"	m	class:GLWidget
trolltechPurple	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^    QColor trolltechPurple;$/;"	m	class:GLWidget
trovamiunnome	vcglib/apps/pivoting/pivot.h	/^    void Pivot::trovamiunnome(std::list<Hinge>::iterator e) {$/;"	f	class:vcg::tri::Pivot::Pivot
trsolve_traits	vcglib/eigenlib/Eigen/src/Core/SolveTriangular.h	/^class trsolve_traits$/;"	c	namespace:Eigen::internal
true_type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
trunc	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal trunc(const mpreal& v)$/;"	f	namespace:mpfr
tryAcquire	vcglib/wrap/system/multithreading/semaphore.h	/^  bool tryAcquire(int n=1)$/;"	f	class:mt::semaphore
trywait	vcglib/wrap/system/multithreading/semaphore.h	/^  bool trywait(void)$/;"	f	class:mt::semaphore
twistedBy	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseSymmetricPermutationProduct<Derived,Upper|Lower> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseMatrixBase
twistedBy	vcglib/eigenlib/Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct<_MatrixTypeNested,UpLo> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseSelfAdjointView
two_demos	vcglib/eigenlib/unsupported/doc/examples/FFT.cpp	/^void two_demos(int nfft)$/;"	f
type	vcglib/apps/trimeshinfo/InstancesNode.h	/^	char*	type;$/;"	m	class:InstanceNode
type	vcglib/apps/trimeshinfo/SlotsNode.h	/^	const char* type;$/;"	m	class:EntryNode
type	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^  typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::type>::type type;$/;"	t	struct:Eigen::internal::add_const_on_value_type_if_arithmetic
type	vcglib/eigenlib/Eigen/src/Core/GenericPacketMath.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::atan2_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::conj_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::pow_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::random_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::sqrt_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::imag_ref_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::real_ref_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs2_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::hypot_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::imag_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::norm1_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::real_retval
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base
type	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	t	struct:Eigen::internal::always_void
type	vcglib/eigenlib/Eigen/src/Core/MatrixBase.h	/^      typedef Matrix<Scalar,MatrixBase::RowsAtCompileTime,MatrixBase::ColsAtCompileTime> type;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type
type	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedAlignedMapType
type	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstAlignedMapType
type	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstMapType
type	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedMapType
type	vcglib/eigenlib/Eigen/src/Core/ProductBase.h	/^  typedef PlainObject const& type;$/;"	t	struct:Eigen::internal::nested
type	vcglib/eigenlib/Eigen/src/Core/ReturnByValue.h	/^  typedef typename traits<Derived>::ReturnType type;$/;"	t	struct:Eigen::internal::nested
type	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;$/;"	t	struct:Eigen::internal::TransposeImpl_base
type	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^      typedef typename ProdRetType::PlainObject type;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type
type	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  typedef SelfAdjointView<MatrixType, Upper> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type
type	vcglib/eigenlib/Eigen/src/Core/TriangularMatrix.h	/^  typedef TriangularView<MatrixType, Mode> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type
type	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	vcglib/eigenlib/Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef PlainObject const& type;$/;"	t	struct:Eigen::internal::nested
type	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef ComplexScalar type(ComplexScalar, int);$/;"	t	struct:Eigen::internal::stem_function
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^    typedef typename binary_result_of_select<Func, ArgType0, ArgType1, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^    typedef typename unary_result_of_select<Func, ArgType, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	t	struct:Eigen::internal::conditional
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	t	struct:Eigen::internal::conditional
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	t	struct:Eigen::internal::remove_const
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	t	struct:Eigen::internal::remove_const
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	t	struct:Eigen::internal::add_const
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	t	struct:Eigen::internal::add_const
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	t	struct:Eigen::internal::remove_all
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^{ typedef T type; };$/;"	t	struct:Eigen::internal::enable_if
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^{typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^{typedef typename Func::template result<Func(ArgType0,ArgType1)>::type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	t	struct:Eigen::ei_cleantype
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	t	struct:Eigen::ei_unconst
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	t	struct:Eigen::ei_unconst
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	t	struct:Eigen::ei_unconst
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	t	struct:Eigen::ei_unconst
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	t	struct:Eigen::ei_unref
type	vcglib/eigenlib/Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	t	struct:Eigen::ei_unref
type	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef MatrixOrTransformType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename TransformType::MatrixType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	vcglib/eigenlib/Eigen/src/Geometry/Homogeneous.h	/^  typedef typename internal::add_const<typename TransformType::ConstAffinePart>::type type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	vcglib/eigenlib/Eigen/src/Geometry/Umeyama.h	/^  > type;$/;"	t	struct:Eigen::internal::umeyama_transform_matrix_type
type	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef Matrix<_Scalar, 1, 1> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Flags> type;$/;"	t	struct:Eigen::internal::plain_matrix_type
type	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, _Flags> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineUtil.h	/^    typedef SkylineMatrix<_Scalar, _Flags> type;$/;"	t	class:Eigen::internal::eval
type	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^  typedef Matrix<Scalar,Dynamic,1> type;$/;"	t	struct:VectorType	file:
type	vcglib/eigenlib/unsupported/test/FFTW.cpp	/^  typedef vector<Scalar> type;$/;"	t	struct:VectorType	file:
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<double>				{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<int64_t  >			{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<int>					{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<long double>			{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<long int>			{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<mpq_t>				{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<mpreal>				{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<mpz_t>				{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<uint64_t >			{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<unsigned int>		{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	template <> struct result_type<unsigned long int>	{typedef mpreal type;};	$/;"	t	struct:mpfr::internal::result_type
type	vcglib/vcg/math/eigen.h	/^struct ei_to_vcgtype { typedef Matrix<typename XprType::Scalar,Rows,Cols,StorageOrder,MRows,MCols> type; };$/;"	t	struct:Eigen::ei_to_vcgtype
type	vcglib/vcg/math/old_matrix.h	/^{ typedef vcg::ndim::Matrix<typename XprType::Scalar> type; };$/;"	t	struct:Eigen::ei_to_vcgtype
type	vcglib/vcg/math/old_matrix33.h	/^{ typedef vcg::Matrix33<typename XprType::Scalar> type; };$/;"	t	struct:Eigen::ei_to_vcgtype
type	vcglib/vcg/math/old_matrix44.h	/^{ typedef vcg::Matrix44<typename XprType::Scalar> type; };$/;"	t	struct:Eigen::ei_to_vcgtype
type	vcglib/vcg/space/point2.h	/^{ typedef vcg::Point2<typename XprType::Scalar> type; };$/;"	t	struct:Eigen::ei_to_vcgtype
type	vcglib/vcg/space/point3.h	/^{ typedef vcg::Point3<typename XprType::Scalar> type; };$/;"	t	struct:Eigen::ei_to_vcgtype
type	vcglib/vcg/space/point4.h	/^{ typedef vcg::Point4<typename XprType::Scalar> type; };$/;"	t	struct:Eigen::ei_to_vcgtype
type	vcglib/wrap/gl/glu_tesselator.h	/^                GLenum type;$/;"	m	class:vcg::glu_tesselator::tess_prim_data
type	vcglib/wrap/glw/buffer.h	/^		virtual Type type(void) const$/;"	f	class:glw::Buffer
type	vcglib/wrap/glw/fragmentshader.h	/^		virtual Type type(void) const$/;"	f	class:glw::FragmentShader
type	vcglib/wrap/glw/framebuffer.h	/^		virtual Type type(void) const$/;"	f	class:glw::Framebuffer
type	vcglib/wrap/glw/geometryshader.h	/^		virtual Type type(void) const$/;"	f	class:glw::GeometryShader
type	vcglib/wrap/glw/object.h	/^		Type type(void) const$/;"	f	class:glw::SafeObject
type	vcglib/wrap/glw/program.h	/^				GLenum      type;$/;"	m	class:glw::Program::UniformInfo
type	vcglib/wrap/glw/program.h	/^		virtual Type type(void) const$/;"	f	class:glw::Program
type	vcglib/wrap/glw/renderbuffer.h	/^		virtual Type type(void) const$/;"	f	class:glw::Renderbuffer
type	vcglib/wrap/glw/texture2d.h	/^		virtual Type type(void) const$/;"	f	class:glw::Texture2D
type	vcglib/wrap/glw/texturecube.h	/^		virtual Type type(void) const$/;"	f	class:glw::TextureCube
type	vcglib/wrap/glw/vertexshader.h	/^		virtual Type type(void) const$/;"	f	class:glw::VertexShader
type	vcglib/wrap/system/qgetopt.h	/^    Type type;$/;"	m	struct:GetOpt::Option
typenames	vcglib/wrap/ply/plylib.cpp	/^  const char * ::vcg::ply::PlyFile::typenames[9]=$/;"	m	class:vcg::ply::vcg::ply::PlyFile	file:
typenames	vcglib/wrap/ply/plylib.h	/^	static const char * typenames[9];$/;"	m	class:vcg::ply::PlyFile
u	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline T & u() { return _t[0][0]; }$/;"	f	class:vcg::TexCoord2
u	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline T & u(const int i) { return _t[i][0]; }$/;"	f	class:vcg::TexCoord2
u	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline const T & u() const { return _t[0][0]; }$/;"	f	class:vcg::TexCoord2
u	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline const T & u(const int i) const { return _t[i][0]; }$/;"	f	class:vcg::TexCoord2
u	vcglib/vcg/space/texcoord2.h	/^    inline T & u() { return _t[0]; }$/;"	f	class:vcg::TexCoord2Simple
u	vcglib/vcg/space/texcoord2.h	/^    inline T & u(const int i) { (void)i; assert(i==0); return _t[0]; }$/;"	f	class:vcg::TexCoord2Simple
u	vcglib/vcg/space/texcoord2.h	/^    inline const T & u() const { return _t[0]; }$/;"	f	class:vcg::TexCoord2Simple
u	vcglib/vcg/space/texcoord2.h	/^    inline const T & u(const int i) const { (void)i; assert(i==0); return _t[0]; }$/;"	f	class:vcg::TexCoord2Simple
u	vcglib/wrap/io_trimesh/import_obj.h	/^                    float u;$/;"	m	struct:vcg::tri::io::ImporterOBJ::ObjTexCoord
u	vcglib/wrap/io_trimesh/import_ply.h	/^	float u,v,w;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
u3dparametersclasses	vcglib/wrap/io_trimesh/export_u3d.h	/^namespace u3dparametersclasses$/;"	n	namespace:vcg::tri::io
uchar	vcglib/wrap/ply/plylib.cpp	/^typedef unsigned char uchar;$/;"	t	namespace:vcg::ply	file:
ugrid	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    GridType *ugrid; \/\/ griglia$/;"	m	class:vcg::tri::FourPCS
ugridP	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    vcg::GridStaticPtr<typename MeshType::VertexType, ScalarType > ugridP;$/;"	m	class:vcg::tri::FourPCS
ugridQ	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^    vcg::GridStaticPtr<typename MeshType::VertexType, ScalarType > ugridQ;$/;"	m	class:vcg::tri::FourPCS
ui	vcglib/apps/pivoting/main.cpp	/^     Ui::MainWindow ui;$/;"	m	class:QMyWindow	file:
ui	vcglib/apps/sample/trimesh_QT/mainwindow.h	/^  Ui::mainWindow ui;$/;"	m	class:MainWindow
uint	vcglib/wrap/ply/plylib.cpp	/^typedef unsigned int uint;$/;"	t	namespace:vcg::ply	file:
uint16_t	vcglib/wrap/gcache/cache.h	/^typedef unsigned __int16 uint16_t;$/;"	t
uint32_t	vcglib/wrap/gcache/cache.h	/^typedef unsigned __int32 uint32_t;$/;"	t
uint64_t	vcglib/wrap/gcache/cache.h	/^typedef unsigned __int64 uint64_t;$/;"	t
uintValue	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^					unsigned int uintValue;$/;"	m	union:vcg::AABBBinaryTree::AABBBinaryTreeNode::SharedDataUnion
ulong	vcglib/wrap/ply/plylib.cpp	/^typedef unsigned long ulong;$/;"	t	namespace:vcg::ply	file:
umeyama	vcglib/eigenlib/Eigen/src/Geometry/Umeyama.h	/^umeyama(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)$/;"	f	namespace:Eigen
umeyama_transform_matrix_type	vcglib/eigenlib/Eigen/src/Geometry/Umeyama.h	/^struct umeyama_transform_matrix_type$/;"	s	namespace:Eigen::internal
umfpack_free_numeric	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, double)$/;"	f	namespace:Eigen
umfpack_free_numeric	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_free_symbolic	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, double)$/;"	f	namespace:Eigen
umfpack_free_symbolic	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_get_determinant	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen
umfpack_get_determinant	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen
umfpack_get_lunz	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)$/;"	f	namespace:Eigen
umfpack_get_lunz	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_get_numeric	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[],$/;"	f	namespace:Eigen
umfpack_get_numeric	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[],$/;"	f	namespace:Eigen
umfpack_numeric	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen
umfpack_numeric	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen
umfpack_solve	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen
umfpack_solve	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen
umfpack_symbolic	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen
unaligned_assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct unaligned_assign_impl$/;"	s	namespace:Eigen::internal
unaligned_assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign.h	/^struct unaligned_assign_impl<false>$/;"	s	namespace:Eigen::internal
unaryExpr	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^unaryExpr(const CustomUnaryOp& func = CustomUnaryOp()) const$/;"	f
unaryViewExpr	vcglib/eigenlib/Eigen/src/plugins/CommonCwiseUnaryOps.h	/^unaryViewExpr(const CustomViewOp& func = CustomViewOp()) const$/;"	f
unary_result_of_select	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	s	namespace:Eigen::internal
unbiasedSeedFlag	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^  bool unbiasedSeedFlag;$/;"	m	struct:vcg::tri::VoronoiProcessingParameter
unbind	vcglib/wrap/glw/buffer.h	/^		virtual void unbind(void)$/;"	f	class:glw::BoundBuffer
unbind	vcglib/wrap/glw/buffer.h	/^		virtual void unbind(void)$/;"	f	class:glw::BoundFeedbackBuffer
unbind	vcglib/wrap/glw/buffer.h	/^		virtual void unbind(void)$/;"	f	class:glw::BoundUniformBuffer
unbind	vcglib/wrap/glw/framebuffer.h	/^		virtual void unbind(void)$/;"	f	class:glw::BoundFramebuffer
unbind	vcglib/wrap/glw/program.h	/^		virtual void unbind(void)$/;"	f	class:glw::BoundProgram
unbind	vcglib/wrap/glw/renderbuffer.h	/^		virtual void unbind(void)$/;"	f	class:glw::BoundRenderbuffer
unbind	vcglib/wrap/glw/shader.h	/^		virtual void unbind(void)$/;"	f	class:glw::BoundShader
unbind	vcglib/wrap/glw/texture.h	/^		virtual void unbind(void)$/;"	f	class:glw::BoundTexture
unbindDrawFramebuffer	vcglib/wrap/glw/context.h	/^		void unbindDrawFramebuffer(void)$/;"	f	class:glw::Context
unbindFeedbackBuffer	vcglib/wrap/glw/context.h	/^		void unbindFeedbackBuffer(GLuint index)$/;"	f	class:glw::Context
unbindFragmentShader	vcglib/wrap/glw/context.h	/^		void unbindFragmentShader(void)$/;"	f	class:glw::Context
unbindGeometryShader	vcglib/wrap/glw/context.h	/^		void unbindGeometryShader(void)$/;"	f	class:glw::Context
unbindIndexBuffer	vcglib/wrap/glw/context.h	/^		void unbindIndexBuffer(void)$/;"	f	class:glw::Context
unbindPixelPackBuffer	vcglib/wrap/glw/context.h	/^		void unbindPixelPackBuffer(void)$/;"	f	class:glw::Context
unbindPixelUnpackBuffer	vcglib/wrap/glw/context.h	/^		void unbindPixelUnpackBuffer(void)$/;"	f	class:glw::Context
unbindProgram	vcglib/wrap/glw/context.h	/^		void unbindProgram(void)$/;"	f	class:glw::Context
unbindReadDrawFramebuffer	vcglib/wrap/glw/context.h	/^		void unbindReadDrawFramebuffer(void)$/;"	f	class:glw::Context
unbindReadFramebuffer	vcglib/wrap/glw/context.h	/^		void unbindReadFramebuffer(void)$/;"	f	class:glw::Context
unbindRenderbuffer	vcglib/wrap/glw/context.h	/^		void unbindRenderbuffer(void)$/;"	f	class:glw::Context
unbindTexture2D	vcglib/wrap/glw/context.h	/^		void unbindTexture2D(GLint unit)$/;"	f	class:glw::Context
unbindTextureCube	vcglib/wrap/glw/context.h	/^		void unbindTextureCube(GLint unit)$/;"	f	class:glw::Context
unbindUniformBuffer	vcglib/wrap/glw/context.h	/^		void unbindUniformBuffer(GLuint index)$/;"	f	class:glw::Context
unbindVertexBuffer	vcglib/wrap/glw/context.h	/^		void unbindVertexBuffer(void)$/;"	f	class:glw::Context
unbindVertexShader	vcglib/wrap/glw/context.h	/^		void unbindVertexShader(void)$/;"	f	class:glw::Context
unblocked	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)$/;"	f	struct:Eigen::internal::ldlt_inplace
unblocked	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  static bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, int* sign=0)$/;"	f	struct:Eigen::internal::ldlt_inplace
unblocked	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
unblocked	vcglib/eigenlib/Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
unblocked_lu	vcglib/eigenlib/Eigen/src/LU/PartialPivLU.h	/^  static Index unblocked_lu(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)$/;"	f	struct:Eigen::internal::partial_lu_impl
undo_begin_action	vcglib/wrap/gui/trackmode.h	/^  bool undo_begin_action;$/;"	m	class:vcg::AreaMode
undo_current_state	vcglib/wrap/gui/trackmode.h	/^  float undo_current_state;$/;"	m	class:vcg::PathMode
undo_delta_mouse	vcglib/wrap/gui/trackmode.h	/^  Point3f undo_delta_mouse;$/;"	m	class:vcg::AreaMode
undo_old_hitpoint	vcglib/wrap/gui/trackmode.h	/^  Point3f undo_old_hitpoint;$/;"	m	class:vcg::PathMode
undo_old_status	vcglib/wrap/gui/trackmode.h	/^  Point3f undo_old_status;$/;"	m	class:vcg::AreaMode
undo_path_index	vcglib/wrap/gui/trackmode.h	/^  unsigned int undo_path_index;$/;"	m	class:vcg::AreaMode
undo_rubberband_handle	vcglib/wrap/gui/trackmode.h	/^  Point3f undo_rubberband_handle;$/;"	m	class:vcg::AreaMode
undo_status	vcglib/wrap/gui/trackmode.h	/^  Point3f undo_status;$/;"	m	class:vcg::AreaMode
undo_track	vcglib/wrap/gui/trackball.h	/^  Similarityf undo_track; $/;"	m	class:vcg::Trackball
uniqueVerse	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    static Vec3 uniqueVerse(Vec3 v){$/;"	f	class:vcg::tri::Zonohedron
unit	vcglib/wrap/glw/object.h	/^		GLint  unit;$/;"	m	class:glw::ObjectBindingParams
unit	vcglib/wrap/glw/object.h	/^		GLint unit(void) const$/;"	f	class:glw::BoundObject
unitOrthogonal	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::unitOrthogonal() const$/;"	f	class:Eigen::MatrixBase
unitOrthogonal_selector	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,2>$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	vcglib/eigenlib/Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,3>$/;"	s	namespace:Eigen::internal
unlimitedArgs	vcglib/wrap/system/qgetopt.h	/^  bool unlimitedArgs;$/;"	m	class:GetOpt
unlink_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define unlink_chunk(/;"	d	file:
unlink_first_small_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define unlink_first_small_chunk(/;"	d	file:
unlink_large_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define unlink_large_chunk(/;"	d	file:
unlink_small_chunk	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define unlink_small_chunk(/;"	d	file:
unload	vcglib/wrap/gcache/cache.h	/^    bool unload() {$/;"	f	class:vcg::Cache
unlock	vcglib/wrap/gcache/door.h	/^  void unlock() {$/;"	f	class:QDoor
unlock	vcglib/wrap/gcache/door.h	/^  void unlock(bool open = false) { \/\/reverse effect of lock$/;"	f	class:QDoor
unlock	vcglib/wrap/gcache/door.h	/^  void unlock(bool open = false) {$/;"	f	class:QDoor
unlock	vcglib/wrap/gcache/token.h	/^    bool unlock() {$/;"	f	class:vcg::Token
unlock	vcglib/wrap/system/multithreading/mutex.h	/^		void unlock(void)$/;"	f	class:mt::mutex
unlock_read	vcglib/wrap/system/multithreading/rw_lock.h	/^		void unlock_read(void)$/;"	f	class:mt::rw_lock
unlock_write	vcglib/wrap/system/multithreading/rw_lock.h	/^		void unlock_write(void)$/;"	f	class:mt::rw_lock
unmap	vcglib/wrap/glw/buffer.h	/^		void unmap(GLenum target, GLint unit)$/;"	f	class:glw::Buffer
unmap	vcglib/wrap/glw/buffer.h	/^		void unmap(void)$/;"	f	class:glw::BoundBuffer
unpack	vcglib/apps/unsupported/ptx2ply/ptx2ply.cpp	/^  bool          unpack;$/;"	v
unpackRhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)$/;"	f	class:Eigen::internal::gebp_traits
unpackRhs	vcglib/eigenlib/Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const Scalar* rhs, Scalar* b)$/;"	f	class:Eigen::internal::gebp_traits
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unref	vcglib/wrap/glw/bookkeeping.h	/^		void unref(void)$/;"	f	class:glw::detail::RefCountedObject
unroll	vcglib/wrap/gl/glu_tesselator.h	/^        static inline void unroll(const std::vector< std::vector<point_type> > & outlines, std::vector<point_type> & points)$/;"	f	class:vcg::glu_tesselator
unwrapTime	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^     int unwrapTime;$/;"	m	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam::Stat
uordblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MALLINFO_FIELD_TYPE uordblks; \/* total allocated space *\/$/;"	m	struct:mallinfo	file:
uordblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^  MALLINFO_FIELD_TYPE uordblks; \/* total allocated space *\/$/;"	m	struct:mallinfo
update	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool update(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, typename MatrixType::RealScalar sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
update	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  static bool update(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, typename MatrixType::RealScalar sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
update	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>::UniformParameters::update(float* mv, float* proj, GLint* vp)$/;"	f	class:SplatRenderer::UniformParameters
updateCurvatureLocal	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^    static void updateCurvatureLocal (MeshType & mesh, float radiusSphere)$/;"	f	class:vcg::tri::UpdateCurvatureFitting
updateInPlace	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^  static bool updateInPlace(MatrixType& mat, MatrixBase<WDerived>& w, typename MatrixType::RealScalar sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
updatePriorities	vcglib/wrap/gcache/controller.h	/^  void updatePriorities() {$/;"	f	class:vcg::Controller
updateRenderBuffer	vcglib/wrap/gl/splatting_apss/splatrenderer.h	/^void SplatRenderer<MeshType>::updateRenderBuffer()$/;"	f	class:SplatRenderer
updateStiffeningJacobianDistorsion	vcglib/wrap/miq/core/stiffening.h	/^    static bool updateStiffeningJacobianDistorsion(MeshType & mesh,ScalarType grad_size)$/;"	f	class:StiffeningInitializer
update_bb	vcg_mesh.cpp	/^void MyMesh::update_bb()$/;"	f	class:vcg::MyMesh
upper	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Scalar& upper(Index i) {$/;"	f	class:Eigen::SkylineStorage
upper	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline const Scalar& upper(Index i) const {$/;"	f	class:Eigen::SkylineStorage
upperNonZeros	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index upperNonZeros() const {$/;"	f	class:Eigen::SkylineMatrix
upperNonZeros	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Index upperNonZeros(Index j) const {$/;"	f	class:Eigen::SkylineMatrix
upperProfile	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index& upperProfile(Index i) {$/;"	f	class:Eigen::SkylineStorage
upperProfile	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline const Index& upperProfile(Index i) const {$/;"	f	class:Eigen::SkylineStorage
upperProfileSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index upperProfileSize() const {$/;"	f	class:Eigen::SkylineStorage
upperSize	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    inline Index upperSize() const {$/;"	f	class:Eigen::SkylineStorage
urandom	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal urandom (gmp_randstate_t& state, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
urandomb	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal urandomb (gmp_randstate_t& state)$/;"	f	namespace:mpfr
usage	vcglib/apps/sample/trimesh_split_vertex/trimesh_split_vertex.cpp	/^void usage(void)$/;"	f
usage	vcglib/wrap/glw/buffer.h	/^		GLenum       usage;$/;"	m	class:glw::BufferArguments
usage	vcglib/wrap/glw/buffer.h	/^		GLenum usage(void) const$/;"	f	class:glw::Buffer
usage	vcglib/wrap/glw/buffer.h	/^		GLenum usage(void) const$/;"	f	class:glw::SafeBuffer
usage	vcglib/wrap/system/qgetopt.cpp	/^QString GetOpt::usage() {$/;"	f	class:GetOpt
useExternalScaling	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    bool useExternalScaling; $/;"	m	class:Eigen::HybridNonLinearSolver
useExternalScaling	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    bool useExternalScaling; $/;"	m	class:Eigen::LevenbergMarquardt
usePerWedgeAttributes	vcglib/wrap/dae/poly_triangulator.h	/^		void usePerWedgeAttributes(PERWEDGEATTRIBUTETYPE att,const unsigned int multitexture = 1,const unsigned int multicolor = 1)$/;"	f	class:vcg::tri::io::PolygonalMesh
useViewPoint	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    bool useViewPoint;  \/\/\/ if the position of the viewpoint has to be used.$/;"	m	struct:vcg::tri::PointCloudNormal::Param
use_direction_field	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    bool use_direction_field,fix_selected,correct_fixed;$/;"	m	class:vcg::tri::PoissonSolver
use_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define use_lock(/;"	d	file:
use_mmap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define use_mmap(/;"	d	file:
use_noncontiguous	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^#define use_noncontiguous(/;"	d	file:
usedBit	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  int usedBit;       \/\/use to detect if a vertex has been already processed.$/;"	m	class:vcg::tri::BallPivoting
users	vcglib/eigenlib/Eigen/src/Core/products/Parallelizer.h	/^  int volatile users;$/;"	m	struct:Eigen::internal::GemmParallelInfo
ushort	vcglib/wrap/ply/plylib.cpp	/^typedef unsigned short ushort;$/;"	t	namespace:vcg::ply	file:
usmblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^  MALLINFO_FIELD_TYPE usmblks;  \/* maximum total allocated space *\/$/;"	m	struct:mallinfo	file:
usmblks	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.h	/^  MALLINFO_FIELD_TYPE usmblks;  \/* maximum total allocated space *\/$/;"	m	struct:mallinfo
v	vcglib/apps/pivoting/cmesh.h	/^   CVertex *v[2];         $/;"	m	class:CEdge
v	vcglib/eigenlib/Eigen/src/Core/arch/AltiVec/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	vcglib/eigenlib/Eigen/src/Core/arch/NEON/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  __m128  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	vcglib/eigenlib/Eigen/src/Core/arch/SSE/Complex.h	/^  __m128d  v;$/;"	m	struct:Eigen::internal::Packet1cd
v	vcglib/vcg/complex/algorithms/clean.h	/^                      unsigned int v[2];$/;"	m	class:vcg::tri::Clean::SortedPair
v	vcglib/vcg/complex/algorithms/clean.h	/^                unsigned int v[3];$/;"	m	class:vcg::tri::Clean::SortedTriple
v	vcglib/vcg/complex/algorithms/clip.h	/^    unsigned int v[3];$/;"	m	class:vcg::tri::TriMeshClipper::TriangleInfo
v	vcglib/vcg/complex/algorithms/clustering.h	/^    CellType *v[3];$/;"	m	class:vcg::tri::Clustering::SimpleTri
v	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^        std::vector< bool > v;$/;"	m	struct:vcg::tri::Zonohedron::Signature
v	vcglib/vcg/complex/algorithms/edge_collapse.h	/^  VERTEX_TYPE *v[2]; \/\/ remember that v[0] will be deleted and v[1] will survive (eventually with a new position)$/;"	m	class:vcg::tri::BasicVertexPair
v	vcglib/vcg/complex/algorithms/geodesic.h	/^    VertexPointer v;$/;"	m	struct:vcg::tri::Geodesic::DIJKDist
v	vcglib/vcg/complex/algorithms/geodesic.h	/^    VertexPointer v;$/;"	m	struct:vcg::tri::Geodesic::VertDist
v	vcglib/vcg/complex/algorithms/update/flag.h	/^    VertexPointer v[2];		\/\/ Puntatore ai due vertici (Ordinati)$/;"	m	class:vcg::tri::UpdateFlags::EdgeSorter
v	vcglib/vcg/complex/algorithms/update/topology.h	/^  VertexPointer  v;		\/\/ the two Vertex pointer are ordered!$/;"	m	class:vcg::tri::UpdateTopology::PVertexEdge
v	vcglib/vcg/complex/algorithms/update/topology.h	/^  VertexPointer  v[2];  \/\/ the two Vertex pointer are ordered!$/;"	m	class:vcg::tri::UpdateTopology::PEdge
v	vcglib/vcg/complex/algorithms/update/topology.h	/^  typename FaceType::TexCoordType  v[2];		\/\/ the two TexCoord are ordered!$/;"	m	class:vcg::tri::UpdateTopology::PEdgeTex
v	vcglib/vcg/math/gen_normal.h	/^    std::vector<Point3x> v;$/;"	m	class:vcg::GenNormal::OctaLevel
v	vcglib/vcg/simplex/edge/component.h	/^  typename T::VertexType *v[2];$/;"	m	class:vcg::edge::VertexRef
v	vcglib/vcg/simplex/edge/pos.h	/^	VertexType *v;$/;"	m	class:vcg::edge::Pos
v	vcglib/vcg/simplex/face/component.h	/^  typename T::VertexType *v[3];$/;"	m	class:vcg::face::VertexRef
v	vcglib/vcg/simplex/face/pos.h	/^	VertexType *v;$/;"	m	class:vcg::face::Pos
v	vcglib/vcg/simplex/tetrahedron/component.h	/^  typename T::VertexType *v[4];$/;"	m	class:vcg::tetra::VertexRef
v	vcglib/vcg/space/rasterized_outline2_packer.h	/^    std::vector<RasterizedOutline2> & v;$/;"	m	class:vcg::ComparisonFunctor
v	vcglib/vcg/space/rect_packer.h	/^  const std::vector<vcg::Point2i> & v;$/;"	m	class:vcg::RectPacker::ComparisonFunctor
v	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline T & v() { return _t[0][1]; }$/;"	f	class:vcg::TexCoord2
v	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline T & v(const int i) { return _t[i][1]; }$/;"	f	class:vcg::TexCoord2
v	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline const T & v() const { return _t[0][1]; }$/;"	f	class:vcg::TexCoord2
v	vcglib/vcg/space/texcoord2.h	/^    \/**\/inline const T & v(const int i) const { return _t[i][1]; }$/;"	f	class:vcg::TexCoord2
v	vcglib/vcg/space/texcoord2.h	/^    inline T & v() { return _t[1]; }$/;"	f	class:vcg::TexCoord2Simple
v	vcglib/vcg/space/texcoord2.h	/^    inline T & v(const int i) { (void)i; assert(i==0); return _t[1]; }$/;"	f	class:vcg::TexCoord2Simple
v	vcglib/vcg/space/texcoord2.h	/^    inline const T & v() const { return _t[1]; }$/;"	f	class:vcg::TexCoord2Simple
v	vcglib/vcg/space/texcoord2.h	/^    inline const T & v(const int i) const { (void)i; assert(i==0); return _t[1]; }$/;"	f	class:vcg::TexCoord2Simple
v	vcglib/wrap/gl/trimesh.h	/^        typename MESH_TYPE::vertex_pointer v;$/;"	m	class:vcg::GLW::VertToSplit
v	vcglib/wrap/io_tetramesh/import_ply.h	/^	int v[512];$/;"	m	struct:vcg::tetra::io::ImporterPLY::LoadPly_TetraAux
v	vcglib/wrap/io_trimesh/import_obj.h	/^                    float v;$/;"	m	struct:vcg::tri::io::ImporterOBJ::ObjTexCoord
v	vcglib/wrap/io_trimesh/import_obj.h	/^                    std::vector<int> v;$/;"	m	struct:vcg::tri::io::ImporterOBJ::ObjIndexedFace
v	vcglib/wrap/io_trimesh/import_ply.h	/^	float u,v,w;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
v	vcglib/wrap/io_trimesh/import_ply.h	/^	int *v;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_TristripAux
v	vcglib/wrap/io_trimesh/import_ply.h	/^	int v[512];$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_FaceAux
v	vcglib/wrap/io_trimesh/import_smf.h	/^		vcg::Point3f v[3];$/;"	m	class:vcg::tri::io::ImporterSMF::SMFFacet
v	vcglib/wrap/io_trimesh/import_stl.h	/^  Point3f v[3];$/;"	m	class:vcg::tri::io::ImporterSTL::STLFacet
v0	vcglib/apps/pivoting/pivot.h	/^      int v0, v1, v2;   \/\/v0, v1 represent the Hinge, v2 the other vertex in the face$/;"	m	struct:vcg::tri::Hinge
v0	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  int v0, v1, v2;   \/\/v0, v1 represent the FrontEdge, v2 the other vertex$/;"	m	class:vcg::tri::FrontEdge
v0	vcglib/vcg/complex/algorithms/hole.h	/^          VertexPointer v0,v1;$/;"	m	class:vcg::tri::Hole::EdgeToBeAvoided
v0	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  	#undef v0$/;"	d
v0	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^    #define v0 /;"	d
v0	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                VertexPointer v0,v1;$/;"	m	struct:vcg::tri::UpdateHalfEdges::VertexPairEdgePtr
v0	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                VertexPointer v0,v1;$/;"	m	struct:vcg::tri::UpdateIndexed::VertexPairEdgePtr
v0	vcglib/wrap/miq/core/vertex_indexing.h	/^    int v0,v0p,v1,v1p;$/;"	m	struct:SeamInfo
v0p	vcglib/wrap/miq/core/vertex_indexing.h	/^    int v0,v0p,v1,v1p;$/;"	m	struct:SeamInfo
v1	vcglib/apps/pivoting/pivot.h	/^      int v0, v1, v2;   \/\/v0, v1 represent the Hinge, v2 the other vertex in the face$/;"	m	struct:vcg::tri::Hinge
v1	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  int v0, v1, v2;   \/\/v0, v1 represent the FrontEdge, v2 the other vertex$/;"	m	class:vcg::tri::FrontEdge
v1	vcglib/vcg/complex/algorithms/hole.h	/^          VertexPointer v0,v1;$/;"	m	class:vcg::tri::Hole::EdgeToBeAvoided
v1	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^      LCVertex *v1, *v2;          \/\/ endpoints$/;"	m	struct:vcg::tri::PolychordCollapse::LinkConditions::LCEdge
v1	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^    #define v1 /;"	d
v1	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^    #undef v1 /;"	d
v1	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                VertexPointer v0,v1;$/;"	m	struct:vcg::tri::UpdateHalfEdges::VertexPairEdgePtr
v1	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^                VertexPointer v0,v1;$/;"	m	struct:vcg::tri::UpdateIndexed::VertexPairEdgePtr
v1	vcglib/wrap/io_trimesh/import_ply.h	/^	int v1,v2;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_EdgeAux
v1	vcglib/wrap/miq/core/vertex_indexing.h	/^    int v0,v0p,v1,v1p;$/;"	m	struct:SeamInfo
v1p	vcglib/wrap/miq/core/vertex_indexing.h	/^    int v0,v0p,v1,v1p;$/;"	m	struct:SeamInfo
v2	vcglib/apps/pivoting/pivot.h	/^      int v0, v1, v2;   \/\/v0, v1 represent the Hinge, v2 the other vertex in the face$/;"	m	struct:vcg::tri::Hinge
v2	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  int v0, v1, v2;   \/\/v0, v1 represent the FrontEdge, v2 the other vertex$/;"	m	class:vcg::tri::FrontEdge
v2	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^      LCVertex *v1, *v2;          \/\/ endpoints$/;"	m	struct:vcg::tri::PolychordCollapse::LinkConditions::LCEdge
v2	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^    #define v2 /;"	d
v2	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^    #undef v2 /;"	d
v2	vcglib/wrap/io_trimesh/import_ply.h	/^	int v1,v2;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_EdgeAux
val	vcglib/wrap/system/getopt.h	/^  int val;$/;"	m	struct:option
valSum	vcglib/vcg/math/histogram.h	/^	double valSum;$/;"	m	class:vcg::Distribution
valence	vcglib/vcg/complex/algorithms/refine_loop.h	/^	ValenceAttr *valence;$/;"	m	struct:vcg::tri::EvenPointLoopGeneric
valence	vcglib/vcg/complex/algorithms/refine_loop.h	/^	ValenceAttr *valence;$/;"	m	struct:vcg::tri::OddPointLoopGeneric
valid	vcglib/vcg/complex/algorithms/clustering.h	/^  bool valid;$/;"	m	class:vcg::tri::NearestToCenter
vals	vcglib/wrap/miq/core/sparsesystemdata.h	/^  double*        vals()     { return m_vals    ; }$/;"	f	class:SparseMatrixData
value	vcglib/apps/trimeshinfo/SlotsNode.h	/^	ValueNode value;$/;"	m	class:EntryNode
value	vcglib/apps/trimeshinfo/SlotsNode.h	/^	string value; \/\/tra due tag$/;"	m	class:ValueNode
value	vcglib/eigenlib/Eigen/src/Core/DenseBase.h	/^    CoeffReturnType value() const$/;"	f	class:Eigen::DenseBase
value	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^         value = is_large  ? Large$/;"	e	enum:Eigen::internal::product_size_category::__anon141
value	vcglib/eigenlib/Eigen/src/Core/GeneralProduct.h	/^    value = selector::ret$/;"	e	enum:Eigen::internal::product_type::__anon144
value	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^         value = (upper <= lower + 1) ? int(floor_log2_terminate)$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon177
value	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };$/;"	e	enum:Eigen::internal::floor_log2::__anon180
value	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, floor_log2_selector<n, lower, upper>::middle, upper>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon179
value	vcglib/eigenlib/Eigen/src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, lower, floor_log2_selector<n, lower, upper>::middle>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon178
value	vcglib/eigenlib/Eigen/src/Core/VectorwiseOp.h	/^  { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };$/;"	e	enum:Eigen::internal::member_redux::Cost::__anon323
value	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon24
value	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon26
value	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon25
value	vcglib/eigenlib/Eigen/src/Core/util/ForwardDeclarations.h	/^         value = has_direct_access ? (has_write_access ? DirectWriteAccessors : DirectAccessors)$/;"	e	enum:Eigen::internal::accessors_level::__anon268
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::false_type::__anon292
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	e	enum:Eigen::internal::true_type::__anon291
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_const::__anon309
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_const::__anon310
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon299
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon300
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon297
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon296
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon298
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon301
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon305
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon307
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon303
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon302
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon306
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon308
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon304
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_same::__anon293
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon295
value	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_same::__anon294
value	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^      Scalar value;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
value	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    Scalar value() const { return m_cachedValue; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
value	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& value(size_t i) { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
value	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    inline const Scalar& value(size_t i) const { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
value	vcglib/eigenlib/Eigen/src/SparseCore/CoreIterators.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::DenseBase::InnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_functor(m_lhsIter.value(), m_rhsIter.value()); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_value; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Scalar value() const { return Base::value() * m_factor; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Scalar value() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseUtil.h	/^  const Scalar& value() const { return m_value; }$/;"	f	class:Eigen::Triplet
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator
value	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
value	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline Scalar& value() { return m_value; }$/;"	f	class:Eigen::AutoDiffScalar
value	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h	/^    inline const Scalar& value() const { return m_value; }$/;"	f	class:Eigen::AutoDiffScalar
value	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar value() const {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
value	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar value() const {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
value	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^      Scalar value;$/;"	m	struct:Eigen::RandomSetter::ScalarWrapper
value	vcglib/vcg/math/factorial.h	/^	enum {value};$/;"	e	enum:vcg::math::MAX_FACTORIAL::__anon490
value	vcglib/vcg/math/factorial.h	/^template <> struct MAX_FACTORIAL<double> 		{enum {value = 170};};$/;"	e	enum:vcg::math::MAX_FACTORIAL::__anon494
value	vcglib/vcg/math/factorial.h	/^template <> struct MAX_FACTORIAL<float> 		{enum {value = 34};};$/;"	e	enum:vcg::math::MAX_FACTORIAL::__anon492
value	vcglib/vcg/math/factorial.h	/^template <> struct MAX_FACTORIAL<int> 			{enum {value = 34};};$/;"	e	enum:vcg::math::MAX_FACTORIAL::__anon493
value	vcglib/vcg/math/factorial.h	/^template <> struct MAX_FACTORIAL<long double> 	{enum {value = 170};};$/;"	e	enum:vcg::math::MAX_FACTORIAL::__anon495
value	vcglib/vcg/math/factorial.h	/^template <> struct MAX_FACTORIAL<short> 		{enum {value = 7};};$/;"	e	enum:vcg::math::MAX_FACTORIAL::__anon491
value	vcglib/wrap/gcache/dheap.h	/^    T *value;$/;"	m	class:PtrDHeap::Item
value	vcglib/wrap/system/qgetopt.h	/^    QVariant *value;$/;"	m	struct:GetOpt::Option
valueAsInt	vcglib/img/img_scalar.h	/^inline int valueAsInt(ScalarType value)$/;"	f	namespace:img
valuePtr	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar* valuePtr() { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix
valuePtr	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix
valuePtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar* valuePtr()$/;"	f	class:Eigen::SparseInnerVectorSet
valuePtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar* valuePtr() const$/;"	f	class:Eigen::SparseInnerVectorSet
valuePtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar* valuePtr() { return &m_data.value(0); }$/;"	f	class:Eigen::SparseMatrix
valuePtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar* valuePtr() const { return &m_data.value(0); }$/;"	f	class:Eigen::SparseMatrix
valuePtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Scalar* valuePtr() { return &m_data.value(0); }$/;"	f	class:Eigen::SparseVector
valuePtr	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Scalar* valuePtr() const { return &m_data.value(0); }$/;"	f	class:Eigen::SparseVector
valuePtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar* valuePtr() {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
valuePtr	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar* valuePtr() {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
valueRef	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id-1]); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
valueRef	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id]); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
valueRef	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator
valueRef	vcglib/eigenlib/Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
valueRef	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id-1]); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
valueRef	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id]); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
valueRef	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id)); }$/;"	f	class:Eigen::SparseVector::InnerIterator
valueRef	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id-1)); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
valueRef	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& valueRef() {$/;"	f	class:Eigen::SkylineMatrix::InnerLowerIterator
valueRef	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline Scalar& valueRef() {$/;"	f	class:Eigen::SkylineMatrix::InnerUpperIterator
valueStringList	vcglib/wrap/dae/util_dae.h	/^		inline static void valueStringList(QStringList& res,const QDomNode srcnode,const QString& tag) $/;"	f	class:vcg::tri::io::UtilDAE
value_type	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator
value_type	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^        typedef Index value_type;$/;"	t	class:Eigen::SparseMatrix::SingletonVector
value_type	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator_indirection
value_type	vcglib/vcg/complex/base.h	/^struct DummyContainer{struct value_type{ typedef int IAm;}; };$/;"	s	struct:vcg::tri::DummyContainer
values	vcglib/apps/trimeshinfo/Node.h	/^enum values {VALUE_INTEGER, VALUE_FLOAT, VALUE_BOOL, VALUE_STRING};$/;"	g
values	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void *values;$/;"	m	struct:Eigen::SluMatrix::__anon434
values	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline ValueType& values() { return m_values; }$/;"	f	class:Eigen::AutoDiffVector
values	vcglib/eigenlib/unsupported/Eigen/src/AutoDiff/AutoDiffVector.h	/^    inline const ValueType& values() const { return m_values; }$/;"	f	class:Eigen::AutoDiffVector
values	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^  int values() const { return m_values; }$/;"	f	struct:Functor
values	vcglib/eigenlib/unsupported/test/NumericalDiff.cpp	/^  int values() const { return m_values; }$/;"	f	struct:Functor
values	vcglib/eigenlib/unsupported/test/autodiff.cpp	/^  int values() const { return m_values; }$/;"	f	struct:TestFunc1
values	vcglib/eigenlib/unsupported/test/forward_adolc.cpp	/^  int values() const { return m_values; }$/;"	f	struct:TestFunc1
varyings	vcglib/wrap/glw/program.h	/^		VaryingVector varyings;$/;"	m	class:glw::TransformFeedbackStream
vas	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^   Stat vas;$/;"	m	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam
vcg	vcg_mesh.cpp	/^namespace vcg {$/;"	n	file:
vcg	vcg_mesh.hpp	/^namespace vcg {$/;"	n
vcg	vcglib/apps/metro/sampling.h	/^namespace vcg$/;"	n
vcg	vcglib/apps/pivoting/pivot.h	/^namespace vcg {$/;"	n
vcg	vcglib/apps/sample/trimesh_isosurface/simple_volume.h	/^namespace vcg $/;"	n
vcg	vcglib/apps/unsupported/shadevis/simplepic.h	/^namespace vcg {$/;"	n
vcg	vcglib/apps/unsupported/shadevis/visshader.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/attribute_seam.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/bitquad_creation.h	/^namespace vcg{namespace tri{$/;"	n
vcg	vcglib/vcg/complex/algorithms/bitquad_optimization.h	/^namespace vcg{namespace tri{$/;"	n
vcg	vcglib/vcg/complex/algorithms/bitquad_support.h	/^namespace vcg{namespace tri{$/;"	n
vcg	vcglib/vcg/complex/algorithms/clean.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/clip.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/closest.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/clustering.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/clustering.h	/^} namespace vcg{ namespace tri{$/;"	n
vcg	vcglib/vcg/complex/algorithms/crease_cut.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/emc_lookup_table.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/extended_marching_cubes.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/extrude.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/marching_cubes.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/mc_lookup_table.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/platonic.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/resampler.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/cylinder_clipping.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/edge_collapse.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/geodesic.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/harmonic.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/hole.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/inertia.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/inside.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/intersection.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/local_optimization.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse_quadric_tex.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/nring.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/outline_support.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/parametrization/distortion.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/parametrization/tangent_field_operators.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/parametrization/uv_utils.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/point_sampling.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/polygon_polychord_collapse.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/polygon_support.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/refine.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/refine_loop.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/algorithms/smooth.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/stat.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/symmetry.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/bounding.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/color.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/component_ep.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/curvature.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/curvature_fitting.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^namespace vcg { namespace tri {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/flag.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/halfedge_indexed.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/normal.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/position.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/quality.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/selection.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/texture.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/update/topology.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/algorithms/voronoi_processing.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/all_types.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/complex/allocate.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/append.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/base.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/complex/exception.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/complex/used_types.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/connectors/halfedge_pos.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/connectors/hedge.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/connectors/hedge_component.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/container/container_allocation_table.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/container/derivation_chain.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/container/entries_allocation_table.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/container/simple_temporary_data.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/container/vector_occ.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/base.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/camera.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/math/disjoint_set.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/math/eigen.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/factorial.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/math/gen_normal.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/histogram.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/legendre.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/linear.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/matrix33.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/matrix44.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/old_deprecated_matrix.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/math/old_lin_algebra.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/math/old_matrix.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/math/old_matrix33.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/old_matrix33.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/math/old_matrix44.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/old_matrix44.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/math/perlin_noise.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/math/polar_decomposition.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/math/quadric.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/quadric5.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/math/quaternion.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/random_generator.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/shot.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/math/similarity.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/math/similarity2.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/math/spherical_harmonics.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/simplex/edge/base.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/edge/component.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/edge/distance.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/edge/pos.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/edge/topology.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/face/base.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/face/component.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/face/component_ep.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/face/component_occ.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/face/component_ocf.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/face/component_polygon.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/face/distance.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/face/jumping_pos.h	/^namespace vcg $/;"	n
vcg	vcglib/vcg/simplex/face/pos.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/face/topology.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/tetrahedron/base.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/tetrahedron/component.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/tetrahedron/pos.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/vertex/base.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/vertex/component.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/vertex/component_occ.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/vertex/component_ocf.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/vertex/component_sph.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/simplex/vertex/distance.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/box.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/box2.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/box3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/color4.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/colorspace.h	/^namespace vcg $/;"	n
vcg	vcglib/vcg/space/deprecated_point.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/deprecated_point2.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/deprecated_point3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/deprecated_point4.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/distance2.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/distance3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/fitting3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/aabb_binary_tree/aabb_binary_tree.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/aabb_binary_tree/closest.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/aabb_binary_tree/frustum_cull.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/aabb_binary_tree/kclosest.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/aabb_binary_tree/ray.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/base.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/grid_closest.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/space/index/grid_static_obj.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/grid_static_ptr.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/grid_util.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/index2D/base_2d.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/index2D/grid_closest_2D.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/index2D/spatial_hashing_2D.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/space/index/kdtree/mlsutils.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/index/octree.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/space/index/octree_template.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/space/index/space_iterators.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/space/index/spatial_hashing.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/space/intersection/triangle_triangle3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/intersection2.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/intersection3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/line2.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/line3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/obox3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/outline2_packer.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/space/planar_polygon_tessellation.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/plane3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/point.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/point2.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/point2.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/space/point3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/point3.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/space/point4.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/point4.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/space/point_matching.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/space/rasterized_outline2_packer.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/space/ray2.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/ray3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/rect_packer.h	/^namespace vcg$/;"	n
vcg	vcglib/vcg/space/segment2.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/segment3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/smallest_enclosing.h	/^namespace vcg{$/;"	n
vcg	vcglib/vcg/space/space.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/sphere3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/tetra3.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/texcoord2.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/triangle2.h	/^namespace vcg {$/;"	n
vcg	vcglib/vcg/space/triangle3.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/bmt/bmt.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/bmt/strip_mesh.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/callback.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/dae/poly_triangulator.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/dae/util_dae.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gcache/cache.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gcache/controller.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gcache/provider.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gcache/token.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gl/addons.h	/^namespace vcg$/;"	n
vcg	vcglib/wrap/gl/deprecated_math.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gl/deprecated_space.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gl/gl_field.h	/^namespace vcg{$/;"	n
vcg	vcglib/wrap/gl/gl_surface.h	/^namespace vcg$/;"	n
vcg	vcglib/wrap/gl/glu_tesselator.h	/^namespace vcg$/;"	n
vcg	vcglib/wrap/gl/glu_tessellator_cap.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gl/math.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gl/pick.h	/^namespace vcg{$/;"	n
vcg	vcglib/wrap/gl/picking.h	/^namespace vcg$/;"	n
vcg	vcglib/wrap/gl/pos.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gl/space.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gl/tetramesh.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gl/trimesh.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gui/activecoordinateframe.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gui/coordinateframe.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gui/frustum.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gui/rubberband.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gui/trackball.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gui/trackmode.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gui/trackrecorder.h	/^namespace vcg{$/;"	n
vcg	vcglib/wrap/gui/trackutils.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/gui/view.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_edgemesh/export_dxf.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_edgemesh/export_svg.h	/^namespace vcg $/;"	n
vcg	vcglib/wrap/io_tetramesh/export_ply.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_tetramesh/export_ts.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_tetramesh/import_ply.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_tetramesh/import_ts.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_tetramesh/io_ply.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_3ds.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_ctm.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_dae.h	/^namespace vcg$/;"	n
vcg	vcglib/wrap/io_trimesh/export_dxf.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_field.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_gts.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_idtf.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_obj.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_off.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_ply.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_smf.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_stl.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_u3d.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_vmi.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/export_vrml.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_asc.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_ctm.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_dae.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_field.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_gts.h	/^namespace vcg$/;"	n
vcg	vcglib/wrap/io_trimesh/import_nvm.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_obj.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_off.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_out.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_ply.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_ptx.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_raw.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_smf.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_stl.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/import_vmi.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/io_fan_tessellator.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/io_mask.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/io_material.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/io_trimesh/io_ply.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/mt/mt.h	/^namespace vcg {  $/;"	n
vcg	vcglib/wrap/opensg/vertex_component.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/ply/plylib.cpp	/^namespace vcg{$/;"	n	file:
vcg	vcglib/wrap/ply/plylib.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/ply/plystuff.h	/^namespace vcg {$/;"	n
vcg	vcglib/wrap/qt/col_qt_convert.h	/^namespace vcg$/;"	n
vcg	vcglib/wrap/qt/gl_label.h	/^namespace vcg$/;"	n
vcg	vcglib/wrap/utils.h	/^namespace vcg {$/;"	n
vdn	vcglib/wrap/io_tetramesh/io_ply.h	/^  int vdn;$/;"	m	class:vcg::tetra::io::PlyInfo
vdn	vcglib/wrap/io_trimesh/io_ply.h	/^  int vdn;$/;"	m	class:vcg::tri::io::PlyInfo
vec	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Block<Coefficients,3,1> vec() { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion
vec	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Block<const Coefficients,3,1> vec() const { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion
vec	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline VectorBlock<Coefficients,3> vec() { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase
vec	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline const VectorBlock<const Coefficients,3> vec() const { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase
vec	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    std::vector<Vec3> vec; \/\/ input vectors$/;"	m	class:vcg::tri::Zonohedron
vec	vcglib/vcg/math/histogram.h	/^	std::vector<ScalarType> vec;$/;"	m	class:vcg::Distribution
vec2d_swizzle1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define vec2d_swizzle1(/;"	d
vec4f_swizzle1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define vec4f_swizzle1(/;"	d
vec4f_swizzle2	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define vec4f_swizzle2(/;"	d
vec4i_swizzle1	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define vec4i_swizzle1(/;"	d
vec4i_swizzle2	vcglib/eigenlib/Eigen/src/Core/arch/SSE/PacketMath.h	/^#define vec4i_swizzle2(/;"	d
vector	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^  class vector<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
vectorD	vcglib/eigenlib/Eigen/src/Cholesky/LDLT.h	/^    inline Diagonal<const MatrixType> vectorD() const$/;"	f	class:Eigen::LDLT
vectorD	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialCholesky
vectorD	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialLDLT
vectorOwner	vcglib/vcg/complex/algorithms/point_sampling.h	/^  bool vectorOwner;$/;"	m	class:vcg::tri::TrivialSampler
vector_base	vcglib/eigenlib/Eigen/src/StlSupport/StdVector.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > vector_base;$/;"	t	class:std::vector
vector_int_pair	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^  vector_int_pair(const VectorType &v, int i) : first(v), second(i) {}$/;"	f	struct:Eigen::internal::vector_int_pair
vector_int_pair	vcglib/eigenlib/unsupported/Eigen/src/BVH/KdBVH.h	/^struct vector_int_pair$/;"	s	namespace:Eigen::internal
vector_occ	vcglib/vcg/container/vector_occ.h	/^	vector_occ():std::vector<VALUE_TYPE>(){id = ID(); ID()=ID()+1; reserve(1);}$/;"	f	class:vcg::vector_occ
vector_occ	vcglib/vcg/container/vector_occ.h	/^class vector_occ: public std::vector<VALUE_TYPE>{$/;"	c	namespace:vcg
vector_ocf	vcglib/vcg/simplex/face/component_ocf.h	/^  vector_ocf():std::vector<VALUE_TYPE>()$/;"	f	class:vcg::face::vector_ocf
vector_ocf	vcglib/vcg/simplex/face/component_ocf.h	/^class vector_ocf: public std::vector<VALUE_TYPE> {$/;"	c	namespace:vcg::face
vector_ocf	vcglib/vcg/simplex/vertex/component_ocf.h	/^  vector_ocf():std::vector<VALUE_TYPE>()$/;"	f	class:vcg::vertex::vector_ocf
vector_ocf	vcglib/vcg/simplex/vertex/component_ocf.h	/^class vector_ocf: public std::vector<VALUE_TYPE> {$/;"	c	namespace:vcg::vertex
vectors	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    const std::vector< Vec3 >& vectors() const {$/;"	f	class:vcg::tri::Zonohedron
verbose	vcglib/apps/trimeshinfo/XMLTree.h	/^	bool verbose;$/;"	m	class:XMLTree
verify	vcglib/apps/test/quaternion/quat_test.cpp	/^bool verify(Matrix33f &m) {$/;"	f
verify	vcglib/apps/test/quaternion/quat_test.cpp	/^bool verify(Quaternionf &q){$/;"	f
version	vcglib/wrap/glw/utility.h	/^		ThisType & version(const std::string & v)$/;"	f	class:glw::ShaderHeaderBuilder
version	vcglib/wrap/ply/plylib.h	/^	float  version;				\/\/ Versione del file$/;"	m	class:vcg::ply::PlyFile
vert	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^        int vert[4]; \/\/ index to vertex array$/;"	m	struct:vcg::tri::Zonohedron::Face
vert	vcglib/vcg/complex/algorithms/update/curvature.h	/^    VertexType * vert;$/;"	m	struct:vcg::tri::UpdateCurvature::AdjVertex
vert	vcglib/vcg/complex/append.h	/^        std::vector<int> vert,face,edge, hedge;$/;"	m	struct:vcg::tri::Append::Remap
vert	vcglib/vcg/complex/base.h	/^    VertContainer vert;$/;"	m	class:vcg::tri::TriMesh
vert	vcglib/wrap/bmt/strip_mesh.h	/^  std::vector<Point3f> vert;$/;"	m	class:vcg::StripMeshBuilder
vert	vcglib/wrap/dae/poly_triangulator.h	/^		std::vector<VertexType> vert;$/;"	m	class:vcg::tri::io::PolygonalMesh
vert	vcglib/wrap/opensg/vertex_component.h	/^namespace vert {$/;"	n	namespace:vcg
vertCount	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    int vertCount;$/;"	m	class:vcg::tri::Zonohedron
vert_attr	vcglib/vcg/complex/base.h	/^    std::set< PointerToAttribute > vert_attr;$/;"	m	class:vcg::tri::TriMesh
vertex	vcglib/vcg/simplex/vertex/component.h	/^namespace vertex {$/;"	n	namespace:vcg
vertex	vcglib/vcg/simplex/vertex/component_occ.h	/^  namespace vertex {$/;"	n	namespace:vcg
vertex	vcglib/vcg/simplex/vertex/component_ocf.h	/^	namespace vertex {$/;"	n	namespace:vcg
vertex	vcglib/vcg/simplex/vertex/component_sph.h	/^namespace vertex {$/;"	n	namespace:vcg
vertex	vcglib/vcg/simplex/vertex/distance.h	/^	namespace vertex{$/;"	n	namespace:vcg
vertexAttribPointer	vcglib/wrap/glw/buffer.h	/^		void vertexAttribPointer(GLenum target, GLint unit, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * offset)$/;"	f	class:glw::Buffer
vertexAttribPointer	vcglib/wrap/glw/buffer.h	/^		void vertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * offset)$/;"	f	class:glw::BoundVertexBuffer
vertexIndex	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    VecIndex vertexIndex(const Signature &s){$/;"	f	class:vcg::tri::Zonohedron
vertexInputs	vcglib/wrap/glw/program.h	/^		VertexAttributeBinding     vertexInputs;$/;"	m	class:glw::ProgramArguments
vertexMap	vcglib/vcg/complex/algorithms/create/zonohedron.h	/^    VertexMap vertexMap;$/;"	m	class:vcg::tri::Zonohedron
vertex_cb	vcglib/wrap/gl/glu_tesselator.h	/^        static void CALLBACK vertex_cb(void * vertex_data, void * polygon_data)$/;"	f	class:vcg::glu_tesselator
vertex_rotate_quad	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static VertexPointer vertex_rotate_quad(VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
vertex_valence	vcglib/vcg/complex/algorithms/update/halfedge_topology.h	/^                static int vertex_valence(VertexPointer vp)$/;"	f	class:vcg::tri::HalfEdgeTopology
vfButton	vcglib/apps/sample/trimesh_pos_demo/window.h	/^		QPushButton * fvButton,*feButton,*ffButton,*neButton,*ldButton,*nbButton,*vfButton;$/;"	m	class:Window
vfite	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^		vcg::face::VFIterator< MyStraightMesh::FaceType> vfite;$/;"	m	class:GLWidget
viewAsCholmod	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_dense viewAsCholmod(MatrixBase<Derived>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(const SparseSelfAdjointView<SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^const cholmod_sparse viewAsCholmod(const SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen
viewAsEigen	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> viewAsEigen(cholmod_sparse& cm)$/;"	f	namespace:Eigen
viewPoint	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    Point3f viewPoint;  \/\/\/ position of a viewpoint used to disambiguate direction$/;"	m	struct:vcg::tri::PointCloudNormal::Param
viewSmooth	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::viewSmooth(bool on) {$/;"	f	class:GLArea
view_point	vcglib/wrap/gui/frustum.h	/^  Point3<T> view_point;$/;"	m	class:vcg::Frustum
view_px	vcglib/wrap/io_trimesh/import_ply.h	/^	float view_px;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
view_py	vcglib/wrap/io_trimesh/import_ply.h	/^	float view_py;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
view_pz	vcglib/wrap/io_trimesh/import_ply.h	/^	float view_pz;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
viewport	vcglib/wrap/gui/view.h	/^  int viewport[4];$/;"	m	class:vcg::View
viewportx	vcglib/wrap/io_trimesh/import_ply.h	/^	int   viewportx;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
viewporty	vcglib/wrap/io_trimesh/import_ply.h	/^	int   viewporty;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
visit	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^void DenseBase<Derived>::visit(Visitor& visitor) const$/;"	f	class:Eigen::DenseBase
visited	vcglib/wrap/mt/mt.h	/^    bool visited;        $/;"	m	struct:vcg::MT::Node
visitor_impl	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^struct visitor_impl$/;"	s	namespace:Eigen::internal
visitor_impl	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, 1>$/;"	s	namespace:Eigen::internal
visitor_impl	vcglib/eigenlib/Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, Dynamic>$/;"	s	namespace:Eigen::internal
vld1_f32	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x2_t vld1_f32 (const float* x) { return ::vld1_f32 ((const float32_t*)x); }$/;"	f	namespace:Eigen::internal
vld1q_f32	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x4_t vld1q_f32(const float* x) { return ::vld1q_f32((const float32_t*)x); }$/;"	f	namespace:Eigen::internal
vml_assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl$/;"	s	namespace:Eigen::internal
vml_assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, InnerVectorizedTraversal>$/;"	s	namespace:Eigen::internal
vml_assign_impl	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, LinearVectorizedTraversal>$/;"	s	namespace:Eigen::internal
vml_assign_traits	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^class vml_assign_traits$/;"	c	namespace:Eigen::internal
vml_call	vcglib/eigenlib/Eigen/src/Core/Assign_MKL.h	/^template<typename Op> struct vml_call$/;"	s	namespace:Eigen::internal
vn	vcglib/apps/trimeshinfo/trimeshinfo.cpp	/^	int vn,fn;$/;"	m	struct:MeshInfo	file:
vn	vcglib/vcg/complex/base.h	/^    int vn;$/;"	m	class:vcg::tri::TriMesh
volume	vcglib/apps/metro/sampling.h	/^    double          volume;$/;"	m	class:vcg::Sampling
volume	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  inline Scalar volume() const$/;"	f	class:Eigen::AlignedBox
voronoiTime	vcglib/vcg/complex/algorithms/parametrization/voronoi_atlas.h	/^     int voronoiTime;$/;"	m	struct:vcg::tri::VoronoiAtlas::VoronoiAtlasParam::Stat
voxel	vcglib/vcg/space/index/grid_util.h	/^	CoordType voxel;	\/\/\/ Dimensions of a single cell$/;"	m	class:vcg::BasicGrid
voxel	vcglib/vcg/space/index/index2D/grid_util_2D.h	/^		CoordType voxel;	\/\/\/ Dimensions of a single cell$/;"	m	class:vcg::BasicGrid2D
voxel	vcglib/vcg/space/index/octree_template.h	/^		VoxelType		voxel;$/;"	m	struct:vcg::OctreeTemplate::Node
vp	vcglib/vcg/complex/algorithms/refine.h	/^        VertexPointer vp[3];$/;"	m	class:vcg::tri::RefinedFaceData
vrem	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^VertexType *vrem;$/;"	m	class:vcg::tetra::TetraEdgeCollapse
vsHandle	vcglib/vcg/complex/algorithms/update/selection.h	/^  typedef typename ComputeMeshType::template PerVertexAttributeHandle< bool > vsHandle;$/;"	t	class:vcg::tri::SelectionStack
vsV	vcglib/vcg/complex/algorithms/update/selection.h	/^  std::vector<vsHandle> vsV;$/;"	m	class:vcg::tri::SelectionStack
vshd	vcglib/wrap/gl/shaders.h	/^	VertexShader vshd;$/;"	m	class:ProgramVF
vst1_f32	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1_f32 (float* to, float32x2_t from) { ::vst1_f32 ((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal
vst1q_f32	vcglib/eigenlib/Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1q_f32(float* to, float32x4_t from) { ::vst1q_f32((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal
w	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    w() const { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase
w	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    w() { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase
w	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar w() const { return m_coeffs.coeff(3); }$/;"	f	class:Eigen::Quaternion
w	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& w() { return m_coeffs.coeffRef(3); }$/;"	f	class:Eigen::Quaternion
w	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar w() const { return this->derived().coeffs().coeff(3); }$/;"	f	class:Eigen::QuaternionBase
w	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& w() { return this->derived().coeffs().coeffRef(3); }$/;"	f	class:Eigen::QuaternionBase
w	vcglib/vcg/complex/algorithms/pointcloud_normal.h	/^    float w;$/;"	m	class:vcg::tri::PointCloudNormal::WArc
w	vcglib/wrap/io_trimesh/import_ply.h	/^	float u,v,w;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_VertAux
wH	vcglib/vcg/complex/algorithms/geodesic.h	/^  typename MeshType::template PerVertexAttributeHandle<float> wH;$/;"	m	class:vcg::tri::IsotropicDistance
wa1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::HybridNonLinearSolver
wa1	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::LevenbergMarquardt
wa2	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::HybridNonLinearSolver
wa2	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::LevenbergMarquardt
wa3	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::HybridNonLinearSolver
wa3	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::LevenbergMarquardt
wa4	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::HybridNonLinearSolver
wa4	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    FVectorType wa1, wa2, wa3, wa4;$/;"	m	class:Eigen::LevenbergMarquardt
wait	vcglib/wrap/system/multithreading/condition.h	/^		void wait(mutex & m)$/;"	f	class:mt::condition
wait	vcglib/wrap/system/multithreading/semaphore.h	/^  void wait(void)$/;"	f	class:mt::semaphore
wait	vcglib/wrap/system/multithreading/thread.h	/^            virtual bool wait(void)$/;"	f	class:mt::thread
waiting	vcglib/wrap/gcache/door.h	/^  bool waiting;$/;"	m	class:QDoor
wc	vcglib/vcg/simplex/face/component_ocf.h	/^  typename VALUE_TYPE::ColorType wc[3];$/;"	m	class:vcg::face::vector_ocf::WedgeColorTypePack
wc	vcglib/wrap/dae/util_dae.h	/^			QStringList wc;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
wcsrc	vcglib/wrap/dae/util_dae.h	/^			QDomNode wcsrc;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
weight	vcglib/vcg/complex/algorithms/refine_loop.h	/^	Weight weight;$/;"	m	struct:vcg::tri::EvenPointLoopGeneric
weight	vcglib/vcg/complex/algorithms/refine_loop.h	/^	Weight weight;$/;"	m	struct:vcg::tri::OddPointLoopGeneric
weight	vcglib/vcg/space/index/kdtree/priorityqueue.h	/^			Weight weight;$/;"	m	struct:HeapMaxPriorityQueue::Element
what	vcglib/vcg/complex/exception.h	/^    virtual const char *what() const throw ()$/;"	f	class:vcg::MissingCompactnessException
what	vcglib/vcg/complex/exception.h	/^    virtual const char *what() const throw ()$/;"	f	class:vcg::MissingComponentException
what	vcglib/vcg/complex/exception.h	/^    virtual const char *what() const throw ()$/;"	f	class:vcg::MissingTriangularRequirementException
wheelEvent	vcglib/apps/pivoting/glarea.cpp	/^void GLArea::wheelEvent(QWheelEvent *e) {     $/;"	f	class:GLArea
wheelEvent	vcglib/apps/sample/trimesh_QT/glarea.cpp	/^void GLArea::wheelEvent (QWheelEvent * e)$/;"	f	class:GLArea
wheelEvent	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^void wheelEvent(int wheel, int direction, int x, int y ){$/;"	f
wheelEvent	vcglib/apps/sample/trimesh_ant_qt/glwidget.cpp	/^void GLWidget::wheelEvent (QWheelEvent * e)$/;"	f	class:GLWidget
wheelEvent	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^ void GLWidget::wheelEvent ( QWheelEvent * e ){$/;"	f	class:GLWidget
why	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^	std::string why() { return "inexact conversion from floating point"; }$/;"	f	class:mpfr::conversion_overflow
width	vcglib/apps/sample/trimesh_ant_freeglut/main.cpp	/^int width,height;$/;"	v
width	vcglib/apps/test/trackball/main.cpp	/^int width = 800;$/;"	v
width	vcglib/apps/unsupported/trackball_SDL/trackball_sdl.cpp	/^int width =800;$/;"	v
width	vcglib/apps/unsupported/trimesh_SDL/trimesh_sdl.cpp	/^int width =1024;$/;"	v
width	vcglib/img/img_image.h	/^  inline int width() const$/;"	f	class:img::Image
width	vcglib/wrap/gl/fbo.h	/^	GLsizei width;$/;"	m	class:BufferRenderTarget
width	vcglib/wrap/gl/gl_surface.h	/^		int width;$/;"	m	class:vcg::gl_surface
width	vcglib/wrap/glw/renderbuffer.h	/^		GLsizei width(void) const$/;"	f	class:glw::Renderbuffer
width	vcglib/wrap/glw/renderbuffer.h	/^		GLsizei width(void) const$/;"	f	class:glw::SafeRenderbuffer
width	vcglib/wrap/glw/renderbuffer.h	/^		GLsizei width;$/;"	m	class:glw::RenderbufferArguments
width	vcglib/wrap/glw/texture2d.h	/^		GLsizei           width;$/;"	m	class:glw::Texture2DArguments
width	vcglib/wrap/glw/texture2d.h	/^		GLsizei width(void) const$/;"	f	class:glw::SafeTexture2D
width	vcglib/wrap/glw/texture2d.h	/^		GLsizei width(void) const$/;"	f	class:glw::Texture2D
width	vcglib/wrap/glw/texturecube.h	/^		GLsizei width(void) const$/;"	f	class:glw::SafeTextureCube
width	vcglib/wrap/glw/texturecube.h	/^		GLsizei width(void) const$/;"	f	class:glw::TextureCube
width	vcglib/wrap/io_trimesh/export_idtf.h	/^		short width;              $/;"	m	struct:vcg::tri::io::TGA_Exporter::TGAHeader
width	vcglib/wrap/qt/Outline2ToQImage.h	/^      int width;$/;"	m	class:Outline2Dumper::Param
win32_acquire_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static FORCEINLINE int win32_acquire_lock (MLOCK_T *sl) {$/;"	f	file:
win32_mlock_t	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^struct win32_mlock_t {$/;"	s	file:
win32_release_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static FORCEINLINE void win32_release_lock (MLOCK_T *sl) {$/;"	f	file:
win32_try_lock	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static FORCEINLINE int win32_try_lock (MLOCK_T *sl) {$/;"	f	file:
win32direct_mmap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static FORCEINLINE void* win32direct_mmap(size_t size) {$/;"	f	file:
win32mmap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static FORCEINLINE void* win32mmap(size_t size) {$/;"	f	file:
win32munmap	vcglib/eigenlib/unsupported/test/mpreal/dlmalloc.c	/^static FORCEINLINE int win32munmap(void* ptr, size_t size) {$/;"	f	file:
winner	vcglib/vcg/complex/algorithms/autoalign_4pcs.h	/^  Candidate winner;$/;"	m	class:vcg::tri::FourPCS
wn	vcglib/vcg/simplex/face/component_ocf.h	/^  typename VALUE_TYPE::NormalType wn[3];$/;"	m	class:vcg::face::vector_ocf::WedgeNormalTypePack
wn	vcglib/wrap/dae/util_dae.h	/^			QStringList wn;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
wnsrc	vcglib/wrap/dae/util_dae.h	/^			QDomNode wnsrc;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
work	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_kissfft_impl.h	/^    void work( int stage,Complex * xout, const _Src * xin, size_t fstride,size_t in_stride)$/;"	f	struct:Eigen::internal::kiss_cpx_fft
workaround_msvc_stl_support	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support() : T() {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
workaround_msvc_stl_support	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support(const T& other) : T(other) {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
workaround_msvc_stl_support	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^  template<typename T> struct workaround_msvc_stl_support : public T$/;"	s	namespace:Eigen::internal
wrap	vcglib/wrap/gui/trackmode.h	/^  bool wrap;$/;"	m	class:vcg::PathMode
wrapR	vcglib/wrap/glw/texture.h	/^		GLenum wrapR;$/;"	m	class:glw::TextureSampleMode
wrapS	vcglib/wrap/glw/texture.h	/^		GLenum wrapS;$/;"	m	class:glw::TextureSampleMode
wrapT	vcglib/wrap/glw/texture.h	/^		GLenum wrapT;$/;"	m	class:glw::TextureSampleMode
wraps	vcglib/wrap/gl/fbo.h	/^	GLenum wraps[1];$/;"	m	class:Texture1D
write	vcglib/wrap/dae/xmldocumentmanaging.h	/^	void write(XMLDocument& doc)$/;"	f	class:XMLDocumentWriter
write	vcglib/wrap/io_trimesh/export_idtf.h	/^	void write(unsigned int tabl,const std::string& st)$/;"	f	class:Output_File
writeAttributes	vcglib/wrap/dae/xmldocumentmanaging.h	/^	void writeAttributes(XMLNode& node)$/;"	f	class:XMLDocumentWriter
writePacket	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ArrayWrapper
writePacket	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::MatrixWrapper
writePacket	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ArrayWrapper
writePacket	vcglib/eigenlib/Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::MatrixWrapper
writePacket	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Block
writePacket	vcglib/eigenlib/Eigen/src/Core/Block.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Block
writePacket	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacket$/;"	f	class:Eigen::DenseCoeffsBase
writePacket	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Flagged
writePacket	vcglib/eigenlib/Eigen/src/Core/Flagged.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Flagged
writePacket	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess
writePacket	vcglib/eigenlib/Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess
writePacket	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::MapBase
writePacket	vcglib/eigenlib/Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::MapBase
writePacket	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue
writePacket	vcglib/eigenlib/Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue
writePacket	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::PlainObjectBase
writePacket	vcglib/eigenlib/Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::PlainObjectBase
writePacket	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Reverse
writePacket	vcglib/eigenlib/Eigen/src/Core/Reverse.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Reverse
writePacket	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl
writePacket	vcglib/eigenlib/Eigen/src/Core/Transpose.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl
writePacketByOuterInner	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacketByOuterInner$/;"	f	class:Eigen::DenseCoeffsBase
writePlyPointCloud	poissonDisk.cpp	/^bool writePlyPointCloud(vector<Point3f>& points, const string& filename)$/;"	f
writeText	vcglib/wrap/dae/xmldocumentmanaging.h	/^	void writeText(XMLLeafNode& node)$/;"	f	class:XMLDocumentWriter
wrong_type	vcglib/vcg/math/eigen.h	/^		wrong_type() { assert(0 && "Eigen: you are using a wrong scalar type" ); }$/;"	f	struct:Eigen::NumTraits::wrong_type
wrong_type	vcglib/vcg/math/eigen.h	/^	struct wrong_type$/;"	s	struct:Eigen::NumTraits
wt	vcglib/vcg/simplex/face/component_ocf.h	/^  typename VALUE_TYPE::TexCoordType wt[3];$/;"	m	class:vcg::face::vector_ocf::WedgeTexTypePack
wt	vcglib/wrap/dae/util_dae.h	/^			QStringList wt;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
wtsrc	vcglib/wrap/dae/util_dae.h	/^			QDomNode wtsrc;$/;"	m	struct:vcg::tri::io::UtilDAE::WedgeAttribute
wxH	vcglib/vcg/complex/algorithms/geodesic.h	/^  typename MeshType::template PerVertexAttributeHandle<Point3f> wxH,wyH;$/;"	m	class:vcg::tri::AnisotropicDistance
wyH	vcglib/vcg/complex/algorithms/geodesic.h	/^  typename MeshType::template PerVertexAttributeHandle<Point3f> wxH,wyH;$/;"	m	class:vcg::tri::AnisotropicDistance
x	utils_sampling.hpp	/^    float x,y,z;$/;"	m	struct:Utils_sampling::Vec3
x	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    x() const { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase
x	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    x() { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase
x	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar x() const { return m_coeffs.coeff(0); }$/;"	f	class:Eigen::Quaternion
x	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& x() { return m_coeffs.coeffRef(0); }$/;"	f	class:Eigen::Quaternion
x	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar x() const { return this->derived().coeffs().coeff(0); }$/;"	f	class:Eigen::QuaternionBase
x	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& x() { return this->derived().coeffs().coeffRef(0); }$/;"	f	class:Eigen::QuaternionBase
x	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline Scalar x() const { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation
x	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline Scalar& x() { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double x[14];$/;"	m	struct:misra1d_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double x[154];$/;"	m	struct:Bennett5_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double x[15];$/;"	m	struct:rat43_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double x[16];$/;"	m	struct:MGH10_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double x[24];$/;"	m	struct:lanczos1_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double x[33];$/;"	m	struct:MGH17_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double x[35];$/;"	m	struct:eckerle4_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double x[6];$/;"	m	struct:BoxBOD_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double x[9];$/;"	m	struct:rat42_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double Bennett5_functor::x[154] = { 7.447168E0, 8.102586E0, 8.452547E0, 8.711278E0, 8.916774E0, 9.087155E0, 9.232590E0, 9.359535E0, 9.472166E0, 9.573384E0, 9.665293E0, 9.749461E0, 9.827092E0, 9.899128E0, 9.966321E0, 10.029280E0, 10.088510E0, 10.144430E0, 10.197380E0, 10.247670E0, 10.295560E0, 10.341250E0, 10.384950E0, 10.426820E0, 10.467000E0, 10.505640E0, 10.542830E0, 10.578690E0, 10.613310E0, 10.646780E0, 10.679150E0, 10.710520E0, 10.740920E0, 10.770440E0, 10.799100E0, 10.826970E0, 10.854080E0, 10.880470E0, 10.906190E0, 10.931260E0, 10.955720E0, 10.979590E0, 11.002910E0, 11.025700E0, 11.047980E0, 11.069770E0, 11.091100E0, 11.111980E0, 11.132440E0, 11.152480E0, 11.172130E0, 11.191410E0, 11.210310E0, 11.228870E0, 11.247090E0, 11.264980E0, 11.282560E0, 11.299840E0, 11.316820E0, 11.333520E0, 11.349940E0, 11.366100E0, 11.382000E0, 11.397660E0, 11.413070E0, 11.428240E0, 11.443200E0, 11.457930E0, 11.472440E0, 11.486750E0, 11.500860E0, 11.514770E0, 11.528490E0, 11.542020E0, 11.555380E0, 11.568550E0, 11.581560E0, 11.594420E0, 11.607121E0, 11.619640E0, 11.632000E0, 11.644210E0, 11.656280E0, 11.668200E0, 11.679980E0, 11.691620E0, 11.703130E0, 11.714510E0, 11.725760E0, 11.736880E0, 11.747890E0, 11.758780E0, 11.769550E0, 11.780200E0, 11.790730E0, 11.801160E0, 11.811480E0, 11.821700E0, 11.831810E0, 11.841820E0, 11.851730E0, 11.861550E0, 11.871270E0, 11.880890E0, 11.890420E0, 11.899870E0, 11.909220E0, 11.918490E0, 11.927680E0, 11.936780E0, 11.945790E0, 11.954730E0, 11.963590E0, 11.972370E0, 11.981070E0, 11.989700E0, 11.998260E0, 12.006740E0, 12.015150E0, 12.023490E0, 12.031760E0, 12.039970E0, 12.048100E0, 12.056170E0, 12.064180E0, 12.072120E0, 12.080010E0, 12.087820E0, 12.095580E0, 12.103280E0, 12.110920E0, 12.118500E0, 12.126030E0, 12.133500E0, 12.140910E0, 12.148270E0, 12.155570E0, 12.162830E0, 12.170030E0, 12.177170E0, 12.184270E0, 12.191320E0, 12.198320E0, 12.205270E0, 12.212170E0, 12.219030E0, 12.225840E0, 12.232600E0, 12.239320E0, 12.245990E0, 12.252620E0, 12.259200E0, 12.265750E0, 12.272240E0 };$/;"	m	class:Bennett5_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double BoxBOD_functor::x[6] = { 1., 2., 3., 5., 7., 10. };$/;"	m	class:BoxBOD_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double MGH10_functor::x[16] = { 5.000000E+01, 5.500000E+01, 6.000000E+01, 6.500000E+01, 7.000000E+01, 7.500000E+01, 8.000000E+01, 8.500000E+01, 9.000000E+01, 9.500000E+01, 1.000000E+02, 1.050000E+02, 1.100000E+02, 1.150000E+02, 1.200000E+02, 1.250000E+02 };$/;"	m	class:MGH10_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double MGH17_functor::x[33] = { 0.000000E+00, 1.000000E+01, 2.000000E+01, 3.000000E+01, 4.000000E+01, 5.000000E+01, 6.000000E+01, 7.000000E+01, 8.000000E+01, 9.000000E+01, 1.000000E+02, 1.100000E+02, 1.200000E+02, 1.300000E+02, 1.400000E+02, 1.500000E+02, 1.600000E+02, 1.700000E+02, 1.800000E+02, 1.900000E+02, 2.000000E+02, 2.100000E+02, 2.200000E+02, 2.300000E+02, 2.400000E+02, 2.500000E+02, 2.600000E+02, 2.700000E+02, 2.800000E+02, 2.900000E+02, 3.000000E+02, 3.100000E+02, 3.200000E+02 };$/;"	m	class:MGH17_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double eckerle4_functor::x[35] = { 400.0, 405.0, 410.0, 415.0, 420.0, 425.0, 430.0, 435.0, 436.5, 438.0, 439.5, 441.0, 442.5, 444.0, 445.5, 447.0, 448.5, 450.0, 451.5, 453.0, 454.5, 456.0, 457.5, 459.0, 460.5, 462.0, 463.5, 465.0, 470.0, 475.0, 480.0, 485.0, 490.0, 495.0, 500.0};$/;"	m	class:eckerle4_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double lanczos1_functor::x[24] = { 0.000000000000E+00, 5.000000000000E-02, 1.000000000000E-01, 1.500000000000E-01, 2.000000000000E-01, 2.500000000000E-01, 3.000000000000E-01, 3.500000000000E-01, 4.000000000000E-01, 4.500000000000E-01, 5.000000000000E-01, 5.500000000000E-01, 6.000000000000E-01, 6.500000000000E-01, 7.000000000000E-01, 7.500000000000E-01, 8.000000000000E-01, 8.500000000000E-01, 9.000000000000E-01, 9.500000000000E-01, 1.000000000000E+00, 1.050000000000E+00, 1.100000000000E+00, 1.150000000000E+00 };$/;"	m	class:lanczos1_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double misra1d_functor::x[14] = { 77.6E0, 114.9E0, 141.1E0, 190.8E0, 239.9E0, 289.0E0, 332.8E0, 378.4E0, 434.8E0, 477.3E0, 536.8E0, 593.1E0, 689.1E0, 760.0E0};$/;"	m	class:misra1d_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double rat42_functor::x[9] = { 9.000E0, 14.000E0, 21.000E0, 28.000E0, 42.000E0, 57.000E0, 63.000E0, 70.000E0, 79.000E0 };$/;"	m	class:rat42_functor	file:
x	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double rat43_functor::x[15] = { 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12., 13., 14., 15. };$/;"	m	class:rat43_functor	file:
x	vcglib/vcg/complex/algorithms/parametrization/poisson_solver.h	/^    Eigen::VectorXd b,x;\/\/ x and b$/;"	m	class:vcg::tri::PoissonSolver
x	vcglib/wrap/io_trimesh/import_out.h	/^    float x;$/;"	m	struct:vcg::tri::io::Correspondence
x	vcglib/wrap/miq/core/sparsesystemdata.h	/^  double*        x()        { return m_x       ; }$/;"	f	class:SparseSystemData
x	vcglib/wrap/ply/plystuff.h	/^	double x;$/;"	m	struct:vcg::ply::PlyPoint3d
xRot	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^    int xRot;$/;"	m	class:GLWidget
xRotation	vcglib/apps/sample/trimesh_pos_demo/glwidget.h	/^    int xRotation() const { return xRot; }$/;"	f	class:GLWidget
x_axis	vcglib/wrap/gui/activecoordinateframe.h	/^  Point3f x_axis,y_axis,z_axis;$/;"	m	class:vcg::ActiveCoordinateFrame
x_axisx	vcglib/wrap/io_trimesh/import_ply.h	/^	float x_axisx;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
x_axisy	vcglib/wrap/io_trimesh/import_ply.h	/^	float x_axisy;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
x_axisz	vcglib/wrap/io_trimesh/import_ply.h	/^	float x_axisz;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
x_modifier	vcglib/wrap/gui/activecoordinateframe.h	/^  const int x_modifier,y_modifier,z_modifier;$/;"	m	class:vcg::ActiveCoordinateFrame
xcolor	vcglib/wrap/gui/coordinateframe.h	/^  Color4b xcolor;$/;"	m	class:vcg::CoordinateFrame
xnorm	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^    Scalar pnorm, xnorm, fnorm1;$/;"	m	class:Eigen::HybridNonLinearSolver
xnorm	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^    Scalar pnorm, xnorm, fnorm1, actred, dirder, prered;$/;"	m	class:Eigen::LevenbergMarquardt
xstart	vcglib/wrap/io_trimesh/export_idtf.h	/^		short xstart;             $/;"	m	struct:vcg::tri::io::TGA_Exporter::TGAHeader
xtol	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/HybridNonLinearSolver.h	/^        Scalar xtol;$/;"	m	struct:Eigen::HybridNonLinearSolver::Parameters
xtol	vcglib/eigenlib/unsupported/Eigen/src/NonLinearOptimization/LevenbergMarquardt.h	/^        Scalar xtol;$/;"	m	struct:Eigen::LevenbergMarquardt::Parameters
xtol	vcglib/wrap/minpack/minpack.h	/^	double xtol; 		\/\/ relative error between last two approximations.$/;"	m	struct:LMDiff::__anon525
xyYtoXYZ	vcglib/vcg/space/colorspace.h	/^	static Color4<T> xyYtoXYZ(const Color4<T> & color)$/;"	f	class:vcg::ColorSpace
xyYtoXYZ	vcglib/vcg/space/colorspace.h	/^	static void xyYtoXYZ(double x, double y, double _Y, double &X, double &Y, double &Z)$/;"	f	class:vcg::ColorSpace
y	utils_sampling.hpp	/^    float x,y,z;$/;"	m	struct:Utils_sampling::Vec3
y	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    y() const { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase
y	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    y() { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase
y	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar y() const { return m_coeffs.coeff(1); }$/;"	f	class:Eigen::Quaternion
y	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& y() { return m_coeffs.coeffRef(1); }$/;"	f	class:Eigen::Quaternion
y	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar y() const { return this->derived().coeffs().coeff(1); }$/;"	f	class:Eigen::QuaternionBase
y	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& y() { return this->derived().coeffs().coeffRef(1); }$/;"	f	class:Eigen::QuaternionBase
y	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline Scalar y() const { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation
y	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline Scalar& y() { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double y[11];$/;"	m	struct:MGH09_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double y[14];$/;"	m	struct:misra1d_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double y[154];$/;"	m	struct:Bennett5_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double y[15];$/;"	m	struct:rat43_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double y[16];$/;"	m	struct:MGH10_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double y[24];$/;"	m	struct:lanczos1_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double y[33];$/;"	m	struct:MGH17_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double y[35];$/;"	m	struct:eckerle4_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^    static const double y[9];$/;"	m	struct:rat42_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double Bennett5_functor::y[154] = { -34.834702E0 ,-34.393200E0 ,-34.152901E0 ,-33.979099E0 ,-33.845901E0 ,-33.732899E0 ,-33.640301E0 ,-33.559200E0 ,-33.486801E0 ,-33.423100E0 ,-33.365101E0 ,-33.313000E0 ,-33.260899E0 ,-33.217400E0 ,-33.176899E0 ,-33.139198E0 ,-33.101601E0 ,-33.066799E0 ,-33.035000E0 ,-33.003101E0 ,-32.971298E0 ,-32.942299E0 ,-32.916302E0 ,-32.890202E0 ,-32.864101E0 ,-32.841000E0 ,-32.817799E0 ,-32.797501E0 ,-32.774300E0 ,-32.757000E0 ,-32.733799E0 ,-32.716400E0 ,-32.699100E0 ,-32.678799E0 ,-32.661400E0 ,-32.644001E0 ,-32.626701E0 ,-32.612202E0 ,-32.597698E0 ,-32.583199E0 ,-32.568699E0 ,-32.554298E0 ,-32.539799E0 ,-32.525299E0 ,-32.510799E0 ,-32.499199E0 ,-32.487598E0 ,-32.473202E0 ,-32.461601E0 ,-32.435501E0 ,-32.435501E0 ,-32.426800E0 ,-32.412300E0 ,-32.400799E0 ,-32.392101E0 ,-32.380501E0 ,-32.366001E0 ,-32.357300E0 ,-32.348598E0 ,-32.339901E0 ,-32.328400E0 ,-32.319698E0 ,-32.311001E0 ,-32.299400E0 ,-32.290699E0 ,-32.282001E0 ,-32.273300E0 ,-32.264599E0 ,-32.256001E0 ,-32.247299E0 ,-32.238602E0 ,-32.229900E0 ,-32.224098E0 ,-32.215401E0 ,-32.203800E0 ,-32.198002E0 ,-32.189400E0 ,-32.183601E0 ,-32.174900E0 ,-32.169102E0 ,-32.163300E0 ,-32.154598E0 ,-32.145901E0 ,-32.140099E0 ,-32.131401E0 ,-32.125599E0 ,-32.119801E0 ,-32.111198E0 ,-32.105400E0 ,-32.096699E0 ,-32.090900E0 ,-32.088001E0 ,-32.079300E0 ,-32.073502E0 ,-32.067699E0 ,-32.061901E0 ,-32.056099E0 ,-32.050301E0 ,-32.044498E0 ,-32.038799E0 ,-32.033001E0 ,-32.027199E0 ,-32.024300E0 ,-32.018501E0 ,-32.012699E0 ,-32.004002E0 ,-32.001099E0 ,-31.995300E0 ,-31.989500E0 ,-31.983700E0 ,-31.977900E0 ,-31.972099E0 ,-31.969299E0 ,-31.963501E0 ,-31.957701E0 ,-31.951900E0 ,-31.946100E0 ,-31.940300E0 ,-31.937401E0 ,-31.931601E0 ,-31.925800E0 ,-31.922899E0 ,-31.917101E0 ,-31.911301E0 ,-31.908400E0 ,-31.902599E0 ,-31.896900E0 ,-31.893999E0 ,-31.888201E0 ,-31.885300E0 ,-31.882401E0 ,-31.876600E0 ,-31.873699E0 ,-31.867901E0 ,-31.862101E0 ,-31.859200E0 ,-31.856300E0 ,-31.850500E0 ,-31.844700E0 ,-31.841801E0 ,-31.838900E0 ,-31.833099E0 ,-31.830200E0 ,-31.827299E0 ,-31.821600E0 ,-31.818701E0 ,-31.812901E0 ,-31.809999E0 ,-31.807100E0 ,-31.801300E0 ,-31.798401E0 ,-31.795500E0 ,-31.789700E0 ,-31.786800E0 };$/;"	m	class:Bennett5_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double MGH09_functor::y[11] = { 1.957000E-01, 1.947000E-01, 1.735000E-01, 1.600000E-01, 8.440000E-02, 6.270000E-02, 4.560000E-02, 3.420000E-02, 3.230000E-02, 2.350000E-02, 2.460000E-02 };$/;"	m	class:MGH09_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double MGH10_functor::y[16] = { 3.478000E+04, 2.861000E+04, 2.365000E+04, 1.963000E+04, 1.637000E+04, 1.372000E+04, 1.154000E+04, 9.744000E+03, 8.261000E+03, 7.030000E+03, 6.005000E+03, 5.147000E+03, 4.427000E+03, 3.820000E+03, 3.307000E+03, 2.872000E+03 };$/;"	m	class:MGH10_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double MGH17_functor::y[33] = { 8.440000E-01, 9.080000E-01, 9.320000E-01, 9.360000E-01, 9.250000E-01, 9.080000E-01, 8.810000E-01, 8.500000E-01, 8.180000E-01, 7.840000E-01, 7.510000E-01, 7.180000E-01, 6.850000E-01, 6.580000E-01, 6.280000E-01, 6.030000E-01, 5.800000E-01, 5.580000E-01, 5.380000E-01, 5.220000E-01, 5.060000E-01, 4.900000E-01, 4.780000E-01, 4.670000E-01, 4.570000E-01, 4.480000E-01, 4.380000E-01, 4.310000E-01, 4.240000E-01, 4.200000E-01, 4.140000E-01, 4.110000E-01, 4.060000E-01 };$/;"	m	class:MGH17_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double eckerle4_functor::y[35] = { 0.0001575, 0.0001699, 0.0002350, 0.0003102, 0.0004917, 0.0008710, 0.0017418, 0.0046400, 0.0065895, 0.0097302, 0.0149002, 0.0237310, 0.0401683, 0.0712559, 0.1264458, 0.2073413, 0.2902366, 0.3445623, 0.3698049, 0.3668534, 0.3106727, 0.2078154, 0.1164354, 0.0616764, 0.0337200, 0.0194023, 0.0117831, 0.0074357, 0.0022732, 0.0008800, 0.0004579, 0.0002345, 0.0001586, 0.0001143, 0.0000710 };$/;"	m	class:eckerle4_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double lanczos1_functor::y[24] = { 2.513400000000E+00 ,2.044333373291E+00 ,1.668404436564E+00 ,1.366418021208E+00 ,1.123232487372E+00 ,9.268897180037E-01 ,7.679338563728E-01 ,6.388775523106E-01 ,5.337835317402E-01 ,4.479363617347E-01 ,3.775847884350E-01 ,3.197393199326E-01 ,2.720130773746E-01 ,2.324965529032E-01 ,1.996589546065E-01 ,1.722704126914E-01 ,1.493405660168E-01 ,1.300700206922E-01 ,1.138119324644E-01 ,1.000415587559E-01 ,8.833209084540E-02 ,7.833544019350E-02 ,6.976693743449E-02 ,6.239312536719E-02 };$/;"	m	class:lanczos1_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double misra1d_functor::y[14] = { 10.07E0, 14.73E0, 17.94E0, 23.93E0, 29.61E0, 35.18E0, 40.02E0, 44.82E0, 50.76E0, 55.05E0, 61.01E0, 66.40E0, 75.47E0, 81.78E0};$/;"	m	class:misra1d_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double rat42_functor::y[9] = { 8.930E0 ,10.800E0 ,18.590E0 ,22.330E0 ,39.350E0 ,56.110E0 ,61.730E0 ,64.620E0 ,67.080E0 };$/;"	m	class:rat42_functor	file:
y	vcglib/eigenlib/unsupported/test/NonLinearOptimization.cpp	/^const double rat43_functor::y[15] = { 16.08, 33.83, 65.80, 97.20, 191.55, 326.20, 386.87, 520.53, 590.03, 651.92, 724.93, 699.56, 689.96, 637.56, 717.41 };$/;"	m	class:rat43_functor	file:
y	vcglib/wrap/io_trimesh/import_out.h	/^    float y;$/;"	m	struct:vcg::tri::io::Correspondence
y	vcglib/wrap/ply/plystuff.h	/^	double y;$/;"	m	struct:vcg::ply::PlyPoint3d
y_axis	vcglib/wrap/gui/activecoordinateframe.h	/^  Point3f x_axis,y_axis,z_axis;$/;"	m	class:vcg::ActiveCoordinateFrame
y_axisx	vcglib/wrap/io_trimesh/import_ply.h	/^	float y_axisx;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
y_axisy	vcglib/wrap/io_trimesh/import_ply.h	/^	float y_axisy;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
y_axisz	vcglib/wrap/io_trimesh/import_ply.h	/^	float y_axisz;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
y_modifier	vcglib/wrap/gui/activecoordinateframe.h	/^  const int x_modifier,y_modifier,z_modifier;$/;"	m	class:vcg::ActiveCoordinateFrame
ycolor	vcglib/wrap/gui/coordinateframe.h	/^  Color4b ycolor;$/;"	m	class:vcg::CoordinateFrame
ystart	vcglib/wrap/io_trimesh/export_idtf.h	/^		short ystart;             $/;"	m	struct:vcg::tri::io::TGA_Exporter::TGAHeader
z	utils_sampling.hpp	/^    float x,y,z;$/;"	m	struct:Utils_sampling::Vec3
z	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    z() const { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase
z	vcglib/eigenlib/Eigen/src/Core/DenseCoeffsBase.h	/^    z() { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase
z	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar z() const { return m_coeffs.coeff(2); }$/;"	f	class:Eigen::Quaternion
z	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& z() { return m_coeffs.coeffRef(2); }$/;"	f	class:Eigen::Quaternion
z	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar z() const { return this->derived().coeffs().coeff(2); }$/;"	f	class:Eigen::QuaternionBase
z	vcglib/eigenlib/Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& z() { return this->derived().coeffs().coeffRef(2); }$/;"	f	class:Eigen::QuaternionBase
z	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline Scalar z() const { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation
z	vcglib/eigenlib/Eigen/src/Geometry/Translation.h	/^  inline Scalar& z() { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation
z	vcglib/vcg/complex/algorithms/update/flag.h	/^    int      z;				\/\/ Indice dell'edge nella faccia$/;"	m	class:vcg::tri::UpdateFlags::EdgeSorter
z	vcglib/vcg/complex/algorithms/update/topology.h	/^  int            z;     \/\/ index in [0..2] of the edge of the face$/;"	m	class:vcg::tri::UpdateTopology::PEdge
z	vcglib/vcg/complex/algorithms/update/topology.h	/^  int      z;				      \/\/ index in [0..1] of the vertex of the edge$/;"	m	class:vcg::tri::UpdateTopology::PVertexEdge
z	vcglib/vcg/complex/algorithms/update/topology.h	/^  int      z;				      \/\/ index in [0..2] of the edge of the face$/;"	m	class:vcg::tri::UpdateTopology::PEdgeTex
z	vcglib/vcg/simplex/edge/pos.h	/^	int z;$/;"	m	class:vcg::edge::VEIterator
z	vcglib/vcg/simplex/edge/pos.h	/^	int z;$/;"	m	class:vcg::edge::VertexStar
z	vcglib/vcg/simplex/face/pos.h	/^	int z;$/;"	m	class:vcg::face::Pos
z	vcglib/vcg/simplex/face/pos.h	/^	int z;$/;"	m	class:vcg::face::VFIterator
z	vcglib/wrap/gl/trimesh.h	/^        char z;$/;"	m	class:vcg::GLW::VertToSplit
z	vcglib/wrap/ply/plystuff.h	/^	double z;$/;"	m	struct:vcg::ply::PlyPoint3d
z_axis	vcglib/wrap/gui/activecoordinateframe.h	/^  Point3f x_axis,y_axis,z_axis;$/;"	m	class:vcg::ActiveCoordinateFrame
z_axisx	vcglib/wrap/io_trimesh/import_ply.h	/^	float z_axisx;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
z_axisy	vcglib/wrap/io_trimesh/import_ply.h	/^	float z_axisy;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
z_axisz	vcglib/wrap/io_trimesh/import_ply.h	/^	float z_axisz;$/;"	m	struct:vcg::tri::io::ImporterPLY::LoadPly_Camera
z_modifier	vcglib/wrap/gui/activecoordinateframe.h	/^  const int x_modifier,y_modifier,z_modifier;$/;"	m	class:vcg::ActiveCoordinateFrame
z_order	vcglib/vcg/space/index/octree.h	/^            ZOrderType		z_order;$/;"	m	struct:vcg::Octree::ObjectPlaceholder
zcolor	vcglib/wrap/gui/coordinateframe.h	/^  Color4b zcolor;$/;"	m	class:vcg::CoordinateFrame
zeta	vcglib/eigenlib/unsupported/test/mpreal/mpreal.h	/^inline const mpreal zeta (const mpreal& v, mp_rnd_t rnd_mode)$/;"	f	namespace:mpfr
~AABBBinaryTree	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::~AABBBinaryTree(void) {$/;"	f	class:vcg::AABBBinaryTree
~AABBBinaryTreeNode	vcglib/vcg/space/index/aabb_binary_tree/base.h	/^AABBBinaryTree<OBJTYPE, SCALARTYPE, NODEAUXDATATYPE>::AABBBinaryTreeNode::~AABBBinaryTreeNode(void) {$/;"	f	class:vcg::AABBBinaryTree::AABBBinaryTreeNode
~ActiveCoordinateFrame	vcglib/wrap/gui/activecoordinateframe.cpp	/^ActiveCoordinateFrame::~ActiveCoordinateFrame()$/;"	f	class:ActiveCoordinateFrame
~AdditionalInfo	vcglib/wrap/io_trimesh/additionalinfo.h	/^	virtual ~AdditionalInfo()$/;"	f	class:AdditionalInfo
~AdvancingFront	vcglib/vcg/complex/algorithms/create/advancing_front.h	/^  virtual ~AdvancingFront() {}$/;"	f	class:vcg::tri::AdvancingFront
~AlignedBox	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox
~AlignedBox	vcglib/eigenlib/Eigen/src/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox
~AmbiVector	vcglib/eigenlib/Eigen/src/SparseCore/AmbiVector.h	/^    ~AmbiVector() { delete[] m_buffer; }$/;"	f	class:Eigen::internal::AmbiVector
~AreaPreservingTextureOptimizer	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  ~AreaPreservingTextureOptimizer(){$/;"	f	class:vcg::tri::AreaPreservingTextureOptimizer
~Attribute	vcglib/vcg/container/simple_temporary_data.h	/^    ~Attribute(){delete attribute;}$/;"	f	class:vcg::Attribute
~BallPivoting	vcglib/vcg/complex/algorithms/create/ball_pivoting.h	/^  ~BallPivoting() {$/;"	f	class:vcg::tri::BallPivoting
~BiCGSTAB	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  ~BiCGSTAB() {}$/;"	f	class:Eigen::BiCGSTAB
~BinaryImage	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			 ~BinaryImage() {}$/;"	f	class:vcg::PerfectSpatialHashing::BinaryImage
~Bmt	vcglib/wrap/bmt/bmt.cpp	/^Bmt::~Bmt() {}$/;"	f	class:Bmt
~BmtBuilder	vcglib/wrap/bmt/bmt.cpp	/^BmtBuilder::~BmtBuilder() {}$/;"	f	class:BmtBuilder
~BoundObject	vcglib/wrap/glw/object.h	/^		virtual ~BoundObject(void)$/;"	f	class:glw::BoundObject
~Box	vcglib/vcg/space/box.h	/^	inline ~Box() { }$/;"	f	class:vcg::Box
~Box2	vcglib/vcg/space/box2.h	/^	inline ~Box2() { }$/;"	f	class:vcg::Box2
~Box3	vcglib/vcg/space/box3.h	/^    inline ~Box3() { }$/;"	f	class:vcg::Box3
~Buffer	vcglib/wrap/glw/buffer.h	/^		virtual ~Buffer(void)$/;"	f	class:glw::Buffer
~Cache	vcglib/wrap/gcache/cache.h	/^    virtual ~Cache() {}$/;"	f	class:vcg::Cache
~CholmodBase	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodBase()$/;"	f	class:Eigen::CholmodBase
~CholmodDecomposition	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodDecomposition() {}$/;"	f	class:Eigen::CholmodDecomposition
~CholmodSimplicialLDLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLDLT() {}$/;"	f	class:Eigen::CholmodSimplicialLDLT
~CholmodSimplicialLLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLLT() {}$/;"	f	class:Eigen::CholmodSimplicialLLT
~CholmodSupernodalLLT	vcglib/eigenlib/Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSupernodalLLT() {}$/;"	f	class:Eigen::CholmodSupernodalLLT
~ClipPlane	vcglib/wrap/gl/tetramesh.h	/^			~ClipPlane (){}$/;"	f	class:vcg::tetra::GlTetramesh::ClipPlane
~CommaInitializer	vcglib/eigenlib/Eigen/src/Core/CommaInitializer.h	/^  inline ~CommaInitializer()$/;"	f	struct:Eigen::CommaInitializer
~CompressedStorage	vcglib/eigenlib/Eigen/src/SparseCore/CompressedStorage.h	/^    ~CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage
~ConjugateGradient	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ~ConjugateGradient() {}$/;"	f	class:Eigen::ConjugateGradient
~Context	vcglib/wrap/glw/context.h	/^		virtual ~Context(void)$/;"	f	class:glw::Context
~Controller	vcglib/wrap/gcache/controller.h	/^  ~Controller() { if(!stopped) finish(); }$/;"	f	class:vcg::Controller
~CoordinateFrame	vcglib/wrap/gui/coordinateframe.h	/^  virtual ~CoordinateFrame() {}$/;"	f	class:vcg::CoordinateFrame
~DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }$/;"	f	class:Eigen::DenseStorage
~DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }$/;"	f	class:Eigen::DenseStorage
~DenseStorage	vcglib/eigenlib/Eigen/src/Core/DenseStorage.h	/^    inline ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }$/;"	f	class:Eigen::DenseStorage
~DynamicSparseMatrix	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/DynamicSparseMatrix.h	/^    inline ~DynamicSparseMatrix() {}$/;"	f	class:Eigen::DynamicSparseMatrix
~Fitmaps	vcglib/vcg/complex/algorithms/update/fitmaps.h	/^    ~Fitmaps(){};$/;"	f	class:vcg::tri::Fitmaps
~Framebuffer	vcglib/wrap/glw/framebuffer.h	/^		virtual ~Framebuffer(void)$/;"	f	class:glw::Framebuffer
~GLObject	vcglib/wrap/gl/gl_object.h	/^	virtual ~GLObject(void)$/;"	f	class:GLObject
~GLWidget	vcglib/apps/sample/trimesh_ant_qt/glwidget.h	/^    ~GLWidget() {};$/;"	f	class:GLWidget
~GLWidget	vcglib/apps/sample/trimesh_pos_demo/glwidget.cpp	/^GLWidget::~GLWidget()$/;"	f	class:GLWidget
~GMRES	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/GMRES.h	/^  ~GMRES() {}$/;"	f	class:Eigen::GMRES
~GlTrimesh	vcglib/wrap/gl/trimesh.h	/^    ~GlTrimesh()$/;"	f	class:vcg::GlTrimesh
~GridStaticObj	vcglib/vcg/space/index/grid_static_obj.h	/^	 inline ~GridStaticObj() { if(grid) delete[] grid; }$/;"	f	class:vcg::GridStaticObj
~HashTable	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			~HashTable() { Clear(true); }$/;"	f	class:vcg::PerfectSpatialHashing::HashTable
~HeapElem	vcglib/vcg/complex/algorithms/local_optimization.h	/^	  ~HeapElem(){}$/;"	f	struct:vcg::LocalOptimization::HeapElem
~Homeometry	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            ~Homeometry(){}$/;"	f	class:vcg::tri::Homeometry
~Hyperplane	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
~Hyperplane	vcglib/eigenlib/Eigen/src/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
~Image	vcglib/img/img_image.h	/^  ~Image()$/;"	f	class:img::Image
~ImageException	vcglib/img/img_base.h	/^  virtual ~ImageException () throw (){}$/;"	f	class:img::ImageException
~Implicit	vcglib/apps/unsupported/extractors/extractor/Implicit.h	/^	virtual ~Implicit() {};$/;"	f	class:Implicit
~ImplicitSphere	vcglib/apps/unsupported/extractors/extractor/ImplicitSphere.h	/^	~ImplicitSphere() $/;"	f	class:ImplicitSphere
~InfoDAE	vcglib/wrap/dae/util_dae.h	/^		~InfoDAE(){$/;"	f	class:vcg::tri::io::InfoDAE
~IterativeSolverBase	vcglib/eigenlib/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ~IterativeSolverBase() {}$/;"	f	class:Eigen::IterativeSolverBase
~KdTree	vcglib/vcg/space/index/kdtree/kdtree.h	/^KdTree<Scalar>::~KdTree()$/;"	f	class:KdTree
~LocalModification	vcglib/vcg/complex/algorithms/local_optimization.h	/^  virtual ~LocalModification(){}$/;"	f	class:vcg::LocalModification
~LocalOptimization	vcglib/vcg/complex/algorithms/local_optimization.h	/^  ~LocalOptimization(){ $/;"	f	class:vcg::LocalOptimization
~MappedSparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline ~MappedSparseMatrix() {}$/;"	f	class:Eigen::MappedSparseMatrix
~MarsenneTwisterRNG	vcglib/vcg/math/random_generator.h	/^	virtual ~MarsenneTwisterRNG()$/;"	f	class:vcg::math::MarsenneTwisterRNG
~Matrix	vcglib/vcg/math/old_deprecated_matrix.h	/^			~Matrix()$/;"	f	class:vcg::ndim::Matrix
~Matrix	vcglib/vcg/math/old_matrix.h	/^	~Matrix() {}$/;"	f	class:vcg::ndim::Matrix
~Matrix44	vcglib/vcg/math/matrix44.h	/^	~Matrix44() {}$/;"	f	class:vcg::Matrix44
~Matrix44	vcglib/vcg/math/old_matrix44.h	/^	~Matrix44() {}$/;"	f	class:vcg::Matrix44
~MatrixMarketIterator	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/MatrixMarketIterator.h	/^    ~MatrixMarketIterator()$/;"	f	class:Eigen::MatrixMarketIterator
~MovableCoordinateFrame	vcglib/wrap/gui/coordinateframe.h	/^  virtual ~MovableCoordinateFrame(){}$/;"	f	class:vcg::MovableCoordinateFrame
~Node	vcglib/apps/trimeshinfo/Node.h	/^	virtual ~Node(void){};$/;"	f	class:Node
~NodeGroup	vcglib/apps/trimeshinfo/Node.h	/^NodeGroup::~NodeGroup() \/\/distruttore: disalloca tutti i figli$/;"	f	class:NodeGroup
~Nring	vcglib/vcg/complex/algorithms/nring.h	/^    ~Nring()$/;"	f	class:vcg::tri::Nring
~OSGColor	vcglib/wrap/opensg/vertex_component.h	/^	~OSGColor() { if( _corep != NULL ) delete _corep; }$/;"	f	class:vcg::vert::OSGColor
~OSGColorCore	vcglib/wrap/opensg/vertex_component.h	/^	~OSGColorCore() { _vertexindex = -1; }$/;"	f	class:vcg::vert::OSGColorCore
~OSGCoord	vcglib/wrap/opensg/vertex_component.h	/^	~OSGCoord() { if( _corep != NULL ) delete _corep; }$/;"	f	class:vcg::vert::OSGCoord
~OSGCoordCore	vcglib/wrap/opensg/vertex_component.h	/^	~OSGCoordCore() { _vertexindex = -1; }$/;"	f	class:vcg::vert::OSGCoordCore
~OSGNormal	vcglib/wrap/opensg/vertex_component.h	/^	~OSGNormal() { if( _corep == NULL ) delete _corep; }$/;"	f	class:vcg::vert::OSGNormal
~OSGNormalCore	vcglib/wrap/opensg/vertex_component.h	/^	~OSGNormalCore() { _vertexindex = -1; }$/;"	f	class:vcg::vert::OSGNormalCore
~Object	vcglib/wrap/glw/object.h	/^		virtual ~Object(void)$/;"	f	class:glw::Object
~ObjectSharedPointer	vcglib/wrap/glw/bookkeeping.h	/^		~ObjectSharedPointer(void)$/;"	f	class:glw::detail::ObjectSharedPointer
~Obox3	vcglib/vcg/space/obox3.h	/^		inline ~Obox3(){}$/;"	f	class:vcg::Obox3
~Octree	vcglib/vcg/space/index/octree.h	/^        ~Octree()$/;"	f	class:vcg::Octree
~OffsetTable	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			~OffsetTable() { Clear(); }$/;"	f	class:vcg::PerfectSpatialHashing::OffsetTable
~Output_File	vcglib/wrap/io_trimesh/export_idtf.h	/^	~Output_File()$/;"	f	class:Output_File
~OverlapEstimation	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^    ~OverlapEstimation(){$/;"	f	class:OverlapEstimation
~ParametrizedLine	vcglib/eigenlib/Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
~ParametrizedLine	vcglib/eigenlib/Eigen/src/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
~PardisoImpl	vcglib/eigenlib/Eigen/src/PardisoSupport/PardisoSupport.h	/^    ~PardisoImpl()$/;"	f	class:Eigen::PardisoImpl
~PastixBase	vcglib/eigenlib/Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ~PastixBase() $/;"	f	class:Eigen::PastixBase
~PerfectSpatialHashing	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^		~PerfectSpatialHashing() { \/* ... I don't remember if there is something to delete! :D *\/ } $/;"	f	class:vcg::PerfectSpatialHashing
~PlanarEdgeFlip	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_flip.h	/^	~PlanarEdgeFlip()$/;"	f	class:vcg::tri::PlanarEdgeFlip
~PlyFile	vcglib/wrap/ply/plylib.cpp	/^PlyFile::~PlyFile( void )$/;"	f	class:vcg::ply::PlyFile
~Pos	vcglib/vcg/simplex/tetrahedron/pos.h	/^	~Pos(){};$/;"	f	class:vcg::tetra::Pos
~Program	vcglib/wrap/glw/program.h	/^		virtual ~Program(void)$/;"	f	class:glw::Program
~Provider	vcglib/wrap/gcache/provider.h	/^  virtual ~Provider() {}$/;"	f	class:vcg::Provider
~QuadDiagonalCollapseBase	vcglib/vcg/complex/algorithms/local_optimization/quad_diag_collapse.h	/^            ~QuadDiagonalCollapseBase()$/;"	f	class:vcg::tri::QuadDiagonalCollapseBase
~RandomGenerator	vcglib/vcg/math/random_generator.h	/^	virtual ~RandomGenerator()$/;"	f	class:vcg::math::RandomGenerator
~RandomSetter	vcglib/eigenlib/unsupported/Eigen/src/SparseExtra/RandomSetter.h	/^    ~RandomSetter()$/;"	f	class:Eigen::RandomSetter
~RefCountedObject	vcglib/wrap/glw/bookkeeping.h	/^		~RefCountedObject(void)$/;"	f	class:glw::detail::RefCountedObject
~Renderbuffer	vcglib/wrap/glw/renderbuffer.h	/^		virtual ~Renderbuffer(void)$/;"	f	class:glw::Renderbuffer
~Rubberband	vcglib/wrap/gui/rubberband.h	/^  virtual ~Rubberband() {}$/;"	f	class:vcg::Rubberband
~SafeObject	vcglib/wrap/glw/object.h	/^		virtual ~SafeObject(void)$/;"	f	class:glw::SafeObject
~Sampling	vcglib/apps/metro/sampling.h	/^Sampling<MetroMesh>::~Sampling()$/;"	f	class:vcg::Sampling
~Scaling	vcglib/eigenlib/unsupported/Eigen/src/IterativeSolvers/Scaling.h	/^    ~Scaling() { }$/;"	f	class:Scaling
~Shader	vcglib/wrap/glw/shader.h	/^		virtual ~Shader(void)$/;"	f	class:glw::Shader
~SimpleTempData	vcglib/vcg/container/simple_temporary_data.h	/^    ~SimpleTempData(){data.clear();}$/;"	f	class:vcg::SimpleTempData
~SimpleTempDataBase	vcglib/vcg/container/simple_temporary_data.h	/^  virtual ~SimpleTempDataBase() {}$/;"	f	class:vcg::SimpleTempDataBase
~SimplicialCholeskyBase	vcglib/eigenlib/Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ~SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase
~SkylineMatrix	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineMatrix.h	/^    inline ~SkylineMatrix() {$/;"	f	class:Eigen::SkylineMatrix
~SkylineStorage	vcglib/eigenlib/unsupported/Eigen/src/Skyline/SkylineStorage.h	/^    ~SkylineStorage() {$/;"	f	class:Eigen::SkylineStorage
~SparseMatrix	vcglib/eigenlib/Eigen/src/SparseCore/SparseMatrix.h	/^    inline ~SparseMatrix()$/;"	f	class:Eigen::SparseMatrix
~SparseMatrixData	vcglib/wrap/miq/core/sparsesystemdata.h	/^  virtual ~SparseMatrixData() {$/;"	f	class:SparseMatrixData
~SparseSystemData	vcglib/wrap/miq/core/sparsesystemdata.h	/^  virtual ~SparseSystemData() {$/;"	f	class:SparseSystemData
~SparseVector	vcglib/eigenlib/Eigen/src/SparseCore/SparseVector.h	/^    inline ~SparseVector() {}$/;"	f	class:Eigen::SparseVector
~SubtractiveRingRNG	vcglib/vcg/math/random_generator.h	/^	virtual ~SubtractiveRingRNG()$/;"	f	class:vcg::math::SubtractiveRingRNG
~SuperILU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperILU()$/;"	f	class:Eigen::SuperILU
~SuperLU	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLU()$/;"	f	class:Eigen::SuperLU
~SuperLUBase	vcglib/eigenlib/Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLUBase()$/;"	f	class:Eigen::SuperLUBase
~TetraEdgeCollapse	vcglib/vcg/complex/algorithms/local_optimization/tetra_edge_collapse.h	/^  ~TetraEdgeCollapse()$/;"	f	class:vcg::tetra::TetraEdgeCollapse
~Texture	vcglib/wrap/glw/texture.h	/^		virtual ~Texture(void)$/;"	f	class:glw::Texture
~TextureOptimizer	vcglib/vcg/complex/algorithms/textcoord_optimization.h	/^  ~TextureOptimizer(){$/;"	f	class:vcg::tri::TextureOptimizer
~TrackMode	vcglib/wrap/gui/trackmode.h	/^  virtual ~TrackMode () {$/;"	f	class:vcg::TrackMode
~Trackball	vcglib/wrap/gui/trackball.cpp	/^Trackball::~Trackball()$/;"	f	class:Trackball
~TriEdgeCollapse	vcglib/vcg/complex/algorithms/local_optimization/tri_edge_collapse.h	/^		~TriEdgeCollapse()$/;"	f	class:vcg::tri::TriEdgeCollapse
~TriMesh	vcglib/vcg/complex/base.h	/^    ~TriMesh()$/;"	f	class:vcg::tri::TriMesh
~TrivialSampler	vcglib/vcg/complex/algorithms/point_sampling.h	/^  ~TrivialSampler()$/;"	f	class:vcg::tri::TrivialSampler
~TrivialWalker	vcglib/vcg/complex/algorithms/create/mc_trivial_walker.h	/^    ~TrivialWalker()$/;"	f	class:vcg::tri::TrivialWalker
~UmfPackLU	vcglib/eigenlib/Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ~UmfPackLU()$/;"	f	class:Eigen::UmfPackLU
~UniformGrid	vcglib/vcg/space/index/perfect_spatial_hashing.h	/^			~UniformGrid() {}$/;"	f	class:vcg::PerfectSpatialHashing::UniformGrid
~VTIterator	vcglib/vcg/simplex/tetrahedron/pos.h	/^	~VTIterator(){};$/;"	f	class:vcg::tetra::VTIterator
~VertReg	vcglib/vcg/complex/algorithms/halfedge_quad_clean.h	/^            ~VertReg(){}$/;"	f	class:vcg::tri::VertReg
~VertexPointerSampler	vcglib/vcg/complex/algorithms/overlap_estimation.h	/^        ~VertexPointerSampler(){ if(m) delete m; }$/;"	f	class:OverlapEstimation::VertexPointerSampler
~Walker	vcglib/apps/unsupported/extractors/extractor/Walker.h	/^	~Walker()$/;"	f	class:Walker
~Walker	vcglib/vcg/complex/algorithms/create/resampler.h	/^		~Walker()$/;"	f	class:vcg::tri::Resampler::Walker
~Weight	vcglib/vcg/complex/algorithms/hole.h	/^            ~Weight() {}$/;"	f	class:vcg::tri::Hole::Weight
~XMLDocument	vcglib/wrap/dae/xmldocumentmanaging.h	/^	~XMLDocument()$/;"	f	class:XMLDocument
~XMLDocumentWriter	vcglib/wrap/dae/xmldocumentmanaging.h	/^  virtual ~XMLDocumentWriter()$/;"	f	class:XMLDocumentWriter
~XMLInteriorNode	vcglib/wrap/dae/xmldocumentmanaging.cpp	/^XMLInteriorNode::~XMLInteriorNode()$/;"	f	class:XMLInteriorNode
~XMLLeafNode	vcglib/wrap/dae/xmldocumentmanaging.cpp	/^XMLLeafNode::~XMLLeafNode()$/;"	f	class:XMLLeafNode
~XMLLeafTag	vcglib/wrap/dae/xmldocumentmanaging.h	/^		virtual ~XMLLeafTag()$/;"	f	class:XMLLeafTag
~XMLNode	vcglib/wrap/dae/xmldocumentmanaging.cpp	/^XMLNode::~XMLNode()$/;"	f	class:XMLNode
~XMLTag	vcglib/wrap/dae/xmldocumentmanaging.h	/^	virtual ~XMLTag()$/;"	f	class:XMLTag
~XMLTree	vcglib/apps/trimeshinfo/XMLTree.h	/^	~XMLTree(void){}$/;"	f	class:XMLTree
~aligned_allocator	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    ~aligned_allocator()$/;"	f	class:Eigen::aligned_allocator
~aligned_allocator_indirection	vcglib/eigenlib/Eigen/src/StlSupport/details.h	/^    ~aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection
~aligned_stack_memory_handler	vcglib/eigenlib/Eigen/src/Core/util/Memory.h	/^    ~aligned_stack_memory_handler()$/;"	f	class:Eigen::internal::aligned_stack_memory_handler
~condition	vcglib/wrap/system/multithreading/condition.h	/^		~condition(void)$/;"	f	class:mt::condition
~fftw_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      ~fftw_plan() {if (m_plan) fftw_destroy_plan(m_plan);}$/;"	f	struct:Eigen::internal::fftw_plan
~fftw_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      ~fftw_plan() {if (m_plan) fftwf_destroy_plan(m_plan);}$/;"	f	struct:Eigen::internal::fftw_plan
~fftw_plan	vcglib/eigenlib/unsupported/Eigen/src/FFT/ei_fftw_impl.h	/^      ~fftw_plan() {if (m_plan) fftwl_destroy_plan(m_plan);}$/;"	f	struct:Eigen::internal::fftw_plan
~gemm_blocking_space	vcglib/eigenlib/Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    ~gemm_blocking_space()$/;"	f	class:Eigen::internal::gemm_blocking_space
~gl_surface	vcglib/wrap/gl/gl_surface.h	/^		~gl_surface(void)$/;"	f	class:vcg::gl_surface
~mpreal	vcglib/eigenlib/unsupported/test/mpreal/mpreal.cpp	/^mpreal::~mpreal() $/;"	f	class:mpfr::mpreal
~mutex	vcglib/wrap/system/multithreading/mutex.h	/^		~mutex(void)$/;"	f	class:mt::mutex
~noncopyable	vcglib/eigenlib/Eigen/src/Core/util/Meta.h	/^  ~noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable
~rw_lock	vcglib/wrap/system/multithreading/rw_lock.h	/^		~rw_lock(void)$/;"	f	class:mt::rw_lock
~scoped_mutex_lock	vcglib/wrap/system/multithreading/scoped_mutex_lock.h	/^            ~scoped_mutex_lock(void)$/;"	f	class:mt::scoped_mutex_lock
~scoped_read_lock	vcglib/wrap/system/multithreading/scoped_read_lock.h	/^		~scoped_read_lock(void)$/;"	f	class:mt::scoped_read_lock
~scoped_write_lock	vcglib/wrap/system/multithreading/scoped_write_lock.h	/^		~scoped_write_lock(void)$/;"	f	class:mt::scoped_write_lock
~semaphore	vcglib/wrap/system/multithreading/semaphore.h	/^  ~semaphore(void)$/;"	f	class:mt::semaphore
~thread	vcglib/wrap/system/multithreading/thread.h	/^            virtual ~thread(void)$/;"	f	class:mt::thread
~vector_occ	vcglib/vcg/container/vector_occ.h	/^vector_occ<VALUE_TYPE>::~vector_occ(){$/;"	f	class:vcg::vector_occ
